4d0175872768fdbe69800243a6138112
/**
 * Real LLM Errors implementation tests - targeting actual coverage
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _llmerrors = require("../../lib/llm-errors");
describe("LLM Errors Real Implementation Tests", ()=>{
    describe("LLMError Base Class", ()=>{
        test("creates basic error with message", ()=>{
            const error = new _llmerrors.LLMError("Test error");
            expect(error.name).toBe("LLMError");
            expect(error.message).toBe("Test error");
            expect(error.code).toBeUndefined();
        });
        test("creates error with message and code", ()=>{
            const error = new _llmerrors.LLMError("Test error", "TEST_CODE");
            expect(error.name).toBe("LLMError");
            expect(error.message).toBe("Test error");
            expect(error.code).toBe("TEST_CODE");
        });
        test("is instance of Error", ()=>{
            const error = new _llmerrors.LLMError("Test error");
            expect(error).toBeInstanceOf(Error);
            expect(error).toBeInstanceOf(_llmerrors.LLMError);
        });
        test("has optional properties", ()=>{
            const error = new _llmerrors.LLMError("Test error");
            error.provider = "openai";
            error.type = "validation";
            error.statusCode = 400;
            expect(error.provider).toBe("openai");
            expect(error.type).toBe("validation");
            expect(error.statusCode).toBe(400);
        });
    });
    describe("RateLimitError", ()=>{
        test("creates rate limit error", ()=>{
            const error = new _llmerrors.RateLimitError("Rate limit exceeded");
            expect(error.name).toBe("RateLimitError");
            expect(error.message).toBe("Rate limit exceeded");
            expect(error.code).toBe("RATE_LIMIT");
            expect(error).toBeInstanceOf(_llmerrors.LLMError);
        });
    });
    describe("AuthenticationError", ()=>{
        test("creates authentication error", ()=>{
            const error = new _llmerrors.AuthenticationError("Invalid credentials");
            expect(error.name).toBe("AuthenticationError");
            expect(error.message).toBe("Invalid credentials");
            expect(error.code).toBe("AUTH_ERROR");
            expect(error).toBeInstanceOf(_llmerrors.LLMError);
        });
    });
    describe("ApiKeyError", ()=>{
        test("creates API key error", ()=>{
            const error = new _llmerrors.ApiKeyError("Invalid API key");
            expect(error.name).toBe("ApiKeyError");
            expect(error.message).toBe("Invalid API key");
            expect(error.code).toBe("API_KEY_ERROR");
            expect(error).toBeInstanceOf(_llmerrors.LLMError);
        });
    });
    describe("TimeoutError", ()=>{
        test("creates timeout error", ()=>{
            const error = new _llmerrors.TimeoutError("Request timed out");
            expect(error.name).toBe("TimeoutError");
            expect(error.message).toBe("Request timed out");
            expect(error.code).toBe("TIMEOUT_ERROR");
            expect(error).toBeInstanceOf(_llmerrors.LLMError);
        });
    });
    describe("NetworkError", ()=>{
        test("creates network error", ()=>{
            const error = new _llmerrors.NetworkError("Network failure");
            expect(error.name).toBe("NetworkError");
            expect(error.message).toBe("Network failure");
            expect(error.code).toBe("NETWORK_ERROR");
            expect(error).toBeInstanceOf(_llmerrors.LLMError);
        });
    });
    describe("withTimeout Function", ()=>{
        test("resolves promise within timeout", async ()=>{
            const promise = Promise.resolve("success");
            const result = await (0, _llmerrors.withTimeout)(promise, 1000);
            expect(result).toBe("success");
        });
        test("rejects promise that exceeds timeout", async ()=>{
            const promise = new Promise((resolve)=>{
                setTimeout(()=>resolve("late"), 200);
            });
            await expect((0, _llmerrors.withTimeout)(promise, 100)).rejects.toThrow("Operation timed out");
        });
        test("rejects with custom timeout message", async ()=>{
            const promise = new Promise((resolve)=>{
                setTimeout(()=>resolve("late"), 200);
            });
            await expect((0, _llmerrors.withTimeout)(promise, 100, "Custom timeout")).rejects.toThrow("Custom timeout");
        });
        test("rejects if original promise rejects", async ()=>{
            const promise = Promise.reject(new Error("Original error"));
            await expect((0, _llmerrors.withTimeout)(promise, 1000)).rejects.toThrow("Original error");
        });
        test("handles zero timeout", async ()=>{
            const promise = new Promise((resolve)=>{
                setTimeout(()=>resolve("late"), 50);
            });
            await expect((0, _llmerrors.withTimeout)(promise, 0)).rejects.toThrow("Operation timed out");
        });
        test("handles negative timeout", async ()=>{
            const promise = Promise.resolve("immediate");
            const result = await (0, _llmerrors.withTimeout)(promise, -100);
            expect(result).toBe("immediate");
        });
    });
    describe("Error Inheritance Chain", ()=>{
        test("all error types inherit from LLMError", ()=>{
            const errors = [
                new _llmerrors.RateLimitError("test"),
                new _llmerrors.AuthenticationError("test"),
                new _llmerrors.ApiKeyError("test"),
                new _llmerrors.TimeoutError("test"),
                new _llmerrors.NetworkError("test")
            ];
            errors.forEach((error)=>{
                expect(error).toBeInstanceOf(_llmerrors.LLMError);
                expect(error).toBeInstanceOf(Error);
            });
        });
        test("error codes are correctly set", ()=>{
            expect(new _llmerrors.RateLimitError("test").code).toBe("RATE_LIMIT");
            expect(new _llmerrors.AuthenticationError("test").code).toBe("AUTH_ERROR");
            expect(new _llmerrors.ApiKeyError("test").code).toBe("API_KEY_ERROR");
            expect(new _llmerrors.TimeoutError("test").code).toBe("TIMEOUT_ERROR");
            expect(new _llmerrors.NetworkError("test").code).toBe("NETWORK_ERROR");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2xsbS1lcnJvcnMtcmVhbC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhbCBMTE0gRXJyb3JzIGltcGxlbWVudGF0aW9uIHRlc3RzIC0gdGFyZ2V0aW5nIGFjdHVhbCBjb3ZlcmFnZVxuICovXG5cbmltcG9ydCB7XG4gIExMTUVycm9yLFxuICBSYXRlTGltaXRFcnJvcixcbiAgQXV0aGVudGljYXRpb25FcnJvcixcbiAgQXBpS2V5RXJyb3IsXG4gIFRpbWVvdXRFcnJvcixcbiAgTmV0d29ya0Vycm9yLFxuICB3aXRoVGltZW91dFxufSBmcm9tIFwiQC9saWIvbGxtLWVycm9yc1wiO1xuXG5kZXNjcmliZShcIkxMTSBFcnJvcnMgUmVhbCBJbXBsZW1lbnRhdGlvbiBUZXN0c1wiLCAoKSA9PiB7XG4gIGRlc2NyaWJlKFwiTExNRXJyb3IgQmFzZSBDbGFzc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcImNyZWF0ZXMgYmFzaWMgZXJyb3Igd2l0aCBtZXNzYWdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IExMTUVycm9yKFwiVGVzdCBlcnJvclwiKTtcbiAgICAgIGV4cGVjdChlcnJvci5uYW1lKS50b0JlKFwiTExNRXJyb3JcIik7XG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9CZShcIlRlc3QgZXJyb3JcIik7XG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImNyZWF0ZXMgZXJyb3Igd2l0aCBtZXNzYWdlIGFuZCBjb2RlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IExMTUVycm9yKFwiVGVzdCBlcnJvclwiLCBcIlRFU1RfQ09ERVwiKTtcbiAgICAgIGV4cGVjdChlcnJvci5uYW1lKS50b0JlKFwiTExNRXJyb3JcIik7XG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9CZShcIlRlc3QgZXJyb3JcIik7XG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZShcIlRFU1RfQ09ERVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJpcyBpbnN0YW5jZSBvZiBFcnJvclwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBMTE1FcnJvcihcIlRlc3QgZXJyb3JcIik7XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoTExNRXJyb3IpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhcyBvcHRpb25hbCBwcm9wZXJ0aWVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IExMTUVycm9yKFwiVGVzdCBlcnJvclwiKTtcbiAgICAgIGVycm9yLnByb3ZpZGVyID0gXCJvcGVuYWlcIjtcbiAgICAgIGVycm9yLnR5cGUgPSBcInZhbGlkYXRpb25cIjtcbiAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSA0MDA7XG5cbiAgICAgIGV4cGVjdChlcnJvci5wcm92aWRlcikudG9CZShcIm9wZW5haVwiKTtcbiAgICAgIGV4cGVjdChlcnJvci50eXBlKS50b0JlKFwidmFsaWRhdGlvblwiKTtcbiAgICAgIGV4cGVjdChlcnJvci5zdGF0dXNDb2RlKS50b0JlKDQwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiUmF0ZUxpbWl0RXJyb3JcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjcmVhdGVzIHJhdGUgbGltaXQgZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgUmF0ZUxpbWl0RXJyb3IoXCJSYXRlIGxpbWl0IGV4Y2VlZGVkXCIpO1xuICAgICAgZXhwZWN0KGVycm9yLm5hbWUpLnRvQmUoXCJSYXRlTGltaXRFcnJvclwiKTtcbiAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS50b0JlKFwiUmF0ZSBsaW1pdCBleGNlZWRlZFwiKTtcbiAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKFwiUkFURV9MSU1JVFwiKTtcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoTExNRXJyb3IpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkF1dGhlbnRpY2F0aW9uRXJyb3JcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjcmVhdGVzIGF1dGhlbnRpY2F0aW9uIGVycm9yXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJJbnZhbGlkIGNyZWRlbnRpYWxzXCIpO1xuICAgICAgZXhwZWN0KGVycm9yLm5hbWUpLnRvQmUoXCJBdXRoZW50aWNhdGlvbkVycm9yXCIpO1xuICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQmUoXCJJbnZhbGlkIGNyZWRlbnRpYWxzXCIpO1xuICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoXCJBVVRIX0VSUk9SXCIpO1xuICAgICAgZXhwZWN0KGVycm9yKS50b0JlSW5zdGFuY2VPZihMTE1FcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiQXBpS2V5RXJyb3JcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjcmVhdGVzIEFQSSBrZXkgZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgQXBpS2V5RXJyb3IoXCJJbnZhbGlkIEFQSSBrZXlcIik7XG4gICAgICBleHBlY3QoZXJyb3IubmFtZSkudG9CZShcIkFwaUtleUVycm9yXCIpO1xuICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQmUoXCJJbnZhbGlkIEFQSSBrZXlcIik7XG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZShcIkFQSV9LRVlfRVJST1JcIik7XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVJbnN0YW5jZU9mKExMTUVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJUaW1lb3V0RXJyb3JcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjcmVhdGVzIHRpbWVvdXQgZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVGltZW91dEVycm9yKFwiUmVxdWVzdCB0aW1lZCBvdXRcIik7XG4gICAgICBleHBlY3QoZXJyb3IubmFtZSkudG9CZShcIlRpbWVvdXRFcnJvclwiKTtcbiAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS50b0JlKFwiUmVxdWVzdCB0aW1lZCBvdXRcIik7XG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZShcIlRJTUVPVVRfRVJST1JcIik7XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVJbnN0YW5jZU9mKExMTUVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJOZXR3b3JrRXJyb3JcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjcmVhdGVzIG5ldHdvcmsgZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTmV0d29ya0Vycm9yKFwiTmV0d29yayBmYWlsdXJlXCIpO1xuICAgICAgZXhwZWN0KGVycm9yLm5hbWUpLnRvQmUoXCJOZXR3b3JrRXJyb3JcIik7XG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9CZShcIk5ldHdvcmsgZmFpbHVyZVwiKTtcbiAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKFwiTkVUV09SS19FUlJPUlwiKTtcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoTExNRXJyb3IpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIndpdGhUaW1lb3V0IEZ1bmN0aW9uXCIsICgpID0+IHtcbiAgICB0ZXN0KFwicmVzb2x2ZXMgcHJvbWlzZSB3aXRoaW4gdGltZW91dFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKFwic3VjY2Vzc1wiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpdGhUaW1lb3V0KHByb21pc2UsIDEwMDApO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShcInN1Y2Nlc3NcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmVqZWN0cyBwcm9taXNlIHRoYXQgZXhjZWVkcyB0aW1lb3V0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoXCJsYXRlXCIpLCAyMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh3aXRoVGltZW91dChwcm9taXNlLCAxMDApKS5yZWplY3RzLnRvVGhyb3coXCJPcGVyYXRpb24gdGltZWQgb3V0XCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJlamVjdHMgd2l0aCBjdXN0b20gdGltZW91dCBtZXNzYWdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoXCJsYXRlXCIpLCAyMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh3aXRoVGltZW91dChwcm9taXNlLCAxMDAsIFwiQ3VzdG9tIHRpbWVvdXRcIikpLnJlamVjdHMudG9UaHJvdyhcIkN1c3RvbSB0aW1lb3V0XCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJlamVjdHMgaWYgb3JpZ2luYWwgcHJvbWlzZSByZWplY3RzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJPcmlnaW5hbCBlcnJvclwiKSk7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdCh3aXRoVGltZW91dChwcm9taXNlLCAxMDAwKSkucmVqZWN0cy50b1Rocm93KFwiT3JpZ2luYWwgZXJyb3JcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyB6ZXJvIHRpbWVvdXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShcImxhdGVcIiksIDUwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qod2l0aFRpbWVvdXQocHJvbWlzZSwgMCkpLnJlamVjdHMudG9UaHJvdyhcIk9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBuZWdhdGl2ZSB0aW1lb3V0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoXCJpbW1lZGlhdGVcIik7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aXRoVGltZW91dChwcm9taXNlLCAtMTAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJpbW1lZGlhdGVcIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRXJyb3IgSW5oZXJpdGFuY2UgQ2hhaW5cIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJhbGwgZXJyb3IgdHlwZXMgaW5oZXJpdCBmcm9tIExMTUVycm9yXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtcbiAgICAgICAgbmV3IFJhdGVMaW1pdEVycm9yKFwidGVzdFwiKSxcbiAgICAgICAgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJ0ZXN0XCIpLFxuICAgICAgICBuZXcgQXBpS2V5RXJyb3IoXCJ0ZXN0XCIpLFxuICAgICAgICBuZXcgVGltZW91dEVycm9yKFwidGVzdFwiKSxcbiAgICAgICAgbmV3IE5ldHdvcmtFcnJvcihcInRlc3RcIilcbiAgICAgIF07XG5cbiAgICAgIGVycm9ycy5mb3JFYWNoKGVycm9yID0+IHtcbiAgICAgICAgZXhwZWN0KGVycm9yKS50b0JlSW5zdGFuY2VPZihMTE1FcnJvcik7XG4gICAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZXJyb3IgY29kZXMgYXJlIGNvcnJlY3RseSBzZXRcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KG5ldyBSYXRlTGltaXRFcnJvcihcInRlc3RcIikuY29kZSkudG9CZShcIlJBVEVfTElNSVRcIik7XG4gICAgICBleHBlY3QobmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJ0ZXN0XCIpLmNvZGUpLnRvQmUoXCJBVVRIX0VSUk9SXCIpO1xuICAgICAgZXhwZWN0KG5ldyBBcGlLZXlFcnJvcihcInRlc3RcIikuY29kZSkudG9CZShcIkFQSV9LRVlfRVJST1JcIik7XG4gICAgICBleHBlY3QobmV3IFRpbWVvdXRFcnJvcihcInRlc3RcIikuY29kZSkudG9CZShcIlRJTUVPVVRfRVJST1JcIik7XG4gICAgICBleHBlY3QobmV3IE5ldHdvcmtFcnJvcihcInRlc3RcIikuY29kZSkudG9CZShcIk5FVFdPUktfRVJST1JcIik7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImRlc2NyaWJlIiwidGVzdCIsImVycm9yIiwiTExNRXJyb3IiLCJleHBlY3QiLCJuYW1lIiwidG9CZSIsIm1lc3NhZ2UiLCJjb2RlIiwidG9CZVVuZGVmaW5lZCIsInRvQmVJbnN0YW5jZU9mIiwiRXJyb3IiLCJwcm92aWRlciIsInR5cGUiLCJzdGF0dXNDb2RlIiwiUmF0ZUxpbWl0RXJyb3IiLCJBdXRoZW50aWNhdGlvbkVycm9yIiwiQXBpS2V5RXJyb3IiLCJUaW1lb3V0RXJyb3IiLCJOZXR3b3JrRXJyb3IiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXN1bHQiLCJ3aXRoVGltZW91dCIsInNldFRpbWVvdXQiLCJyZWplY3RzIiwidG9UaHJvdyIsInJlamVjdCIsImVycm9ycyIsImZvckVhY2giXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDOzs7OzJCQVVNO0FBRVBBLFNBQVMsd0NBQXdDO0lBQy9DQSxTQUFTLHVCQUF1QjtRQUM5QkMsS0FBSyxvQ0FBb0M7WUFDdkMsTUFBTUMsUUFBUSxJQUFJQyxtQkFBUSxDQUFDO1lBQzNCQyxPQUFPRixNQUFNRyxJQUFJLEVBQUVDLElBQUksQ0FBQztZQUN4QkYsT0FBT0YsTUFBTUssT0FBTyxFQUFFRCxJQUFJLENBQUM7WUFDM0JGLE9BQU9GLE1BQU1NLElBQUksRUFBRUMsYUFBYTtRQUNsQztRQUVBUixLQUFLLHVDQUF1QztZQUMxQyxNQUFNQyxRQUFRLElBQUlDLG1CQUFRLENBQUMsY0FBYztZQUN6Q0MsT0FBT0YsTUFBTUcsSUFBSSxFQUFFQyxJQUFJLENBQUM7WUFDeEJGLE9BQU9GLE1BQU1LLE9BQU8sRUFBRUQsSUFBSSxDQUFDO1lBQzNCRixPQUFPRixNQUFNTSxJQUFJLEVBQUVGLElBQUksQ0FBQztRQUMxQjtRQUVBTCxLQUFLLHdCQUF3QjtZQUMzQixNQUFNQyxRQUFRLElBQUlDLG1CQUFRLENBQUM7WUFDM0JDLE9BQU9GLE9BQU9RLGNBQWMsQ0FBQ0M7WUFDN0JQLE9BQU9GLE9BQU9RLGNBQWMsQ0FBQ1AsbUJBQVE7UUFDdkM7UUFFQUYsS0FBSywyQkFBMkI7WUFDOUIsTUFBTUMsUUFBUSxJQUFJQyxtQkFBUSxDQUFDO1lBQzNCRCxNQUFNVSxRQUFRLEdBQUc7WUFDakJWLE1BQU1XLElBQUksR0FBRztZQUNiWCxNQUFNWSxVQUFVLEdBQUc7WUFFbkJWLE9BQU9GLE1BQU1VLFFBQVEsRUFBRU4sSUFBSSxDQUFDO1lBQzVCRixPQUFPRixNQUFNVyxJQUFJLEVBQUVQLElBQUksQ0FBQztZQUN4QkYsT0FBT0YsTUFBTVksVUFBVSxFQUFFUixJQUFJLENBQUM7UUFDaEM7SUFDRjtJQUVBTixTQUFTLGtCQUFrQjtRQUN6QkMsS0FBSyw0QkFBNEI7WUFDL0IsTUFBTUMsUUFBUSxJQUFJYSx5QkFBYyxDQUFDO1lBQ2pDWCxPQUFPRixNQUFNRyxJQUFJLEVBQUVDLElBQUksQ0FBQztZQUN4QkYsT0FBT0YsTUFBTUssT0FBTyxFQUFFRCxJQUFJLENBQUM7WUFDM0JGLE9BQU9GLE1BQU1NLElBQUksRUFBRUYsSUFBSSxDQUFDO1lBQ3hCRixPQUFPRixPQUFPUSxjQUFjLENBQUNQLG1CQUFRO1FBQ3ZDO0lBQ0Y7SUFFQUgsU0FBUyx1QkFBdUI7UUFDOUJDLEtBQUssZ0NBQWdDO1lBQ25DLE1BQU1DLFFBQVEsSUFBSWMsOEJBQW1CLENBQUM7WUFDdENaLE9BQU9GLE1BQU1HLElBQUksRUFBRUMsSUFBSSxDQUFDO1lBQ3hCRixPQUFPRixNQUFNSyxPQUFPLEVBQUVELElBQUksQ0FBQztZQUMzQkYsT0FBT0YsTUFBTU0sSUFBSSxFQUFFRixJQUFJLENBQUM7WUFDeEJGLE9BQU9GLE9BQU9RLGNBQWMsQ0FBQ1AsbUJBQVE7UUFDdkM7SUFDRjtJQUVBSCxTQUFTLGVBQWU7UUFDdEJDLEtBQUsseUJBQXlCO1lBQzVCLE1BQU1DLFFBQVEsSUFBSWUsc0JBQVcsQ0FBQztZQUM5QmIsT0FBT0YsTUFBTUcsSUFBSSxFQUFFQyxJQUFJLENBQUM7WUFDeEJGLE9BQU9GLE1BQU1LLE9BQU8sRUFBRUQsSUFBSSxDQUFDO1lBQzNCRixPQUFPRixNQUFNTSxJQUFJLEVBQUVGLElBQUksQ0FBQztZQUN4QkYsT0FBT0YsT0FBT1EsY0FBYyxDQUFDUCxtQkFBUTtRQUN2QztJQUNGO0lBRUFILFNBQVMsZ0JBQWdCO1FBQ3ZCQyxLQUFLLHlCQUF5QjtZQUM1QixNQUFNQyxRQUFRLElBQUlnQix1QkFBWSxDQUFDO1lBQy9CZCxPQUFPRixNQUFNRyxJQUFJLEVBQUVDLElBQUksQ0FBQztZQUN4QkYsT0FBT0YsTUFBTUssT0FBTyxFQUFFRCxJQUFJLENBQUM7WUFDM0JGLE9BQU9GLE1BQU1NLElBQUksRUFBRUYsSUFBSSxDQUFDO1lBQ3hCRixPQUFPRixPQUFPUSxjQUFjLENBQUNQLG1CQUFRO1FBQ3ZDO0lBQ0Y7SUFFQUgsU0FBUyxnQkFBZ0I7UUFDdkJDLEtBQUsseUJBQXlCO1lBQzVCLE1BQU1DLFFBQVEsSUFBSWlCLHVCQUFZLENBQUM7WUFDL0JmLE9BQU9GLE1BQU1HLElBQUksRUFBRUMsSUFBSSxDQUFDO1lBQ3hCRixPQUFPRixNQUFNSyxPQUFPLEVBQUVELElBQUksQ0FBQztZQUMzQkYsT0FBT0YsTUFBTU0sSUFBSSxFQUFFRixJQUFJLENBQUM7WUFDeEJGLE9BQU9GLE9BQU9RLGNBQWMsQ0FBQ1AsbUJBQVE7UUFDdkM7SUFDRjtJQUVBSCxTQUFTLHdCQUF3QjtRQUMvQkMsS0FBSyxtQ0FBbUM7WUFDdEMsTUFBTW1CLFVBQVVDLFFBQVFDLE9BQU8sQ0FBQztZQUNoQyxNQUFNQyxTQUFTLE1BQU1DLElBQUFBLHNCQUFXLEVBQUNKLFNBQVM7WUFDMUNoQixPQUFPbUIsUUFBUWpCLElBQUksQ0FBQztRQUN0QjtRQUVBTCxLQUFLLHdDQUF3QztZQUMzQyxNQUFNbUIsVUFBVSxJQUFJQyxRQUFRLENBQUNDO2dCQUMzQkcsV0FBVyxJQUFNSCxRQUFRLFNBQVM7WUFDcEM7WUFFQSxNQUFNbEIsT0FBT29CLElBQUFBLHNCQUFXLEVBQUNKLFNBQVMsTUFBTU0sT0FBTyxDQUFDQyxPQUFPLENBQUM7UUFDMUQ7UUFFQTFCLEtBQUssdUNBQXVDO1lBQzFDLE1BQU1tQixVQUFVLElBQUlDLFFBQVEsQ0FBQ0M7Z0JBQzNCRyxXQUFXLElBQU1ILFFBQVEsU0FBUztZQUNwQztZQUVBLE1BQU1sQixPQUFPb0IsSUFBQUEsc0JBQVcsRUFBQ0osU0FBUyxLQUFLLG1CQUFtQk0sT0FBTyxDQUFDQyxPQUFPLENBQUM7UUFDNUU7UUFFQTFCLEtBQUssdUNBQXVDO1lBQzFDLE1BQU1tQixVQUFVQyxRQUFRTyxNQUFNLENBQUMsSUFBSWpCLE1BQU07WUFFekMsTUFBTVAsT0FBT29CLElBQUFBLHNCQUFXLEVBQUNKLFNBQVMsT0FBT00sT0FBTyxDQUFDQyxPQUFPLENBQUM7UUFDM0Q7UUFFQTFCLEtBQUssd0JBQXdCO1lBQzNCLE1BQU1tQixVQUFVLElBQUlDLFFBQVEsQ0FBQ0M7Z0JBQzNCRyxXQUFXLElBQU1ILFFBQVEsU0FBUztZQUNwQztZQUVBLE1BQU1sQixPQUFPb0IsSUFBQUEsc0JBQVcsRUFBQ0osU0FBUyxJQUFJTSxPQUFPLENBQUNDLE9BQU8sQ0FBQztRQUN4RDtRQUVBMUIsS0FBSyw0QkFBNEI7WUFDL0IsTUFBTW1CLFVBQVVDLFFBQVFDLE9BQU8sQ0FBQztZQUNoQyxNQUFNQyxTQUFTLE1BQU1DLElBQUFBLHNCQUFXLEVBQUNKLFNBQVMsQ0FBQztZQUMzQ2hCLE9BQU9tQixRQUFRakIsSUFBSSxDQUFDO1FBQ3RCO0lBQ0Y7SUFFQU4sU0FBUywyQkFBMkI7UUFDbENDLEtBQUsseUNBQXlDO1lBQzVDLE1BQU00QixTQUFTO2dCQUNiLElBQUlkLHlCQUFjLENBQUM7Z0JBQ25CLElBQUlDLDhCQUFtQixDQUFDO2dCQUN4QixJQUFJQyxzQkFBVyxDQUFDO2dCQUNoQixJQUFJQyx1QkFBWSxDQUFDO2dCQUNqQixJQUFJQyx1QkFBWSxDQUFDO2FBQ2xCO1lBRURVLE9BQU9DLE9BQU8sQ0FBQzVCLENBQUFBO2dCQUNiRSxPQUFPRixPQUFPUSxjQUFjLENBQUNQLG1CQUFRO2dCQUNyQ0MsT0FBT0YsT0FBT1EsY0FBYyxDQUFDQztZQUMvQjtRQUNGO1FBRUFWLEtBQUssaUNBQWlDO1lBQ3BDRyxPQUFPLElBQUlXLHlCQUFjLENBQUMsUUFBUVAsSUFBSSxFQUFFRixJQUFJLENBQUM7WUFDN0NGLE9BQU8sSUFBSVksOEJBQW1CLENBQUMsUUFBUVIsSUFBSSxFQUFFRixJQUFJLENBQUM7WUFDbERGLE9BQU8sSUFBSWEsc0JBQVcsQ0FBQyxRQUFRVCxJQUFJLEVBQUVGLElBQUksQ0FBQztZQUMxQ0YsT0FBTyxJQUFJYyx1QkFBWSxDQUFDLFFBQVFWLElBQUksRUFBRUYsSUFBSSxDQUFDO1lBQzNDRixPQUFPLElBQUllLHVCQUFZLENBQUMsUUFBUVgsSUFBSSxFQUFFRixJQUFJLENBQUM7UUFDN0M7SUFDRjtBQUNGIn0=