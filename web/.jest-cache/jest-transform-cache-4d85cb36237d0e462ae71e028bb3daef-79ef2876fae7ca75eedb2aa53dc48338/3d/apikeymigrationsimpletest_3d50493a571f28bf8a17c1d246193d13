197be7492478b00eabf46958fd10a4a1
/**
 * Phase 1: lib/api-key-migration.ts Simplified Test Suite
 * Target: Complete API key migration functionality (simplified approach)
 * Goal: Maximum statement coverage for security migration utilities
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _apikeymigration = require("../../lib/api-key-migration");
// Mock localStorage
const mockLocalStorage = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn(),
    length: 0,
    key: jest.fn()
};
Object.defineProperty(window, "localStorage", {
    value: mockLocalStorage,
    writable: true
});
describe("lib/api-key-migration.ts - Simplified Coverage", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe("checkForApiKeysToMigrate function", ()=>{
        test("returns providers when API keys found in localStorage", ()=>{
            const mockSettings = {
                provider: "openai",
                apiKey: "sk-test123",
                model: "gpt-4"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([
                "openai"
            ]);
            expect(mockLocalStorage.getItem).toHaveBeenCalledWith("llm-settings");
        });
        test("returns empty array when no settings in localStorage", ()=>{
            mockLocalStorage.getItem.mockReturnValue(null);
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
            expect(mockLocalStorage.getItem).toHaveBeenCalledWith("llm-settings");
        });
        test("returns empty array when settings exist but no API key", ()=>{
            const mockSettings = {
                provider: "openai",
                model: "gpt-4"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
        });
        test("returns empty array when settings exist but no provider", ()=>{
            const mockSettings = {
                apiKey: "sk-test123",
                model: "gpt-4"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
        });
        test("handles invalid JSON in localStorage gracefully", ()=>{
            const consoleSpy = jest.spyOn(console, "error").mockImplementation();
            mockLocalStorage.getItem.mockReturnValue("invalid-json");
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
            expect(consoleSpy).toHaveBeenCalledWith("Error checking for API keys to migrate:", expect.any(Error));
            consoleSpy.mockRestore();
        });
        test("handles localStorage access errors gracefully", ()=>{
            const consoleSpy = jest.spyOn(console, "error").mockImplementation();
            mockLocalStorage.getItem.mockImplementation(()=>{
                throw new Error("localStorage not available");
            });
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
            expect(consoleSpy).toHaveBeenCalledWith("Error checking for API keys to migrate:", expect.any(Error));
            consoleSpy.mockRestore();
        });
        test("handles different provider types", ()=>{
            const providers = [
                "openai",
                "anthropic",
                "google",
                "mistral",
                "custom"
            ];
            providers.forEach((provider)=>{
                const mockSettings = {
                    provider,
                    apiKey: `${provider}-key-123`,
                    model: "test-model"
                };
                mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
                const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
                expect(result).toEqual([
                    provider
                ]);
            });
        });
        test("handles edge case settings structures", ()=>{
            const edgeCaseSettings = [
                // Empty objects
                {},
                // Null values
                {
                    provider: null,
                    apiKey: null
                },
                // Empty strings
                {
                    provider: "",
                    apiKey: ""
                },
                // Undefined values
                {
                    provider: undefined,
                    apiKey: undefined
                },
                // Mixed valid/invalid
                {
                    provider: "openai",
                    apiKey: null
                },
                {
                    provider: null,
                    apiKey: "sk-test123"
                }
            ];
            edgeCaseSettings.forEach((settings)=>{
                mockLocalStorage.getItem.mockReturnValue(JSON.stringify(settings));
                const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
                expect(Array.isArray(result)).toBe(true);
            });
        });
        test("handles truthy/falsy value edge cases", ()=>{
            const edgeCases = [
                {
                    provider: "openai",
                    apiKey: "valid-key"
                },
                {
                    provider: "openai",
                    apiKey: ""
                },
                {
                    provider: "",
                    apiKey: "valid-key"
                },
                {
                    provider: 0,
                    apiKey: "valid-key"
                },
                {
                    provider: "openai",
                    apiKey: 0
                },
                {
                    provider: false,
                    apiKey: "valid-key"
                },
                {
                    provider: "openai",
                    apiKey: false
                }
            ];
            edgeCases.forEach((settings, index)=>{
                mockLocalStorage.getItem.mockReturnValue(JSON.stringify(settings));
                const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
                if (index === 0) {
                    // Only the first case should return a provider
                    expect(result).toEqual([
                        "openai"
                    ]);
                } else {
                    // All other cases should return empty array
                    expect(result).toEqual([]);
                }
            });
        });
        test("validates function behavior with large data", ()=>{
            const largeSettings = {
                provider: "x".repeat(1000),
                apiKey: "y".repeat(10000),
                extraData: Array.from({
                    length: 100
                }, (_, i)=>({
                        key: `value-${i}`,
                        data: "z".repeat(100)
                    }))
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(largeSettings));
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([
                largeSettings.provider
            ]);
        });
        test("ensures consistent return type and structure", ()=>{
            const testCases = [
                null,
                "invalid-json",
                "{}",
                "[]",
                "null",
                "undefined"
            ];
            testCases.forEach((testCase)=>{
                mockLocalStorage.getItem.mockReturnValue(testCase);
                const consoleSpy = jest.spyOn(console, "error").mockImplementation();
                const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
                // Should always return an array
                expect(Array.isArray(result)).toBe(true);
                // Should always be an array of strings
                result.forEach((item)=>{
                    expect(typeof item).toBe("string");
                });
                consoleSpy.mockRestore();
            });
        });
        test("handles concurrent access patterns", ()=>{
            // Simulate concurrent calls
            const mockSettings = {
                provider: "openai",
                apiKey: "sk-test123"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            const concurrentCalls = Array.from({
                length: 10
            }, ()=>(0, _apikeymigration.checkForApiKeysToMigrate)());
            const results = concurrentCalls;
            // All calls should succeed and return same result
            expect(results).toHaveLength(10);
            results.forEach((result)=>{
                expect(result).toEqual([
                    "openai"
                ]);
            });
        });
        test("validates memory efficiency with repeated calls", ()=>{
            const mockSettings = {
                provider: "anthropic",
                apiKey: "claude-key-123"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            // Make many repeated calls
            for(let i = 0; i < 1000; i++){
                const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
                expect(result).toEqual([
                    "anthropic"
                ]);
            }
            // Function should still work correctly after many calls
            const finalResult = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(finalResult).toEqual([
                "anthropic"
            ]);
        });
    });
    describe("API compatibility and type safety", ()=>{
        test("function has correct signature", ()=>{
            expect(typeof _apikeymigration.checkForApiKeysToMigrate).toBe("function");
            expect(_apikeymigration.checkForApiKeysToMigrate.length).toBe(0); // No parameters expected
        });
        test("function returns correct type", ()=>{
            mockLocalStorage.getItem.mockReturnValue(null);
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(Array.isArray(result)).toBe(true);
            expect(typeof result).toBe("object");
        });
        test("handles extreme edge cases without crashing", ()=>{
            const extremeCases = [
                undefined,
                null,
                "",
                " ",
                "\n",
                "	",
                "{}",
                "[]",
                "null",
                "undefined",
                "NaN",
                "0",
                "false",
                "true"
            ];
            extremeCases.forEach((testCase)=>{
                mockLocalStorage.getItem.mockReturnValue(testCase);
                const consoleSpy = jest.spyOn(console, "error").mockImplementation();
                expect(()=>{
                    const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
                    expect(Array.isArray(result)).toBe(true);
                }).not.toThrow();
                consoleSpy.mockRestore();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2FwaS1rZXktbWlncmF0aW9uLXNpbXBsZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGhhc2UgMTogbGliL2FwaS1rZXktbWlncmF0aW9uLnRzIFNpbXBsaWZpZWQgVGVzdCBTdWl0ZVxuICogVGFyZ2V0OiBDb21wbGV0ZSBBUEkga2V5IG1pZ3JhdGlvbiBmdW5jdGlvbmFsaXR5IChzaW1wbGlmaWVkIGFwcHJvYWNoKVxuICogR29hbDogTWF4aW11bSBzdGF0ZW1lbnQgY292ZXJhZ2UgZm9yIHNlY3VyaXR5IG1pZ3JhdGlvbiB1dGlsaXRpZXNcbiAqL1xuXG5pbXBvcnQgeyBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUgfSBmcm9tIFwiLi4vLi4vbGliL2FwaS1rZXktbWlncmF0aW9uXCI7XG5cbi8vIE1vY2sgbG9jYWxTdG9yYWdlXG5jb25zdCBtb2NrTG9jYWxTdG9yYWdlID0ge1xuICBnZXRJdGVtOiBqZXN0LmZuKCksXG4gIHNldEl0ZW06IGplc3QuZm4oKSxcbiAgcmVtb3ZlSXRlbTogamVzdC5mbigpLFxuICBjbGVhcjogamVzdC5mbigpLFxuICBsZW5ndGg6IDAsXG4gIGtleTogamVzdC5mbigpLFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwibG9jYWxTdG9yYWdlXCIsIHtcbiAgdmFsdWU6IG1vY2tMb2NhbFN0b3JhZ2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxufSk7XG5cbmRlc2NyaWJlKFwibGliL2FwaS1rZXktbWlncmF0aW9uLnRzIC0gU2ltcGxpZmllZCBDb3ZlcmFnZVwiLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZShcImNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSBmdW5jdGlvblwiLCAoKSA9PiB7XG4gICAgdGVzdChcInJldHVybnMgcHJvdmlkZXJzIHdoZW4gQVBJIGtleXMgZm91bmQgaW4gbG9jYWxTdG9yYWdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICAgIGFwaUtleTogXCJzay10ZXN0MTIzXCIsXG4gICAgICAgIG1vZGVsOiBcImdwdC00XCIsXG4gICAgICB9O1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShtb2NrU2V0dGluZ3MpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1wib3BlbmFpXCJdKTtcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwibGxtLXNldHRpbmdzXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJldHVybnMgZW1wdHkgYXJyYXkgd2hlbiBubyBzZXR0aW5ncyBpbiBsb2NhbFN0b3JhZ2VcIiwgKCkgPT4ge1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJsbG0tc2V0dGluZ3NcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmV0dXJucyBlbXB0eSBhcnJheSB3aGVuIHNldHRpbmdzIGV4aXN0IGJ1dCBubyBBUEkga2V5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICAgIG1vZGVsOiBcImdwdC00XCIsXG4gICAgICAgIC8vIE5vIGFwaUtleVxuICAgICAgfTtcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoSlNPTi5zdHJpbmdpZnkobW9ja1NldHRpbmdzKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJyZXR1cm5zIGVtcHR5IGFycmF5IHdoZW4gc2V0dGluZ3MgZXhpc3QgYnV0IG5vIHByb3ZpZGVyXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgICAgYXBpS2V5OiBcInNrLXRlc3QxMjNcIixcbiAgICAgICAgbW9kZWw6IFwiZ3B0LTRcIixcbiAgICAgICAgLy8gTm8gcHJvdmlkZXJcbiAgICAgIH07XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KG1vY2tTZXR0aW5ncykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBpbnZhbGlkIEpTT04gaW4gbG9jYWxTdG9yYWdlIGdyYWNlZnVsbHlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgXCJlcnJvclwiKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoXCJpbnZhbGlkLWpzb25cIik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJFcnJvciBjaGVja2luZyBmb3IgQVBJIGtleXMgdG8gbWlncmF0ZTpcIixcbiAgICAgICAgZXhwZWN0LmFueShFcnJvciksXG4gICAgICApO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBsb2NhbFN0b3JhZ2UgYWNjZXNzIGVycm9ycyBncmFjZWZ1bGx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsIFwiZXJyb3JcIikubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9jYWxTdG9yYWdlIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkVycm9yIGNoZWNraW5nIGZvciBBUEkga2V5cyB0byBtaWdyYXRlOlwiLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGRpZmZlcmVudCBwcm92aWRlciB0eXBlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBwcm92aWRlcnMgPSBbXCJvcGVuYWlcIiwgXCJhbnRocm9waWNcIiwgXCJnb29nbGVcIiwgXCJtaXN0cmFsXCIsIFwiY3VzdG9tXCJdO1xuXG4gICAgICBwcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXIpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1NldHRpbmdzID0ge1xuICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgIGFwaUtleTogYCR7cHJvdmlkZXJ9LWtleS0xMjNgLFxuICAgICAgICAgIG1vZGVsOiBcInRlc3QtbW9kZWxcIixcbiAgICAgICAgfTtcbiAgICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShtb2NrU2V0dGluZ3MpKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUoKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtwcm92aWRlcl0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlZGdlIGNhc2Ugc2V0dGluZ3Mgc3RydWN0dXJlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBlZGdlQ2FzZVNldHRpbmdzID0gW1xuICAgICAgICAvLyBFbXB0eSBvYmplY3RzXG4gICAgICAgIHt9LFxuICAgICAgICAvLyBOdWxsIHZhbHVlc1xuICAgICAgICB7IHByb3ZpZGVyOiBudWxsLCBhcGlLZXk6IG51bGwgfSxcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5nc1xuICAgICAgICB7IHByb3ZpZGVyOiBcIlwiLCBhcGlLZXk6IFwiXCIgfSxcbiAgICAgICAgLy8gVW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICB7IHByb3ZpZGVyOiB1bmRlZmluZWQsIGFwaUtleTogdW5kZWZpbmVkIH0sXG4gICAgICAgIC8vIE1peGVkIHZhbGlkL2ludmFsaWRcbiAgICAgICAgeyBwcm92aWRlcjogXCJvcGVuYWlcIiwgYXBpS2V5OiBudWxsIH0sXG4gICAgICAgIHsgcHJvdmlkZXI6IG51bGwsIGFwaUtleTogXCJzay10ZXN0MTIzXCIgfSxcbiAgICAgIF07XG5cbiAgICAgIGVkZ2VDYXNlU2V0dGluZ3MuZm9yRWFjaCgoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUoKTtcbiAgICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkocmVzdWx0KSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgdHJ1dGh5L2ZhbHN5IHZhbHVlIGVkZ2UgY2FzZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZWRnZUNhc2VzID0gW1xuICAgICAgICB7IHByb3ZpZGVyOiBcIm9wZW5haVwiLCBhcGlLZXk6IFwidmFsaWQta2V5XCIgfSwgLy8gU2hvdWxkIHBhc3NcbiAgICAgICAgeyBwcm92aWRlcjogXCJvcGVuYWlcIiwgYXBpS2V5OiBcIlwiIH0sIC8vIEVtcHR5IHN0cmluZyBzaG91bGQgZmFpbFxuICAgICAgICB7IHByb3ZpZGVyOiBcIlwiLCBhcGlLZXk6IFwidmFsaWQta2V5XCIgfSwgLy8gRW1wdHkgcHJvdmlkZXIgc2hvdWxkIGZhaWxcbiAgICAgICAgeyBwcm92aWRlcjogMCwgYXBpS2V5OiBcInZhbGlkLWtleVwiIH0sIC8vIEZhbHN5IHByb3ZpZGVyIHNob3VsZCBmYWlsXG4gICAgICAgIHsgcHJvdmlkZXI6IFwib3BlbmFpXCIsIGFwaUtleTogMCB9LCAvLyBGYWxzeSBhcGlLZXkgc2hvdWxkIGZhaWxcbiAgICAgICAgeyBwcm92aWRlcjogZmFsc2UsIGFwaUtleTogXCJ2YWxpZC1rZXlcIiB9LCAvLyBCb29sZWFuIGZhbHNlIHNob3VsZCBmYWlsXG4gICAgICAgIHsgcHJvdmlkZXI6IFwib3BlbmFpXCIsIGFwaUtleTogZmFsc2UgfSwgLy8gQm9vbGVhbiBmYWxzZSBzaG91bGQgZmFpbFxuICAgICAgXTtcblxuICAgICAgZWRnZUNhc2VzLmZvckVhY2goKHNldHRpbmdzLCBpbmRleCkgPT4ge1xuICAgICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGNhc2Ugc2hvdWxkIHJldHVybiBhIHByb3ZpZGVyXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXCJvcGVuYWlcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsbCBvdGhlciBjYXNlcyBzaG91bGQgcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInZhbGlkYXRlcyBmdW5jdGlvbiBiZWhhdmlvciB3aXRoIGxhcmdlIGRhdGFcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VTZXR0aW5ncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IFwieFwiLnJlcGVhdCgxMDAwKSxcbiAgICAgICAgYXBpS2V5OiBcInlcIi5yZXBlYXQoMTAwMDApLFxuICAgICAgICBleHRyYURhdGE6IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgICBrZXk6IGB2YWx1ZS0ke2l9YCxcbiAgICAgICAgICBkYXRhOiBcInpcIi5yZXBlYXQoMTAwKSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShsYXJnZVNldHRpbmdzKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtsYXJnZVNldHRpbmdzLnByb3ZpZGVyXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZW5zdXJlcyBjb25zaXN0ZW50IHJldHVybiB0eXBlIGFuZCBzdHJ1Y3R1cmVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENhc2VzID0gW1xuICAgICAgICBudWxsLCAvLyBObyBsb2NhbFN0b3JhZ2UgZGF0YVxuICAgICAgICBcImludmFsaWQtanNvblwiLCAvLyBJbnZhbGlkIEpTT05cbiAgICAgICAgXCJ7fVwiLCAvLyBFbXB0eSBvYmplY3RcbiAgICAgICAgXCJbXVwiLCAvLyBBcnJheSBpbnN0ZWFkIG9mIG9iamVjdFxuICAgICAgICBcIm51bGxcIiwgLy8gU3RyaW5nICdudWxsJ1xuICAgICAgICBcInVuZGVmaW5lZFwiLCAvLyBTdHJpbmcgJ3VuZGVmaW5lZCdcbiAgICAgIF07XG5cbiAgICAgIHRlc3RDYXNlcy5mb3JFYWNoKCh0ZXN0Q2FzZSkgPT4ge1xuICAgICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKHRlc3RDYXNlKTtcbiAgICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgXCJlcnJvclwiKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUoKTtcblxuICAgICAgICAvLyBTaG91bGQgYWx3YXlzIHJldHVybiBhbiBhcnJheVxuICAgICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShyZXN1bHQpKS50b0JlKHRydWUpO1xuICAgICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgICAgcmVzdWx0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBleHBlY3QodHlwZW9mIGl0ZW0pLnRvQmUoXCJzdHJpbmdcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgY29uY3VycmVudCBhY2Nlc3MgcGF0dGVybnNcIiwgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhdGUgY29uY3VycmVudCBjYWxsc1xuICAgICAgY29uc3QgbW9ja1NldHRpbmdzID0ge1xuICAgICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgICAgYXBpS2V5OiBcInNrLXRlc3QxMjNcIixcbiAgICAgIH07XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KG1vY2tTZXR0aW5ncykpO1xuXG4gICAgICBjb25zdCBjb25jdXJyZW50Q2FsbHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCAoKSA9PlxuICAgICAgICBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUoKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25jdXJyZW50Q2FsbHM7XG5cbiAgICAgIC8vIEFsbCBjYWxscyBzaG91bGQgc3VjY2VlZCBhbmQgcmV0dXJuIHNhbWUgcmVzdWx0XG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDEwKTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1wib3BlbmFpXCJdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInZhbGlkYXRlcyBtZW1vcnkgZWZmaWNpZW5jeSB3aXRoIHJlcGVhdGVkIGNhbGxzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IFwiYW50aHJvcGljXCIsXG4gICAgICAgIGFwaUtleTogXCJjbGF1ZGUta2V5LTEyM1wiLFxuICAgICAgfTtcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoSlNPTi5zdHJpbmdpZnkobW9ja1NldHRpbmdzKSk7XG5cbiAgICAgIC8vIE1ha2UgbWFueSByZXBlYXRlZCBjYWxsc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlKCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1wiYW50aHJvcGljXCJdKTtcbiAgICAgIH1cblxuICAgICAgLy8gRnVuY3Rpb24gc2hvdWxkIHN0aWxsIHdvcmsgY29ycmVjdGx5IGFmdGVyIG1hbnkgY2FsbHNcbiAgICAgIGNvbnN0IGZpbmFsUmVzdWx0ID0gY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlKCk7XG4gICAgICBleHBlY3QoZmluYWxSZXN1bHQpLnRvRXF1YWwoW1wiYW50aHJvcGljXCJdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJBUEkgY29tcGF0aWJpbGl0eSBhbmQgdHlwZSBzYWZldHlcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJmdW5jdGlvbiBoYXMgY29ycmVjdCBzaWduYXR1cmVcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KHR5cGVvZiBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUpLnRvQmUoXCJmdW5jdGlvblwiKTtcbiAgICAgIGV4cGVjdChjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUubGVuZ3RoKS50b0JlKDApOyAvLyBObyBwYXJhbWV0ZXJzIGV4cGVjdGVkXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZnVuY3Rpb24gcmV0dXJucyBjb3JyZWN0IHR5cGVcIiwgKCkgPT4ge1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlKCk7XG5cbiAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KHJlc3VsdCkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdCkudG9CZShcIm9iamVjdFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGV4dHJlbWUgZWRnZSBjYXNlcyB3aXRob3V0IGNyYXNoaW5nXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGV4dHJlbWVDYXNlcyA9IFtcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBudWxsLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIiBcIixcbiAgICAgICAgXCJcXG5cIixcbiAgICAgICAgXCJcXHRcIixcbiAgICAgICAgXCJ7fVwiLFxuICAgICAgICBcIltdXCIsXG4gICAgICAgIFwibnVsbFwiLFxuICAgICAgICBcInVuZGVmaW5lZFwiLFxuICAgICAgICBcIk5hTlwiLFxuICAgICAgICBcIjBcIixcbiAgICAgICAgXCJmYWxzZVwiLFxuICAgICAgICBcInRydWVcIixcbiAgICAgIF07XG5cbiAgICAgIGV4dHJlbWVDYXNlcy5mb3JFYWNoKCh0ZXN0Q2FzZSkgPT4ge1xuICAgICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKHRlc3RDYXNlKTtcbiAgICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgXCJlcnJvclwiKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuICAgICAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KHJlc3VsdCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pLm5vdC50b1Rocm93KCk7XG5cbiAgICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsibW9ja0xvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJqZXN0IiwiZm4iLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImNsZWFyIiwibGVuZ3RoIiwia2V5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3aW5kb3ciLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInRlc3QiLCJtb2NrU2V0dGluZ3MiLCJwcm92aWRlciIsImFwaUtleSIsIm1vZGVsIiwibW9ja1JldHVyblZhbHVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3VsdCIsImNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSIsImV4cGVjdCIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImNvbnNvbGVTcHkiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJhbnkiLCJFcnJvciIsIm1vY2tSZXN0b3JlIiwicHJvdmlkZXJzIiwiZm9yRWFjaCIsImVkZ2VDYXNlU2V0dGluZ3MiLCJ1bmRlZmluZWQiLCJzZXR0aW5ncyIsIkFycmF5IiwiaXNBcnJheSIsInRvQmUiLCJlZGdlQ2FzZXMiLCJpbmRleCIsImxhcmdlU2V0dGluZ3MiLCJyZXBlYXQiLCJleHRyYURhdGEiLCJmcm9tIiwiXyIsImkiLCJkYXRhIiwidGVzdENhc2VzIiwidGVzdENhc2UiLCJpdGVtIiwiY29uY3VycmVudENhbGxzIiwicmVzdWx0cyIsInRvSGF2ZUxlbmd0aCIsImZpbmFsUmVzdWx0IiwiZXh0cmVtZUNhc2VzIiwibm90IiwidG9UaHJvdyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQzs7OztpQ0FFd0M7QUFFekMsb0JBQW9CO0FBQ3BCLE1BQU1BLG1CQUFtQjtJQUN2QkMsU0FBU0MsS0FBS0MsRUFBRTtJQUNoQkMsU0FBU0YsS0FBS0MsRUFBRTtJQUNoQkUsWUFBWUgsS0FBS0MsRUFBRTtJQUNuQkcsT0FBT0osS0FBS0MsRUFBRTtJQUNkSSxRQUFRO0lB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