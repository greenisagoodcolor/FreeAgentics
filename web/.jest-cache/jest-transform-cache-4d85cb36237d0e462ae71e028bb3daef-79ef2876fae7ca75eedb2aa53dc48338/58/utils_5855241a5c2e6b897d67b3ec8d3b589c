75f60319b97396814f6a68febd03077b
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    cn: function() {
        return cn;
    },
    extractTagsFromMarkdown: function() {
        return extractTagsFromMarkdown;
    },
    formatTimestamp: function() {
        return formatTimestamp;
    }
});
const _clsx = require("clsx");
const _tailwindmerge = require("tailwind-merge");
function cn(...inputs) {
    return (0, _tailwindmerge.twMerge)((0, _clsx.clsx)(inputs));
}
function extractTagsFromMarkdown(markdown) {
    // Match both [[tag]] syntax and #tag syntax (including #tag-with-hyphens)
    const tagRegex = /\[\[(.*?)\]\]|#([\w-]+)/g;
    const matches = Array.from(markdown.matchAll(tagRegex));
    if (!matches.length) return [];
    return matches.map((match)=>(match[1] || match[2]).trim()) // Get the tag from either capture group
    .filter((tag, index, self)=>self.indexOf(tag) === index); // Remove duplicates
}
function formatTimestamp(date) {
    try {
        // Handle null and undefined explicitly
        if (date === null || date === undefined) {
            return "Invalid date";
        }
        // Parse the date to ensure consistency
        let validDate;
        if (date instanceof Date) {
            validDate = date;
        } else if (typeof date === "string") {
            // Handle ISO strings with time zones directly
            if (date.includes("T")) {
                validDate = new Date(date);
            } else {
                // Normalize string date formats to avoid timezone issues
                let normalizedDate = date;
                // Convert 2024/01/15 to 2024-01-15
                if (normalizedDate.includes("/")) {
                    normalizedDate = normalizedDate.replace(/\//g, "-");
                }
                // Convert "Jan 15, 2024" to "2024-01-15"
                const monthNameMatch = normalizedDate.match(/(\w{3})\s+(\d{1,2}),?\s+(\d{4})/);
                if (monthNameMatch) {
                    const [, monthName, day, year] = monthNameMatch;
                    const monthMap = {
                        Jan: "01",
                        Feb: "02",
                        Mar: "03",
                        Apr: "04",
                        May: "05",
                        Jun: "06",
                        Jul: "07",
                        Aug: "08",
                        Sep: "09",
                        Oct: "10",
                        Nov: "11",
                        Dec: "12"
                    };
                    const month = monthMap[monthName];
                    normalizedDate = `${year}-${month}-${day.padStart(2, "0")}`;
                }
                // Convert "15 Jan 2024" to "2024-01-15"
                const dayFirstMatch = normalizedDate.match(/(\d{1,2})\s+(\w{3})\s+(\d{4})/);
                if (dayFirstMatch) {
                    const [, day, monthName, year] = dayFirstMatch;
                    const monthMap = {
                        Jan: "01",
                        Feb: "02",
                        Mar: "03",
                        Apr: "04",
                        May: "05",
                        Jun: "06",
                        Jul: "07",
                        Aug: "08",
                        Sep: "09",
                        Oct: "10",
                        Nov: "11",
                        Dec: "12"
                    };
                    const month = monthMap[monthName];
                    normalizedDate = `${year}-${month}-${day.padStart(2, "0")}`;
                }
                validDate = new Date(normalizedDate + "T00:00:00.000Z");
            }
        } else {
            validDate = new Date(date);
        }
        // Check if the date is valid
        if (isNaN(validDate.getTime())) {
            console.warn("Invalid date value:", date);
            return "Invalid date";
        }
        // Use UTC to avoid timezone issues in tests
        return validDate.toISOString().split("T")[0];
    } catch (error) {
        console.error("Error formatting timestamp:", error, date);
        return "Invalid date";
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBDbGFzc1ZhbHVlLCBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IHR3TWVyZ2UgfSBmcm9tIFwidGFpbHdpbmQtbWVyZ2VcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNuKC4uLmlucHV0czogQ2xhc3NWYWx1ZVtdKSB7XG4gIHJldHVybiB0d01lcmdlKGNsc3goaW5wdXRzKSk7XG59XG5cbi8vIFVwZGF0ZSB0aGUgZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24gZnVuY3Rpb24gdG8gYWxzbyBmaW5kIHdpa2ktc3R5bGUgbGlua3NcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGFnc0Zyb21NYXJrZG93bihtYXJrZG93bjogc3RyaW5nKTogc3RyaW5nW10ge1xuICAvLyBNYXRjaCBib3RoIFtbdGFnXV0gc3ludGF4IGFuZCAjdGFnIHN5bnRheCAoaW5jbHVkaW5nICN0YWctd2l0aC1oeXBoZW5zKVxuICBjb25zdCB0YWdSZWdleCA9IC9cXFtcXFsoLio/KVxcXVxcXXwjKFtcXHctXSspL2c7XG4gIGNvbnN0IG1hdGNoZXMgPSBBcnJheS5mcm9tKG1hcmtkb3duLm1hdGNoQWxsKHRhZ1JlZ2V4KSk7XG5cbiAgaWYgKCFtYXRjaGVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBtYXRjaGVzXG4gICAgLm1hcCgobWF0Y2gpID0+IChtYXRjaFsxXSB8fCBtYXRjaFsyXSkudHJpbSgpKSAvLyBHZXQgdGhlIHRhZyBmcm9tIGVpdGhlciBjYXB0dXJlIGdyb3VwXG4gICAgLmZpbHRlcigodGFnLCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHRhZykgPT09IGluZGV4KTsgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWVzdGFtcChkYXRlOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICAvLyBIYW5kbGUgbnVsbCBhbmQgdW5kZWZpbmVkIGV4cGxpY2l0bHlcbiAgICBpZiAoZGF0ZSA9PT0gbnVsbCB8fCBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcIkludmFsaWQgZGF0ZVwiO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHRoZSBkYXRlIHRvIGVuc3VyZSBjb25zaXN0ZW5jeVxuICAgIGxldCB2YWxpZERhdGU6IERhdGU7XG5cbiAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHZhbGlkRGF0ZSA9IGRhdGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gSGFuZGxlIElTTyBzdHJpbmdzIHdpdGggdGltZSB6b25lcyBkaXJlY3RseVxuICAgICAgaWYgKGRhdGUuaW5jbHVkZXMoXCJUXCIpKSB7XG4gICAgICAgIHZhbGlkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHN0cmluZyBkYXRlIGZvcm1hdHMgdG8gYXZvaWQgdGltZXpvbmUgaXNzdWVzXG4gICAgICAgIGxldCBub3JtYWxpemVkRGF0ZSA9IGRhdGU7XG5cbiAgICAgICAgLy8gQ29udmVydCAyMDI0LzAxLzE1IHRvIDIwMjQtMDEtMTVcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWREYXRlLmluY2x1ZGVzKFwiL1wiKSkge1xuICAgICAgICAgIG5vcm1hbGl6ZWREYXRlID0gbm9ybWFsaXplZERhdGUucmVwbGFjZSgvXFwvL2csIFwiLVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgXCJKYW4gMTUsIDIwMjRcIiB0byBcIjIwMjQtMDEtMTVcIlxuICAgICAgICBjb25zdCBtb250aE5hbWVNYXRjaCA9IG5vcm1hbGl6ZWREYXRlLm1hdGNoKFxuICAgICAgICAgIC8oXFx3ezN9KVxccysoXFxkezEsMn0pLD9cXHMrKFxcZHs0fSkvLFxuICAgICAgICApO1xuICAgICAgICBpZiAobW9udGhOYW1lTWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBbLCBtb250aE5hbWUsIGRheSwgeWVhcl0gPSBtb250aE5hbWVNYXRjaDtcbiAgICAgICAgICBjb25zdCBtb250aE1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgICAgIEphbjogXCIwMVwiLFxuICAgICAgICAgICAgRmViOiBcIjAyXCIsXG4gICAgICAgICAgICBNYXI6IFwiMDNcIixcbiAgICAgICAgICAgIEFwcjogXCIwNFwiLFxuICAgICAgICAgICAgTWF5OiBcIjA1XCIsXG4gICAgICAgICAgICBKdW46IFwiMDZcIixcbiAgICAgICAgICAgIEp1bDogXCIwN1wiLFxuICAgICAgICAgICAgQXVnOiBcIjA4XCIsXG4gICAgICAgICAgICBTZXA6IFwiMDlcIixcbiAgICAgICAgICAgIE9jdDogXCIxMFwiLFxuICAgICAgICAgICAgTm92OiBcIjExXCIsXG4gICAgICAgICAgICBEZWM6IFwiMTJcIixcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IG1vbnRoID0gbW9udGhNYXBbbW9udGhOYW1lXTtcbiAgICAgICAgICBub3JtYWxpemVkRGF0ZSA9IGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5LnBhZFN0YXJ0KDIsIFwiMFwiKX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCBcIjE1IEphbiAyMDI0XCIgdG8gXCIyMDI0LTAxLTE1XCJcbiAgICAgICAgY29uc3QgZGF5Rmlyc3RNYXRjaCA9IG5vcm1hbGl6ZWREYXRlLm1hdGNoKFxuICAgICAgICAgIC8oXFxkezEsMn0pXFxzKyhcXHd7M30pXFxzKyhcXGR7NH0pLyxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRheUZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBbLCBkYXksIG1vbnRoTmFtZSwgeWVhcl0gPSBkYXlGaXJzdE1hdGNoO1xuICAgICAgICAgIGNvbnN0IG1vbnRoTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgICAgICAgSmFuOiBcIjAxXCIsXG4gICAgICAgICAgICBGZWI6IFwiMDJcIixcbiAgICAgICAgICAgIE1hcjogXCIwM1wiLFxuICAgICAgICAgICAgQXByOiBcIjA0XCIsXG4gICAgICAgICAgICBNYXk6IFwiMDVcIixcbiAgICAgICAgICAgIEp1bjogXCIwNlwiLFxuICAgICAgICAgICAgSnVsOiBcIjA3XCIsXG4gICAgICAgICAgICBBdWc6IFwiMDhcIixcbiAgICAgICAgICAgIFNlcDogXCIwOVwiLFxuICAgICAgICAgICAgT2N0OiBcIjEwXCIsXG4gICAgICAgICAgICBOb3Y6IFwiMTFcIixcbiAgICAgICAgICAgIERlYzogXCIxMlwiLFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgbW9udGggPSBtb250aE1hcFttb250aE5hbWVdO1xuICAgICAgICAgIG5vcm1hbGl6ZWREYXRlID0gYCR7eWVhcn0tJHttb250aH0tJHtkYXkucGFkU3RhcnQoMiwgXCIwXCIpfWA7XG4gICAgICAgIH1cblxuICAgICAgICB2YWxpZERhdGUgPSBuZXcgRGF0ZShub3JtYWxpemVkRGF0ZSArIFwiVDAwOjAwOjAwLjAwMFpcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBkYXRlIGlzIHZhbGlkXG4gICAgaWYgKGlzTmFOKHZhbGlkRGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIGRhdGUgdmFsdWU6XCIsIGRhdGUpO1xuICAgICAgcmV0dXJuIFwiSW52YWxpZCBkYXRlXCI7XG4gICAgfVxuXG4gICAgLy8gVXNlIFVUQyB0byBhdm9pZCB0aW1lem9uZSBpc3N1ZXMgaW4gdGVzdHNcbiAgICByZXR1cm4gdmFsaWREYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmb3JtYXR0aW5nIHRpbWVzdGFtcDpcIiwgZXJyb3IsIGRhdGUpO1xuICAgIHJldHVybiBcIkludmFsaWQgZGF0ZVwiO1xuICB9XG59XG4iXSwibmFtZXMiOlsiY24iLCJleHRyYWN0VGFnc0Zyb21NYXJrZG93biIsImZvcm1hdFRpbWVzdGFtcCIsImlucHV0cyIsInR3TWVyZ2UiLCJjbHN4IiwibWFya2Rvd24iLCJ0YWdSZWdleCIsIm1hdGNoZXMiLCJBcnJheSIsImZyb20iLCJtYXRjaEFsbCIsImxlbmd0aCIsIm1hcCIsIm1hdGNoIiwidHJpbSIsImZpbHRlciIsInRhZyIsImluZGV4Iiwic2VsZiIsImluZGV4T2YiLCJkYXRlIiwidW5kZWZpbmVkIiwidmFsaWREYXRlIiwiRGF0ZSIsImluY2x1ZGVzIiwibm9ybWFsaXplZERhdGUiLCJyZXBsYWNlIiwibW9udGhOYW1lTWF0Y2giLCJtb250aE5hbWUiLCJkYXkiLCJ5ZWFyIiwibW9udGhNYXAiLCJKYW4iLCJGZWIiLCJNYXIiLCJBcHIiLCJNYXkiLCJKdW4iLCJKdWwiLCJBdWciLCJTZXAiLCJPY3QiLCJOb3YiLCJEZWMiLCJtb250aCIsInBhZFN0YXJ0IiwiZGF5Rmlyc3RNYXRjaCIsImlzTmFOIiwiZ2V0VGltZSIsImNvbnNvbGUiLCJ3YXJuIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImVycm9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztJQUdnQkEsRUFBRTtlQUFGQTs7SUFLQUMsdUJBQXVCO2VBQXZCQTs7SUFZQUMsZUFBZTtlQUFmQTs7O3NCQXBCc0I7K0JBQ2Q7QUFFakIsU0FBU0YsR0FBRyxHQUFHRyxNQUFvQjtJQUN4QyxPQUFPQyxJQUFBQSxzQkFBTyxFQUFDQyxJQUFBQSxVQUFJLEVBQUNGO0FBQ3RCO0FBR08sU0FBU0Ysd0JBQXdCSyxRQUFnQjtJQUN0RCwwRUFBMEU7SUFDMUUsTUFBTUMs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