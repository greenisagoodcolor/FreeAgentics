8d77ad130f1ee7fa1e42d64106258966
/**
 * Phase 1: lib/performance/performance-monitor.ts Comprehensive Test Suite
 * Target: Complete performance monitoring and benchmarking functionality
 * Goal: Maximum statement coverage for performance analysis utilities
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _performancemonitor = require("../../../lib/performance/performance-monitor");
// Mock performance API
const mockPerformance = {
    now: jest.fn(()=>1000),
    mark: jest.fn(),
    measure: jest.fn(),
    getEntriesByName: jest.fn(),
    clearMarks: jest.fn(),
    clearMeasures: jest.fn(),
    memory: {
        usedJSHeapSize: 1024 * 1024
    }
};
// Mock navigator.storage
const mockNavigatorStorage = {
    estimate: jest.fn(()=>Promise.resolve({
            usage: 512 * 1024
        }))
};
// Mock localStorage
const mockLocalStorage = {
    setItem: jest.fn(),
    removeItem: jest.fn(),
    getItem: jest.fn(),
    clear: jest.fn(),
    length: 0,
    key: jest.fn()
};
// Mock TextEncoder
const mockTextEncoder = {
    encode: jest.fn((str)=>new Uint8Array(str.length))
};
// Setup mocks
beforeAll(()=>{
    global.performance = mockPerformance;
    global.navigator = {
        ...global.navigator,
        storage: mockNavigatorStorage
    };
    global.localStorage = mockLocalStorage;
    global.TextEncoder = jest.fn(()=>mockTextEncoder);
});
beforeEach(()=>{
    jest.clearAllMocks();
    _performancemonitor.performanceMonitor.clearMetrics();
    // Reset performance.now mock to return incrementing values
    let timeCounter = 1000;
    mockPerformance.now.mockImplementation(()=>timeCounter++);
    // Setup default mock returns
    mockPerformance.getEntriesByName.mockReturnValue([
        {
            name: "test_operation",
            duration: 100,
            startTime: 1000,
            entryType: "measure"
        }
    ]);
});
afterEach(()=>{
    jest.clearAllTimers();
    jest.useRealTimers();
});
describe("lib/performance/performance-monitor.ts - Complete Coverage", ()=>{
    describe("PerformanceMonitor - Basic Operations", ()=>{
        test("starts and ends operation successfully", async ()=>{
            const operationId = await _performancemonitor.performanceMonitor.startOperation("test_operation");
            expect(operationId).toContain("test_operation");
            expect(mockPerformance.mark).toHaveBeenCalledWith(`${operationId}_start`);
            const metric = await _performancemonitor.performanceMonitor.endOperation(operationId);
            expect(mockPerformance.mark).toHaveBeenCalledWith(`${operationId}_end`);
            expect(mockPerformance.measure).toHaveBeenCalled();
            expect(metric.operation).toBe("test_operation");
            expect(metric.duration).toBe(100);
        });
        test("generates unique operation IDs", async ()=>{
            const id1 = await _performancemonitor.performanceMonitor.startOperation("operation");
            const id2 = await _performancemonitor.performanceMonitor.startOperation("operation");
            expect(id1).not.toBe(id2);
            expect(id1).toContain("operation");
            expect(id2).toContain("operation");
        });
        test("includes metadata in metrics", async ()=>{
            const operationId = await _performancemonitor.performanceMonitor.startOperation("test_with_metadata");
            const metadata = {
                dataSize: 1024,
                errors: [
                    "Test error"
                ],
                compressionRatio: 0.5
            };
            const metric = await _performancemonitor.performanceMonitor.endOperation(operationId, metadata);
            expect(metric.dataSize).toBe(1024);
            expect(metric.errors).toEqual([
                "Test error"
            ]);
            expect(metric.compressionRatio).toBe(0.5);
            expect(metric.memoryUsage).toBe(1024 * 1024);
        });
        test("handles missing performance memory", async ()=>{
            const originalMemory = mockPerformance.memory;
            delete mockPerformance.memory;
            const operationId = await _performancemonitor.performanceMonitor.startOperation("no_memory");
            const metric = await _performancemonitor.performanceMonitor.endOperation(operationId);
            expect(metric.memoryUsage).toBeUndefined();
            mockPerformance.memory = originalMemory;
        });
        test("handles storage estimation failure", async ()=>{
            mockNavigatorStorage.estimate.mockRejectedValue(new Error("Storage not available"));
            const operationId = await _performancemonitor.performanceMonitor.startOperation("no_storage");
            const metric = await _performancemonitor.performanceMonitor.endOperation(operationId);
            expect(metric.storageUsage).toBeUndefined();
        });
        test("handles missing storage API", async ()=>{
            const originalNavigator = global.navigator;
            global.navigator = {};
            const operationId = await _performancemonitor.performanceMonitor.startOperation("no_navigator_storage");
            const metric = await _performancemonitor.performanceMonitor.endOperation(operationId);
            expect(metric.storageUsage).toBeUndefined();
            global.navigator = originalNavigator;
        });
    });
    describe("Metrics Management", ()=>{
        test("maintains metrics history limit", async ()=>{
            // Simulate adding more than max history
            for(let i = 0; i < 1200; i++){
                const operationId = await _performancemonitor.performanceMonitor.startOperation(`operation_${i}`);
                await _performancemonitor.performanceMonitor.endOperation(operationId);
            }
            const metrics = _performancemonitor.performanceMonitor.getMetrics();
            expect(metrics.length).toBeLessThanOrEqual(1000); // Should be capped at max history
        });
        test("filters metrics by operation", async ()=>{
            const op1Id = await _performancemonitor.performanceMonitor.startOperation("operation1");
            await _performancemonitor.performanceMonitor.endOperation(op1Id);
            const op2Id = await _performancemonitor.performanceMonitor.startOperation("operation2");
            await _performancemonitor.performanceMonitor.endOperation(op2Id);
            const op1Metrics = _performancemonitor.performanceMonitor.getMetrics("operation1");
            const op2Metrics = _performancemonitor.performanceMonitor.getMetrics("operation2");
            expect(op1Metrics).toHaveLength(1);
            expect(op2Metrics).toHaveLength(1);
            expect(op1Metrics[0].operation).toBe("operation1");
            expect(op2Metrics[0].operation).toBe("operation2");
        });
        test("limits returned metrics", async ()=>{
            for(let i = 0; i < 50; i++){
                const operationId = await _performancemonitor.performanceMonitor.startOperation("test");
                await _performancemonitor.performanceMonitor.endOperation(operationId);
            }
            const limited = _performancemonitor.performanceMonitor.getMetrics("test", 10);
            expect(limited.length).toBe(10);
            const unlimited = _performancemonitor.performanceMonitor.getMetrics("test");
            expect(unlimited.length).toBe(50);
        });
        test("clears all metrics and benchmarks", async ()=>{
            const operationId = await _performancemonitor.performanceMonitor.startOperation("test");
            await _performancemonitor.performanceMonitor.endOperation(operationId);
            expect(_performancemonitor.performanceMonitor.getMetrics()).toHaveLength(1);
            expect(_performancemonitor.performanceMonitor.getBenchmarks()).toHaveLength(1);
            _performancemonitor.performanceMonitor.clearMetrics();
            expect(_performancemonitor.performanceMonitor.getMetrics()).toHaveLength(0);
            expect(_performancemonitor.performanceMonitor.getBenchmarks()).toHaveLength(0);
        });
    });
    describe("Benchmark Tracking", ()=>{
        test("creates benchmark for new operation", async ()=>{
            const operationId = await _performancemonitor.performanceMonitor.startOperation("new_operation");
            await _performancemonitor.performanceMonitor.endOperation(operationId);
            const benchmarks = _performancemonitor.performanceMonitor.getBenchmarks();
            expect(benchmarks).toHaveLength(1);
            const benchmark = benchmarks[0];
            expect(benchmark.operation).toBe("new_operation");
            expect(benchmark.totalOperations).toBe(1);
            expect(benchmark.averageDuration).toBe(100);
            expect(benchmark.minDuration).toBe(100);
            expect(benchmark.maxDuration).toBe(100);
            expect(benchmark.errorRate).toBe(0);
        });
        test("updates existing benchmark with new operation", async ()=>{
            // First operation
            mockPerformance.getEntriesByName.mockReturnValueOnce([
                {
                    duration: 100
                }
            ]);
            const op1Id = await _performancemonitor.performanceMonitor.startOperation("repeat_operation");
            await _performancemonitor.performanceMonitor.endOperation(op1Id);
            // Second operation with different duration
            mockPerformance.getEntriesByName.mockReturnValueOnce([
                {
                    duration: 200
                }
            ]);
            const op2Id = await _performancemonitor.performanceMonitor.startOperation("repeat_operation");
            await _performancemonitor.performanceMonitor.endOperation(op2Id);
            const benchmarks = _performancemonitor.performanceMonitor.getBenchmarks();
            expect(benchmarks).toHaveLength(1);
            const benchmark = benchmarks[0];
            expect(benchmark.totalOperations).toBe(2);
            expect(benchmark.averageDuration).toBe(150); // (100 + 200) / 2
            expect(benchmark.minDuration).toBe(100);
            expect(benchmark.maxDuration).toBe(200);
        });
        test("tracks error rates", async ()=>{
            // Operation with error
            const op1Id = await _performancemonitor.performanceMonitor.startOperation("error_operation");
            await _performancemonitor.performanceMonitor.endOperation(op1Id, {
                errors: [
                    "Test error"
                ]
            });
            // Operation without error
            const op2Id = await _performancemonitor.performanceMonitor.startOperation("error_operation");
            await _performancemonitor.performanceMonitor.endOperation(op2Id);
            const benchmarks = _performancemonitor.performanceMonitor.getBenchmarks();
            const benchmark = benchmarks[0];
            expect(benchmark.errorRate).toBe(0.5); // 1 error out of 2 operations
            expect(benchmark.lastError).toBe("Test error");
        });
        test("handles operation with multiple errors", async ()=>{
            const operationId = await _performancemonitor.performanceMonitor.startOperation("multi_error");
            await _performancemonitor.performanceMonitor.endOperation(operationId, {
                errors: [
                    "Error 1",
                    "Error 2",
                    "Error 3"
                ]
            });
            const benchmarks = _performancemonitor.performanceMonitor.getBenchmarks();
            const benchmark = benchmarks[0];
            expect(benchmark.errorRate).toBe(1);
            expect(benchmark.lastError).toBe("Error 1"); // Takes first error
        });
        test("gets average operation time", async ()=>{
            mockPerformance.getEntriesByName.mockReturnValueOnce([
                {
                    duration: 150
                }
            ]);
            const operationId = await _performancemonitor.performanceMonitor.startOperation("timed_operation");
            await _performancemonitor.performanceMonitor.endOperation(operationId);
            const avgTime = _performancemonitor.performanceMonitor.getAverageOperationTime("timed_operation");
            expect(avgTime).toBe(150);
            const nonExistentAvg = _performancemonitor.performanceMonitor.getAverageOperationTime("nonexistent");
            expect(nonExistentAvg).toBe(0);
        });
    });
    describe("System Health Analysis", ()=>{
        test("reports healthy status with good metrics", async ()=>{
            // Add some fast operations
            for(let i = 0; i < 5; i++){
                mockPerformance.getEntriesByName.mockReturnValueOnce([
                    {
                        duration: 100
                    }
                ]);
                const operationId = await _performancemonitor.performanceMonitor.startOperation("fast_op");
                await _performancemonitor.performanceMonitor.endOperation(operationId);
            }
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.status).toBe("healthy");
            expect(health.issues).toHaveLength(0);
            expect(health.metrics.averageResponseTime).toBe(100);
            expect(health.metrics.errorRate).toBe(0);
        });
        test("reports warning status with elevated response time", async ()=>{
            mockPerformance.getEntriesByName.mockReturnValueOnce([
                {
                    duration: 1500
                }
            ]);
            const operationId = await _performancemonitor.performanceMonitor.startOperation("slow_op");
            await _performancemonitor.performanceMonitor.endOperation(operationId);
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.status).toBe("warning");
            expect(health.issues[0]).toContain("Average response time is elevated");
            expect(health.recommendations[0]).toContain("Monitor performance");
        });
        test("reports critical status with very high response time", async ()=>{
            mockPerformance.getEntriesByName.mockReturnValueOnce([
                {
                    duration: 3000
                }
            ]);
            const operationId = await _performancemonitor.performanceMonitor.startOperation("very_slow_op");
            await _performancemonitor.performanceMonitor.endOperation(operationId);
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.status).toBe("critical");
            expect(health.issues[0]).toContain("Average response time is very high");
            expect(health.recommendations[0]).toContain("compression");
        });
        test("reports warning status with elevated error rate", async ()=>{
            // Add operations with errors to trigger elevated error rate
            for(let i = 0; i < 10; i++){
                const operationId = await _performancemonitor.performanceMonitor.startOperation("error_prone");
                await _performancemonitor.performanceMonitor.endOperation(operationId, {
                    errors: i < 1 ? [
                        "Error"
                    ] : undefined
                });
            }
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.status).toBe("warning");
            expect(health.issues.some((issue)=>issue.includes("Elevated error rate"))).toBe(true);
        });
        test("reports critical status with high error rate", async ()=>{
            // Add operations with high error rate
            for(let i = 0; i < 5; i++){
                const operationId = await _performancemonitor.performanceMonitor.startOperation("very_error_prone");
                await _performancemonitor.performanceMonitor.endOperation(operationId, {
                    errors: i < 3 ? [
                        "Error"
                    ] : undefined
                });
            }
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.status).toBe("critical");
            expect(health.issues.some((issue)=>issue.includes("High error rate"))).toBe(true);
            expect(health.recommendations.some((rec)=>rec.includes("Investigate and fix"))).toBe(true);
        });
        test("analyzes memory trends", async ()=>{
            // Add metrics with increasing memory usage
            const memoryValues = [
                1000,
                1100,
                1200,
                1300,
                1400,
                1500
            ];
            for(let i = 0; i < memoryValues.length; i++){
                mockPerformance.memory.usedJSHeapSize = memoryValues[i];
                const operationId = await _performancemonitor.performanceMonitor.startOperation("memory_test");
                await _performancemonitor.performanceMonitor.endOperation(operationId);
            }
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.metrics.memoryTrend).toBe("increasing rapidly");
            expect(health.status).toBe("critical");
            expect(health.issues.some((issue)=>issue.includes("Memory usage is increasing rapidly"))).toBe(true);
        });
        test("analyzes storage trends", async ()=>{
            // Add metrics with increasing storage usage
            const storageValues = [
                1000,
                1100,
                1200,
                1300,
                1400,
                1500
            ];
            for(let i = 0; i < storageValues.length; i++){
                mockNavigatorStorage.estimate.mockResolvedValueOnce({
                    usage: storageValues[i]
                });
                const operationId = await _performancemonitor.performanceMonitor.startOperation("storage_test");
                await _performancemonitor.performanceMonitor.endOperation(operationId);
            }
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.metrics.storageTrend).toBe("increasing rapidly");
            expect(health.issues.some((issue)=>issue.includes("Storage usage is increasing rapidly"))).toBe(true);
        });
        test("handles insufficient data for trend analysis", async ()=>{
            // Add only 2 metrics (insufficient for trend analysis)
            for(let i = 0; i < 2; i++){
                const operationId = await _performancemonitor.performanceMonitor.startOperation("insufficient_data");
                await _performancemonitor.performanceMonitor.endOperation(operationId);
            }
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.metrics.memoryTrend).toBe("insufficient data");
            expect(health.metrics.storageTrend).toBe("insufficient data");
        });
        test("analyzes stable trends", async ()=>{
            // Add metrics with stable values
            for(let i = 0; i < 10; i++){
                mockPerformance.memory.usedJSHeapSize = 1000; // Stable memory
                mockNavigatorStorage.estimate.mockResolvedValueOnce({
                    usage: 500
                }); // Stable storage
                const operationId = await _performancemonitor.performanceMonitor.startOperation("stable_test");
                await _performancemonitor.performanceMonitor.endOperation(operationId);
            }
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.metrics.memoryTrend).toBe("stable");
            expect(health.metrics.storageTrend).toBe("stable");
        });
        test("analyzes decreasing trends", async ()=>{
            // Add metrics with decreasing values
            const values = [
                1000,
                900,
                800,
                700,
                600,
                500
            ];
            for(let i = 0; i < values.length; i++){
                mockPerformance.memory.usedJSHeapSize = values[i];
                const operationId = await _performancemonitor.performanceMonitor.startOperation("decreasing_test");
                await _performancemonitor.performanceMonitor.endOperation(operationId);
            }
            const health = _performancemonitor.performanceMonitor.getSystemHealth();
            expect(health.metrics.memoryTrend).toBe("decreasing rapidly");
        });
    });
    describe("Performance Tests", ()=>{
        test("runs compression test", async ()=>{
            const results = await _performancemonitor.performanceMonitor.runPerformanceTest();
            expect(results.compressionTest).toHaveProperty("duration");
            expect(results.compressionTest).toHaveProperty("ratio");
            expect(results.compressionTest.duration).toBeGreaterThan(0);
            expect(results.compressionTest.ratio).toBeGreaterThan(0);
            expect(mockTextEncoder.encode).toHaveBeenCalled();
        });
        test("runs storage test", async ()=>{
            const results = await _performancemonitor.performanceMonitor.runPerformanceTest();
            expect(results.storageTest).toHaveProperty("duration");
            expect(results.storageTest).toHaveProperty("throughput");
            expect(results.storageTest.duration).toBeGreaterThan(0);
            expect(results.storageTest.throughput).toBeGreaterThan(0);
            // Verify localStorage was used for testing
            expect(mockLocalStorage.setItem).toHaveBeenCalled();
            expect(mockLocalStorage.removeItem).toHaveBeenCalled();
        });
        test("runs validation test", async ()=>{
            const results = await _performancemonitor.performanceMonitor.runPerformanceTest();
            expect(results.validationTest).toHaveProperty("duration");
            expect(results.validationTest).toHaveProperty("itemsPerSecond");
            expect(results.validationTest.duration).toBeGreaterThan(0);
            expect(results.validationTest.itemsPerSecond).toBeGreaterThan(0);
        });
        test("handles validation test errors", async ()=>{
            // Mock an invalid item that would fail validation
            const originalTestValidation = _performancemonitor.performanceMonitor["testValidation"];
            _performancemonitor.performanceMonitor["testValidation"] = jest.fn().mockImplementation(async ()=>{
                // Simulate validation that throws an error
                const testItems = [
                    {
                        id: "",
                        name: "",
                        createdAt: ""
                    }
                ]; // Invalid item
                for (const item of testItems){
                    if (!item.id || !item.name || !item.createdAt) {
                        throw new Error("Validation failed");
                    }
                }
                return {
                    duration: 0,
                    itemsPerSecond: 0
                };
            });
            await expect(_performancemonitor.performanceMonitor.runPerformanceTest()).rejects.toThrow("Validation failed");
            // Restore original method
            _performancemonitor.performanceMonitor["testValidation"] = originalTestValidation;
        });
    });
    describe("Export and Import", ()=>{
        test("exports metrics and benchmarks", async ()=>{
            const operationId = await _performancemonitor.performanceMonitor.startOperation("export_test");
            await _performancemonitor.performanceMonitor.endOperation(operationId);
            const exported = _performancemonitor.performanceMonitor.exportMetrics();
            expect(exported).toHaveProperty("metrics");
            expect(exported).toHaveProperty("benchmarks");
            expect(exported).toHaveProperty("exportedAt");
            expect(exported.metrics).toHaveLength(1);
            expect(exported.benchmarks).toHaveLength(1);
            expect(new Date(exported.exportedAt)).toBeInstanceOf(Date);
        });
        test("exports empty data when no operations performed", ()=>{
            const exported = _performancemonitor.performanceMonitor.exportMetrics();
            expect(exported.metrics).toHaveLength(0);
            expect(exported.benchmarks).toHaveLength(0);
            expect(exported.exportedAt).toBeTruthy();
        });
    });
    describe("Edge Cases and Error Handling", ()=>{
        test("handles performance API errors gracefully", async ()=>{
            mockPerformance.getEntriesByName.mockReturnValue([]);
            const operationId = await _performancemonitor.performanceMonitor.startOperation("no_measure");
            // This should handle missing performance measure gracefully
            await expect(_performancemonitor.performanceMonitor.endOperation(operationId)).rejects.toThrow();
        });
        test("handles operations with empty metadata", async ()=>{
            const operationId = await _performancemonitor.performanceMonitor.startOperation("empty_metadata");
            const metric = await _performancemonitor.performanceMonitor.endOperation(operationId, {});
            expect(metric.dataSize).toBeUndefined();
            expect(metric.errors).toBeUndefined();
            expect(metric.compressionRatio).toBeUndefined();
        });
        test("handles operations with null/undefined metadata", async ()=>{
            const operationId = await _performancemonitor.performanceMonitor.startOperation("null_metadata");
            const metric = await _performancemonitor.performanceMonitor.endOperation(operationId, undefined);
            expect(metric.dataSize).toBeUndefined();
            expect(metric.errors).toBeUndefined();
            expect(metric.compressionRatio).toBeUndefined();
        });
        test("handles division by zero in trend analysis", ()=>{
            const values = [
                0,
                0,
                0,
                0
            ]; // All zeros
            const trendResult = _performancemonitor.performanceMonitor["analyzeTrend"](values);
            // Should handle division by zero gracefully
            expect(trendResult).toBeDefined();
        });
        test("handles empty values in trend analysis", ()=>{
            const emptyValues = [];
            const result = _performancemonitor.performanceMonitor["analyzeTrend"](emptyValues);
            expect(result).toBe("insufficient data");
        });
        test("handles single value in trend analysis", ()=>{
            const singleValue = [
                100
            ];
            const result = _performancemonitor.performanceMonitor["analyzeTrend"](singleValue);
            expect(result).toBe("insufficient data");
        });
        test("handles concurrent operations", async ()=>{
            const promises = [];
            for(let i = 0; i < 10; i++){
                const promise = (async ()=>{
                    const operationId = await _performancemonitor.performanceMonitor.startOperation(`concurrent_${i}`);
                    return _performancemonitor.performanceMonitor.endOperation(operationId);
                })();
                promises.push(promise);
            }
            const results = await Promise.all(promises);
            expect(results).toHaveLength(10);
            expect(_performancemonitor.performanceMonitor.getMetrics()).toHaveLength(10);
            expect(_performancemonitor.performanceMonitor.getBenchmarks().length).toBeGreaterThan(0);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL3BlcmZvcm1hbmNlL3BlcmZvcm1hbmNlLW1vbml0b3IudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBoYXNlIDE6IGxpYi9wZXJmb3JtYW5jZS9wZXJmb3JtYW5jZS1tb25pdG9yLnRzIENvbXByZWhlbnNpdmUgVGVzdCBTdWl0ZVxuICogVGFyZ2V0OiBDb21wbGV0ZSBwZXJmb3JtYW5jZSBtb25pdG9yaW5nIGFuZCBiZW5jaG1hcmtpbmcgZnVuY3Rpb25hbGl0eVxuICogR29hbDogTWF4aW11bSBzdGF0ZW1lbnQgY292ZXJhZ2UgZm9yIHBlcmZvcm1hbmNlIGFuYWx5c2lzIHV0aWxpdGllc1xuICovXG5cbmltcG9ydCB7XG4gIHBlcmZvcm1hbmNlTW9uaXRvcixcbiAgUGVyZm9ybWFuY2VNZXRyaWNzLFxuICBQZXJmb3JtYW5jZUJlbmNobWFyayxcbn0gZnJvbSBcIi4uLy4uLy4uL2xpYi9wZXJmb3JtYW5jZS9wZXJmb3JtYW5jZS1tb25pdG9yXCI7XG5cbi8vIE1vY2sgcGVyZm9ybWFuY2UgQVBJXG5jb25zdCBtb2NrUGVyZm9ybWFuY2UgPSB7XG4gIG5vdzogamVzdC5mbigoKSA9PiAxMDAwKSxcbiAgbWFyazogamVzdC5mbigpLFxuICBtZWFzdXJlOiBqZXN0LmZuKCksXG4gIGdldEVudHJpZXNCeU5hbWU6IGplc3QuZm4oKSxcbiAgY2xlYXJNYXJrczogamVzdC5mbigpLFxuICBjbGVhck1lYXN1cmVzOiBqZXN0LmZuKCksXG4gIG1lbW9yeToge1xuICAgIHVzZWRKU0hlYXBTaXplOiAxMDI0ICogMTAyNCwgLy8gMU1CXG4gIH0sXG59O1xuXG4vLyBNb2NrIG5hdmlnYXRvci5zdG9yYWdlXG5jb25zdCBtb2NrTmF2aWdhdG9yU3RvcmFnZSA9IHtcbiAgZXN0aW1hdGU6IGplc3QuZm4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgdXNhZ2U6IDUxMiAqIDEwMjQgfSkpLCAvLyA1MTJLQlxufTtcblxuLy8gTW9jayBsb2NhbFN0b3JhZ2VcbmNvbnN0IG1vY2tMb2NhbFN0b3JhZ2UgPSB7XG4gIHNldEl0ZW06IGplc3QuZm4oKSxcbiAgcmVtb3ZlSXRlbTogamVzdC5mbigpLFxuICBnZXRJdGVtOiBqZXN0LmZuKCksXG4gIGNsZWFyOiBqZXN0LmZuKCksXG4gIGxlbmd0aDogMCxcbiAga2V5OiBqZXN0LmZuKCksXG59O1xuXG4vLyBNb2NrIFRleHRFbmNvZGVyXG5jb25zdCBtb2NrVGV4dEVuY29kZXIgPSB7XG4gIGVuY29kZTogamVzdC5mbigoc3RyOiBzdHJpbmcpID0+IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpKSxcbn07XG5cbi8vIFNldHVwIG1vY2tzXG5iZWZvcmVBbGwoKCkgPT4ge1xuICBnbG9iYWwucGVyZm9ybWFuY2UgPSBtb2NrUGVyZm9ybWFuY2UgYXMgYW55O1xuICBnbG9iYWwubmF2aWdhdG9yID0ge1xuICAgIC4uLmdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgc3RvcmFnZTogbW9ja05hdmlnYXRvclN0b3JhZ2UsXG4gIH0gYXMgYW55O1xuICBnbG9iYWwubG9jYWxTdG9yYWdlID0gbW9ja0xvY2FsU3RvcmFnZSBhcyBhbnk7XG4gIGdsb2JhbC5UZXh0RW5jb2RlciA9IGplc3QuZm4oKCkgPT4gbW9ja1RleHRFbmNvZGVyKSBhcyBhbnk7XG59KTtcblxuYmVmb3JlRWFjaCgoKSA9PiB7XG4gIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICBwZXJmb3JtYW5jZU1vbml0b3IuY2xlYXJNZXRyaWNzKCk7XG5cbiAgLy8gUmVzZXQgcGVyZm9ybWFuY2Uubm93IG1vY2sgdG8gcmV0dXJuIGluY3JlbWVudGluZyB2YWx1ZXNcbiAgbGV0IHRpbWVDb3VudGVyID0gMTAwMDtcbiAgbW9ja1BlcmZvcm1hbmNlLm5vdy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdGltZUNvdW50ZXIrKyk7XG5cbiAgLy8gU2V0dXAgZGVmYXVsdCBtb2NrIHJldHVybnNcbiAgbW9ja1BlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUubW9ja1JldHVyblZhbHVlKFtcbiAgICB7XG4gICAgICBuYW1lOiBcInRlc3Rfb3BlcmF0aW9uXCIsXG4gICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgc3RhcnRUaW1lOiAxMDAwLFxuICAgICAgZW50cnlUeXBlOiBcIm1lYXN1cmVcIixcbiAgICB9LFxuICBdKTtcbn0pO1xuXG5hZnRlckVhY2goKCkgPT4ge1xuICBqZXN0LmNsZWFyQWxsVGltZXJzKCk7XG4gIGplc3QudXNlUmVhbFRpbWVycygpO1xufSk7XG5cbmRlc2NyaWJlKFwibGliL3BlcmZvcm1hbmNlL3BlcmZvcm1hbmNlLW1vbml0b3IudHMgLSBDb21wbGV0ZSBDb3ZlcmFnZVwiLCAoKSA9PiB7XG4gIGRlc2NyaWJlKFwiUGVyZm9ybWFuY2VNb25pdG9yIC0gQmFzaWMgT3BlcmF0aW9uc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInN0YXJ0cyBhbmQgZW5kcyBvcGVyYXRpb24gc3VjY2Vzc2Z1bGx5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbklkID1cbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0T3BlcmF0aW9uKFwidGVzdF9vcGVyYXRpb25cIik7XG5cbiAgICAgIGV4cGVjdChvcGVyYXRpb25JZCkudG9Db250YWluKFwidGVzdF9vcGVyYXRpb25cIik7XG4gICAgICBleHBlY3QobW9ja1BlcmZvcm1hbmNlLm1hcmspLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGAke29wZXJhdGlvbklkfV9zdGFydGApO1xuXG4gICAgICBjb25zdCBtZXRyaWMgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkKTtcblxuICAgICAgZXhwZWN0KG1vY2tQZXJmb3JtYW5jZS5tYXJrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChgJHtvcGVyYXRpb25JZH1fZW5kYCk7XG4gICAgICBleHBlY3QobW9ja1BlcmZvcm1hbmNlLm1lYXN1cmUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtZXRyaWMub3BlcmF0aW9uKS50b0JlKFwidGVzdF9vcGVyYXRpb25cIik7XG4gICAgICBleHBlY3QobWV0cmljLmR1cmF0aW9uKS50b0JlKDEwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZ2VuZXJhdGVzIHVuaXF1ZSBvcGVyYXRpb24gSURzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGlkMSA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcIm9wZXJhdGlvblwiKTtcbiAgICAgIGNvbnN0IGlkMiA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcIm9wZXJhdGlvblwiKTtcblxuICAgICAgZXhwZWN0KGlkMSkubm90LnRvQmUoaWQyKTtcbiAgICAgIGV4cGVjdChpZDEpLnRvQ29udGFpbihcIm9wZXJhdGlvblwiKTtcbiAgICAgIGV4cGVjdChpZDIpLnRvQ29udGFpbihcIm9wZXJhdGlvblwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJpbmNsdWRlcyBtZXRhZGF0YSBpbiBtZXRyaWNzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbklkID1cbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0T3BlcmF0aW9uKFwidGVzdF93aXRoX21ldGFkYXRhXCIpO1xuXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgZGF0YVNpemU6IDEwMjQsXG4gICAgICAgIGVycm9yczogW1wiVGVzdCBlcnJvclwiXSxcbiAgICAgICAgY29tcHJlc3Npb25SYXRpbzogMC41LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbWV0cmljID0gYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihcbiAgICAgICAgb3BlcmF0aW9uSWQsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KG1ldHJpYy5kYXRhU2l6ZSkudG9CZSgxMDI0KTtcbiAgICAgIGV4cGVjdChtZXRyaWMuZXJyb3JzKS50b0VxdWFsKFtcIlRlc3QgZXJyb3JcIl0pO1xuICAgICAgZXhwZWN0KG1ldHJpYy5jb21wcmVzc2lvblJhdGlvKS50b0JlKDAuNSk7XG4gICAgICBleHBlY3QobWV0cmljLm1lbW9yeVVzYWdlKS50b0JlKDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG1pc3NpbmcgcGVyZm9ybWFuY2UgbWVtb3J5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWVtb3J5ID0gbW9ja1BlcmZvcm1hbmNlLm1lbW9yeTtcbiAgICAgIGRlbGV0ZSBtb2NrUGVyZm9ybWFuY2UubWVtb3J5O1xuXG4gICAgICBjb25zdCBvcGVyYXRpb25JZCA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcIm5vX21lbW9yeVwiKTtcbiAgICAgIGNvbnN0IG1ldHJpYyA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5lbmRPcGVyYXRpb24ob3BlcmF0aW9uSWQpO1xuXG4gICAgICBleHBlY3QobWV0cmljLm1lbW9yeVVzYWdlKS50b0JlVW5kZWZpbmVkKCk7XG5cbiAgICAgIG1vY2tQZXJmb3JtYW5jZS5tZW1vcnkgPSBvcmlnaW5hbE1lbW9yeTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIHN0b3JhZ2UgZXN0aW1hdGlvbiBmYWlsdXJlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tOYXZpZ2F0b3JTdG9yYWdlLmVzdGltYXRlLm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgRXJyb3IoXCJTdG9yYWdlIG5vdCBhdmFpbGFibGVcIiksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBvcGVyYXRpb25JZCA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcIm5vX3N0b3JhZ2VcIik7XG4gICAgICBjb25zdCBtZXRyaWMgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkKTtcblxuICAgICAgZXhwZWN0KG1ldHJpYy5zdG9yYWdlVXNhZ2UpLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG1pc3Npbmcgc3RvcmFnZSBBUElcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxOYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xuICAgICAgZ2xvYmFsLm5hdmlnYXRvciA9IHt9IGFzIGFueTtcblxuICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXG4gICAgICAgIFwibm9fbmF2aWdhdG9yX3N0b3JhZ2VcIixcbiAgICAgICk7XG4gICAgICBjb25zdCBtZXRyaWMgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkKTtcblxuICAgICAgZXhwZWN0KG1ldHJpYy5zdG9yYWdlVXNhZ2UpLnRvQmVVbmRlZmluZWQoKTtcblxuICAgICAgZ2xvYmFsLm5hdmlnYXRvciA9IG9yaWdpbmFsTmF2aWdhdG9yO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIk1ldHJpY3MgTWFuYWdlbWVudFwiLCAoKSA9PiB7XG4gICAgdGVzdChcIm1haW50YWlucyBtZXRyaWNzIGhpc3RvcnkgbGltaXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhdGUgYWRkaW5nIG1vcmUgdGhhbiBtYXggaGlzdG9yeVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjAwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXG4gICAgICAgICAgYG9wZXJhdGlvbl8ke2l9YCxcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcGVyYXRpb25JZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBwZXJmb3JtYW5jZU1vbml0b3IuZ2V0TWV0cmljcygpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MubGVuZ3RoKS50b0JlTGVzc1RoYW5PckVxdWFsKDEwMDApOyAvLyBTaG91bGQgYmUgY2FwcGVkIGF0IG1heCBoaXN0b3J5XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZmlsdGVycyBtZXRyaWNzIGJ5IG9wZXJhdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcDFJZCA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcIm9wZXJhdGlvbjFcIik7XG4gICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wMUlkKTtcblxuICAgICAgY29uc3Qgb3AySWQgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJvcGVyYXRpb24yXCIpO1xuICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcDJJZCk7XG5cbiAgICAgIGNvbnN0IG9wMU1ldHJpY3MgPSBwZXJmb3JtYW5jZU1vbml0b3IuZ2V0TWV0cmljcyhcIm9wZXJhdGlvbjFcIik7XG4gICAgICBjb25zdCBvcDJNZXRyaWNzID0gcGVyZm9ybWFuY2VNb25pdG9yLmdldE1ldHJpY3MoXCJvcGVyYXRpb24yXCIpO1xuXG4gICAgICBleHBlY3Qob3AxTWV0cmljcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KG9wMk1ldHJpY3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChvcDFNZXRyaWNzWzBdLm9wZXJhdGlvbikudG9CZShcIm9wZXJhdGlvbjFcIik7XG4gICAgICBleHBlY3Qob3AyTWV0cmljc1swXS5vcGVyYXRpb24pLnRvQmUoXCJvcGVyYXRpb24yXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImxpbWl0cyByZXR1cm5lZCBtZXRyaWNzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICBjb25zdCBvcGVyYXRpb25JZCA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcInRlc3RcIik7XG4gICAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5lbmRPcGVyYXRpb24ob3BlcmF0aW9uSWQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsaW1pdGVkID0gcGVyZm9ybWFuY2VNb25pdG9yLmdldE1ldHJpY3MoXCJ0ZXN0XCIsIDEwKTtcbiAgICAgIGV4cGVjdChsaW1pdGVkLmxlbmd0aCkudG9CZSgxMCk7XG5cbiAgICAgIGNvbnN0IHVubGltaXRlZCA9IHBlcmZvcm1hbmNlTW9uaXRvci5nZXRNZXRyaWNzKFwidGVzdFwiKTtcbiAgICAgIGV4cGVjdCh1bmxpbWl0ZWQubGVuZ3RoKS50b0JlKDUwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJjbGVhcnMgYWxsIG1ldHJpY3MgYW5kIGJlbmNobWFya3NcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJ0ZXN0XCIpO1xuICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcGVyYXRpb25JZCk7XG5cbiAgICAgIGV4cGVjdChwZXJmb3JtYW5jZU1vbml0b3IuZ2V0TWV0cmljcygpKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2VNb25pdG9yLmdldEJlbmNobWFya3MoKSkudG9IYXZlTGVuZ3RoKDEpO1xuXG4gICAgICBwZXJmb3JtYW5jZU1vbml0b3IuY2xlYXJNZXRyaWNzKCk7XG5cbiAgICAgIGV4cGVjdChwZXJmb3JtYW5jZU1vbml0b3IuZ2V0TWV0cmljcygpKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2VNb25pdG9yLmdldEJlbmNobWFya3MoKSkudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkJlbmNobWFyayBUcmFja2luZ1wiLCAoKSA9PiB7XG4gICAgdGVzdChcImNyZWF0ZXMgYmVuY2htYXJrIGZvciBuZXcgb3BlcmF0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbklkID1cbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0T3BlcmF0aW9uKFwibmV3X29wZXJhdGlvblwiKTtcbiAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5lbmRPcGVyYXRpb24ob3BlcmF0aW9uSWQpO1xuXG4gICAgICBjb25zdCBiZW5jaG1hcmtzID0gcGVyZm9ybWFuY2VNb25pdG9yLmdldEJlbmNobWFya3MoKTtcbiAgICAgIGV4cGVjdChiZW5jaG1hcmtzKS50b0hhdmVMZW5ndGgoMSk7XG5cbiAgICAgIGNvbnN0IGJlbmNobWFyayA9IGJlbmNobWFya3NbMF07XG4gICAgICBleHBlY3QoYmVuY2htYXJrLm9wZXJhdGlvbikudG9CZShcIm5ld19vcGVyYXRpb25cIik7XG4gICAgICBleHBlY3QoYmVuY2htYXJrLnRvdGFsT3BlcmF0aW9ucykudG9CZSgxKTtcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsuYXZlcmFnZUR1cmF0aW9uKS50b0JlKDEwMCk7XG4gICAgICBleHBlY3QoYmVuY2htYXJrLm1pbkR1cmF0aW9uKS50b0JlKDEwMCk7XG4gICAgICBleHBlY3QoYmVuY2htYXJrLm1heER1cmF0aW9uKS50b0JlKDEwMCk7XG4gICAgICBleHBlY3QoYmVuY2htYXJrLmVycm9yUmF0ZSkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJ1cGRhdGVzIGV4aXN0aW5nIGJlbmNobWFyayB3aXRoIG5ldyBvcGVyYXRpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gRmlyc3Qgb3BlcmF0aW9uXG4gICAgICBtb2NrUGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZS5tb2NrUmV0dXJuVmFsdWVPbmNlKFt7IGR1cmF0aW9uOiAxMDAgfV0pO1xuICAgICAgY29uc3Qgb3AxSWQgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJyZXBlYXRfb3BlcmF0aW9uXCIpO1xuICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcDFJZCk7XG5cbiAgICAgIC8vIFNlY29uZCBvcGVyYXRpb24gd2l0aCBkaWZmZXJlbnQgZHVyYXRpb25cbiAgICAgIG1vY2tQZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lLm1vY2tSZXR1cm5WYWx1ZU9uY2UoW3sgZHVyYXRpb246IDIwMCB9XSk7XG4gICAgICBjb25zdCBvcDJJZCA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcInJlcGVhdF9vcGVyYXRpb25cIik7XG4gICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wMklkKTtcblxuICAgICAgY29uc3QgYmVuY2htYXJrcyA9IHBlcmZvcm1hbmNlTW9uaXRvci5nZXRCZW5jaG1hcmtzKCk7XG4gICAgICBleHBlY3QoYmVuY2htYXJrcykudG9IYXZlTGVuZ3RoKDEpO1xuXG4gICAgICBjb25zdCBiZW5jaG1hcmsgPSBiZW5jaG1hcmtzWzBdO1xuICAgICAgZXhwZWN0KGJlbmNobWFyay50b3RhbE9wZXJhdGlvbnMpLnRvQmUoMik7XG4gICAgICBleHBlY3QoYmVuY2htYXJrLmF2ZXJhZ2VEdXJhdGlvbikudG9CZSgxNTApOyAvLyAoMTAwICsgMjAwKSAvIDJcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsubWluRHVyYXRpb24pLnRvQmUoMTAwKTtcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsubWF4RHVyYXRpb24pLnRvQmUoMjAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJ0cmFja3MgZXJyb3IgcmF0ZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gT3BlcmF0aW9uIHdpdGggZXJyb3JcbiAgICAgIGNvbnN0IG9wMUlkID0gYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0T3BlcmF0aW9uKFwiZXJyb3Jfb3BlcmF0aW9uXCIpO1xuICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcDFJZCwgeyBlcnJvcnM6IFtcIlRlc3QgZXJyb3JcIl0gfSk7XG5cbiAgICAgIC8vIE9wZXJhdGlvbiB3aXRob3V0IGVycm9yXG4gICAgICBjb25zdCBvcDJJZCA9IGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcImVycm9yX29wZXJhdGlvblwiKTtcbiAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5lbmRPcGVyYXRpb24ob3AySWQpO1xuXG4gICAgICBjb25zdCBiZW5jaG1hcmtzID0gcGVyZm9ybWFuY2VNb25pdG9yLmdldEJlbmNobWFya3MoKTtcbiAgICAgIGNvbnN0IGJlbmNobWFyayA9IGJlbmNobWFya3NbMF07XG5cbiAgICAgIGV4cGVjdChiZW5jaG1hcmsuZXJyb3JSYXRlKS50b0JlKDAuNSk7IC8vIDEgZXJyb3Igb3V0IG9mIDIgb3BlcmF0aW9uc1xuICAgICAgZXhwZWN0KGJlbmNobWFyay5sYXN0RXJyb3IpLnRvQmUoXCJUZXN0IGVycm9yXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgb3BlcmF0aW9uIHdpdGggbXVsdGlwbGUgZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbklkID1cbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0T3BlcmF0aW9uKFwibXVsdGlfZXJyb3JcIik7XG4gICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkLCB7XG4gICAgICAgIGVycm9yczogW1wiRXJyb3IgMVwiLCBcIkVycm9yIDJcIiwgXCJFcnJvciAzXCJdLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGJlbmNobWFya3MgPSBwZXJmb3JtYW5jZU1vbml0b3IuZ2V0QmVuY2htYXJrcygpO1xuICAgICAgY29uc3QgYmVuY2htYXJrID0gYmVuY2htYXJrc1swXTtcblxuICAgICAgZXhwZWN0KGJlbmNobWFyay5lcnJvclJhdGUpLnRvQmUoMSk7XG4gICAgICBleHBlY3QoYmVuY2htYXJrLmxhc3RFcnJvcikudG9CZShcIkVycm9yIDFcIik7IC8vIFRha2VzIGZpcnN0IGVycm9yXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZ2V0cyBhdmVyYWdlIG9wZXJhdGlvbiB0aW1lXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lLm1vY2tSZXR1cm5WYWx1ZU9uY2UoW3sgZHVyYXRpb246IDE1MCB9XSk7XG4gICAgICBjb25zdCBvcGVyYXRpb25JZCA9XG4gICAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcInRpbWVkX29wZXJhdGlvblwiKTtcbiAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5lbmRPcGVyYXRpb24ob3BlcmF0aW9uSWQpO1xuXG4gICAgICBjb25zdCBhdmdUaW1lID1cbiAgICAgICAgcGVyZm9ybWFuY2VNb25pdG9yLmdldEF2ZXJhZ2VPcGVyYXRpb25UaW1lKFwidGltZWRfb3BlcmF0aW9uXCIpO1xuICAgICAgZXhwZWN0KGF2Z1RpbWUpLnRvQmUoMTUwKTtcblxuICAgICAgY29uc3Qgbm9uRXhpc3RlbnRBdmcgPVxuICAgICAgICBwZXJmb3JtYW5jZU1vbml0b3IuZ2V0QXZlcmFnZU9wZXJhdGlvblRpbWUoXCJub25leGlzdGVudFwiKTtcbiAgICAgIGV4cGVjdChub25FeGlzdGVudEF2ZykudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJTeXN0ZW0gSGVhbHRoIEFuYWx5c2lzXCIsICgpID0+IHtcbiAgICB0ZXN0KFwicmVwb3J0cyBoZWFsdGh5IHN0YXR1cyB3aXRoIGdvb2QgbWV0cmljc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgc29tZSBmYXN0IG9wZXJhdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIG1vY2tQZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lLm1vY2tSZXR1cm5WYWx1ZU9uY2UoW1xuICAgICAgICAgIHsgZHVyYXRpb246IDEwMCB9LFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJmYXN0X29wXCIpO1xuICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVhbHRoID0gcGVyZm9ybWFuY2VNb25pdG9yLmdldFN5c3RlbUhlYWx0aCgpO1xuXG4gICAgICBleHBlY3QoaGVhbHRoLnN0YXR1cykudG9CZShcImhlYWx0aHlcIik7XG4gICAgICBleHBlY3QoaGVhbHRoLmlzc3VlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgZXhwZWN0KGhlYWx0aC5tZXRyaWNzLmF2ZXJhZ2VSZXNwb25zZVRpbWUpLnRvQmUoMTAwKTtcbiAgICAgIGV4cGVjdChoZWFsdGgubWV0cmljcy5lcnJvclJhdGUpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmVwb3J0cyB3YXJuaW5nIHN0YXR1cyB3aXRoIGVsZXZhdGVkIHJlc3BvbnNlIHRpbWVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1BlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUubW9ja1JldHVyblZhbHVlT25jZShbXG4gICAgICAgIHsgZHVyYXRpb246IDE1MDAgfSxcbiAgICAgIF0pO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJzbG93X29wXCIpO1xuICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcGVyYXRpb25JZCk7XG5cbiAgICAgIGNvbnN0IGhlYWx0aCA9IHBlcmZvcm1hbmNlTW9uaXRvci5nZXRTeXN0ZW1IZWFsdGgoKTtcblxuICAgICAgZXhwZWN0KGhlYWx0aC5zdGF0dXMpLnRvQmUoXCJ3YXJuaW5nXCIpO1xuICAgICAgZXhwZWN0KGhlYWx0aC5pc3N1ZXNbMF0pLnRvQ29udGFpbihcIkF2ZXJhZ2UgcmVzcG9uc2UgdGltZSBpcyBlbGV2YXRlZFwiKTtcbiAgICAgIGV4cGVjdChoZWFsdGgucmVjb21tZW5kYXRpb25zWzBdKS50b0NvbnRhaW4oXCJNb25pdG9yIHBlcmZvcm1hbmNlXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJlcG9ydHMgY3JpdGljYWwgc3RhdHVzIHdpdGggdmVyeSBoaWdoIHJlc3BvbnNlIHRpbWVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1BlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUubW9ja1JldHVyblZhbHVlT25jZShbXG4gICAgICAgIHsgZHVyYXRpb246IDMwMDAgfSxcbiAgICAgIF0pO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPVxuICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJ2ZXJ5X3Nsb3dfb3BcIik7XG4gICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkKTtcblxuICAgICAgY29uc3QgaGVhbHRoID0gcGVyZm9ybWFuY2VNb25pdG9yLmdldFN5c3RlbUhlYWx0aCgpO1xuXG4gICAgICBleHBlY3QoaGVhbHRoLnN0YXR1cykudG9CZShcImNyaXRpY2FsXCIpO1xuICAgICAgZXhwZWN0KGhlYWx0aC5pc3N1ZXNbMF0pLnRvQ29udGFpbihcIkF2ZXJhZ2UgcmVzcG9uc2UgdGltZSBpcyB2ZXJ5IGhpZ2hcIik7XG4gICAgICBleHBlY3QoaGVhbHRoLnJlY29tbWVuZGF0aW9uc1swXSkudG9Db250YWluKFwiY29tcHJlc3Npb25cIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmVwb3J0cyB3YXJuaW5nIHN0YXR1cyB3aXRoIGVsZXZhdGVkIGVycm9yIHJhdGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIG9wZXJhdGlvbnMgd2l0aCBlcnJvcnMgdG8gdHJpZ2dlciBlbGV2YXRlZCBlcnJvciByYXRlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPVxuICAgICAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcImVycm9yX3Byb25lXCIpO1xuICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkLCB7XG4gICAgICAgICAgZXJyb3JzOiBpIDwgMSA/IFtcIkVycm9yXCJdIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVhbHRoID0gcGVyZm9ybWFuY2VNb25pdG9yLmdldFN5c3RlbUhlYWx0aCgpO1xuXG4gICAgICBleHBlY3QoaGVhbHRoLnN0YXR1cykudG9CZShcIndhcm5pbmdcIik7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGhlYWx0aC5pc3N1ZXMuc29tZSgoaXNzdWUpID0+IGlzc3VlLmluY2x1ZGVzKFwiRWxldmF0ZWQgZXJyb3IgcmF0ZVwiKSksXG4gICAgICApLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmVwb3J0cyBjcml0aWNhbCBzdGF0dXMgd2l0aCBoaWdoIGVycm9yIHJhdGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIG9wZXJhdGlvbnMgd2l0aCBoaWdoIGVycm9yIHJhdGVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbklkID1cbiAgICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJ2ZXJ5X2Vycm9yX3Byb25lXCIpO1xuICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkLCB7XG4gICAgICAgICAgZXJyb3JzOiBpIDwgMyA/IFtcIkVycm9yXCJdIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVhbHRoID0gcGVyZm9ybWFuY2VNb25pdG9yLmdldFN5c3RlbUhlYWx0aCgpO1xuXG4gICAgICBleHBlY3QoaGVhbHRoLnN0YXR1cykudG9CZShcImNyaXRpY2FsXCIpO1xuICAgICAgZXhwZWN0KFxuICAgICAgICBoZWFsdGguaXNzdWVzLnNvbWUoKGlzc3VlKSA9PiBpc3N1ZS5pbmNsdWRlcyhcIkhpZ2ggZXJyb3IgcmF0ZVwiKSksXG4gICAgICApLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGhlYWx0aC5yZWNvbW1lbmRhdGlvbnMuc29tZSgocmVjKSA9PlxuICAgICAgICAgIHJlYy5pbmNsdWRlcyhcIkludmVzdGlnYXRlIGFuZCBmaXhcIiksXG4gICAgICAgICksXG4gICAgICApLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiYW5hbHl6ZXMgbWVtb3J5IHRyZW5kc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgbWV0cmljcyB3aXRoIGluY3JlYXNpbmcgbWVtb3J5IHVzYWdlXG4gICAgICBjb25zdCBtZW1vcnlWYWx1ZXMgPSBbMTAwMCwgMTEwMCwgMTIwMCwgMTMwMCwgMTQwMCwgMTUwMF07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVtb3J5VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vY2tQZXJmb3JtYW5jZS5tZW1vcnkudXNlZEpTSGVhcFNpemUgPSBtZW1vcnlWYWx1ZXNbaV07XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbklkID1cbiAgICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJtZW1vcnlfdGVzdFwiKTtcbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcGVyYXRpb25JZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlYWx0aCA9IHBlcmZvcm1hbmNlTW9uaXRvci5nZXRTeXN0ZW1IZWFsdGgoKTtcblxuICAgICAgZXhwZWN0KGhlYWx0aC5tZXRyaWNzLm1lbW9yeVRyZW5kKS50b0JlKFwiaW5jcmVhc2luZyByYXBpZGx5XCIpO1xuICAgICAgZXhwZWN0KGhlYWx0aC5zdGF0dXMpLnRvQmUoXCJjcml0aWNhbFwiKTtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgaGVhbHRoLmlzc3Vlcy5zb21lKChpc3N1ZSkgPT5cbiAgICAgICAgICBpc3N1ZS5pbmNsdWRlcyhcIk1lbW9yeSB1c2FnZSBpcyBpbmNyZWFzaW5nIHJhcGlkbHlcIiksXG4gICAgICAgICksXG4gICAgICApLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiYW5hbHl6ZXMgc3RvcmFnZSB0cmVuZHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIG1ldHJpY3Mgd2l0aCBpbmNyZWFzaW5nIHN0b3JhZ2UgdXNhZ2VcbiAgICAgIGNvbnN0IHN0b3JhZ2VWYWx1ZXMgPSBbMTAwMCwgMTEwMCwgMTIwMCwgMTMwMCwgMTQwMCwgMTUwMF07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcmFnZVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb2NrTmF2aWdhdG9yU3RvcmFnZS5lc3RpbWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIHVzYWdlOiBzdG9yYWdlVmFsdWVzW2ldLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPVxuICAgICAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcInN0b3JhZ2VfdGVzdFwiKTtcbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcGVyYXRpb25JZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlYWx0aCA9IHBlcmZvcm1hbmNlTW9uaXRvci5nZXRTeXN0ZW1IZWFsdGgoKTtcblxuICAgICAgZXhwZWN0KGhlYWx0aC5tZXRyaWNzLnN0b3JhZ2VUcmVuZCkudG9CZShcImluY3JlYXNpbmcgcmFwaWRseVwiKTtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgaGVhbHRoLmlzc3Vlcy5zb21lKChpc3N1ZSkgPT5cbiAgICAgICAgICBpc3N1ZS5pbmNsdWRlcyhcIlN0b3JhZ2UgdXNhZ2UgaXMgaW5jcmVhc2luZyByYXBpZGx5XCIpLFxuICAgICAgICApLFxuICAgICAgKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgaW5zdWZmaWNpZW50IGRhdGEgZm9yIHRyZW5kIGFuYWx5c2lzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFkZCBvbmx5IDIgbWV0cmljcyAoaW5zdWZmaWNpZW50IGZvciB0cmVuZCBhbmFseXNpcylcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbklkID1cbiAgICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJpbnN1ZmZpY2llbnRfZGF0YVwiKTtcbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcGVyYXRpb25JZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlYWx0aCA9IHBlcmZvcm1hbmNlTW9uaXRvci5nZXRTeXN0ZW1IZWFsdGgoKTtcblxuICAgICAgZXhwZWN0KGhlYWx0aC5tZXRyaWNzLm1lbW9yeVRyZW5kKS50b0JlKFwiaW5zdWZmaWNpZW50IGRhdGFcIik7XG4gICAgICBleHBlY3QoaGVhbHRoLm1ldHJpY3Muc3RvcmFnZVRyZW5kKS50b0JlKFwiaW5zdWZmaWNpZW50IGRhdGFcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiYW5hbHl6ZXMgc3RhYmxlIHRyZW5kc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBZGQgbWV0cmljcyB3aXRoIHN0YWJsZSB2YWx1ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBtb2NrUGVyZm9ybWFuY2UubWVtb3J5LnVzZWRKU0hlYXBTaXplID0gMTAwMDsgLy8gU3RhYmxlIG1lbW9yeVxuICAgICAgICBtb2NrTmF2aWdhdG9yU3RvcmFnZS5lc3RpbWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyB1c2FnZTogNTAwIH0pOyAvLyBTdGFibGUgc3RvcmFnZVxuICAgICAgICBjb25zdCBvcGVyYXRpb25JZCA9XG4gICAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0T3BlcmF0aW9uKFwic3RhYmxlX3Rlc3RcIik7XG4gICAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5lbmRPcGVyYXRpb24ob3BlcmF0aW9uSWQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoZWFsdGggPSBwZXJmb3JtYW5jZU1vbml0b3IuZ2V0U3lzdGVtSGVhbHRoKCk7XG5cbiAgICAgIGV4cGVjdChoZWFsdGgubWV0cmljcy5tZW1vcnlUcmVuZCkudG9CZShcInN0YWJsZVwiKTtcbiAgICAgIGV4cGVjdChoZWFsdGgubWV0cmljcy5zdG9yYWdlVHJlbmQpLnRvQmUoXCJzdGFibGVcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiYW5hbHl6ZXMgZGVjcmVhc2luZyB0cmVuZHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIG1ldHJpY3Mgd2l0aCBkZWNyZWFzaW5nIHZhbHVlc1xuICAgICAgY29uc3QgdmFsdWVzID0gWzEwMDAsIDkwMCwgODAwLCA3MDAsIDYwMCwgNTAwXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW9ja1BlcmZvcm1hbmNlLm1lbW9yeS51c2VkSlNIZWFwU2l6ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPVxuICAgICAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcImRlY3JlYXNpbmdfdGVzdFwiKTtcbiAgICAgICAgYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcGVyYXRpb25JZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlYWx0aCA9IHBlcmZvcm1hbmNlTW9uaXRvci5nZXRTeXN0ZW1IZWFsdGgoKTtcblxuICAgICAgZXhwZWN0KGhlYWx0aC5tZXRyaWNzLm1lbW9yeVRyZW5kKS50b0JlKFwiZGVjcmVhc2luZyByYXBpZGx5XCIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlBlcmZvcm1hbmNlIFRlc3RzXCIsICgpID0+IHtcbiAgICB0ZXN0KFwicnVucyBjb21wcmVzc2lvbiB0ZXN0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IucnVuUGVyZm9ybWFuY2VUZXN0KCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHRzLmNvbXByZXNzaW9uVGVzdCkudG9IYXZlUHJvcGVydHkoXCJkdXJhdGlvblwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmNvbXByZXNzaW9uVGVzdCkudG9IYXZlUHJvcGVydHkoXCJyYXRpb1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmNvbXByZXNzaW9uVGVzdC5kdXJhdGlvbikudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdHMuY29tcHJlc3Npb25UZXN0LnJhdGlvKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QobW9ja1RleHRFbmNvZGVyLmVuY29kZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJ1bnMgc3RvcmFnZSB0ZXN0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3IucnVuUGVyZm9ybWFuY2VUZXN0KCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHRzLnN0b3JhZ2VUZXN0KS50b0hhdmVQcm9wZXJ0eShcImR1cmF0aW9uXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdHMuc3RvcmFnZVRlc3QpLnRvSGF2ZVByb3BlcnR5KFwidGhyb3VnaHB1dFwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLnN0b3JhZ2VUZXN0LmR1cmF0aW9uKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QocmVzdWx0cy5zdG9yYWdlVGVzdC50aHJvdWdocHV0KS50b0JlR3JlYXRlclRoYW4oMCk7XG5cbiAgICAgIC8vIFZlcmlmeSBsb2NhbFN0b3JhZ2Ugd2FzIHVzZWQgZm9yIHRlc3RpbmdcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJydW5zIHZhbGlkYXRpb24gdGVzdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLnJ1blBlcmZvcm1hbmNlVGVzdCgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cy52YWxpZGF0aW9uVGVzdCkudG9IYXZlUHJvcGVydHkoXCJkdXJhdGlvblwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLnZhbGlkYXRpb25UZXN0KS50b0hhdmVQcm9wZXJ0eShcIml0ZW1zUGVyU2Vjb25kXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdHMudmFsaWRhdGlvblRlc3QuZHVyYXRpb24pLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLnZhbGlkYXRpb25UZXN0Lml0ZW1zUGVyU2Vjb25kKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyB2YWxpZGF0aW9uIHRlc3QgZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgYW4gaW52YWxpZCBpdGVtIHRoYXQgd291bGQgZmFpbCB2YWxpZGF0aW9uXG4gICAgICBjb25zdCBvcmlnaW5hbFRlc3RWYWxpZGF0aW9uID0gcGVyZm9ybWFuY2VNb25pdG9yW1widGVzdFZhbGlkYXRpb25cIl07XG5cbiAgICAgIHBlcmZvcm1hbmNlTW9uaXRvcltcInRlc3RWYWxpZGF0aW9uXCJdID0gamVzdFxuICAgICAgICAuZm4oKVxuICAgICAgICAubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyBTaW11bGF0ZSB2YWxpZGF0aW9uIHRoYXQgdGhyb3dzIGFuIGVycm9yXG4gICAgICAgICAgY29uc3QgdGVzdEl0ZW1zID0gW3sgaWQ6IFwiXCIsIG5hbWU6IFwiXCIsIGNyZWF0ZWRBdDogXCJcIiB9XTsgLy8gSW52YWxpZCBpdGVtXG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGVzdEl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uaWQgfHwgIWl0ZW0ubmFtZSB8fCAhaXRlbS5jcmVhdGVkQXQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgZHVyYXRpb246IDAsIGl0ZW1zUGVyU2Vjb25kOiAwIH07XG4gICAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QocGVyZm9ybWFuY2VNb25pdG9yLnJ1blBlcmZvcm1hbmNlVGVzdCgpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiVmFsaWRhdGlvbiBmYWlsZWRcIixcbiAgICAgICk7XG5cbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbWV0aG9kXG4gICAgICBwZXJmb3JtYW5jZU1vbml0b3JbXCJ0ZXN0VmFsaWRhdGlvblwiXSA9IG9yaWdpbmFsVGVzdFZhbGlkYXRpb247XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRXhwb3J0IGFuZCBJbXBvcnRcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJleHBvcnRzIG1ldHJpY3MgYW5kIGJlbmNobWFya3NcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPVxuICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJleHBvcnRfdGVzdFwiKTtcbiAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5lbmRPcGVyYXRpb24ob3BlcmF0aW9uSWQpO1xuXG4gICAgICBjb25zdCBleHBvcnRlZCA9IHBlcmZvcm1hbmNlTW9uaXRvci5leHBvcnRNZXRyaWNzKCk7XG5cbiAgICAgIGV4cGVjdChleHBvcnRlZCkudG9IYXZlUHJvcGVydHkoXCJtZXRyaWNzXCIpO1xuICAgICAgZXhwZWN0KGV4cG9ydGVkKS50b0hhdmVQcm9wZXJ0eShcImJlbmNobWFya3NcIik7XG4gICAgICBleHBlY3QoZXhwb3J0ZWQpLnRvSGF2ZVByb3BlcnR5KFwiZXhwb3J0ZWRBdFwiKTtcbiAgICAgIGV4cGVjdChleHBvcnRlZC5tZXRyaWNzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZXhwb3J0ZWQuYmVuY2htYXJrcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KG5ldyBEYXRlKGV4cG9ydGVkLmV4cG9ydGVkQXQpKS50b0JlSW5zdGFuY2VPZihEYXRlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJleHBvcnRzIGVtcHR5IGRhdGEgd2hlbiBubyBvcGVyYXRpb25zIHBlcmZvcm1lZFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBleHBvcnRlZCA9IHBlcmZvcm1hbmNlTW9uaXRvci5leHBvcnRNZXRyaWNzKCk7XG5cbiAgICAgIGV4cGVjdChleHBvcnRlZC5tZXRyaWNzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICBleHBlY3QoZXhwb3J0ZWQuYmVuY2htYXJrcykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgZXhwZWN0KGV4cG9ydGVkLmV4cG9ydGVkQXQpLnRvQmVUcnV0aHkoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFZGdlIENhc2VzIGFuZCBFcnJvciBIYW5kbGluZ1wiLCAoKSA9PiB7XG4gICAgdGVzdChcImhhbmRsZXMgcGVyZm9ybWFuY2UgQVBJIGVycm9ycyBncmFjZWZ1bGx5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lLm1vY2tSZXR1cm5WYWx1ZShbXSk7XG5cbiAgICAgIGNvbnN0IG9wZXJhdGlvbklkID0gYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0T3BlcmF0aW9uKFwibm9fbWVhc3VyZVwiKTtcblxuICAgICAgLy8gVGhpcyBzaG91bGQgaGFuZGxlIG1pc3NpbmcgcGVyZm9ybWFuY2UgbWVhc3VyZSBncmFjZWZ1bGx5XG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHBlcmZvcm1hbmNlTW9uaXRvci5lbmRPcGVyYXRpb24ob3BlcmF0aW9uSWQpLFxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG9wZXJhdGlvbnMgd2l0aCBlbXB0eSBtZXRhZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRpb25JZCA9XG4gICAgICAgIGF3YWl0IHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE9wZXJhdGlvbihcImVtcHR5X21ldGFkYXRhXCIpO1xuICAgICAgY29uc3QgbWV0cmljID0gYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihvcGVyYXRpb25JZCwge30pO1xuXG4gICAgICBleHBlY3QobWV0cmljLmRhdGFTaXplKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QobWV0cmljLmVycm9ycykudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG1ldHJpYy5jb21wcmVzc2lvblJhdGlvKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBvcGVyYXRpb25zIHdpdGggbnVsbC91bmRlZmluZWQgbWV0YWRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPVxuICAgICAgICBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXCJudWxsX21ldGFkYXRhXCIpO1xuICAgICAgY29uc3QgbWV0cmljID0gYXdhaXQgcGVyZm9ybWFuY2VNb25pdG9yLmVuZE9wZXJhdGlvbihcbiAgICAgICAgb3BlcmF0aW9uSWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChtZXRyaWMuZGF0YVNpemUpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtZXRyaWMuZXJyb3JzKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QobWV0cmljLmNvbXByZXNzaW9uUmF0aW8pLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGRpdmlzaW9uIGJ5IHplcm8gaW4gdHJlbmQgYW5hbHlzaXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gWzAsIDAsIDAsIDBdOyAvLyBBbGwgemVyb3NcbiAgICAgIGNvbnN0IHRyZW5kUmVzdWx0ID0gcGVyZm9ybWFuY2VNb25pdG9yW1wiYW5hbHl6ZVRyZW5kXCJdKHZhbHVlcyk7XG5cbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgZGl2aXNpb24gYnkgemVybyBncmFjZWZ1bGx5XG4gICAgICBleHBlY3QodHJlbmRSZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlbXB0eSB2YWx1ZXMgaW4gdHJlbmQgYW5hbHlzaXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZW1wdHlWYWx1ZXM6IG51bWJlcltdID0gW107XG4gICAgICBjb25zdCByZXN1bHQgPSBwZXJmb3JtYW5jZU1vbml0b3JbXCJhbmFseXplVHJlbmRcIl0oZW1wdHlWYWx1ZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwiaW5zdWZmaWNpZW50IGRhdGFcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBzaW5nbGUgdmFsdWUgaW4gdHJlbmQgYW5hbHlzaXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2luZ2xlVmFsdWUgPSBbMTAwXTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBlcmZvcm1hbmNlTW9uaXRvcltcImFuYWx5emVUcmVuZFwiXShzaW5nbGVWYWx1ZSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJpbnN1ZmZpY2llbnQgZGF0YVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGNvbmN1cnJlbnQgb3BlcmF0aW9uc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb3BlcmF0aW9uSWQgPSBhd2FpdCBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRPcGVyYXRpb24oXG4gICAgICAgICAgICBgY29uY3VycmVudF8ke2l9YCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBwZXJmb3JtYW5jZU1vbml0b3IuZW5kT3BlcmF0aW9uKG9wZXJhdGlvbklkKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCgxMCk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2VNb25pdG9yLmdldE1ldHJpY3MoKSkudG9IYXZlTGVuZ3RoKDEwKTtcbiAgICAgIGV4cGVjdChwZXJmb3JtYW5jZU1vbml0b3IuZ2V0QmVuY2htYXJrcygpLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vY2tQZXJmb3JtYW5jZSIsIm5vdyIsImplc3QiLCJmbiIsIm1hcmsiLCJtZWFzdXJlIiwiZ2V0RW50cmllc0J5TmFtZSIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwibWVtb3J5IiwidXNlZEpTSGVhcFNpemUiLCJtb2NrTmF2aWdhdG9yU3RvcmFnZSIsImVzdGltYXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1c2FnZSIsIm1vY2tMb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImdldEl0ZW0iLCJjbGVhciIsImxlbmd0aCIsImtleSIsIm1vY2tUZXh0RW5jb2RlciIsImVuY29kZSIsInN0ciIsIlVpbnQ4QXJyYXkiLCJiZWZvcmVBbGwiLCJnbG9iYWwiLCJwZXJmb3JtYW5jZSIsIm5hdmlnYXRvciIsInN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJUZXh0RW5jb2RlciIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwicGVyZm9ybWFuY2VNb25pdG9yIiwiY2xlYXJNZXRyaWNzIiwidGltZUNvdW50ZXIiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJtb2NrUmV0dXJuVmFsdWUiLCJuYW1lIiwiZHVyYXRpb24iLCJzdGFydFRpbWUiLCJlbnRyeVR5cGUiLCJhZnRlckVhY2giLCJjbGVhckFsbFRpbWVycyIsInVzZVJlYWxUaW1lcnMiLCJkZXNjcmliZSIsInRlc3QiLCJvcGVyYXRpb25JZCIsInN0YXJ0T3BlcmF0aW9uIiwiZXhwZWN0IiwidG9Db250YWluIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJtZXRyaWMiLCJlbmRPcGVyYXRpb24iLCJ0b0hhdmVCZWVuQ2FsbGVkIiwib3BlcmF0aW9uIiwidG9CZSIsImlkMSIsImlkMiIsIm5vdCIsIm1ldGFkYXRhIiwiZGF0YVNpemUiLCJlcnJvcnMiLCJjb21wcmVzc2lvblJhdGlvIiwidG9FcXVhbCIsIm1lbW9yeVVzYWdlIiwib3JpZ2luYWxNZW1vcnkiLCJ0b0JlVW5kZWZpbmVkIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsInN0b3JhZ2VVc2FnZSIsIm9yaWdpbmFsTmF2aWdhdG9yIiwiaSIsIm1ldHJpY3MiLCJnZXRNZXRyaWNzIiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsIm9wMUlkIiwib3AySWQiLCJvcDFNZXRyaWNzIiwib3AyTWV0cmljcyIsInRvSGF2ZUxlbmd0aCIsImxpbWl0ZWQiLCJ1bmxpbWl0ZWQiLCJnZXRCZW5jaG1hcmtzIiwiYmVuY2htYXJrcyIsImJlbmNobWFyayIsInRvdGFsT3BlcmF0aW9ucyIsImF2ZXJhZ2VEdXJhdGlvbiIsIm1pbkR1cmF0aW9uIiwibWF4RHVyYXRpb24iLCJlcnJvclJhdGUiLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwibGFzdEVycm9yIiwiYXZnVGltZSIsImdldEF2ZXJhZ2VPcGVyYXRpb25UaW1lIiwibm9uRXhpc3RlbnRBdmciLCJoZWFsdGgiLCJnZXRTeXN0ZW1IZWFsdGgiLCJzdGF0dXMiLCJpc3N1ZXMiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwicmVjb21tZW5kYXRpb25zIiwidW5kZWZpbmVkIiwic29tZSIsImlzc3VlIiwiaW5jbHVkZXMiLCJyZWMiLCJtZW1vcnlWYWx1ZXMiLCJtZW1vcnlUcmVuZCIsInN0b3JhZ2VWYWx1ZXMiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJzdG9yYWdlVHJlbmQiLCJ2YWx1ZXMiLCJyZXN1bHRzIiwicnVuUGVyZm9ybWFuY2VUZXN0IiwiY29tcHJlc3Npb25UZXN0IiwidG9IYXZlUHJvcGVydHkiLCJ0b0JlR3JlYXRlclRoYW4iLCJyYXRpbyIsInN0b3JhZ2VUZXN0IiwidGhyb3VnaHB1dCIsInZhbGlkYXRpb25UZXN0IiwiaXRlbXNQZXJTZWNvbmQiLCJvcmlnaW5hbFRlc3RWYWxpZGF0aW9uIiwidGVzdEl0ZW1zIiwiaWQiLCJjcmVhdGVkQXQiLCJpdGVtIiwicmVqZWN0cyIsInRvVGhyb3ciLCJleHBvcnRlZCIsImV4cG9ydE1ldHJpY3MiLCJEYXRlIiwiZXhwb3J0ZWRBdCIsInRvQmVJbnN0YW5jZU9mIiwidG9CZVRydXRoeSIsInRyZW5kUmVzdWx0IiwidG9CZURlZmluZWQiLCJlbXB0eVZhbHVlcyIsInJlc3VsdCIsInNpbmdsZVZhbHVlIiwicHJvbWlzZXMiLCJwcm9taXNlIiwicHVzaCIsImFsbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQzs7OztvQ0FNTTtBQUVQLHVCQUF1QjtBQUN2QixNQUFNQSxrQkFBa0I7SUFDdEJDLEtBQUtDLEtBQUtDLEVBQUUsQ0FBQyxJQUFNO0lBQ25CQyxNQUFNRixLQUFLQyxFQUFFO0lBQ2JFLFNBQVNILEtBQUtDLEVBQUU7SUFDaEJHLGtCQUFrQkosS0FBS0MsRUFBRTtJQUN6QkksWUFBWUwsS0FBS0MsRUFBRTtJQUNuQkssZUFBZU4sS0FBS0MsRUFBRTtJQUN0Qk0sUUFBUTtRQUNOQyxnQkFBZ0IsT0FBTztJQUN6QjtBQUNGO0FBRUEseUJBQXlCO0FBQ3pCLE1BQU1DLHVCQUF1QjtJQUMzQkMsVUFBVVYsS0FBS0MsRUFBRSxDQUFDLElBQU1VLFFBQVFDLE9BQU8sQ0FBQztZQUFFQyxPQUFPLE1BQU07UUFBSztBQUM5RDtB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