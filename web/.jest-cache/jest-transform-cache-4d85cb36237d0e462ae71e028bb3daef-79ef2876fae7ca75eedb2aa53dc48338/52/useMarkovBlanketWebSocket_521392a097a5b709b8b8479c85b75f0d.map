{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/hooks/useMarkovBlanketWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from \"react\";\n\nexport interface MarkovBlanketEvent {\n  type: string;\n  timestamp: string;\n  agent_id: string;\n  data: any;\n  severity: \"info\" | \"warning\" | \"error\" | \"critical\";\n  metadata?: any;\n}\n\nexport interface MarkovBlanketSubscription {\n  agent_ids?: string[];\n  event_types?: string[];\n  severity_levels?: string[];\n  include_mathematical_proofs?: boolean;\n  include_detailed_metrics?: boolean;\n  violation_alerts_only?: boolean;\n  real_time_updates?: boolean;\n}\n\nexport interface BoundaryViolation {\n  agent_id: string;\n  violation_type: string;\n  independence_measure: number;\n  threshold: number;\n  mathematical_justification: string;\n  evidence: any;\n  severity: string;\n  timestamp: string;\n}\n\nexport interface MonitoringStatus {\n  monitoring_active: boolean;\n  monitored_agents: string[];\n  total_violations: number;\n  system_uptime: number;\n  last_check: string;\n}\n\nexport interface ConnectionStats {\n  total_connections: number;\n  total_events_sent: number;\n  active_violations: number;\n  monitored_agents: number;\n  system_uptime: number;\n  connections: Array<{\n    client_id: string;\n    connected_at: string;\n    events_sent: number;\n    subscribed_agents: number;\n  }>;\n}\n\nexport interface UseMarkovBlanketWebSocketOptions {\n  autoConnect?: boolean;\n  reconnectDelay?: number;\n  maxReconnectAttempts?: number;\n  subscription?: MarkovBlanketSubscription;\n  onEvent?: (event: MarkovBlanketEvent) => void;\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n  onError?: (error: string) => void;\n  onViolation?: (violation: BoundaryViolation) => void;\n}\n\nexport interface UseMarkovBlanketWebSocketReturn {\n  isConnected: boolean;\n  isConnecting: boolean;\n  error: string | null;\n  lastEventTime: Date | null;\n  connectionStats: ConnectionStats | null;\n  monitoringStatus: MonitoringStatus | null;\n  violations: BoundaryViolation[];\n\n  // Connection management\n  connect: () => void;\n  disconnect: () => void;\n\n  // Subscription management\n  updateSubscription: (subscription: MarkovBlanketSubscription) => void;\n\n  // Agent management\n  registerAgent: (agentId: string) => void;\n  unregisterAgent: (agentId: string) => void;\n\n  // Monitoring control\n  startMonitoring: () => void;\n  stopMonitoring: () => void;\n\n  // Data fetching\n  getMonitoringStatus: () => void;\n  getAgentViolations: (agentId: string) => void;\n  getConnectionStats: () => void;\n  getComplianceReport: (agentId?: string) => void;\n\n  // Utility\n  sendMessage: (message: any) => void;\n  ping: () => void;\n}\n\nexport function useMarkovBlanketWebSocket(\n  options: UseMarkovBlanketWebSocketOptions = {},\n): UseMarkovBlanketWebSocketReturn {\n  const {\n    autoConnect = true,\n    reconnectDelay = 3000,\n    maxReconnectAttempts = 5,\n    subscription,\n    onEvent,\n    onConnect,\n    onDisconnect,\n    onError,\n    onViolation,\n  } = options;\n\n  const [state, setState] = useState({\n    isConnected: false,\n    isConnecting: false,\n    error: null as string | null,\n    lastEventTime: null as Date | null,\n    connectionStats: null as ConnectionStats | null,\n    monitoringStatus: null as MonitoringStatus | null,\n    violations: [] as BoundaryViolation[],\n  });\n\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Handle incoming messages\n  const handleMessage = useCallback(\n    (event: MessageEvent) => {\n      try {\n        const data = JSON.parse(event.data);\n\n        setState((prev) => ({\n          ...prev,\n          lastEventTime: new Date(),\n          error: null,\n        }));\n\n        // Handle different message types\n        switch (data.type) {\n          case \"connection_established\":\n            console.log(\n              \"Markov Blanket WebSocket connection established:\",\n              data.client_id,\n            );\n            setState((prev) => ({\n              ...prev,\n              isConnected: true,\n              isConnecting: false,\n            }));\n            onConnect?.();\n            break;\n\n          case \"pong\":\n            // Handle ping/pong for connection health\n            break;\n\n          case \"subscription_updated\":\n            console.log(\n              \"Markov Blanket subscription updated:\",\n              data.subscription,\n            );\n            break;\n\n          case \"monitoring_status\":\n            setState((prev) => ({ ...prev, monitoringStatus: data.data }));\n            break;\n\n          case \"connection_stats\":\n            setState((prev) => ({ ...prev, connectionStats: data.stats }));\n            break;\n\n          case \"agent_violations\":\n            setState((prev) => ({\n              ...prev,\n              violations: [...prev.violations, ...data.violations],\n            }));\n            break;\n\n          case \"compliance_report\":\n            console.log(\n              \"Compliance report received for agent:\",\n              data.agent_id,\n              data.report,\n            );\n            break;\n\n          case \"error\":\n            console.error(\"Markov Blanket WebSocket error:\", data.message);\n            setState((prev) => ({ ...prev, error: data.message }));\n            onError?.(data.message);\n            break;\n\n          // Monitoring events\n          case \"boundary_violation\":\n            const violation: BoundaryViolation = {\n              agent_id: data.agent_id,\n              violation_type: data.data.violation_type,\n              independence_measure: data.data.independence_measure,\n              threshold: data.data.threshold,\n              mathematical_justification: data.data.mathematical_justification,\n              evidence: data.data.evidence,\n              severity: data.severity,\n              timestamp: data.timestamp,\n            };\n            setState((prev) => ({\n              ...prev,\n              violations: [...prev.violations, violation],\n            }));\n            onViolation?.(violation);\n            onEvent?.(data as MarkovBlanketEvent);\n            break;\n\n          case \"state_update\":\n          case \"agent_registered\":\n          case \"agent_unregistered\":\n          case \"monitoring_started\":\n          case \"monitoring_stopped\":\n          case \"threshold_breach\":\n          case \"integrity_update\":\n          case \"monitoring_error\":\n            onEvent?.(data as MarkovBlanketEvent);\n            break;\n\n          default:\n            console.log(\n              \"Unknown Markov Blanket WebSocket message type:\",\n              data.type,\n            );\n        }\n      } catch (error) {\n        console.error(\"Error parsing Markov Blanket WebSocket message:\", error);\n        setState((prev) => ({ ...prev, error: \"Failed to parse message\" }));\n        onError?.(\"Failed to parse message\");\n      }\n    },\n    [onEvent, onConnect, onError, onViolation],\n  );\n\n  // Handle connection open\n  const handleOpen = useCallback(() => {\n    console.log(\"Markov Blanket WebSocket connection opened\");\n    reconnectAttemptsRef.current = 0;\n\n    setState((prev) => ({\n      ...prev,\n      isConnected: true,\n      isConnecting: false,\n      error: null,\n    }));\n\n    // Send initial subscription if provided\n    if (subscription) {\n      setTimeout(() => {\n        updateSubscription(subscription);\n      }, 100);\n    }\n  }, [subscription]);\n\n  // Handle connection close\n  const handleClose = useCallback(\n    (event: CloseEvent) => {\n      console.log(\n        \"Markov Blanket WebSocket connection closed:\",\n        event.code,\n        event.reason,\n      );\n\n      setState((prev) => ({\n        ...prev,\n        isConnected: false,\n        isConnecting: false,\n      }));\n\n      onDisconnect?.();\n\n      // Attempt to reconnect if not a manual disconnect\n      if (\n        event.code !== 1000 &&\n        reconnectAttemptsRef.current < maxReconnectAttempts\n      ) {\n        reconnectAttemptsRef.current++;\n        console.log(\n          `Attempting to reconnect Markov Blanket WebSocket (${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`,\n        );\n\n        reconnectTimeoutRef.current = setTimeout(() => {\n          connect();\n        }, reconnectDelay);\n      }\n    },\n    [maxReconnectAttempts, reconnectDelay, onDisconnect],\n  );\n\n  // Handle connection error\n  const handleError = useCallback(\n    (event: Event) => {\n      console.error(\"Markov Blanket WebSocket error:\", event);\n      setState((prev) => ({\n        ...prev,\n        error: \"Connection error\",\n        isConnecting: false,\n      }));\n      onError?.(\"Connection error\");\n    },\n    [onError],\n  );\n\n  // Connect function\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    setState((prev) => ({ ...prev, isConnecting: true, error: null }));\n\n    try {\n      const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n      const wsUrl = `${protocol}//${window.location.host}/api/ws/markov-blanket`;\n\n      wsRef.current = new WebSocket(wsUrl);\n      wsRef.current.onopen = handleOpen;\n      wsRef.current.onmessage = handleMessage;\n      wsRef.current.onclose = handleClose;\n      wsRef.current.onerror = handleError;\n    } catch (error) {\n      console.error(\n        \"Error creating Markov Blanket WebSocket connection:\",\n        error,\n      );\n      setState((prev) => ({\n        ...prev,\n        error: \"Failed to create connection\",\n        isConnecting: false,\n      }));\n      onError?.(\"Failed to create connection\");\n    }\n  }, [handleOpen, handleMessage, handleClose, handleError, onError]);\n\n  // Disconnect function\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n\n    if (wsRef.current) {\n      wsRef.current.close(1000, \"Manual disconnect\");\n      wsRef.current = null;\n    }\n\n    setState((prev) => ({\n      ...prev,\n      isConnected: false,\n      isConnecting: false,\n    }));\n  }, []);\n\n  // Send message function\n  const sendMessage = useCallback((message: any) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn(\n        \"Markov Blanket WebSocket not connected, cannot send message:\",\n        message,\n      );\n    }\n  }, []);\n\n  // Subscription management\n  const updateSubscription = useCallback(\n    (newSubscription: MarkovBlanketSubscription) => {\n      sendMessage({\n        type: \"subscribe\",\n        subscription: newSubscription,\n      });\n    },\n    [sendMessage],\n  );\n\n  // Agent management\n  const registerAgent = useCallback(\n    (agentId: string) => {\n      sendMessage({\n        type: \"register_agent\",\n        agent_id: agentId,\n      });\n    },\n    [sendMessage],\n  );\n\n  const unregisterAgent = useCallback(\n    (agentId: string) => {\n      sendMessage({\n        type: \"unregister_agent\",\n        agent_id: agentId,\n      });\n    },\n    [sendMessage],\n  );\n\n  // Monitoring control\n  const startMonitoring = useCallback(() => {\n    sendMessage({ type: \"start_monitoring\" });\n  }, [sendMessage]);\n\n  const stopMonitoring = useCallback(() => {\n    sendMessage({ type: \"stop_monitoring\" });\n  }, [sendMessage]);\n\n  // Data fetching\n  const getMonitoringStatus = useCallback(() => {\n    sendMessage({ type: \"get_monitoring_status\" });\n  }, [sendMessage]);\n\n  const getAgentViolations = useCallback(\n    (agentId: string) => {\n      sendMessage({\n        type: \"get_agent_violations\",\n        agent_id: agentId,\n      });\n    },\n    [sendMessage],\n  );\n\n  const getConnectionStats = useCallback(() => {\n    sendMessage({ type: \"get_stats\" });\n  }, [sendMessage]);\n\n  const getComplianceReport = useCallback(\n    (agentId?: string) => {\n      sendMessage({\n        type: \"get_compliance_report\",\n        agent_id: agentId,\n      });\n    },\n    [sendMessage],\n  );\n\n  // Ping function\n  const ping = useCallback(() => {\n    sendMessage({ type: \"ping\" });\n  }, [sendMessage]);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n\n    return () => {\n      disconnect();\n    };\n  }, [autoConnect, connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    ...state,\n    connect,\n    disconnect,\n    updateSubscription,\n    registerAgent,\n    unregisterAgent,\n    startMonitoring,\n    stopMonitoring,\n    getMonitoringStatus,\n    getAgentViolations,\n    getConnectionStats,\n    getComplianceReport,\n    sendMessage,\n    ping,\n  };\n}\n"],"names":["useMarkovBlanketWebSocket","options","autoConnect","reconnectDelay","maxReconnectAttempts","subscription","onEvent","onConnect","onDisconnect","onError","onViolation","state","setState","useState","isConnected","isConnecting","error","lastEventTime","connectionStats","monitoringStatus","violations","wsRef","useRef","reconnectAttemptsRef","reconnectTimeoutRef","handleMessage","useCallback","event","data","JSON","parse","prev","Date","type","console","log","client_id","stats","agent_id","report","message","violation","violation_type","independence_measure","threshold","mathematical_justification","evidence","severity","timestamp","handleOpen","current","setTimeout","updateSubscription","handleClose","code","reason","connect","handleError","readyState","WebSocket","OPEN","protocol","window","location","wsUrl","host","onopen","onmessage","onclose","onerror","disconnect","clearTimeout","close","sendMessage","send","stringify","warn","newSubscription","registerAgent","agentId","unregisterAgent","startMonitoring","stopMonitoring","getMonitoringStatus","getAgentViolations","getConnectionStats","getComplianceReport","ping","useEffect"],"mappings":"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"}