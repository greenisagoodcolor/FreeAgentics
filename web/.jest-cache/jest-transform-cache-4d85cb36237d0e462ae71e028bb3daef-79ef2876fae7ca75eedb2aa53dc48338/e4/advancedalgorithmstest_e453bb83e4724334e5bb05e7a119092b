6ea1b8ba39485e74b077ecc335a1e9da
/**
 * Advanced Algorithms Tests
 *
 * Tests for mathematical algorithms, optimization functions, machine learning utilities,
 * and computational methods following ADR-007 requirements for algorithm coverage.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// Matrix Operations Library
class Matrix {
    constructor(rows, cols, initialValue = 0){
        this.rows = rows;
        this.cols = cols;
        this.data = Array(rows).fill(null).map(()=>Array(cols).fill(initialValue));
    }
    static fromArray(array) {
        const matrix = new Matrix(array.length, array[0]?.length || 0);
        matrix.data = array.map((row)=>[
                ...row
            ]);
        return matrix;
    }
    get(row, col) {
        if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
            throw new Error("Index out of bounds");
        }
        return this.data[row][col];
    }
    set(row, col, value) {
        if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
            throw new Error("Index out of bounds");
        }
        this.data[row][col] = value;
    }
    multiply(other) {
        if (this.cols !== other.rows) {
            throw new Error("Matrix dimensions incompatible for multiplication");
        }
        const result = new Matrix(this.rows, other.cols);
        for(let i = 0; i < this.rows; i++){
            for(let j = 0; j < other.cols; j++){
                let sum = 0;
                for(let k = 0; k < this.cols; k++){
                    sum += this.data[i][k] * other.data[k][j];
                }
                result.set(i, j, sum);
            }
        }
        return result;
    }
    add(other) {
        if (this.rows !== other.rows || this.cols !== other.cols) {
            throw new Error("Matrix dimensions must match for addition");
        }
        const result = new Matrix(this.rows, this.cols);
        for(let i = 0; i < this.rows; i++){
            for(let j = 0; j < this.cols; j++){
                result.set(i, j, this.get(i, j) + other.get(i, j));
            }
        }
        return result;
    }
    subtract(other) {
        if (this.rows !== other.rows || this.cols !== other.cols) {
            throw new Error("Matrix dimensions must match for subtraction");
        }
        const result = new Matrix(this.rows, this.cols);
        for(let i = 0; i < this.rows; i++){
            for(let j = 0; j < this.cols; j++){
                result.set(i, j, this.get(i, j) - other.get(i, j));
            }
        }
        return result;
    }
    transpose() {
        const result = new Matrix(this.cols, this.rows);
        for(let i = 0; i < this.rows; i++){
            for(let j = 0; j < this.cols; j++){
                result.set(j, i, this.get(i, j));
            }
        }
        return result;
    }
    determinant() {
        if (this.rows !== this.cols) {
            throw new Error("Determinant only defined for square matrices");
        }
        if (this.rows === 1) {
            return this.get(0, 0);
        }
        if (this.rows === 2) {
            return this.get(0, 0) * this.get(1, 1) - this.get(0, 1) * this.get(1, 0);
        }
        let det = 0;
        for(let j = 0; j < this.cols; j++){
            const subMatrix = this.getSubMatrix(0, j);
            const cofactor = Math.pow(-1, j) * this.get(0, j) * subMatrix.determinant();
            det += cofactor;
        }
        return det;
    }
    getSubMatrix(excludeRow, excludeCol) {
        const result = new Matrix(this.rows - 1, this.cols - 1);
        let resultRow = 0;
        for(let i = 0; i < this.rows; i++){
            if (i === excludeRow) continue;
            let resultCol = 0;
            for(let j = 0; j < this.cols; j++){
                if (j === excludeCol) continue;
                result.set(resultRow, resultCol, this.get(i, j));
                resultCol++;
            }
            resultRow++;
        }
        return result;
    }
    toArray() {
        return this.data.map((row)=>[
                ...row
            ]);
    }
}
class GradientDescent {
    constructor(learningRate = 0.01, maxIterations = 1000, tolerance = 1e-6){
        this.learningRate = learningRate;
        this.maxIterations = maxIterations;
        this.tolerance = tolerance;
    }
    optimize(objectiveFunction, gradientFunction, initialGuess) {
        let x = [
            ...initialGuess
        ];
        let iteration = 0;
        let previousValue = objectiveFunction(x);
        for(iteration = 0; iteration < this.maxIterations; iteration++){
            const gradient = gradientFunction(x);
            // Update parameters
            for(let i = 0; i < x.length; i++){
                x[i] -= this.learningRate * gradient[i];
            }
            const currentValue = objectiveFunction(x);
            // Check convergence
            if (Math.abs(currentValue - previousValue) < this.tolerance) {
                return {
                    solution: x,
                    value: currentValue,
                    iterations: iteration + 1,
                    converged: true
                };
            }
            previousValue = currentValue;
        }
        return {
            solution: x,
            value: objectiveFunction(x),
            iterations: this.maxIterations,
            converged: false
        };
    }
}
class GeneticAlgorithm {
    constructor(options = {}){
        this.options = {
            populationSize: 100,
            mutationRate: 0.01,
            crossoverRate: 0.8,
            eliteSize: 10,
            maxGenerations: 1000,
            ...options
        };
    }
    optimize(fitnessFunction, geneLength, geneRange = [
        0,
        1
    ]) {
        // Initialize population
        let population = this.initializePopulation(geneLength, geneRange);
        // Evaluate initial population
        population = this.evaluatePopulation(population, fitnessFunction);
        let generation = 0;
        let bestIndividual = this.getBestIndividual(population);
        for(generation = 0; generation < this.options.maxGenerations; generation++){
            // Selection
            const parents = this.selection(population);
            // Crossover
            let offspring = this.crossover(parents);
            // Mutation
            offspring = this.mutate(offspring, geneRange);
            // Evaluate offspring
            offspring = this.evaluatePopulation(offspring, fitnessFunction);
            // Replacement
            population = this.replacement(population, offspring);
            // Update best individual
            const currentBest = this.getBestIndividual(population);
            if (currentBest.fitness > bestIndividual.fitness) {
                bestIndividual = currentBest;
            }
            // Check termination condition
            if (this.options.targetFitness && bestIndividual.fitness >= this.options.targetFitness) {
                return {
                    solution: bestIndividual.genes,
                    value: bestIndividual.fitness,
                    iterations: generation + 1,
                    converged: true
                };
            }
        }
        return {
            solution: bestIndividual.genes,
            value: bestIndividual.fitness,
            iterations: this.options.maxGenerations,
            converged: false
        };
    }
    initializePopulation(geneLength, geneRange) {
        const population = [];
        for(let i = 0; i < this.options.populationSize; i++){
            const genes = [];
            for(let j = 0; j < geneLength; j++){
                const value = Math.random() * (geneRange[1] - geneRange[0]) + geneRange[0];
                genes.push(value);
            }
            population.push({
                genes,
                fitness: 0
            });
        }
        return population;
    }
    evaluatePopulation(population, fitnessFunction) {
        return population.map((individual)=>({
                ...individual,
                fitness: fitnessFunction(individual.genes)
            }));
    }
    selection(population) {
        // Tournament selection
        const parents = [];
        const tournamentSize = Math.max(2, Math.floor(this.options.populationSize * 0.1));
        for(let i = 0; i < this.options.populationSize; i++){
            const tournament = [];
            for(let j = 0; j < tournamentSize; j++){
                const randomIndex = Math.floor(Math.random() * population.length);
                tournament.push(population[randomIndex]);
            }
            const winner = tournament.reduce((best, current)=>current.fitness > best.fitness ? current : best);
            parents.push({
                ...winner
            });
        }
        return parents;
    }
    crossover(parents) {
        const offspring = [];
        for(let i = 0; i < parents.length; i += 2){
            const parent1 = parents[i];
            const parent2 = parents[i + 1] || parents[0];
            if (Math.random() < this.options.crossoverRate) {
                const crossoverPoint = Math.floor(Math.random() * parent1.genes.length);
                const child1Genes = [
                    ...parent1.genes.slice(0, crossoverPoint),
                    ...parent2.genes.slice(crossoverPoint)
                ];
                const child2Genes = [
                    ...parent2.genes.slice(0, crossoverPoint),
                    ...parent1.genes.slice(crossoverPoint)
                ];
                offspring.push({
                    genes: child1Genes,
                    fitness: 0
                });
                offspring.push({
                    genes: child2Genes,
                    fitness: 0
                });
            } else {
                offspring.push({
                    ...parent1
                });
                offspring.push({
                    ...parent2
                });
            }
        }
        return offspring.slice(0, this.options.populationSize);
    }
    mutate(population, geneRange) {
        return population.map((individual)=>{
            const mutatedGenes = individual.genes.map((gene)=>{
                if (Math.random() < this.options.mutationRate) {
                    const mutationStrength = 0.1;
                    const mutation = (Math.random() - 0.5) * 2 * mutationStrength * (geneRange[1] - geneRange[0]);
                    return Math.max(geneRange[0], Math.min(geneRange[1], gene + mutation));
                }
                return gene;
            });
            return {
                genes: mutatedGenes,
                fitness: individual.fitness
            };
        });
    }
    replacement(oldPopulation, offspring) {
        // Elitism + replace worst
        const combined = [
            ...oldPopulation,
            ...offspring
        ];
        combined.sort((a, b)=>b.fitness - a.fitness);
        return combined.slice(0, this.options.populationSize);
    }
    getBestIndividual(population) {
        return population.reduce((best, current)=>current.fitness > best.fitness ? current : best);
    }
}
// Machine Learning Utilities
class NeuralNetwork {
    constructor(layers, learningRate = 0.01){
        this.learningRate = learningRate;
        this.weights = [];
        this.biases = [];
        // Initialize weights and biases
        for(let i = 0; i < layers.length - 1; i++){
            const weight = new Matrix(layers[i + 1], layers[i]);
            const bias = new Matrix(layers[i + 1], 1);
            // Xavier initialization
            const limit = Math.sqrt(6 / (layers[i] + layers[i + 1]));
            for(let row = 0; row < weight.rows; row++){
                for(let col = 0; col < weight.cols; col++){
                    weight.set(row, col, (Math.random() - 0.5) * 2 * limit);
                }
                bias.set(row, 0, (Math.random() - 0.5) * 2 * limit);
            }
            this.weights.push(weight);
            this.biases.push(bias);
        }
    }
    sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
    }
    sigmoidDerivative(x) {
        const s = this.sigmoid(x);
        return s * (1 - s);
    }
    applyActivation(matrix) {
        const result = new Matrix(matrix.rows, matrix.cols);
        for(let i = 0; i < matrix.rows; i++){
            for(let j = 0; j < matrix.cols; j++){
                result.set(i, j, this.sigmoid(matrix.get(i, j)));
            }
        }
        return result;
    }
    forward(input) {
        let current = Matrix.fromArray([
            input
        ]).transpose();
        for(let i = 0; i < this.weights.length; i++){
            current = this.weights[i].multiply(current).add(this.biases[i]);
            current = this.applyActivation(current);
        }
        const result = [];
        for(let i = 0; i < current.rows; i++){
            result.push(current.get(i, 0));
        }
        return result;
    }
    train(inputs, outputs, epochs) {
        const losses = [];
        for(let epoch = 0; epoch < epochs; epoch++){
            let totalLoss = 0;
            for(let i = 0; i < inputs.length; i++){
                const predicted = this.forward(inputs[i]);
                const target = outputs[i];
                // Calculate loss (MSE)
                let loss = 0;
                for(let j = 0; j < predicted.length; j++){
                    loss += Math.pow(predicted[j] - target[j], 2);
                }
                loss /= predicted.length;
                totalLoss += loss;
                // Backpropagation (simplified)
                this.backward(inputs[i], target, predicted);
            }
            losses.push(totalLoss / inputs.length);
        }
        return losses;
    }
    backward(input, target, predicted) {
        // Simplified backpropagation - calculate output error
        const outputError = [];
        for(let i = 0; i < predicted.length; i++){
            outputError.push((target[i] - predicted[i]) * this.sigmoidDerivative(predicted[i]));
        }
        // Update weights (simplified - only output layer)
        if (this.weights.length > 0) {
            const lastWeightIndex = this.weights.length - 1;
            const lastWeight = this.weights[lastWeightIndex];
            for(let i = 0; i < lastWeight.rows; i++){
                for(let j = 0; j < lastWeight.cols; j++){
                    const delta = this.learningRate * outputError[i] * input[j];
                    lastWeight.set(i, j, lastWeight.get(i, j) + delta);
                }
                // Update bias
                const biasIndex = this.biases.length - 1;
                const currentBias = this.biases[biasIndex].get(i, 0);
                this.biases[biasIndex].set(i, 0, currentBias + this.learningRate * outputError[i]);
            }
        }
    }
}
// Statistical Functions
class Statistics {
    static mean(values) {
        if (values.length === 0) return 0;
        return values.reduce((sum, value)=>sum + value, 0) / values.length;
    }
    static median(values) {
        if (values.length === 0) return 0;
        const sorted = [
            ...values
        ].sort((a, b)=>a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
    }
    static standardDeviation(values) {
        if (values.length === 0) return 0;
        const mean = this.mean(values);
        const variance = values.reduce((sum, value)=>sum + Math.pow(value - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
    }
    static correlation(x, y) {
        if (x.length !== y.length || x.length === 0) {
            throw new Error("Arrays must have the same non-zero length");
        }
        const meanX = this.mean(x);
        const meanY = this.mean(y);
        let numerator = 0;
        let sumSquareX = 0;
        let sumSquareY = 0;
        for(let i = 0; i < x.length; i++){
            const deltaX = x[i] - meanX;
            const deltaY = y[i] - meanY;
            numerator += deltaX * deltaY;
            sumSquareX += deltaX * deltaX;
            sumSquareY += deltaY * deltaY;
        }
        const denominator = Math.sqrt(sumSquareX * sumSquareY);
        return denominator === 0 ? 0 : numerator / denominator;
    }
    static linearRegression(x, y) {
        if (x.length !== y.length || x.length === 0) {
            throw new Error("Arrays must have the same non-zero length");
        }
        const n = x.length;
        const sumX = x.reduce((sum, val)=>sum + val, 0);
        const sumY = y.reduce((sum, val)=>sum + val, 0);
        const sumXY = x.reduce((sum, val, i)=>sum + val * y[i], 0);
        const sumXX = x.reduce((sum, val)=>sum + val * val, 0);
        const sumYY = y.reduce((sum, val)=>sum + val * val, 0);
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        // Calculate R-squared
        const meanY = sumY / n;
        const totalSumSquares = sumYY - n * meanY * meanY;
        const residualSumSquares = y.reduce((sum, val, i)=>{
            const predicted = slope * x[i] + intercept;
            return sum + Math.pow(val - predicted, 2);
        }, 0);
        const r2 = 1 - residualSumSquares / totalSumSquares;
        return {
            slope,
            intercept,
            r2
        };
    }
}
class Graph {
    addNode(node) {
        this.nodes.set(node.id, node);
        if (!this.adjacencyList.has(node.id)) {
            this.adjacencyList.set(node.id, []);
        }
    }
    addEdge(edge) {
        const edgeKey = `${edge.from}-${edge.to}`;
        this.edges.set(edgeKey, edge);
        if (!this.adjacencyList.has(edge.from)) {
            this.adjacencyList.set(edge.from, []);
        }
        if (!this.adjacencyList.has(edge.to)) {
            this.adjacencyList.set(edge.to, []);
        }
        this.adjacencyList.get(edge.from).push(edge.to);
    }
    getNeighbors(nodeId) {
        return this.adjacencyList.get(nodeId) || [];
    }
    dijkstra(startId, endId) {
        const distances = new Map();
        const previous = new Map();
        const unvisited = new Set();
        // Initialize distances
        for (const nodeId of this.nodes.keys()){
            distances.set(nodeId, nodeId === startId ? 0 : Infinity);
            previous.set(nodeId, null);
            unvisited.add(nodeId);
        }
        while(unvisited.size > 0){
            // Find node with minimum distance
            let currentNode = null;
            let minDistance = Infinity;
            for (const nodeId of unvisited){
                const distance = distances.get(nodeId);
                if (distance < minDistance) {
                    minDistance = distance;
                    currentNode = nodeId;
                }
            }
            if (currentNode === null || minDistance === Infinity) {
                break; // No path exists
            }
            unvisited.delete(currentNode);
            if (currentNode === endId) {
                // Reconstruct path
                const path = [];
                let current = endId;
                while(current !== null){
                    path.unshift(current);
                    current = previous.get(current);
                }
                return {
                    path,
                    distance: distances.get(endId)
                };
            }
            // Update distances to neighbors
            const neighbors = this.getNeighbors(currentNode);
            for (const neighborId of neighbors){
                if (!unvisited.has(neighborId)) continue;
                const edgeKey = `${currentNode}-${neighborId}`;
                const edge = this.edges.get(edgeKey);
                const weight = edge?.weight || 1;
                const newDistance = distances.get(currentNode) + weight;
                if (newDistance < distances.get(neighborId)) {
                    distances.set(neighborId, newDistance);
                    previous.set(neighborId, currentNode);
                }
            }
        }
        return null; // No path found
    }
    bfs(startId) {
        const visited = new Set();
        const queue = [
            startId
        ];
        const result = [];
        while(queue.length > 0){
            const current = queue.shift();
            if (visited.has(current)) continue;
            visited.add(current);
            result.push(current);
            const neighbors = this.getNeighbors(current);
            for (const neighbor of neighbors){
                if (!visited.has(neighbor)) {
                    queue.push(neighbor);
                }
            }
        }
        return result;
    }
    dfs(startId) {
        const visited = new Set();
        const result = [];
        const dfsRecursive = (nodeId)=>{
            visited.add(nodeId);
            result.push(nodeId);
            const neighbors = this.getNeighbors(nodeId);
            for (const neighbor of neighbors){
                if (!visited.has(neighbor)) {
                    dfsRecursive(neighbor);
                }
            }
        };
        dfsRecursive(startId);
        return result;
    }
    detectCycles() {
        const visited = new Set();
        const recStack = new Set();
        const hasCycleRecursive = (nodeId)=>{
            visited.add(nodeId);
            recStack.add(nodeId);
            const neighbors = this.getNeighbors(nodeId);
            for (const neighbor of neighbors){
                if (!visited.has(neighbor)) {
                    if (hasCycleRecursive(neighbor)) {
                        return true;
                    }
                } else if (recStack.has(neighbor)) {
                    return true;
                }
            }
            recStack.delete(nodeId);
            return false;
        };
        for (const nodeId of this.nodes.keys()){
            if (!visited.has(nodeId)) {
                if (hasCycleRecursive(nodeId)) {
                    return true;
                }
            }
        }
        return false;
    }
    constructor(){
        this.nodes = new Map();
        this.adjacencyList = new Map();
        this.edges = new Map();
    }
}
// Tests
describe("Advanced Algorithms", ()=>{
    describe("Matrix Operations", ()=>{
        test("should create matrix with correct dimensions", ()=>{
            const matrix = new Matrix(3, 4, 5);
            expect(matrix.rows).toBe(3);
            expect(matrix.cols).toBe(4);
            expect(matrix.get(0, 0)).toBe(5);
            expect(matrix.get(2, 3)).toBe(5);
        });
        test("should handle matrix multiplication", ()=>{
            const a = Matrix.fromArray([
                [
                    1,
                    2
                ],
                [
                    3,
                    4
                ]
            ]);
            const b = Matrix.fromArray([
                [
                    5,
                    6
                ],
                [
                    7,
                    8
                ]
            ]);
            const result = a.multiply(b);
            expect(result.get(0, 0)).toBe(19); // 1*5 + 2*7
            expect(result.get(0, 1)).toBe(22); // 1*6 + 2*8
            expect(result.get(1, 0)).toBe(43); // 3*5 + 4*7
            expect(result.get(1, 1)).toBe(50); // 3*6 + 4*8
        });
        test("should calculate determinant", ()=>{
            const matrix2x2 = Matrix.fromArray([
                [
                    1,
                    2
                ],
                [
                    3,
                    4
                ]
            ]);
            expect(matrix2x2.determinant()).toBe(-2);
            const matrix3x3 = Matrix.fromArray([
                [
                    1,
                    2,
                    3
                ],
                [
                    4,
                    5,
                    6
                ],
                [
                    7,
                    8,
                    9
                ]
            ]);
            expect(matrix3x3.determinant()).toBe(0); // Singular matrix
        });
        test("should transpose matrix", ()=>{
            const matrix = Matrix.fromArray([
                [
                    1,
                    2,
                    3
                ],
                [
                    4,
                    5,
                    6
                ]
            ]);
            const transposed = matrix.transpose();
            expect(transposed.rows).toBe(3);
            expect(transposed.cols).toBe(2);
            expect(transposed.get(0, 0)).toBe(1);
            expect(transposed.get(1, 0)).toBe(2);
            expect(transposed.get(2, 1)).toBe(6);
        });
        test("should handle matrix addition and subtraction", ()=>{
            const a = Matrix.fromArray([
                [
                    1,
                    2
                ],
                [
                    3,
                    4
                ]
            ]);
            const b = Matrix.fromArray([
                [
                    5,
                    6
                ],
                [
                    7,
                    8
                ]
            ]);
            const sum = a.add(b);
            expect(sum.get(0, 0)).toBe(6);
            expect(sum.get(1, 1)).toBe(12);
            const diff = a.subtract(b);
            expect(diff.get(0, 0)).toBe(-4);
            expect(diff.get(1, 1)).toBe(-4);
        });
        test("should throw error for invalid operations", ()=>{
            const a = new Matrix(2, 3);
            const b = new Matrix(2, 2);
            expect(()=>a.multiply(b)).toThrow("Matrix dimensions incompatible");
            expect(()=>a.add(b)).toThrow("Matrix dimensions must match");
            expect(()=>a.determinant()).toThrow("Determinant only defined for square matrices");
        });
    });
    describe("Gradient Descent", ()=>{
        test("should minimize quadratic function", ()=>{
            const gd = new GradientDescent(0.1, 100, 1e-6);
            // Minimize f(x) = x^2, gradient = 2x
            const objective = (x)=>x[0] * x[0];
            const gradient = (x)=>[
                    2 * x[0]
                ];
            const result = gd.optimize(objective, gradient, [
                10
            ]);
            expect(result.converged).toBe(true);
            expect(Math.abs(result.solution[0])).toBeLessThan(0.1);
            expect(result.value).toBeLessThan(0.01);
        });
        test("should handle multi-dimensional optimization", ()=>{
            const gd = new GradientDescent(0.01, 1000, 1e-6);
            // Minimize f(x,y) = x^2 + y^2
            const objective = (x)=>x[0] * x[0] + x[1] * x[1];
            const gradient = (x)=>[
                    2 * x[0],
                    2 * x[1]
                ];
            const result = gd.optimize(objective, gradient, [
                5,
                -3
            ]);
            expect(result.converged).toBe(true);
            expect(Math.abs(result.solution[0])).toBeLessThan(0.1);
            expect(Math.abs(result.solution[1])).toBeLessThan(0.1);
        });
        test("should return non-converged result for difficult problems", ()=>{
            const gd = new GradientDescent(0.001, 10, 1e-6); // Too few iterations
            const objective = (x)=>x[0] * x[0];
            const gradient = (x)=>[
                    2 * x[0]
                ];
            const result = gd.optimize(objective, gradient, [
                100
            ]);
            expect(result.converged).toBe(false);
            expect(result.iterations).toBe(10);
        });
    });
    describe("Genetic Algorithm", ()=>{
        test("should optimize simple function", ()=>{
            const ga = new GeneticAlgorithm({
                populationSize: 50,
                maxGenerations: 100,
                mutationRate: 0.1
            });
            // Maximize f(x) = -(x-5)^2 + 25 (peak at x=5)
            const fitness = (genes)=>{
                const x = genes[0] * 10; // Scale from [0,1] to [0,10]
                return -Math.pow(x - 5, 2) + 25;
            };
            const result = ga.optimize(fitness, 1, [
                0,
                1
            ]);
            expect(result.solution).toHaveLength(1);
            const scaledSolution = result.solution[0] * 10;
            expect(Math.abs(scaledSolution - 5)).toBeLessThan(1);
            expect(result.value).toBeGreaterThan(20);
        });
        test("should handle multi-dimensional optimization", ()=>{
            const ga = new GeneticAlgorithm({
                populationSize: 100,
                maxGenerations: 50,
                mutationRate: 0.05
            });
            // Maximize f(x,y) = -(x-3)^2 - (y-4)^2 + 25
            const fitness = (genes)=>{
                const x = genes[0] * 10;
                const y = genes[1] * 10;
                return -Math.pow(x - 3, 2) - Math.pow(y - 4, 2) + 25;
            };
            const result = ga.optimize(fitness, 2, [
                0,
                1
            ]);
            expect(result.solution).toHaveLength(2);
            expect(result.iterations).toBeGreaterThan(0);
        });
        test("should terminate early with target fitness", ()=>{
            const ga = new GeneticAlgorithm({
                populationSize: 50,
                maxGenerations: 1000,
                targetFitness: 20
            });
            const fitness = (genes)=>{
                const x = genes[0] * 10;
                return -Math.pow(x - 5, 2) + 25;
            };
            const result = ga.optimize(fitness, 1, [
                0,
                1
            ]);
            expect(result.converged).toBe(true);
            expect(result.iterations).toBeLessThan(1000);
            expect(result.value).toBeGreaterThanOrEqual(20);
        });
    });
    describe("Neural Network", ()=>{
        test("should create network with correct architecture", ()=>{
            const nn = new NeuralNetwork([
                2,
                3,
                1
            ]);
            // Test that network can process input
            const output = nn.forward([
                0.5,
                0.3
            ]);
            expect(output).toHaveLength(1);
            expect(output[0]).toBeGreaterThanOrEqual(0);
            expect(output[0]).toBeLessThanOrEqual(1);
        });
        test("should train on XOR problem", ()=>{
            const nn = new NeuralNetwork([
                2,
                4,
                1
            ], 0.5);
            const inputs = [
                [
                    0,
                    0
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    0
                ],
                [
                    1,
                    1
                ]
            ];
            const outputs = [
                [
                    0
                ],
                [
                    1
                ],
                [
                    1
                ],
                [
                    0
                ]
            ];
            const losses = nn.train(inputs, outputs, 100);
            expect(losses).toHaveLength(100);
            expect(losses[losses.length - 1]).toBeLessThan(losses[0]);
        });
        test("should learn simple pattern", ()=>{
            const nn = new NeuralNetwork([
                1,
                2,
                1
            ], 0.1);
            // Learn f(x) = x
            const inputs = [
                [
                    0
                ],
                [
                    0.25
                ],
                [
                    0.5
                ],
                [
                    0.75
                ],
                [
                    1
                ]
            ];
            const outputs = [
                [
                    0
                ],
                [
                    0.25
                ],
                [
                    0.5
                ],
                [
                    0.75
                ],
                [
                    1
                ]
            ];
            nn.train(inputs, outputs, 200);
            const testOutput = nn.forward([
                0.6
            ]);
            expect(Math.abs(testOutput[0] - 0.6)).toBeLessThan(0.3);
        });
    });
    describe("Statistics", ()=>{
        test("should calculate mean correctly", ()=>{
            expect(Statistics.mean([
                1,
                2,
                3,
                4,
                5
            ])).toBe(3);
            expect(Statistics.mean([
                10
            ])).toBe(10);
            expect(Statistics.mean([])).toBe(0);
        });
        test("should calculate median correctly", ()=>{
            expect(Statistics.median([
                1,
                2,
                3,
                4,
                5
            ])).toBe(3);
            expect(Statistics.median([
                1,
                2,
                3,
                4
            ])).toBe(2.5);
            expect(Statistics.median([
                5,
                1,
                3
            ])).toBe(3);
        });
        test("should calculate standard deviation", ()=>{
            const std = Statistics.standardDeviation([
                2,
                4,
                4,
                4,
                5,
                5,
                7,
                9
            ]);
            expect(Math.abs(std - 2)).toBeLessThan(0.1);
        });
        test("should calculate correlation", ()=>{
            const x = [
                1,
                2,
                3,
                4,
                5
            ];
            const y = [
                2,
                4,
                6,
                8,
                10
            ];
            const correlation = Statistics.correlation(x, y);
            expect(Math.abs(correlation - 1)).toBeLessThan(0.01); // Perfect positive correlation
        });
        test("should perform linear regression", ()=>{
            const x = [
                1,
                2,
                3,
                4,
                5
            ];
            const y = [
                2,
                4,
                6,
                8,
                10
            ]; // y = 2x
            const regression = Statistics.linearRegression(x, y);
            expect(Math.abs(regression.slope - 2)).toBeLessThan(0.01);
            expect(Math.abs(regression.intercept)).toBeLessThan(0.01);
            expect(regression.r2).toBeGreaterThan(0.99);
        });
        test("should handle edge cases", ()=>{
            expect(()=>Statistics.correlation([], [])).toThrow();
            expect(()=>Statistics.correlation([
                    1
                ], [
                    1,
                    2
                ])).toThrow();
            expect(()=>Statistics.linearRegression([], [])).toThrow();
        });
    });
    describe("Graph Algorithms", ()=>{
        let graph;
        beforeEach(()=>{
            graph = new Graph();
            // Create test graph
            graph.addNode({
                id: "A"
            });
            graph.addNode({
                id: "B"
            });
            graph.addNode({
                id: "C"
            });
            graph.addNode({
                id: "D"
            });
            graph.addEdge({
                from: "A",
                to: "B",
                weight: 1
            });
            graph.addEdge({
                from: "A",
                to: "C",
                weight: 4
            });
            graph.addEdge({
                from: "B",
                to: "C",
                weight: 2
            });
            graph.addEdge({
                from: "B",
                to: "D",
                weight: 5
            });
            graph.addEdge({
                from: "C",
                to: "D",
                weight: 1
            });
        });
        test("should perform breadth-first search", ()=>{
            const result = graph.bfs("A");
            expect(result).toContain("A");
            expect(result).toContain("B");
            expect(result).toContain("C");
            expect(result[0]).toBe("A"); // Start node should be first
        });
        test("should perform depth-first search", ()=>{
            const result = graph.dfs("A");
            expect(result).toContain("A");
            expect(result).toContain("B");
            expect(result).toContain("C");
            expect(result[0]).toBe("A"); // Start node should be first
        });
        test("should find shortest path with Dijkstra", ()=>{
            const result = graph.dijkstra("A", "D");
            expect(result).not.toBeNull();
            expect(result.path[0]).toBe("A");
            expect(result.path[result.path.length - 1]).toBe("D");
            expect(result.distance).toBe(5); // A -> B -> C -> D = 1 + 2 + 1 = 4 or A -> C -> D = 4 + 1 = 5
        });
        test("should detect cycles", ()=>{
            const cyclicGraph = new Graph();
            cyclicGraph.addNode({
                id: "X"
            });
            cyclicGraph.addNode({
                id: "Y"
            });
            cyclicGraph.addNode({
                id: "Z"
            });
            cyclicGraph.addEdge({
                from: "X",
                to: "Y"
            });
            cyclicGraph.addEdge({
                from: "Y",
                to: "Z"
            });
            cyclicGraph.addEdge({
                from: "Z",
                to: "X"
            }); // Creates cycle
            expect(cyclicGraph.detectCycles()).toBe(true);
            expect(graph.detectCycles()).toBe(false); // Original graph is acyclic
        });
        test("should handle disconnected nodes", ()=>{
            graph.addNode({
                id: "E"
            }); // Isolated node
            const result = graph.dijkstra("A", "E");
            expect(result).toBeNull(); // No path exists
        });
        test("should return empty arrays for non-existent nodes", ()=>{
            const neighbors = graph.getNeighbors("NonExistent");
            expect(neighbors).toEqual([]);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2FkdmFuY2VkLWFsZ29yaXRobXMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFkdmFuY2VkIEFsZ29yaXRobXMgVGVzdHNcbiAqXG4gKiBUZXN0cyBmb3IgbWF0aGVtYXRpY2FsIGFsZ29yaXRobXMsIG9wdGltaXphdGlvbiBmdW5jdGlvbnMsIG1hY2hpbmUgbGVhcm5pbmcgdXRpbGl0aWVzLFxuICogYW5kIGNvbXB1dGF0aW9uYWwgbWV0aG9kcyBmb2xsb3dpbmcgQURSLTAwNyByZXF1aXJlbWVudHMgZm9yIGFsZ29yaXRobSBjb3ZlcmFnZS5cbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSBcIkBqZXN0L2dsb2JhbHNcIjtcblxuLy8gTWF0cml4IE9wZXJhdGlvbnMgTGlicmFyeVxuY2xhc3MgTWF0cml4IHtcbiAgcHJpdmF0ZSBkYXRhOiBudW1iZXJbXVtdO1xuICBwdWJsaWMgcm93czogbnVtYmVyO1xuICBwdWJsaWMgY29sczogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHJvd3M6IG51bWJlciwgY29sczogbnVtYmVyLCBpbml0aWFsVmFsdWU6IG51bWJlciA9IDApIHtcbiAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgIHRoaXMuY29scyA9IGNvbHM7XG4gICAgdGhpcy5kYXRhID0gQXJyYXkocm93cylcbiAgICAgIC5maWxsKG51bGwpXG4gICAgICAubWFwKCgpID0+IEFycmF5KGNvbHMpLmZpbGwoaW5pdGlhbFZhbHVlKSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUFycmF5KGFycmF5OiBudW1iZXJbXVtdKTogTWF0cml4IHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KGFycmF5Lmxlbmd0aCwgYXJyYXlbMF0/Lmxlbmd0aCB8fCAwKTtcbiAgICBtYXRyaXguZGF0YSA9IGFycmF5Lm1hcCgocm93KSA9PiBbLi4ucm93XSk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIGdldChyb3c6IG51bWJlciwgY29sOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChyb3cgPCAwIHx8IHJvdyA+PSB0aGlzLnJvd3MgfHwgY29sIDwgMCB8fCBjb2wgPj0gdGhpcy5jb2xzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBvdXQgb2YgYm91bmRzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd11bY29sXTtcbiAgfVxuXG4gIHNldChyb3c6IG51bWJlciwgY29sOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAocm93IDwgMCB8fCByb3cgPj0gdGhpcy5yb3dzIHx8IGNvbCA8IDAgfHwgY29sID49IHRoaXMuY29scykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhW3Jvd11bY29sXSA9IHZhbHVlO1xuICB9XG5cbiAgbXVsdGlwbHkob3RoZXI6IE1hdHJpeCk6IE1hdHJpeCB7XG4gICAgaWYgKHRoaXMuY29scyAhPT0gb3RoZXIucm93cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWF0cml4IGRpbWVuc2lvbnMgaW5jb21wYXRpYmxlIGZvciBtdWx0aXBsaWNhdGlvblwiKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KHRoaXMucm93cywgb3RoZXIuY29scyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG90aGVyLmNvbHM7IGorKykge1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLmNvbHM7IGsrKykge1xuICAgICAgICAgIHN1bSArPSB0aGlzLmRhdGFbaV1ba10gKiBvdGhlci5kYXRhW2tdW2pdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgc3VtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYWRkKG90aGVyOiBNYXRyaXgpOiBNYXRyaXgge1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG90aGVyLnJvd3MgfHwgdGhpcy5jb2xzICE9PSBvdGhlci5jb2xzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXRyaXggZGltZW5zaW9ucyBtdXN0IG1hdGNoIGZvciBhZGRpdGlvblwiKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KHRoaXMucm93cywgdGhpcy5jb2xzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2xzOyBqKyspIHtcbiAgICAgICAgcmVzdWx0LnNldChpLCBqLCB0aGlzLmdldChpLCBqKSArIG90aGVyLmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN1YnRyYWN0KG90aGVyOiBNYXRyaXgpOiBNYXRyaXgge1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG90aGVyLnJvd3MgfHwgdGhpcy5jb2xzICE9PSBvdGhlci5jb2xzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXRyaXggZGltZW5zaW9ucyBtdXN0IG1hdGNoIGZvciBzdWJ0cmFjdGlvblwiKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KHRoaXMucm93cywgdGhpcy5jb2xzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2xzOyBqKyspIHtcbiAgICAgICAgcmVzdWx0LnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAtIG90aGVyLmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHRyYW5zcG9zZSgpOiBNYXRyaXgge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgodGhpcy5jb2xzLCB0aGlzLnJvd3MpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHM7IGorKykge1xuICAgICAgICByZXN1bHQuc2V0KGosIGksIHRoaXMuZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZGV0ZXJtaW5hbnQoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5yb3dzICE9PSB0aGlzLmNvbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRldGVybWluYW50IG9ubHkgZGVmaW5lZCBmb3Igc3F1YXJlIG1hdHJpY2VzXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJvd3MgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgwLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yb3dzID09PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoMCwgMCkgKiB0aGlzLmdldCgxLCAxKSAtIHRoaXMuZ2V0KDAsIDEpICogdGhpcy5nZXQoMSwgMCk7XG4gICAgfVxuXG4gICAgbGV0IGRldCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHM7IGorKykge1xuICAgICAgY29uc3Qgc3ViTWF0cml4ID0gdGhpcy5nZXRTdWJNYXRyaXgoMCwgaik7XG4gICAgICBjb25zdCBjb2ZhY3RvciA9XG4gICAgICAgIE1hdGgucG93KC0xLCBqKSAqIHRoaXMuZ2V0KDAsIGopICogc3ViTWF0cml4LmRldGVybWluYW50KCk7XG4gICAgICBkZXQgKz0gY29mYWN0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRldDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3ViTWF0cml4KGV4Y2x1ZGVSb3c6IG51bWJlciwgZXhjbHVkZUNvbDogbnVtYmVyKTogTWF0cml4IHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KHRoaXMucm93cyAtIDEsIHRoaXMuY29scyAtIDEpO1xuXG4gICAgbGV0IHJlc3VsdFJvdyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgaWYgKGkgPT09IGV4Y2x1ZGVSb3cpIGNvbnRpbnVlO1xuXG4gICAgICBsZXQgcmVzdWx0Q29sID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2xzOyBqKyspIHtcbiAgICAgICAgaWYgKGogPT09IGV4Y2x1ZGVDb2wpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlc3VsdC5zZXQocmVzdWx0Um93LCByZXN1bHRDb2wsIHRoaXMuZ2V0KGksIGopKTtcbiAgICAgICAgcmVzdWx0Q29sKys7XG4gICAgICB9XG4gICAgICByZXN1bHRSb3crKztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdG9BcnJheSgpOiBudW1iZXJbXVtdIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1hcCgocm93KSA9PiBbLi4ucm93XSk7XG4gIH1cbn1cblxuLy8gT3B0aW1pemF0aW9uIEFsZ29yaXRobXNcbmludGVyZmFjZSBPcHRpbWl6YXRpb25SZXN1bHQge1xuICBzb2x1dGlvbjogbnVtYmVyW107XG4gIHZhbHVlOiBudW1iZXI7XG4gIGl0ZXJhdGlvbnM6IG51bWJlcjtcbiAgY29udmVyZ2VkOiBib29sZWFuO1xufVxuXG5jbGFzcyBHcmFkaWVudERlc2NlbnQge1xuICBwcml2YXRlIGxlYXJuaW5nUmF0ZTogbnVtYmVyO1xuICBwcml2YXRlIG1heEl0ZXJhdGlvbnM6IG51bWJlcjtcbiAgcHJpdmF0ZSB0b2xlcmFuY2U6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBsZWFybmluZ1JhdGU6IG51bWJlciA9IDAuMDEsXG4gICAgbWF4SXRlcmF0aW9uczogbnVtYmVyID0gMTAwMCxcbiAgICB0b2xlcmFuY2U6IG51bWJlciA9IDFlLTYsXG4gICkge1xuICAgIHRoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IG1heEl0ZXJhdGlvbnM7XG4gICAgdGhpcy50b2xlcmFuY2UgPSB0b2xlcmFuY2U7XG4gIH1cblxuICBvcHRpbWl6ZShcbiAgICBvYmplY3RpdmVGdW5jdGlvbjogKHg6IG51bWJlcltdKSA9PiBudW1iZXIsXG4gICAgZ3JhZGllbnRGdW5jdGlvbjogKHg6IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbiAgICBpbml0aWFsR3Vlc3M6IG51bWJlcltdLFxuICApOiBPcHRpbWl6YXRpb25SZXN1bHQge1xuICAgIGxldCB4ID0gWy4uLmluaXRpYWxHdWVzc107XG4gICAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gICAgbGV0IHByZXZpb3VzVmFsdWUgPSBvYmplY3RpdmVGdW5jdGlvbih4KTtcblxuICAgIGZvciAoaXRlcmF0aW9uID0gMDsgaXRlcmF0aW9uIDwgdGhpcy5tYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xuICAgICAgY29uc3QgZ3JhZGllbnQgPSBncmFkaWVudEZ1bmN0aW9uKHgpO1xuXG4gICAgICAvLyBVcGRhdGUgcGFyYW1ldGVyc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhbaV0gLT0gdGhpcy5sZWFybmluZ1JhdGUgKiBncmFkaWVudFtpXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gb2JqZWN0aXZlRnVuY3Rpb24oeCk7XG5cbiAgICAgIC8vIENoZWNrIGNvbnZlcmdlbmNlXG4gICAgICBpZiAoTWF0aC5hYnMoY3VycmVudFZhbHVlIC0gcHJldmlvdXNWYWx1ZSkgPCB0aGlzLnRvbGVyYW5jZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvbHV0aW9uOiB4LFxuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgaXRlcmF0aW9uczogaXRlcmF0aW9uICsgMSxcbiAgICAgICAgICBjb252ZXJnZWQ6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvbHV0aW9uOiB4LFxuICAgICAgdmFsdWU6IG9iamVjdGl2ZUZ1bmN0aW9uKHgpLFxuICAgICAgaXRlcmF0aW9uczogdGhpcy5tYXhJdGVyYXRpb25zLFxuICAgICAgY29udmVyZ2VkOiBmYWxzZSxcbiAgICB9O1xuICB9XG59XG5cbi8vIEdlbmV0aWMgQWxnb3JpdGhtXG5pbnRlcmZhY2UgR2VuZXRpY0FsZ29yaXRobU9wdGlvbnMge1xuICBwb3B1bGF0aW9uU2l6ZTogbnVtYmVyO1xuICBtdXRhdGlvblJhdGU6IG51bWJlcjtcbiAgY3Jvc3NvdmVyUmF0ZTogbnVtYmVyO1xuICBlbGl0ZVNpemU6IG51bWJlcjtcbiAgbWF4R2VuZXJhdGlvbnM6IG51bWJlcjtcbiAgdGFyZ2V0Rml0bmVzcz86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEluZGl2aWR1YWwge1xuICBnZW5lczogbnVtYmVyW107XG4gIGZpdG5lc3M6IG51bWJlcjtcbn1cblxuY2xhc3MgR2VuZXRpY0FsZ29yaXRobSB7XG4gIHByaXZhdGUgb3B0aW9uczogR2VuZXRpY0FsZ29yaXRobU9wdGlvbnM7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUGFydGlhbDxHZW5ldGljQWxnb3JpdGhtT3B0aW9ucz4gPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHBvcHVsYXRpb25TaXplOiAxMDAsXG4gICAgICBtdXRhdGlvblJhdGU6IDAuMDEsXG4gICAgICBjcm9zc292ZXJSYXRlOiAwLjgsXG4gICAgICBlbGl0ZVNpemU6IDEwLFxuICAgICAgbWF4R2VuZXJhdGlvbnM6IDEwMDAsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gIH1cblxuICBvcHRpbWl6ZShcbiAgICBmaXRuZXNzRnVuY3Rpb246IChnZW5lczogbnVtYmVyW10pID0+IG51bWJlcixcbiAgICBnZW5lTGVuZ3RoOiBudW1iZXIsXG4gICAgZ2VuZVJhbmdlOiBbbnVtYmVyLCBudW1iZXJdID0gWzAsIDFdLFxuICApOiBPcHRpbWl6YXRpb25SZXN1bHQge1xuICAgIC8vIEluaXRpYWxpemUgcG9wdWxhdGlvblxuICAgIGxldCBwb3B1bGF0aW9uID0gdGhpcy5pbml0aWFsaXplUG9wdWxhdGlvbihnZW5lTGVuZ3RoLCBnZW5lUmFuZ2UpO1xuXG4gICAgLy8gRXZhbHVhdGUgaW5pdGlhbCBwb3B1bGF0aW9uXG4gICAgcG9wdWxhdGlvbiA9IHRoaXMuZXZhbHVhdGVQb3B1bGF0aW9uKHBvcHVsYXRpb24sIGZpdG5lc3NGdW5jdGlvbik7XG5cbiAgICBsZXQgZ2VuZXJhdGlvbiA9IDA7XG4gICAgbGV0IGJlc3RJbmRpdmlkdWFsID0gdGhpcy5nZXRCZXN0SW5kaXZpZHVhbChwb3B1bGF0aW9uKTtcblxuICAgIGZvciAoXG4gICAgICBnZW5lcmF0aW9uID0gMDtcbiAgICAgIGdlbmVyYXRpb24gPCB0aGlzLm9wdGlvbnMubWF4R2VuZXJhdGlvbnM7XG4gICAgICBnZW5lcmF0aW9uKytcbiAgICApIHtcbiAgICAgIC8vIFNlbGVjdGlvblxuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXMuc2VsZWN0aW9uKHBvcHVsYXRpb24pO1xuXG4gICAgICAvLyBDcm9zc292ZXJcbiAgICAgIGxldCBvZmZzcHJpbmcgPSB0aGlzLmNyb3Nzb3ZlcihwYXJlbnRzKTtcblxuICAgICAgLy8gTXV0YXRpb25cbiAgICAgIG9mZnNwcmluZyA9IHRoaXMubXV0YXRlKG9mZnNwcmluZywgZ2VuZVJhbmdlKTtcblxuICAgICAgLy8gRXZhbHVhdGUgb2Zmc3ByaW5nXG4gICAgICBvZmZzcHJpbmcgPSB0aGlzLmV2YWx1YXRlUG9wdWxhdGlvbihvZmZzcHJpbmcsIGZpdG5lc3NGdW5jdGlvbik7XG5cbiAgICAgIC8vIFJlcGxhY2VtZW50XG4gICAgICBwb3B1bGF0aW9uID0gdGhpcy5yZXBsYWNlbWVudChwb3B1bGF0aW9uLCBvZmZzcHJpbmcpO1xuXG4gICAgICAvLyBVcGRhdGUgYmVzdCBpbmRpdmlkdWFsXG4gICAgICBjb25zdCBjdXJyZW50QmVzdCA9IHRoaXMuZ2V0QmVzdEluZGl2aWR1YWwocG9wdWxhdGlvbik7XG4gICAgICBpZiAoY3VycmVudEJlc3QuZml0bmVzcyA+IGJlc3RJbmRpdmlkdWFsLmZpdG5lc3MpIHtcbiAgICAgICAgYmVzdEluZGl2aWR1YWwgPSBjdXJyZW50QmVzdDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdGVybWluYXRpb24gY29uZGl0aW9uXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMub3B0aW9ucy50YXJnZXRGaXRuZXNzICYmXG4gICAgICAgIGJlc3RJbmRpdmlkdWFsLmZpdG5lc3MgPj0gdGhpcy5vcHRpb25zLnRhcmdldEZpdG5lc3NcbiAgICAgICkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvbHV0aW9uOiBiZXN0SW5kaXZpZHVhbC5nZW5lcyxcbiAgICAgICAgICB2YWx1ZTogYmVzdEluZGl2aWR1YWwuZml0bmVzcyxcbiAgICAgICAgICBpdGVyYXRpb25zOiBnZW5lcmF0aW9uICsgMSxcbiAgICAgICAgICBjb252ZXJnZWQ6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvbHV0aW9uOiBiZXN0SW5kaXZpZHVhbC5nZW5lcyxcbiAgICAgIHZhbHVlOiBiZXN0SW5kaXZpZHVhbC5maXRuZXNzLFxuICAgICAgaXRlcmF0aW9uczogdGhpcy5vcHRpb25zLm1heEdlbmVyYXRpb25zLFxuICAgICAgY29udmVyZ2VkOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplUG9wdWxhdGlvbihcbiAgICBnZW5lTGVuZ3RoOiBudW1iZXIsXG4gICAgZ2VuZVJhbmdlOiBbbnVtYmVyLCBudW1iZXJdLFxuICApOiBJbmRpdmlkdWFsW10ge1xuICAgIGNvbnN0IHBvcHVsYXRpb246IEluZGl2aWR1YWxbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMucG9wdWxhdGlvblNpemU7IGkrKykge1xuICAgICAgY29uc3QgZ2VuZXM6IG51bWJlcltdID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdlbmVMZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9XG4gICAgICAgICAgTWF0aC5yYW5kb20oKSAqIChnZW5lUmFuZ2VbMV0gLSBnZW5lUmFuZ2VbMF0pICsgZ2VuZVJhbmdlWzBdO1xuICAgICAgICBnZW5lcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHBvcHVsYXRpb24ucHVzaCh7IGdlbmVzLCBmaXRuZXNzOiAwIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwb3B1bGF0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBldmFsdWF0ZVBvcHVsYXRpb24oXG4gICAgcG9wdWxhdGlvbjogSW5kaXZpZHVhbFtdLFxuICAgIGZpdG5lc3NGdW5jdGlvbjogKGdlbmVzOiBudW1iZXJbXSkgPT4gbnVtYmVyLFxuICApOiBJbmRpdmlkdWFsW10ge1xuICAgIHJldHVybiBwb3B1bGF0aW9uLm1hcCgoaW5kaXZpZHVhbCkgPT4gKHtcbiAgICAgIC4uLmluZGl2aWR1YWwsXG4gICAgICBmaXRuZXNzOiBmaXRuZXNzRnVuY3Rpb24oaW5kaXZpZHVhbC5nZW5lcyksXG4gICAgfSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZWxlY3Rpb24ocG9wdWxhdGlvbjogSW5kaXZpZHVhbFtdKTogSW5kaXZpZHVhbFtdIHtcbiAgICAvLyBUb3VybmFtZW50IHNlbGVjdGlvblxuICAgIGNvbnN0IHBhcmVudHM6IEluZGl2aWR1YWxbXSA9IFtdO1xuICAgIGNvbnN0IHRvdXJuYW1lbnRTaXplID0gTWF0aC5tYXgoXG4gICAgICAyLFxuICAgICAgTWF0aC5mbG9vcih0aGlzLm9wdGlvbnMucG9wdWxhdGlvblNpemUgKiAwLjEpLFxuICAgICk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5wb3B1bGF0aW9uU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCB0b3VybmFtZW50OiBJbmRpdmlkdWFsW10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b3VybmFtZW50U2l6ZTsgaisrKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9wdWxhdGlvbi5sZW5ndGgpO1xuICAgICAgICB0b3VybmFtZW50LnB1c2gocG9wdWxhdGlvbltyYW5kb21JbmRleF0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3aW5uZXIgPSB0b3VybmFtZW50LnJlZHVjZSgoYmVzdCwgY3VycmVudCkgPT5cbiAgICAgICAgY3VycmVudC5maXRuZXNzID4gYmVzdC5maXRuZXNzID8gY3VycmVudCA6IGJlc3QsXG4gICAgICApO1xuXG4gICAgICBwYXJlbnRzLnB1c2goeyAuLi53aW5uZXIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cblxuICBwcml2YXRlIGNyb3Nzb3ZlcihwYXJlbnRzOiBJbmRpdmlkdWFsW10pOiBJbmRpdmlkdWFsW10ge1xuICAgIGNvbnN0IG9mZnNwcmluZzogSW5kaXZpZHVhbFtdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHBhcmVudDEgPSBwYXJlbnRzW2ldO1xuICAgICAgY29uc3QgcGFyZW50MiA9IHBhcmVudHNbaSArIDFdIHx8IHBhcmVudHNbMF07XG5cbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgdGhpcy5vcHRpb25zLmNyb3Nzb3ZlclJhdGUpIHtcbiAgICAgICAgY29uc3QgY3Jvc3NvdmVyUG9pbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYXJlbnQxLmdlbmVzLmxlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgY2hpbGQxR2VuZXMgPSBbXG4gICAgICAgICAgLi4ucGFyZW50MS5nZW5lcy5zbGljZSgwLCBjcm9zc292ZXJQb2ludCksXG4gICAgICAgICAgLi4ucGFyZW50Mi5nZW5lcy5zbGljZShjcm9zc292ZXJQb2ludCksXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hpbGQyR2VuZXMgPSBbXG4gICAgICAgICAgLi4ucGFyZW50Mi5nZW5lcy5zbGljZSgwLCBjcm9zc292ZXJQb2ludCksXG4gICAgICAgICAgLi4ucGFyZW50MS5nZW5lcy5zbGljZShjcm9zc292ZXJQb2ludCksXG4gICAgICAgIF07XG5cbiAgICAgICAgb2Zmc3ByaW5nLnB1c2goeyBnZW5lczogY2hpbGQxR2VuZXMsIGZpdG5lc3M6IDAgfSk7XG4gICAgICAgIG9mZnNwcmluZy5wdXNoKHsgZ2VuZXM6IGNoaWxkMkdlbmVzLCBmaXRuZXNzOiAwIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc3ByaW5nLnB1c2goeyAuLi5wYXJlbnQxIH0pO1xuICAgICAgICBvZmZzcHJpbmcucHVzaCh7IC4uLnBhcmVudDIgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNwcmluZy5zbGljZSgwLCB0aGlzLm9wdGlvbnMucG9wdWxhdGlvblNpemUpO1xuICB9XG5cbiAgcHJpdmF0ZSBtdXRhdGUoXG4gICAgcG9wdWxhdGlvbjogSW5kaXZpZHVhbFtdLFxuICAgIGdlbmVSYW5nZTogW251bWJlciwgbnVtYmVyXSxcbiAgKTogSW5kaXZpZHVhbFtdIHtcbiAgICByZXR1cm4gcG9wdWxhdGlvbi5tYXAoKGluZGl2aWR1YWwpID0+IHtcbiAgICAgIGNvbnN0IG11dGF0ZWRHZW5lcyA9IGluZGl2aWR1YWwuZ2VuZXMubWFwKChnZW5lKSA9PiB7XG4gICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgdGhpcy5vcHRpb25zLm11dGF0aW9uUmF0ZSkge1xuICAgICAgICAgIGNvbnN0IG11dGF0aW9uU3RyZW5ndGggPSAwLjE7XG4gICAgICAgICAgY29uc3QgbXV0YXRpb24gPVxuICAgICAgICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICpcbiAgICAgICAgICAgIDIgKlxuICAgICAgICAgICAgbXV0YXRpb25TdHJlbmd0aCAqXG4gICAgICAgICAgICAoZ2VuZVJhbmdlWzFdIC0gZ2VuZVJhbmdlWzBdKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgICAgICBnZW5lUmFuZ2VbMF0sXG4gICAgICAgICAgICBNYXRoLm1pbihnZW5lUmFuZ2VbMV0sIGdlbmUgKyBtdXRhdGlvbiksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4geyBnZW5lczogbXV0YXRlZEdlbmVzLCBmaXRuZXNzOiBpbmRpdmlkdWFsLmZpdG5lc3MgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVwbGFjZW1lbnQoXG4gICAgb2xkUG9wdWxhdGlvbjogSW5kaXZpZHVhbFtdLFxuICAgIG9mZnNwcmluZzogSW5kaXZpZHVhbFtdLFxuICApOiBJbmRpdmlkdWFsW10ge1xuICAgIC8vIEVsaXRpc20gKyByZXBsYWNlIHdvcnN0XG4gICAgY29uc3QgY29tYmluZWQgPSBbLi4ub2xkUG9wdWxhdGlvbiwgLi4ub2Zmc3ByaW5nXTtcbiAgICBjb21iaW5lZC5zb3J0KChhLCBiKSA9PiBiLmZpdG5lc3MgLSBhLmZpdG5lc3MpO1xuXG4gICAgcmV0dXJuIGNvbWJpbmVkLnNsaWNlKDAsIHRoaXMub3B0aW9ucy5wb3B1bGF0aW9uU2l6ZSk7XG4gIH1cblxuICBwcml2YXRlIGdldEJlc3RJbmRpdmlkdWFsKHBvcHVsYXRpb246IEluZGl2aWR1YWxbXSk6IEluZGl2aWR1YWwge1xuICAgIHJldHVybiBwb3B1bGF0aW9uLnJlZHVjZSgoYmVzdCwgY3VycmVudCkgPT5cbiAgICAgIGN1cnJlbnQuZml0bmVzcyA+IGJlc3QuZml0bmVzcyA/IGN1cnJlbnQgOiBiZXN0LFxuICAgICk7XG4gIH1cbn1cblxuLy8gTWFjaGluZSBMZWFybmluZyBVdGlsaXRpZXNcbmNsYXNzIE5ldXJhbE5ldHdvcmsge1xuICBwcml2YXRlIHdlaWdodHM6IE1hdHJpeFtdO1xuICBwcml2YXRlIGJpYXNlczogTWF0cml4W107XG4gIHByaXZhdGUgbGVhcm5pbmdSYXRlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IobGF5ZXJzOiBudW1iZXJbXSwgbGVhcm5pbmdSYXRlOiBudW1iZXIgPSAwLjAxKSB7XG4gICAgdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgdGhpcy53ZWlnaHRzID0gW107XG4gICAgdGhpcy5iaWFzZXMgPSBbXTtcblxuICAgIC8vIEluaXRpYWxpemUgd2VpZ2h0cyBhbmQgYmlhc2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCB3ZWlnaHQgPSBuZXcgTWF0cml4KGxheWVyc1tpICsgMV0sIGxheWVyc1tpXSk7XG4gICAgICBjb25zdCBiaWFzID0gbmV3IE1hdHJpeChsYXllcnNbaSArIDFdLCAxKTtcblxuICAgICAgLy8gWGF2aWVyIGluaXRpYWxpemF0aW9uXG4gICAgICBjb25zdCBsaW1pdCA9IE1hdGguc3FydCg2IC8gKGxheWVyc1tpXSArIGxheWVyc1tpICsgMV0pKTtcblxuICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgd2VpZ2h0LnJvd3M7IHJvdysrKSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHdlaWdodC5jb2xzOyBjb2wrKykge1xuICAgICAgICAgIHdlaWdodC5zZXQocm93LCBjb2wsIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIgKiBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgYmlhcy5zZXQocm93LCAwLCAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyICogbGltaXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndlaWdodHMucHVzaCh3ZWlnaHQpO1xuICAgICAgdGhpcy5iaWFzZXMucHVzaChiaWFzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNpZ21vaWQoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gMSAvICgxICsgTWF0aC5leHAoLXgpKTtcbiAgfVxuXG4gIHByaXZhdGUgc2lnbW9pZERlcml2YXRpdmUoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaWdtb2lkKHgpO1xuICAgIHJldHVybiBzICogKDEgLSBzKTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlBY3RpdmF0aW9uKG1hdHJpeDogTWF0cml4KTogTWF0cml4IHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KG1hdHJpeC5yb3dzLCBtYXRyaXguY29scyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHM7IGorKykge1xuICAgICAgICByZXN1bHQuc2V0KGksIGosIHRoaXMuc2lnbW9pZChtYXRyaXguZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZvcndhcmQoaW5wdXQ6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIGxldCBjdXJyZW50ID0gTWF0cml4LmZyb21BcnJheShbaW5wdXRdKS50cmFuc3Bvc2UoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJyZW50ID0gdGhpcy53ZWlnaHRzW2ldLm11bHRpcGx5KGN1cnJlbnQpLmFkZCh0aGlzLmJpYXNlc1tpXSk7XG4gICAgICBjdXJyZW50ID0gdGhpcy5hcHBseUFjdGl2YXRpb24oY3VycmVudCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5yb3dzOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQuZ2V0KGksIDApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdHJhaW4oaW5wdXRzOiBudW1iZXJbXVtdLCBvdXRwdXRzOiBudW1iZXJbXVtdLCBlcG9jaHM6IG51bWJlcik6IG51bWJlcltdIHtcbiAgICBjb25zdCBsb3NzZXM6IG51bWJlcltdID0gW107XG5cbiAgICBmb3IgKGxldCBlcG9jaCA9IDA7IGVwb2NoIDwgZXBvY2hzOyBlcG9jaCsrKSB7XG4gICAgICBsZXQgdG90YWxMb3NzID0gMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJlZGljdGVkID0gdGhpcy5mb3J3YXJkKGlucHV0c1tpXSk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG91dHB1dHNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGxvc3MgKE1TRSlcbiAgICAgICAgbGV0IGxvc3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHByZWRpY3RlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxvc3MgKz0gTWF0aC5wb3cocHJlZGljdGVkW2pdIC0gdGFyZ2V0W2pdLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBsb3NzIC89IHByZWRpY3RlZC5sZW5ndGg7XG4gICAgICAgIHRvdGFsTG9zcyArPSBsb3NzO1xuXG4gICAgICAgIC8vIEJhY2twcm9wYWdhdGlvbiAoc2ltcGxpZmllZClcbiAgICAgICAgdGhpcy5iYWNrd2FyZChpbnB1dHNbaV0sIHRhcmdldCwgcHJlZGljdGVkKTtcbiAgICAgIH1cblxuICAgICAgbG9zc2VzLnB1c2godG90YWxMb3NzIC8gaW5wdXRzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvc3NlcztcbiAgfVxuXG4gIHByaXZhdGUgYmFja3dhcmQoXG4gICAgaW5wdXQ6IG51bWJlcltdLFxuICAgIHRhcmdldDogbnVtYmVyW10sXG4gICAgcHJlZGljdGVkOiBudW1iZXJbXSxcbiAgKTogdm9pZCB7XG4gICAgLy8gU2ltcGxpZmllZCBiYWNrcHJvcGFnYXRpb24gLSBjYWxjdWxhdGUgb3V0cHV0IGVycm9yXG4gICAgY29uc3Qgb3V0cHV0RXJyb3I6IG51bWJlcltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVkaWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dEVycm9yLnB1c2goXG4gICAgICAgICh0YXJnZXRbaV0gLSBwcmVkaWN0ZWRbaV0pICogdGhpcy5zaWdtb2lkRGVyaXZhdGl2ZShwcmVkaWN0ZWRbaV0pLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgd2VpZ2h0cyAoc2ltcGxpZmllZCAtIG9ubHkgb3V0cHV0IGxheWVyKVxuICAgIGlmICh0aGlzLndlaWdodHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGFzdFdlaWdodEluZGV4ID0gdGhpcy53ZWlnaHRzLmxlbmd0aCAtIDE7XG4gICAgICBjb25zdCBsYXN0V2VpZ2h0ID0gdGhpcy53ZWlnaHRzW2xhc3RXZWlnaHRJbmRleF07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdFdlaWdodC5yb3dzOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsYXN0V2VpZ2h0LmNvbHM7IGorKykge1xuICAgICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5sZWFybmluZ1JhdGUgKiBvdXRwdXRFcnJvcltpXSAqIGlucHV0W2pdO1xuICAgICAgICAgIGxhc3RXZWlnaHQuc2V0KGksIGosIGxhc3RXZWlnaHQuZ2V0KGksIGopICsgZGVsdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGJpYXNcbiAgICAgICAgY29uc3QgYmlhc0luZGV4ID0gdGhpcy5iaWFzZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgY3VycmVudEJpYXMgPSB0aGlzLmJpYXNlc1tiaWFzSW5kZXhdLmdldChpLCAwKTtcbiAgICAgICAgdGhpcy5iaWFzZXNbYmlhc0luZGV4XS5zZXQoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGN1cnJlbnRCaWFzICsgdGhpcy5sZWFybmluZ1JhdGUgKiBvdXRwdXRFcnJvcltpXSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gU3RhdGlzdGljYWwgRnVuY3Rpb25zXG5jbGFzcyBTdGF0aXN0aWNzIHtcbiAgc3RhdGljIG1lYW4odmFsdWVzOiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCkgLyB2YWx1ZXMubGVuZ3RoO1xuICB9XG5cbiAgc3RhdGljIG1lZGlhbih2YWx1ZXM6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG5cbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4udmFsdWVzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihzb3J0ZWQubGVuZ3RoIC8gMik7XG5cbiAgICByZXR1cm4gc29ydGVkLmxlbmd0aCAlIDIgPT09IDBcbiAgICAgID8gKHNvcnRlZFttaWQgLSAxXSArIHNvcnRlZFttaWRdKSAvIDJcbiAgICAgIDogc29ydGVkW21pZF07XG4gIH1cblxuICBzdGF0aWMgc3RhbmRhcmREZXZpYXRpb24odmFsdWVzOiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuXG4gICAgY29uc3QgbWVhbiA9IHRoaXMubWVhbih2YWx1ZXMpO1xuICAgIGNvbnN0IHZhcmlhbmNlID1cbiAgICAgIHZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIE1hdGgucG93KHZhbHVlIC0gbWVhbiwgMiksIDApIC9cbiAgICAgIHZhbHVlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgfVxuXG4gIHN0YXRpYyBjb3JyZWxhdGlvbih4OiBudW1iZXJbXSwgeTogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGggfHwgeC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbm9uLXplcm8gbGVuZ3RoXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IG1lYW5YID0gdGhpcy5tZWFuKHgpO1xuICAgIGNvbnN0IG1lYW5ZID0gdGhpcy5tZWFuKHkpO1xuXG4gICAgbGV0IG51bWVyYXRvciA9IDA7XG4gICAgbGV0IHN1bVNxdWFyZVggPSAwO1xuICAgIGxldCBzdW1TcXVhcmVZID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVsdGFYID0geFtpXSAtIG1lYW5YO1xuICAgICAgY29uc3QgZGVsdGFZID0geVtpXSAtIG1lYW5ZO1xuXG4gICAgICBudW1lcmF0b3IgKz0gZGVsdGFYICogZGVsdGFZO1xuICAgICAgc3VtU3F1YXJlWCArPSBkZWx0YVggKiBkZWx0YVg7XG4gICAgICBzdW1TcXVhcmVZICs9IGRlbHRhWSAqIGRlbHRhWTtcbiAgICB9XG5cbiAgICBjb25zdCBkZW5vbWluYXRvciA9IE1hdGguc3FydChzdW1TcXVhcmVYICogc3VtU3F1YXJlWSk7XG5cbiAgICByZXR1cm4gZGVub21pbmF0b3IgPT09IDAgPyAwIDogbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gIH1cblxuICBzdGF0aWMgbGluZWFyUmVncmVzc2lvbihcbiAgICB4OiBudW1iZXJbXSxcbiAgICB5OiBudW1iZXJbXSxcbiAgKTogeyBzbG9wZTogbnVtYmVyOyBpbnRlcmNlcHQ6IG51bWJlcjsgcjI6IG51bWJlciB9IHtcbiAgICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoIHx8IHgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIG5vbi16ZXJvIGxlbmd0aFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBuID0geC5sZW5ndGg7XG4gICAgY29uc3Qgc3VtWCA9IHgucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKTtcbiAgICBjb25zdCBzdW1ZID0geS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApO1xuICAgIGNvbnN0IHN1bVhZID0geC5yZWR1Y2UoKHN1bSwgdmFsLCBpKSA9PiBzdW0gKyB2YWwgKiB5W2ldLCAwKTtcbiAgICBjb25zdCBzdW1YWCA9IHgucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsICogdmFsLCAwKTtcbiAgICBjb25zdCBzdW1ZWSA9IHkucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsICogdmFsLCAwKTtcblxuICAgIGNvbnN0IHNsb3BlID0gKG4gKiBzdW1YWSAtIHN1bVggKiBzdW1ZKSAvIChuICogc3VtWFggLSBzdW1YICogc3VtWCk7XG4gICAgY29uc3QgaW50ZXJjZXB0ID0gKHN1bVkgLSBzbG9wZSAqIHN1bVgpIC8gbjtcblxuICAgIC8vIENhbGN1bGF0ZSBSLXNxdWFyZWRcbiAgICBjb25zdCBtZWFuWSA9IHN1bVkgLyBuO1xuICAgIGNvbnN0IHRvdGFsU3VtU3F1YXJlcyA9IHN1bVlZIC0gbiAqIG1lYW5ZICogbWVhblk7XG4gICAgY29uc3QgcmVzaWR1YWxTdW1TcXVhcmVzID0geS5yZWR1Y2UoKHN1bSwgdmFsLCBpKSA9PiB7XG4gICAgICBjb25zdCBwcmVkaWN0ZWQgPSBzbG9wZSAqIHhbaV0gKyBpbnRlcmNlcHQ7XG4gICAgICByZXR1cm4gc3VtICsgTWF0aC5wb3codmFsIC0gcHJlZGljdGVkLCAyKTtcbiAgICB9LCAwKTtcblxuICAgIGNvbnN0IHIyID0gMSAtIHJlc2lkdWFsU3VtU3F1YXJlcyAvIHRvdGFsU3VtU3F1YXJlcztcblxuICAgIHJldHVybiB7IHNsb3BlLCBpbnRlcmNlcHQsIHIyIH07XG4gIH1cbn1cblxuLy8gR3JhcGggQWxnb3JpdGhtc1xuaW50ZXJmYWNlIEdyYXBoTm9kZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGRhdGE/OiBhbnk7XG59XG5cbmludGVyZmFjZSBHcmFwaEVkZ2Uge1xuICBmcm9tOiBzdHJpbmc7XG4gIHRvOiBzdHJpbmc7XG4gIHdlaWdodD86IG51bWJlcjtcbiAgZGF0YT86IGFueTtcbn1cblxuY2xhc3MgR3JhcGgge1xuICBwcml2YXRlIG5vZGVzOiBNYXA8c3RyaW5nLCBHcmFwaE5vZGU+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGFkamFjZW5jeUxpc3Q6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBlZGdlczogTWFwPHN0cmluZywgR3JhcGhFZGdlPiA9IG5ldyBNYXAoKTtcblxuICBhZGROb2RlKG5vZGU6IEdyYXBoTm9kZSk6IHZvaWQge1xuICAgIHRoaXMubm9kZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgIGlmICghdGhpcy5hZGphY2VuY3lMaXN0Lmhhcyhub2RlLmlkKSkge1xuICAgICAgdGhpcy5hZGphY2VuY3lMaXN0LnNldChub2RlLmlkLCBbXSk7XG4gICAgfVxuICB9XG5cbiAgYWRkRWRnZShlZGdlOiBHcmFwaEVkZ2UpOiB2b2lkIHtcbiAgICBjb25zdCBlZGdlS2V5ID0gYCR7ZWRnZS5mcm9tfS0ke2VkZ2UudG99YDtcbiAgICB0aGlzLmVkZ2VzLnNldChlZGdlS2V5LCBlZGdlKTtcblxuICAgIGlmICghdGhpcy5hZGphY2VuY3lMaXN0LmhhcyhlZGdlLmZyb20pKSB7XG4gICAgICB0aGlzLmFkamFjZW5jeUxpc3Quc2V0KGVkZ2UuZnJvbSwgW10pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYWRqYWNlbmN5TGlzdC5oYXMoZWRnZS50bykpIHtcbiAgICAgIHRoaXMuYWRqYWNlbmN5TGlzdC5zZXQoZWRnZS50bywgW10pO1xuICAgIH1cblxuICAgIHRoaXMuYWRqYWNlbmN5TGlzdC5nZXQoZWRnZS5mcm9tKSEucHVzaChlZGdlLnRvKTtcbiAgfVxuXG4gIGdldE5laWdoYm9ycyhub2RlSWQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5hZGphY2VuY3lMaXN0LmdldChub2RlSWQpIHx8IFtdO1xuICB9XG5cbiAgZGlqa3N0cmEoXG4gICAgc3RhcnRJZDogc3RyaW5nLFxuICAgIGVuZElkOiBzdHJpbmcsXG4gICk6IHsgcGF0aDogc3RyaW5nW107IGRpc3RhbmNlOiBudW1iZXIgfSB8IG51bGwge1xuICAgIGNvbnN0IGRpc3RhbmNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgY29uc3QgcHJldmlvdXMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nIHwgbnVsbD4oKTtcbiAgICBjb25zdCB1bnZpc2l0ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2VzXG4gICAgZm9yIChjb25zdCBub2RlSWQgb2YgdGhpcy5ub2Rlcy5rZXlzKCkpIHtcbiAgICAgIGRpc3RhbmNlcy5zZXQobm9kZUlkLCBub2RlSWQgPT09IHN0YXJ0SWQgPyAwIDogSW5maW5pdHkpO1xuICAgICAgcHJldmlvdXMuc2V0KG5vZGVJZCwgbnVsbCk7XG4gICAgICB1bnZpc2l0ZWQuYWRkKG5vZGVJZCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHVudmlzaXRlZC5zaXplID4gMCkge1xuICAgICAgLy8gRmluZCBub2RlIHdpdGggbWluaW11bSBkaXN0YW5jZVxuICAgICAgbGV0IGN1cnJlbnROb2RlOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiB1bnZpc2l0ZWQpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZXMuZ2V0KG5vZGVJZCkhO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBub2RlSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBudWxsIHx8IG1pbkRpc3RhbmNlID09PSBJbmZpbml0eSkge1xuICAgICAgICBicmVhazsgLy8gTm8gcGF0aCBleGlzdHNcbiAgICAgIH1cblxuICAgICAgdW52aXNpdGVkLmRlbGV0ZShjdXJyZW50Tm9kZSk7XG5cbiAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gZW5kSWQpIHtcbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgcGF0aFxuICAgICAgICBjb25zdCBwYXRoOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudDogc3RyaW5nIHwgbnVsbCA9IGVuZElkO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICAgIGN1cnJlbnQgPSBwcmV2aW91cy5nZXQoY3VycmVudCkhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcGF0aCwgZGlzdGFuY2U6IGRpc3RhbmNlcy5nZXQoZW5kSWQpISB9O1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZGlzdGFuY2VzIHRvIG5laWdoYm9yc1xuICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5nZXROZWlnaGJvcnMoY3VycmVudE5vZGUpO1xuICAgICAgZm9yIChjb25zdCBuZWlnaGJvcklkIG9mIG5laWdoYm9ycykge1xuICAgICAgICBpZiAoIXVudmlzaXRlZC5oYXMobmVpZ2hib3JJZCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IGVkZ2VLZXkgPSBgJHtjdXJyZW50Tm9kZX0tJHtuZWlnaGJvcklkfWA7XG4gICAgICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmVkZ2VzLmdldChlZGdlS2V5KTtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0gZWRnZT8ud2VpZ2h0IHx8IDE7XG5cbiAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZXMuZ2V0KGN1cnJlbnROb2RlKSEgKyB3ZWlnaHQ7XG5cbiAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIDwgZGlzdGFuY2VzLmdldChuZWlnaGJvcklkKSEpIHtcbiAgICAgICAgICBkaXN0YW5jZXMuc2V0KG5laWdoYm9ySWQsIG5ld0Rpc3RhbmNlKTtcbiAgICAgICAgICBwcmV2aW91cy5zZXQobmVpZ2hib3JJZCwgY3VycmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7IC8vIE5vIHBhdGggZm91bmRcbiAgfVxuXG4gIGJmcyhzdGFydElkOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHF1ZXVlOiBzdHJpbmdbXSA9IFtzdGFydElkXTtcbiAgICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHF1ZXVlLnNoaWZ0KCkhO1xuXG4gICAgICBpZiAodmlzaXRlZC5oYXMoY3VycmVudCkpIGNvbnRpbnVlO1xuXG4gICAgICB2aXNpdGVkLmFkZChjdXJyZW50KTtcbiAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuXG4gICAgICBjb25zdCBuZWlnaGJvcnMgPSB0aGlzLmdldE5laWdoYm9ycyhjdXJyZW50KTtcbiAgICAgIGZvciAoY29uc3QgbmVpZ2hib3Igb2YgbmVpZ2hib3JzKSB7XG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMobmVpZ2hib3IpKSB7XG4gICAgICAgICAgcXVldWUucHVzaChuZWlnaGJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZGZzKHN0YXJ0SWQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgY29uc3QgZGZzUmVjdXJzaXZlID0gKG5vZGVJZDogc3RyaW5nKSA9PiB7XG4gICAgICB2aXNpdGVkLmFkZChub2RlSWQpO1xuICAgICAgcmVzdWx0LnB1c2gobm9kZUlkKTtcblxuICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5nZXROZWlnaGJvcnMobm9kZUlkKTtcbiAgICAgIGZvciAoY29uc3QgbmVpZ2hib3Igb2YgbmVpZ2hib3JzKSB7XG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMobmVpZ2hib3IpKSB7XG4gICAgICAgICAgZGZzUmVjdXJzaXZlKG5laWdoYm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkZnNSZWN1cnNpdmUoc3RhcnRJZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGRldGVjdEN5Y2xlcygpOiBib29sZWFuIHtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgcmVjU3RhY2sgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIGNvbnN0IGhhc0N5Y2xlUmVjdXJzaXZlID0gKG5vZGVJZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICB2aXNpdGVkLmFkZChub2RlSWQpO1xuICAgICAgcmVjU3RhY2suYWRkKG5vZGVJZCk7XG5cbiAgICAgIGNvbnN0IG5laWdoYm9ycyA9IHRoaXMuZ2V0TmVpZ2hib3JzKG5vZGVJZCk7XG4gICAgICBmb3IgKGNvbnN0IG5laWdoYm9yIG9mIG5laWdoYm9ycykge1xuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5laWdoYm9yKSkge1xuICAgICAgICAgIGlmIChoYXNDeWNsZVJlY3Vyc2l2ZShuZWlnaGJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNTdGFjay5oYXMobmVpZ2hib3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVjU3RhY2suZGVsZXRlKG5vZGVJZCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIHRoaXMubm9kZXMua2V5cygpKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgaWYgKGhhc0N5Y2xlUmVjdXJzaXZlKG5vZGVJZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBUZXN0c1xuZGVzY3JpYmUoXCJBZHZhbmNlZCBBbGdvcml0aG1zXCIsICgpID0+IHtcbiAgZGVzY3JpYmUoXCJNYXRyaXggT3BlcmF0aW9uc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCBjcmVhdGUgbWF0cml4IHdpdGggY29ycmVjdCBkaW1lbnNpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXgoMywgNCwgNSk7XG5cbiAgICAgIGV4cGVjdChtYXRyaXgucm93cykudG9CZSgzKTtcbiAgICAgIGV4cGVjdChtYXRyaXguY29scykudG9CZSg0KTtcbiAgICAgIGV4cGVjdChtYXRyaXguZ2V0KDAsIDApKS50b0JlKDUpO1xuICAgICAgZXhwZWN0KG1hdHJpeC5nZXQoMiwgMykpLnRvQmUoNSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBtYXRyaXggbXVsdGlwbGljYXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYSA9IE1hdHJpeC5mcm9tQXJyYXkoW1xuICAgICAgICBbMSwgMl0sXG4gICAgICAgIFszLCA0XSxcbiAgICAgIF0pO1xuICAgICAgY29uc3QgYiA9IE1hdHJpeC5mcm9tQXJyYXkoW1xuICAgICAgICBbNSwgNl0sXG4gICAgICAgIFs3LCA4XSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhLm11bHRpcGx5KGIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmdldCgwLCAwKSkudG9CZSgxOSk7IC8vIDEqNSArIDIqN1xuICAgICAgZXhwZWN0KHJlc3VsdC5nZXQoMCwgMSkpLnRvQmUoMjIpOyAvLyAxKjYgKyAyKjhcbiAgICAgIGV4cGVjdChyZXN1bHQuZ2V0KDEsIDApKS50b0JlKDQzKTsgLy8gMyo1ICsgNCo3XG4gICAgICBleHBlY3QocmVzdWx0LmdldCgxLCAxKSkudG9CZSg1MCk7IC8vIDMqNiArIDQqOFxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjYWxjdWxhdGUgZGV0ZXJtaW5hbnRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbWF0cml4MngyID0gTWF0cml4LmZyb21BcnJheShbXG4gICAgICAgIFsxLCAyXSxcbiAgICAgICAgWzMsIDRdLFxuICAgICAgXSk7XG4gICAgICBleHBlY3QobWF0cml4MngyLmRldGVybWluYW50KCkpLnRvQmUoLTIpO1xuXG4gICAgICBjb25zdCBtYXRyaXgzeDMgPSBNYXRyaXguZnJvbUFycmF5KFtcbiAgICAgICAgWzEsIDIsIDNdLFxuICAgICAgICBbNCwgNSwgNl0sXG4gICAgICAgIFs3LCA4LCA5XSxcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KG1hdHJpeDN4My5kZXRlcm1pbmFudCgpKS50b0JlKDApOyAvLyBTaW5ndWxhciBtYXRyaXhcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgdHJhbnNwb3NlIG1hdHJpeFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYXRyaXggPSBNYXRyaXguZnJvbUFycmF5KFtcbiAgICAgICAgWzEsIDIsIDNdLFxuICAgICAgICBbNCwgNSwgNl0sXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IHRyYW5zcG9zZWQgPSBtYXRyaXgudHJhbnNwb3NlKCk7XG5cbiAgICAgIGV4cGVjdCh0cmFuc3Bvc2VkLnJvd3MpLnRvQmUoMyk7XG4gICAgICBleHBlY3QodHJhbnNwb3NlZC5jb2xzKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHRyYW5zcG9zZWQuZ2V0KDAsIDApKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHRyYW5zcG9zZWQuZ2V0KDEsIDApKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHRyYW5zcG9zZWQuZ2V0KDIsIDEpKS50b0JlKDYpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgbWF0cml4IGFkZGl0aW9uIGFuZCBzdWJ0cmFjdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBhID0gTWF0cml4LmZyb21BcnJheShbXG4gICAgICAgIFsxLCAyXSxcbiAgICAgICAgWzMsIDRdLFxuICAgICAgXSk7XG4gICAgICBjb25zdCBiID0gTWF0cml4LmZyb21BcnJheShbXG4gICAgICAgIFs1LCA2XSxcbiAgICAgICAgWzcsIDhdLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHN1bSA9IGEuYWRkKGIpO1xuICAgICAgZXhwZWN0KHN1bS5nZXQoMCwgMCkpLnRvQmUoNik7XG4gICAgICBleHBlY3Qoc3VtLmdldCgxLCAxKSkudG9CZSgxMik7XG5cbiAgICAgIGNvbnN0IGRpZmYgPSBhLnN1YnRyYWN0KGIpO1xuICAgICAgZXhwZWN0KGRpZmYuZ2V0KDAsIDApKS50b0JlKC00KTtcbiAgICAgIGV4cGVjdChkaWZmLmdldCgxLCAxKSkudG9CZSgtNCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHRocm93IGVycm9yIGZvciBpbnZhbGlkIG9wZXJhdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYSA9IG5ldyBNYXRyaXgoMiwgMyk7XG4gICAgICBjb25zdCBiID0gbmV3IE1hdHJpeCgyLCAyKTtcblxuICAgICAgZXhwZWN0KCgpID0+IGEubXVsdGlwbHkoYikpLnRvVGhyb3coXCJNYXRyaXggZGltZW5zaW9ucyBpbmNvbXBhdGlibGVcIik7XG4gICAgICBleHBlY3QoKCkgPT4gYS5hZGQoYikpLnRvVGhyb3coXCJNYXRyaXggZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpO1xuICAgICAgZXhwZWN0KCgpID0+IGEuZGV0ZXJtaW5hbnQoKSkudG9UaHJvdyhcbiAgICAgICAgXCJEZXRlcm1pbmFudCBvbmx5IGRlZmluZWQgZm9yIHNxdWFyZSBtYXRyaWNlc1wiLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJHcmFkaWVudCBEZXNjZW50XCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkIG1pbmltaXplIHF1YWRyYXRpYyBmdW5jdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBnZCA9IG5ldyBHcmFkaWVudERlc2NlbnQoMC4xLCAxMDAsIDFlLTYpO1xuXG4gICAgICAvLyBNaW5pbWl6ZSBmKHgpID0geF4yLCBncmFkaWVudCA9IDJ4XG4gICAgICBjb25zdCBvYmplY3RpdmUgPSAoeDogbnVtYmVyW10pID0+IHhbMF0gKiB4WzBdO1xuICAgICAgY29uc3QgZ3JhZGllbnQgPSAoeDogbnVtYmVyW10pID0+IFsyICogeFswXV07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdkLm9wdGltaXplKG9iamVjdGl2ZSwgZ3JhZGllbnQsIFsxMF0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmNvbnZlcmdlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChNYXRoLmFicyhyZXN1bHQuc29sdXRpb25bMF0pKS50b0JlTGVzc1RoYW4oMC4xKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUpLnRvQmVMZXNzVGhhbigwLjAxKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIG11bHRpLWRpbWVuc2lvbmFsIG9wdGltaXphdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBnZCA9IG5ldyBHcmFkaWVudERlc2NlbnQoMC4wMSwgMTAwMCwgMWUtNik7XG5cbiAgICAgIC8vIE1pbmltaXplIGYoeCx5KSA9IHheMiArIHleMlxuICAgICAgY29uc3Qgb2JqZWN0aXZlID0gKHg6IG51bWJlcltdKSA9PiB4WzBdICogeFswXSArIHhbMV0gKiB4WzFdO1xuICAgICAgY29uc3QgZ3JhZGllbnQgPSAoeDogbnVtYmVyW10pID0+IFsyICogeFswXSwgMiAqIHhbMV1dO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBnZC5vcHRpbWl6ZShvYmplY3RpdmUsIGdyYWRpZW50LCBbNSwgLTNdKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jb252ZXJnZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoTWF0aC5hYnMocmVzdWx0LnNvbHV0aW9uWzBdKSkudG9CZUxlc3NUaGFuKDAuMSk7XG4gICAgICBleHBlY3QoTWF0aC5hYnMocmVzdWx0LnNvbHV0aW9uWzFdKSkudG9CZUxlc3NUaGFuKDAuMSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHJldHVybiBub24tY29udmVyZ2VkIHJlc3VsdCBmb3IgZGlmZmljdWx0IHByb2JsZW1zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGdkID0gbmV3IEdyYWRpZW50RGVzY2VudCgwLjAwMSwgMTAsIDFlLTYpOyAvLyBUb28gZmV3IGl0ZXJhdGlvbnNcblxuICAgICAgY29uc3Qgb2JqZWN0aXZlID0gKHg6IG51bWJlcltdKSA9PiB4WzBdICogeFswXTtcbiAgICAgIGNvbnN0IGdyYWRpZW50ID0gKHg6IG51bWJlcltdKSA9PiBbMiAqIHhbMF1dO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBnZC5vcHRpbWl6ZShvYmplY3RpdmUsIGdyYWRpZW50LCBbMTAwXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY29udmVyZ2VkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuaXRlcmF0aW9ucykudG9CZSgxMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiR2VuZXRpYyBBbGdvcml0aG1cIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgb3B0aW1pemUgc2ltcGxlIGZ1bmN0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGdhID0gbmV3IEdlbmV0aWNBbGdvcml0aG0oe1xuICAgICAgICBwb3B1bGF0aW9uU2l6ZTogNTAsXG4gICAgICAgIG1heEdlbmVyYXRpb25zOiAxMDAsXG4gICAgICAgIG11dGF0aW9uUmF0ZTogMC4xLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1heGltaXplIGYoeCkgPSAtKHgtNSleMiArIDI1IChwZWFrIGF0IHg9NSlcbiAgICAgIGNvbnN0IGZpdG5lc3MgPSAoZ2VuZXM6IG51bWJlcltdKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBnZW5lc1swXSAqIDEwOyAvLyBTY2FsZSBmcm9tIFswLDFdIHRvIFswLDEwXVxuICAgICAgICByZXR1cm4gLU1hdGgucG93KHggLSA1LCAyKSArIDI1O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZ2Eub3B0aW1pemUoZml0bmVzcywgMSwgWzAsIDFdKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zb2x1dGlvbikudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgY29uc3Qgc2NhbGVkU29sdXRpb24gPSByZXN1bHQuc29sdXRpb25bMF0gKiAxMDtcbiAgICAgIGV4cGVjdChNYXRoLmFicyhzY2FsZWRTb2x1dGlvbiAtIDUpKS50b0JlTGVzc1RoYW4oMSk7XG4gICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0JlR3JlYXRlclRoYW4oMjApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgbXVsdGktZGltZW5zaW9uYWwgb3B0aW1pemF0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGdhID0gbmV3IEdlbmV0aWNBbGdvcml0aG0oe1xuICAgICAgICBwb3B1bGF0aW9uU2l6ZTogMTAwLFxuICAgICAgICBtYXhHZW5lcmF0aW9uczogNTAsXG4gICAgICAgIG11dGF0aW9uUmF0ZTogMC4wNSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNYXhpbWl6ZSBmKHgseSkgPSAtKHgtMyleMiAtICh5LTQpXjIgKyAyNVxuICAgICAgY29uc3QgZml0bmVzcyA9IChnZW5lczogbnVtYmVyW10pID0+IHtcbiAgICAgICAgY29uc3QgeCA9IGdlbmVzWzBdICogMTA7XG4gICAgICAgIGNvbnN0IHkgPSBnZW5lc1sxXSAqIDEwO1xuICAgICAgICByZXR1cm4gLU1hdGgucG93KHggLSAzLCAyKSAtIE1hdGgucG93KHkgLSA0LCAyKSArIDI1O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZ2Eub3B0aW1pemUoZml0bmVzcywgMiwgWzAsIDFdKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zb2x1dGlvbikudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5pdGVyYXRpb25zKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHRlcm1pbmF0ZSBlYXJseSB3aXRoIHRhcmdldCBmaXRuZXNzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGdhID0gbmV3IEdlbmV0aWNBbGdvcml0aG0oe1xuICAgICAgICBwb3B1bGF0aW9uU2l6ZTogNTAsXG4gICAgICAgIG1heEdlbmVyYXRpb25zOiAxMDAwLFxuICAgICAgICB0YXJnZXRGaXRuZXNzOiAyMCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmaXRuZXNzID0gKGdlbmVzOiBudW1iZXJbXSkgPT4ge1xuICAgICAgICBjb25zdCB4ID0gZ2VuZXNbMF0gKiAxMDtcbiAgICAgICAgcmV0dXJuIC1NYXRoLnBvdyh4IC0gNSwgMikgKyAyNTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdhLm9wdGltaXplKGZpdG5lc3MsIDEsIFswLCAxXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY29udmVyZ2VkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5pdGVyYXRpb25zKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDIwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJOZXVyYWwgTmV0d29ya1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCBjcmVhdGUgbmV0d29yayB3aXRoIGNvcnJlY3QgYXJjaGl0ZWN0dXJlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG5uID0gbmV3IE5ldXJhbE5ldHdvcmsoWzIsIDMsIDFdKTtcblxuICAgICAgLy8gVGVzdCB0aGF0IG5ldHdvcmsgY2FuIHByb2Nlc3MgaW5wdXRcbiAgICAgIGNvbnN0IG91dHB1dCA9IG5uLmZvcndhcmQoWzAuNSwgMC4zXSk7XG5cbiAgICAgIGV4cGVjdChvdXRwdXQpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChvdXRwdXRbMF0pLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICBleHBlY3Qob3V0cHV0WzBdKS50b0JlTGVzc1RoYW5PckVxdWFsKDEpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0cmFpbiBvbiBYT1IgcHJvYmxlbVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBubiA9IG5ldyBOZXVyYWxOZXR3b3JrKFsyLCA0LCAxXSwgMC41KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFswLCAxXSxcbiAgICAgICAgWzEsIDBdLFxuICAgICAgICBbMSwgMV0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBvdXRwdXRzID0gW1swXSwgWzFdLCBbMV0sIFswXV07XG5cbiAgICAgIGNvbnN0IGxvc3NlcyA9IG5uLnRyYWluKGlucHV0cywgb3V0cHV0cywgMTAwKTtcblxuICAgICAgZXhwZWN0KGxvc3NlcykudG9IYXZlTGVuZ3RoKDEwMCk7XG4gICAgICBleHBlY3QobG9zc2VzW2xvc3Nlcy5sZW5ndGggLSAxXSkudG9CZUxlc3NUaGFuKGxvc3Nlc1swXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGxlYXJuIHNpbXBsZSBwYXR0ZXJuXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG5uID0gbmV3IE5ldXJhbE5ldHdvcmsoWzEsIDIsIDFdLCAwLjEpO1xuXG4gICAgICAvLyBMZWFybiBmKHgpID0geFxuICAgICAgY29uc3QgaW5wdXRzID0gW1swXSwgWzAuMjVdLCBbMC41XSwgWzAuNzVdLCBbMV1dO1xuICAgICAgY29uc3Qgb3V0cHV0cyA9IFtbMF0sIFswLjI1XSwgWzAuNV0sIFswLjc1XSwgWzFdXTtcblxuICAgICAgbm4udHJhaW4oaW5wdXRzLCBvdXRwdXRzLCAyMDApO1xuXG4gICAgICBjb25zdCB0ZXN0T3V0cHV0ID0gbm4uZm9yd2FyZChbMC42XSk7XG4gICAgICBleHBlY3QoTWF0aC5hYnModGVzdE91dHB1dFswXSAtIDAuNikpLnRvQmVMZXNzVGhhbigwLjMpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlN0YXRpc3RpY3NcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgY2FsY3VsYXRlIG1lYW4gY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChTdGF0aXN0aWNzLm1lYW4oWzEsIDIsIDMsIDQsIDVdKSkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChTdGF0aXN0aWNzLm1lYW4oWzEwXSkpLnRvQmUoMTApO1xuICAgICAgZXhwZWN0KFN0YXRpc3RpY3MubWVhbihbXSkpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGNhbGN1bGF0ZSBtZWRpYW4gY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChTdGF0aXN0aWNzLm1lZGlhbihbMSwgMiwgMywgNCwgNV0pKS50b0JlKDMpO1xuICAgICAgZXhwZWN0KFN0YXRpc3RpY3MubWVkaWFuKFsxLCAyLCAzLCA0XSkpLnRvQmUoMi41KTtcbiAgICAgIGV4cGVjdChTdGF0aXN0aWNzLm1lZGlhbihbNSwgMSwgM10pKS50b0JlKDMpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjYWxjdWxhdGUgc3RhbmRhcmQgZGV2aWF0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0ZCA9IFN0YXRpc3RpY3Muc3RhbmRhcmREZXZpYXRpb24oWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTtcbiAgICAgIGV4cGVjdChNYXRoLmFicyhzdGQgLSAyKSkudG9CZUxlc3NUaGFuKDAuMSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGNhbGN1bGF0ZSBjb3JyZWxhdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB4ID0gWzEsIDIsIDMsIDQsIDVdO1xuICAgICAgY29uc3QgeSA9IFsyLCA0LCA2LCA4LCAxMF07XG5cbiAgICAgIGNvbnN0IGNvcnJlbGF0aW9uID0gU3RhdGlzdGljcy5jb3JyZWxhdGlvbih4LCB5KTtcbiAgICAgIGV4cGVjdChNYXRoLmFicyhjb3JyZWxhdGlvbiAtIDEpKS50b0JlTGVzc1RoYW4oMC4wMSk7IC8vIFBlcmZlY3QgcG9zaXRpdmUgY29ycmVsYXRpb25cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcGVyZm9ybSBsaW5lYXIgcmVncmVzc2lvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB4ID0gWzEsIDIsIDMsIDQsIDVdO1xuICAgICAgY29uc3QgeSA9IFsyLCA0LCA2LCA4LCAxMF07IC8vIHkgPSAyeFxuXG4gICAgICBjb25zdCByZWdyZXNzaW9uID0gU3RhdGlzdGljcy5saW5lYXJSZWdyZXNzaW9uKHgsIHkpO1xuXG4gICAgICBleHBlY3QoTWF0aC5hYnMocmVncmVzc2lvbi5zbG9wZSAtIDIpKS50b0JlTGVzc1RoYW4oMC4wMSk7XG4gICAgICBleHBlY3QoTWF0aC5hYnMocmVncmVzc2lvbi5pbnRlcmNlcHQpKS50b0JlTGVzc1RoYW4oMC4wMSk7XG4gICAgICBleHBlY3QocmVncmVzc2lvbi5yMikudG9CZUdyZWF0ZXJUaGFuKDAuOTkpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgZWRnZSBjYXNlc1wiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4gU3RhdGlzdGljcy5jb3JyZWxhdGlvbihbXSwgW10pKS50b1Rocm93KCk7XG4gICAgICBleHBlY3QoKCkgPT4gU3RhdGlzdGljcy5jb3JyZWxhdGlvbihbMV0sIFsxLCAyXSkpLnRvVGhyb3coKTtcbiAgICAgIGV4cGVjdCgoKSA9PiBTdGF0aXN0aWNzLmxpbmVhclJlZ3Jlc3Npb24oW10sIFtdKSkudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkdyYXBoIEFsZ29yaXRobXNcIiwgKCkgPT4ge1xuICAgIGxldCBncmFwaDogR3JhcGg7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGdyYXBoID0gbmV3IEdyYXBoKCk7XG5cbiAgICAgIC8vIENyZWF0ZSB0ZXN0IGdyYXBoXG4gICAgICBncmFwaC5hZGROb2RlKHsgaWQ6IFwiQVwiIH0pO1xuICAgICAgZ3JhcGguYWRkTm9kZSh7IGlkOiBcIkJcIiB9KTtcbiAgICAgIGdyYXBoLmFkZE5vZGUoeyBpZDogXCJDXCIgfSk7XG4gICAgICBncmFwaC5hZGROb2RlKHsgaWQ6IFwiRFwiIH0pO1xuXG4gICAgICBncmFwaC5hZGRFZGdlKHsgZnJvbTogXCJBXCIsIHRvOiBcIkJcIiwgd2VpZ2h0OiAxIH0pO1xuICAgICAgZ3JhcGguYWRkRWRnZSh7IGZyb206IFwiQVwiLCB0bzogXCJDXCIsIHdlaWdodDogNCB9KTtcbiAgICAgIGdyYXBoLmFkZEVkZ2UoeyBmcm9tOiBcIkJcIiwgdG86IFwiQ1wiLCB3ZWlnaHQ6IDIgfSk7XG4gICAgICBncmFwaC5hZGRFZGdlKHsgZnJvbTogXCJCXCIsIHRvOiBcIkRcIiwgd2VpZ2h0OiA1IH0pO1xuICAgICAgZ3JhcGguYWRkRWRnZSh7IGZyb206IFwiQ1wiLCB0bzogXCJEXCIsIHdlaWdodDogMSB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcGVyZm9ybSBicmVhZHRoLWZpcnN0IHNlYXJjaFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBncmFwaC5iZnMoXCJBXCIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJBXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiQlwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcIkNcIik7XG4gICAgICBleHBlY3QocmVzdWx0WzBdKS50b0JlKFwiQVwiKTsgLy8gU3RhcnQgbm9kZSBzaG91bGQgYmUgZmlyc3RcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcGVyZm9ybSBkZXB0aC1maXJzdCBzZWFyY2hcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ3JhcGguZGZzKFwiQVwiKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiQVwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcIkJcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJDXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXSkudG9CZShcIkFcIik7IC8vIFN0YXJ0IG5vZGUgc2hvdWxkIGJlIGZpcnN0XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGZpbmQgc2hvcnRlc3QgcGF0aCB3aXRoIERpamtzdHJhXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdyYXBoLmRpamtzdHJhKFwiQVwiLCBcIkRcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdCEucGF0aFswXSkudG9CZShcIkFcIik7XG4gICAgICBleHBlY3QocmVzdWx0IS5wYXRoW3Jlc3VsdCEucGF0aC5sZW5ndGggLSAxXSkudG9CZShcIkRcIik7XG4gICAgICBleHBlY3QocmVzdWx0IS5kaXN0YW5jZSkudG9CZSg1KTsgLy8gQSAtPiBCIC0+IEMgLT4gRCA9IDEgKyAyICsgMSA9IDQgb3IgQSAtPiBDIC0+IEQgPSA0ICsgMSA9IDVcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZGV0ZWN0IGN5Y2xlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjeWNsaWNHcmFwaCA9IG5ldyBHcmFwaCgpO1xuICAgICAgY3ljbGljR3JhcGguYWRkTm9kZSh7IGlkOiBcIlhcIiB9KTtcbiAgICAgIGN5Y2xpY0dyYXBoLmFkZE5vZGUoeyBpZDogXCJZXCIgfSk7XG4gICAgICBjeWNsaWNHcmFwaC5hZGROb2RlKHsgaWQ6IFwiWlwiIH0pO1xuXG4gICAgICBjeWNsaWNHcmFwaC5hZGRFZGdlKHsgZnJvbTogXCJYXCIsIHRvOiBcIllcIiB9KTtcbiAgICAgIGN5Y2xpY0dyYXBoLmFkZEVkZ2UoeyBmcm9tOiBcIllcIiwgdG86IFwiWlwiIH0pO1xuICAgICAgY3ljbGljR3JhcGguYWRkRWRnZSh7IGZyb206IFwiWlwiLCB0bzogXCJYXCIgfSk7IC8vIENyZWF0ZXMgY3ljbGVcblxuICAgICAgZXhwZWN0KGN5Y2xpY0dyYXBoLmRldGVjdEN5Y2xlcygpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGdyYXBoLmRldGVjdEN5Y2xlcygpKS50b0JlKGZhbHNlKTsgLy8gT3JpZ2luYWwgZ3JhcGggaXMgYWN5Y2xpY1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgZGlzY29ubmVjdGVkIG5vZGVzXCIsICgpID0+IHtcbiAgICAgIGdyYXBoLmFkZE5vZGUoeyBpZDogXCJFXCIgfSk7IC8vIElzb2xhdGVkIG5vZGVcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZ3JhcGguZGlqa3N0cmEoXCJBXCIsIFwiRVwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7IC8vIE5vIHBhdGggZXhpc3RzXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHJldHVybiBlbXB0eSBhcnJheXMgZm9yIG5vbi1leGlzdGVudCBub2Rlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBuZWlnaGJvcnMgPSBncmFwaC5nZXROZWlnaGJvcnMoXCJOb25FeGlzdGVudFwiKTtcbiAgICAgIGV4cGVjdChuZWlnaGJvcnMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIk1hdHJpeCIsImNvbnN0cnVjdG9yIiwicm93cyIsImNvbHMiLCJpbml0aWFsVmFsdWUiLCJkYXRhIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiZnJvbUFycmF5IiwiYXJyYXkiLCJtYXRyaXgiLCJsZW5ndGgiLCJyb3ciLCJnZXQiLCJjb2wiLCJFcnJvciIsInNldCIsInZhbHVlIiwibXVsdGlwbHkiLCJvdGhlciIsInJlc3VsdCIsImkiLCJqIiwic3VtIiwiayIsImFkZCIsInN1YnRyYWN0IiwidHJhbnNwb3NlIiwiZGV0ZXJtaW5hbnQiLCJkZXQiLCJzdWJNYXRyaXgiLCJnZXRTdWJNYXRyaXgiLCJjb2ZhY3RvciIsIk1hdGgiLCJwb3ciLCJleGNsdWRlUm93IiwiZXhjbHVkZUNvbCIsInJlc3VsdFJvdyIsInJlc3VsdENvbCIsInRvQXJyYXkiLCJHcmFkaWVudERlc2NlbnQiLCJsZWFybmluZ1JhdGUiLCJtYXhJdGVyYXRpb25zIiwidG9sZXJhbmNlIiwib3B0aW1pemUiLCJvYmplY3RpdmVGdW5jdGlvbiIsImdyYWRpZW50RnVuY3Rpb24iLCJpbml0aWFsR3Vlc3MiLCJ4IiwiaXRlcmF0aW9uIiwicHJldmlvdXNWYWx1ZSIsImdyYWRpZW50IiwiY3VycmVudFZhbHVlIiwiYWJzIiwic29sdXRpb24iLCJpdGVyYXRpb25zIiwiY29udmVyZ2VkIiwiR2VuZXRpY0FsZ29yaXRobSIsIm9wdGlvbnMiLCJwb3B1bGF0aW9uU2l6ZSIsIm11dGF0aW9uUmF0ZSIsImNyb3Nzb3ZlclJhdGUiLCJlbGl0ZVNpemUiLCJtYXhHZW5lcmF0aW9ucyIsImZpdG5lc3NGdW5jdGlvbiIsImdlbmVMZW5ndGgiLCJnZW5lUmFuZ2UiLCJwb3B1bGF0aW9uIiwiaW5pdGlhbGl6ZVBvcHVsYXRpb24iLCJldmFsdWF0ZVBvcHVsYXRpb24iLCJnZW5lcmF0aW9uIiwiYmVzdEluZGl2aWR1YWwiLCJnZXRCZXN0SW5kaXZpZHVhbCIsInBhcmVudHMiLCJzZWxlY3Rpb24iLCJvZmZzcHJpbmciLCJjcm9zc292ZXIiLCJtdXRhdGUiLCJyZXBsYWNlbWVudCIsImN1cnJlbnRCZXN0IiwiZml0bmVzcyIsInRhcmdldEZpdG5lc3MiLCJnZW5lcyIsInJhbmRvbSIsInB1c2giLCJpbmRpdmlkdWFsIiwidG91cm5hbWVudFNpemUiLCJtYXgiLCJmbG9vciIsInRvdXJuYW1lbnQiLCJyYW5kb21JbmRleCIsIndpbm5lciIsInJlZHVjZSIsImJlc3QiLCJjdXJyZW50IiwicGFyZW50MSIsInBhcmVudDIiLCJjcm9zc292ZXJQb2ludCIsImNoaWxkMUdlbmVzIiwic2xpY2UiLCJjaGlsZDJHZW5lcyIsIm11dGF0ZWRHZW5lcyIsImdlbmUiLCJtdXRhdGlvblN0cmVuZ3RoIiwibXV0YXRpb24iLCJtaW4iLCJvbGRQb3B1bGF0aW9uIiwiY29tYmluZWQiLCJzb3J0IiwiYSIsImIiLCJOZXVyYWxOZXR3b3JrIiwibGF5ZXJzIiwid2VpZ2h0cyIsImJpYXNlcyIsIndlaWdodCIsImJpYXMiLCJsaW1pdCIsInNxcnQiLCJzaWdtb2lkIiwiZXhwIiwic2lnbW9pZERlcml2YXRpdmUiLCJzIiwiYXBwbHlBY3RpdmF0aW9uIiwiZm9yd2FyZCIsImlucHV0IiwidHJhaW4iLCJpbnB1dHMiLCJvdXRwdXRzIiwiZXBvY2hzIiwibG9zc2VzIiwiZXBvY2giLCJ0b3RhbExvc3MiLCJwcmVkaWN0ZWQiLCJ0YXJnZXQiLCJsb3NzIiwiYmFja3dhcmQiLCJvdXRwdXRFcnJvciIsImxhc3RXZWlnaHRJbmRleCIsImxhc3RXZWlnaHQiLCJkZWx0YSIsImJpYXNJbmRleCIsImN1cnJlbnRCaWFzIiwiU3RhdGlzdGljcyIsIm1lYW4iLCJ2YWx1ZXMiLCJtZWRpYW4iLCJzb3J0ZWQiLCJtaWQiLCJzdGFuZGFyZERldmlhdGlvbiIsInZhcmlhbmNlIiwiY29ycmVsYXRpb24iLCJ5IiwibWVhblgiLCJtZWFuWSIsIm51bWVyYXRvciIsInN1bVNxdWFyZVgiLCJzdW1TcXVhcmVZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZGVub21pbmF0b3IiLCJsaW5lYXJSZWdyZXNzaW9uIiwibiIsInN1bVgiLCJ2YWwiLCJzdW1ZIiwic3VtWFkiLCJzdW1YWCIsInN1bVlZIiwic2xvcGUiLCJpbnRlcmNlcHQiLCJ0b3RhbFN1bVNxdWFyZXMiLCJyZXNpZHVhbFN1bVNxdWFyZXMiLCJyMiIsIkdyYXBoIiwiYWRkTm9kZSIsIm5vZGUiLCJub2RlcyIsImlkIiwiYWRqYWNlbmN5TGlzdCIsImhhcyIsImFkZEVkZ2UiLCJlZGdlIiwiZWRnZUtleSIsImZyb20iLCJ0byIsImVkZ2VzIiwiZ2V0TmVpZ2hib3JzIiwibm9kZUlkIiwiZGlqa3N0cmEiLCJzdGFydElkIiwiZW5kSWQiLCJkaXN0YW5jZXMiLCJNYXAiLCJwcmV2aW91cyIsInVudmlzaXRlZCIsIlNldCIsImtleXMiLCJJbmZpbml0eSIsInNpemUiLCJjdXJyZW50Tm9kZSIsIm1pbkRpc3RhbmNlIiwiZGlzdGFuY2UiLCJkZWxldGUiLCJwYXRoIiwidW5zaGlmdCIsIm5laWdoYm9ycyIsIm5laWdoYm9ySWQiLCJuZXdEaXN0YW5jZSIsImJmcyIsInZpc2l0ZWQiLCJxdWV1ZSIsInNoaWZ0IiwibmVpZ2hib3IiLCJkZnMiLCJkZnNSZWN1cnNpdmUiLCJkZXRlY3RDeWNsZXMiLCJyZWNTdGFjayIsImhhc0N5Y2xlUmVjdXJzaXZlIiwiZGVzY3JpYmUiLCJ0ZXN0IiwiZXhwZWN0IiwidG9CZSIsIm1hdHJpeDJ4MiIsIm1hdHJpeDN4MyIsInRyYW5zcG9zZWQiLCJkaWZmIiwidG9UaHJvdyIsImdkIiwib2JqZWN0aXZlIiwidG9CZUxlc3NUaGFuIiwiZ2EiLCJ0b0hhdmVMZW5ndGgiLCJzY2FsZWRTb2x1dGlvbiIsInRvQmVHcmVhdGVyVGhhbiIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJubiIsIm91dHB1dCIsInRvQmVMZXNzVGhhbk9yRXF1YWwiLCJ0ZXN0T3V0cHV0Iiwic3RkIiwicmVncmVzc2lvbiIsImdyYXBoIiwiYmVmb3JlRWFjaCIsInRvQ29udGFpbiIsIm5vdCIsInRvQmVOdWxsIiwiY3ljbGljR3JhcGgiLCJ0b0VxdWFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7OztBQUlELDRCQUE0QjtBQUM1QixNQUFNQTtJQUtKQyxZQUFZQyxJQUFZLEVBQUVDLElBQVksRUFBRUMsZUFBdUIsQ0FBQyxDQUFFO1FBQ2hFLElBQUksQ0FBQ0YsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0UsSUFBSSxHQUFHQyxNQUFNSixNQUNmSyxJQUFJLENBQUMsTUFDTEMsR0FBRyxDQUFDLElBQU1GLE1BQU1ILE1BQU1JLElBQUksQ0FBQ0g7SUFDaEM7SUFFQSxPQUFPSyxVQUFVQyxLQUFpQixFQUFVO1FBQzFDLE1BQU1DLFNBQVMsSUFBSVgsT0FBT1UsTUFBTUUsTUFBTSxFQUFFRixLQUFLLENBQUMsRUFBRSxFQUFFRSxVQUFVO1FBQzVERCxPQUFPTixJQUFJLEdBQUdLLE1BQU1GLEdBQUcsQ0FBQyxDQUFDSyxNQUFRO21CQUFJQTthQUFJO1FBQ3pDLE9BQU9GO0lBQ1Q7SUFFQUcsSUFBSUQsR0FBVyxFQUFFRSxHQUFXLEVBQVU7UUFDcEMsSUFBSUYsTUFBTSxLQUFLQSxPQUFPLElBQUksQ0FBQ1gsSUFBSSxJQUFJYSxNQUFNLEtBQUtBLE9BQU8sSUFBSSxDQUFD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