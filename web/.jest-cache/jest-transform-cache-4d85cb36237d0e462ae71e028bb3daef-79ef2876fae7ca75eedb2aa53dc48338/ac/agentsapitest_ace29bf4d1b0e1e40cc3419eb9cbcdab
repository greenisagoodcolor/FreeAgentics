ed07ee65fed252654eeccfcb363bc924
/**
 * Phase 1: lib/api/agents-api.ts Comprehensive Test Suite
 * Target: Complete API layer coverage with mocked HTTP calls
 * Goal: Maximize statement coverage for agents API
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _agentsapi = require("../../../lib/api/agents-api");
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
describe("lib/api/agents-api.ts - Complete Coverage", ()=>{
    let api;
    beforeEach(()=>{
        api = new _agentsapi.AgentsApi();
        mockFetch.mockClear();
        jest.clearAllMocks();
        // Clear console spies
        jest.spyOn(console, "error").mockImplementation(()=>{});
    });
    afterEach(()=>{
        jest.restoreAllMocks();
    });
    describe("AgentsApi class initialization", ()=>{
        test("creates instance with default baseUrl", ()=>{
            const defaultApi = new _agentsapi.AgentsApi();
            expect(defaultApi).toBeInstanceOf(_agentsapi.AgentsApi);
        });
        test("creates instance with custom baseUrl", ()=>{
            const customApi = new _agentsapi.AgentsApi("/custom/api/agents");
            expect(customApi).toBeInstanceOf(_agentsapi.AgentsApi);
        });
        test("singleton instance is exported", ()=>{
            expect(_agentsapi.agentsApi).toBeInstanceOf(_agentsapi.AgentsApi);
        });
    });
    describe("handleResponse method - all error paths", ()=>{
        test("handles successful response", async ()=>{
            const mockData = {
                success: true,
                agent: {
                    id: "1",
                    name: "Test"
                }
            };
            const mockResponse = {
                ok: true,
                json: jest.fn().mockResolvedValue(mockData)
            };
            // Access private method via reflection for testing
            const result = await api.handleResponse(mockResponse);
            expect(result).toEqual(mockData);
            expect(mockResponse.json).toHaveBeenCalled();
        });
        test("handles HTTP error with JSON error details", async ()=>{
            const errorData = {
                error: "Validation failed",
                details: {
                    field: "name is required"
                }
            };
            const mockResponse = {
                ok: false,
                status: 400,
                statusText: "Bad Request",
                json: jest.fn().mockResolvedValue(errorData)
            };
            const consoleSpy = jest.spyOn(console, "error").mockImplementation();
            await expect(api.handleResponse(mockResponse)).rejects.toThrow("Validation failed");
            expect(consoleSpy).toHaveBeenCalledWith("API Error Details:", {
                field: "name is required"
            });
            consoleSpy.mockRestore();
        });
        test("handles HTTP error without error message in response", async ()=>{
            const errorData = {
                someOtherField: "value"
            };
            const mockResponse = {
                ok: false,
                status: 500,
                statusText: "Internal Server Error",
                json: jest.fn().mockResolvedValue(errorData)
            };
            await expect(api.handleResponse(mockResponse)).rejects.toThrow("HTTP 500: Internal Server Error");
        });
        test("handles HTTP error with JSON parsing failure", async ()=>{
            const mockResponse = {
                ok: false,
                status: 404,
                statusText: "Not Found",
                json: jest.fn().mockRejectedValue(new Error("Invalid JSON"))
            };
            await expect(api.handleResponse(mockResponse)).rejects.toThrow("HTTP 404: Not Found");
        });
        test("handles successful response with JSON parsing failure", async ()=>{
            const mockResponse = {
                ok: true,
                json: jest.fn().mockRejectedValue(new Error("Invalid JSON"))
            };
            await expect(api.handleResponse(mockResponse)).rejects.toThrow("Failed to parse JSON response");
        });
    });
    describe("createAgent method - all scenarios", ()=>{
        test("creates agent successfully", async ()=>{
            const mockAgent = {
                id: "1",
                name: "Test Agent",
                status: "idle",
                capabilities: [
                    "movement"
                ],
                position: {
                    x: 0,
                    y: 0
                },
                resources: {
                    energy: 100,
                    health: 100,
                    memory_used: 0,
                    memory_capacity: 1000
                },
                tags: [
                    "test"
                ],
                metadata: {},
                created_at: "2024-01-01T00:00:00Z",
                updated_at: "2024-01-01T00:00:00Z"
            };
            const mockResponse = {
                agent: mockAgent
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue(mockResponse)
            });
            const request = {
                name: "Test Agent",
                capabilities: [
                    "movement"
                ],
                tags: [
                    "test"
                ]
            };
            const result = await api.createAgent(request);
            expect(mockFetch).toHaveBeenCalledWith("/api/rest/agents", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                credentials: "include",
                body: JSON.stringify(request)
            });
            expect(result).toEqual(mockResponse);
        });
        test("creates agent with full configuration", async ()=>{
            const activeInferenceConfig = {
                template: "explorer",
                stateLabels: [
                    "exploring",
                    "resting"
                ],
                numStates: 2,
                numObservations: 2,
                numActions: 2,
                generativeModel: {
                    A: [
                        [
                            1,
                            0
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    B: [
                        [
                            [
                                0.8,
                                0.2
                            ],
                            [
                                0.3,
                                0.7
                            ]
                        ],
                        [
                            [
                                0.7,
                                0.3
                            ],
                            [
                                0.2,
                                0.8
                            ]
                        ]
                    ],
                    C: [
                        0.6,
                        0.4
                    ],
                    D: [
                        0.5,
                        0.5
                    ]
                },
                precisionParameters: {
                    sensory: 1.0,
                    policy: 2.0,
                    state: 1.5
                }
            };
            const request = {
                name: "Complex Agent",
                personality: {
                    openness: 0.8,
                    conscientiousness: 0.7,
                    extraversion: 0.6,
                    agreeableness: 0.9,
                    neuroticism: 0.3
                },
                activeInference: activeInferenceConfig,
                capabilities: [
                    "movement",
                    "perception",
                    "planning"
                ],
                initialPosition: {
                    x: 10,
                    y: 20,
                    z: 5
                },
                tags: [
                    "complex",
                    "test"
                ],
                metadata: {
                    customField: "value"
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "2",
                        ...request
                    }
                })
            });
            const result = await api.createAgent(request);
            expect(result.agent.id).toBe("2");
        });
        test("handles fetch failure", async ()=>{
            mockFetch.mockRejectedValue(new Error("Network error"));
            const request = {
                name: "Test Agent"
            };
            await expect(api.createAgent(request)).rejects.toThrow("Failed to create agent: Network error");
        });
        test("handles API error response", async ()=>{
            mockFetch.mockResolvedValue({
                ok: false,
                status: 400,
                statusText: "Bad Request",
                json: jest.fn().mockResolvedValue({
                    error: "Invalid name"
                })
            });
            const request = {
                name: ""
            };
            await expect(api.createAgent(request)).rejects.toThrow("Failed to create agent: Invalid name");
        });
        test("handles unknown error types", async ()=>{
            mockFetch.mockRejectedValue("String error");
            const request = {
                name: "Test Agent"
            };
            await expect(api.createAgent(request)).rejects.toThrow("Failed to create agent: Unknown error");
        });
    });
    describe("createAgentFromTemplate method - all templates and paths", ()=>{
        test("creates explorer agent from template", async ()=>{
            const templateConfig = {
                template: "explorer",
                name: "Explorer Agent",
                stateLabels: [
                    "idle",
                    "exploring",
                    "returning"
                ],
                precisionParameters: {
                    sensory: 1.0,
                    policy: 2.0,
                    state: 1.5
                },
                tags: [
                    "explorer",
                    "test"
                ],
                metadata: {
                    role: "scout"
                }
            };
            const mockAgent = {
                id: "explorer-1",
                name: "Explorer Agent",
                status: "idle",
                capabilities: [
                    "movement",
                    "perception",
                    "planning",
                    "learning"
                ],
                position: {
                    x: 0,
                    y: 0
                },
                resources: {
                    energy: 100,
                    health: 100,
                    memory_used: 0,
                    memory_capacity: 1000
                },
                tags: [
                    "explorer",
                    "test"
                ],
                metadata: {
                    role: "scout",
                    templateType: "explorer",
                    mathematicallyValidated: true
                },
                created_at: "2024-01-01T00:00:00Z",
                updated_at: "2024-01-01T00:00:00Z"
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: mockAgent
                })
            });
            const result = await api.createAgentFromTemplate(templateConfig);
            expect(result.agent.capabilities).toEqual([
                "movement",
                "perception",
                "planning",
                "learning"
            ]);
            expect(result.agent.metadata?.templateType).toBe("explorer");
            expect(result.agent.metadata?.mathematicallyValidated).toBe(true);
        });
        test("creates guardian agent from template", async ()=>{
            const templateConfig = {
                template: "guardian",
                name: "Guardian Agent",
                stateLabels: [
                    "patrolling",
                    "alert",
                    "responding"
                ],
                precisionParameters: {
                    sensory: 2.0,
                    policy: 1.5,
                    state: 1.0
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "guardian-1",
                        name: "Guardian Agent"
                    }
                })
            });
            const result = await api.createAgentFromTemplate(templateConfig);
            // Verify the correct capabilities are set for guardian
            const callArgs = mockFetch.mock.calls[0][1];
            const requestBody = JSON.parse(callArgs.body);
            expect(requestBody.capabilities).toEqual([
                "perception",
                "communication",
                "planning",
                "memory"
            ]);
        });
        test("creates merchant agent from template", async ()=>{
            const templateConfig = {
                template: "merchant",
                name: "Merchant Agent",
                stateLabels: [
                    "trading",
                    "negotiating",
                    "calculating"
                ],
                precisionParameters: {
                    sensory: 1.5,
                    policy: 2.5,
                    state: 1.0
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "merchant-1",
                        name: "Merchant Agent"
                    }
                })
            });
            await api.createAgentFromTemplate(templateConfig);
            const callArgs = mockFetch.mock.calls[0][1];
            const requestBody = JSON.parse(callArgs.body);
            expect(requestBody.capabilities).toEqual([
                "communication",
                "social_interaction",
                "resource_management",
                "planning"
            ]);
        });
        test("creates scholar agent from template", async ()=>{
            const templateConfig = {
                template: "scholar",
                name: "Scholar Agent",
                stateLabels: [
                    "researching",
                    "analyzing",
                    "documenting"
                ],
                precisionParameters: {
                    sensory: 1.0,
                    policy: 1.0,
                    state: 2.0
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "scholar-1",
                        name: "Scholar Agent"
                    }
                })
            });
            await api.createAgentFromTemplate(templateConfig);
            const callArgs = mockFetch.mock.calls[0][1];
            const requestBody = JSON.parse(callArgs.body);
            expect(requestBody.capabilities).toEqual([
                "learning",
                "memory",
                "planning",
                "communication"
            ]);
        });
        test("generates correct Active Inference configuration", async ()=>{
            const templateConfig = {
                template: "explorer",
                name: "Test Agent",
                stateLabels: [
                    "state1",
                    "state2",
                    "state3"
                ],
                precisionParameters: {
                    sensory: 1.0,
                    policy: 2.0,
                    state: 1.5
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "1",
                        name: "Test Agent"
                    }
                })
            });
            await api.createAgentFromTemplate(templateConfig);
            const callArgs = mockFetch.mock.calls[0][1];
            const requestBody = JSON.parse(callArgs.body);
            const activeInference = requestBody.activeInference;
            // Verify Active Inference configuration structure
            expect(activeInference.template).toBe("explorer");
            expect(activeInference.stateLabels).toEqual([
                "state1",
                "state2",
                "state3"
            ]);
            expect(activeInference.numStates).toBe(3);
            expect(activeInference.numObservations).toBe(3);
            expect(activeInference.numActions).toBe(3); // min(3, 4)
            // Verify generative model matrices
            expect(activeInference.generativeModel.A).toHaveLength(3);
            expect(activeInference.generativeModel.A[0]).toEqual([
                1.0,
                0.0,
                0.0
            ]); // Identity matrix
            expect(activeInference.generativeModel.A[1]).toEqual([
                0.0,
                1.0,
                0.0
            ]);
            expect(activeInference.generativeModel.A[2]).toEqual([
                0.0,
                0.0,
                1.0
            ]);
            // Verify transition model tensor B
            expect(activeInference.generativeModel.B).toHaveLength(3); // numActions
            expect(activeInference.generativeModel.B[0]).toHaveLength(3); // numStates
            expect(activeInference.generativeModel.B[0][0]).toEqual([
                1 / 3,
                1 / 3,
                1 / 3
            ]); // Uniform distribution
            // Verify preferences C and initial beliefs D
            expect(activeInference.generativeModel.C).toEqual([
                1 / 3,
                1 / 3,
                1 / 3
            ]);
            expect(activeInference.generativeModel.D).toEqual([
                1 / 3,
                1 / 3,
                1 / 3
            ]);
            // Verify precision parameters
            expect(activeInference.precisionParameters).toEqual({
                sensory: 1.0,
                policy: 2.0,
                state: 1.5
            });
            // Verify mathematical constraints
            expect(activeInference.mathematicalConstraints).toEqual({
                normalizedBeliefs: true,
                stochasticMatrices: true,
                precisionBounds: true
            });
        });
        test("handles edge case with many states", async ()=>{
            const templateConfig = {
                template: "explorer",
                name: "Many States Agent",
                stateLabels: Array.from({
                    length: 10
                }, (_, i)=>`state${i}`),
                precisionParameters: {
                    sensory: 1.0,
                    policy: 2.0,
                    state: 1.5
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "1",
                        name: "Many States Agent"
                    }
                })
            });
            await api.createAgentFromTemplate(templateConfig);
            const callArgs = mockFetch.mock.calls[0][1];
            const requestBody = JSON.parse(callArgs.body);
            const activeInference = requestBody.activeInference;
            expect(activeInference.numStates).toBe(10);
            expect(activeInference.numObservations).toBe(10);
            expect(activeInference.numActions).toBe(4); // min(10, 4)
            expect(activeInference.generativeModel.B).toHaveLength(4); // Capped at 4 actions
        });
        test("handles template without custom tags/metadata", async ()=>{
            const templateConfig = {
                template: "guardian",
                name: "Basic Guardian",
                stateLabels: [
                    "alert",
                    "patrol"
                ],
                precisionParameters: {
                    sensory: 1.0,
                    policy: 1.0,
                    state: 1.0
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "1",
                        name: "Basic Guardian"
                    }
                })
            });
            await api.createAgentFromTemplate(templateConfig);
            const callArgs = mockFetch.mock.calls[0][1];
            const requestBody = JSON.parse(callArgs.body);
            expect(requestBody.tags).toEqual([
                "guardian"
            ]); // Default tag
            expect(requestBody.metadata).toEqual({
                templateType: "guardian",
                mathematicallyValidated: true
            });
        });
    });
    describe("getDefaultCapabilities method - all templates", ()=>{
        test("returns correct capabilities for each template type", ()=>{
            // Access private method for testing
            const getCapabilities = api.getDefaultCapabilities;
            expect(getCapabilities("explorer")).toEqual([
                "movement",
                "perception",
                "planning",
                "learning"
            ]);
            expect(getCapabilities("guardian")).toEqual([
                "perception",
                "communication",
                "planning",
                "memory"
            ]);
            expect(getCapabilities("merchant")).toEqual([
                "communication",
                "social_interaction",
                "resource_management",
                "planning"
            ]);
            expect(getCapabilities("scholar")).toEqual([
                "learning",
                "memory",
                "planning",
                "communication"
            ]);
        });
        test("returns default capabilities for unknown template", ()=>{
            const getCapabilities = api.getDefaultCapabilities;
            expect(getCapabilities("unknown")).toEqual([
                "movement",
                "perception",
                "communication"
            ]);
        });
    });
    describe("Type definitions and interfaces", ()=>{
        test("BeliefState interface has correct structure", ()=>{
            const beliefState = {
                beliefs: [
                    0.5,
                    0.3,
                    0.2
                ],
                entropy: 1.03,
                confidence: 0.8,
                mostLikelyState: 0,
                timestamp: Date.now()
            };
            expect(beliefState.beliefs).toHaveLength(3);
            expect(typeof beliefState.entropy).toBe("number");
            expect(typeof beliefState.confidence).toBe("number");
            expect(typeof beliefState.mostLikelyState).toBe("number");
            expect(typeof beliefState.timestamp).toBe("number");
        });
        test("Agent interface covers all status types", ()=>{
            const statuses = [
                "idle",
                "moving",
                "interacting",
                "planning",
                "executing",
                "learning",
                "error",
                "offline"
            ];
            statuses.forEach((status)=>{
                const agent = {
                    id: "1",
                    name: "Test",
                    status: status,
                    capabilities: [],
                    position: {
                        x: 0,
                        y: 0
                    },
                    resources: {
                        energy: 100,
                        health: 100,
                        memory_used: 0,
                        memory_capacity: 1000
                    },
                    tags: [],
                    metadata: {},
                    created_at: "2024-01-01T00:00:00Z",
                    updated_at: "2024-01-01T00:00:00Z"
                };
                expect(agent.status).toBe(status);
            });
        });
        test("ActiveInferenceConfig covers all template types", ()=>{
            const templates = [
                "explorer",
                "guardian",
                "merchant",
                "scholar"
            ];
            templates.forEach((template)=>{
                const config = {
                    template: template,
                    stateLabels: [
                        "state1"
                    ],
                    numStates: 1,
                    numObservations: 1,
                    numActions: 1,
                    generativeModel: {
                        A: [
                            [
                                1
                            ]
                        ],
                        B: [
                            [
                                [
                                    1
                                ]
                            ]
                        ],
                        C: [
                            1
                        ],
                        D: [
                            1
                        ]
                    },
                    precisionParameters: {
                        sensory: 1,
                        policy: 1,
                        state: 1
                    }
                };
                expect(config.template).toBe(template);
            });
        });
    });
    describe("Error handling and edge cases", ()=>{
        test("handles malformed precision parameters", async ()=>{
            const templateConfig = {
                template: "explorer",
                name: "Test Agent",
                stateLabels: [
                    "state1"
                ],
                precisionParameters: {
                    sensory: -1,
                    policy: 0,
                    state: Infinity
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "1",
                        name: "Test Agent"
                    }
                })
            });
            // Should not throw - API accepts any numeric values
            await expect(api.createAgentFromTemplate(templateConfig)).resolves.toBeDefined();
        });
        test("handles empty state labels array", async ()=>{
            const templateConfig = {
                template: "explorer",
                name: "Empty States Agent",
                stateLabels: [],
                precisionParameters: {
                    sensory: 1.0,
                    policy: 1.0,
                    state: 1.0
                }
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "1",
                        name: "Empty States Agent"
                    }
                })
            });
            await api.createAgentFromTemplate(templateConfig);
            const callArgs = mockFetch.mock.calls[0][1];
            const requestBody = JSON.parse(callArgs.body);
            const activeInference = requestBody.activeInference;
            expect(activeInference.numStates).toBe(0);
            expect(activeInference.numObservations).toBe(0);
            expect(activeInference.numActions).toBe(0);
            expect(activeInference.generativeModel.A).toEqual([]);
            expect(activeInference.generativeModel.B).toEqual([]);
            expect(activeInference.generativeModel.C).toEqual([]);
            expect(activeInference.generativeModel.D).toEqual([]);
        });
        test("handles network timeout simulation", async ()=>{
            jest.useFakeTimers();
            const request = {
                name: "Timeout Agent"
            };
            mockFetch.mockImplementation(()=>new Promise((_, reject)=>setTimeout(()=>reject(new Error("Request timeout")), 5000)));
            const createPromise = api.createAgent(request);
            jest.advanceTimersByTime(5000);
            await expect(createPromise).rejects.toThrow("Failed to create agent: Request timeout");
            jest.useRealTimers();
        });
    });
    describe("Integration scenarios", ()=>{
        test("creates multiple agents in sequence", async ()=>{
            const agents = [
                {
                    name: "Agent 1",
                    template: "explorer"
                },
                {
                    name: "Agent 2",
                    template: "guardian"
                },
                {
                    name: "Agent 3",
                    template: "merchant"
                }
            ];
            let callCount = 0;
            mockFetch.mockImplementation(()=>{
                callCount++;
                return Promise.resolve({
                    ok: true,
                    json: jest.fn().mockResolvedValue({
                        agent: {
                            id: `agent-${callCount}`,
                            name: `Agent ${callCount}`
                        }
                    })
                });
            });
            for (const agent of agents){
                const result = await api.createAgentFromTemplate({
                    template: agent.template,
                    name: agent.name,
                    stateLabels: [
                        "state1",
                        "state2"
                    ],
                    precisionParameters: {
                        sensory: 1.0,
                        policy: 1.0,
                        state: 1.0
                    }
                });
                expect(result.agent.name).toContain("Agent");
            }
            expect(mockFetch).toHaveBeenCalledTimes(3);
        });
        test("handles concurrent agent creation", async ()=>{
            mockFetch.mockResolvedValue({
                ok: true,
                json: jest.fn().mockResolvedValue({
                    agent: {
                        id: "concurrent",
                        name: "Concurrent Agent"
                    }
                })
            });
            const promises = Array.from({
                length: 5
            }, (_, i)=>api.createAgent({
                    name: `Concurrent Agent ${i}`
                }));
            const results = await Promise.all(promises);
            expect(results).toHaveLength(5);
            expect(mockFetch).toHaveBeenCalledTimes(5);
            results.forEach((result)=>{
                expect(result.agent.name).toBe("Concurrent Agent");
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2FwaS9hZ2VudHMtYXBpLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQaGFzZSAxOiBsaWIvYXBpL2FnZW50cy1hcGkudHMgQ29tcHJlaGVuc2l2ZSBUZXN0IFN1aXRlXG4gKiBUYXJnZXQ6IENvbXBsZXRlIEFQSSBsYXllciBjb3ZlcmFnZSB3aXRoIG1vY2tlZCBIVFRQIGNhbGxzXG4gKiBHb2FsOiBNYXhpbWl6ZSBzdGF0ZW1lbnQgY292ZXJhZ2UgZm9yIGFnZW50cyBBUElcbiAqL1xuXG5pbXBvcnQge1xuICBBZ2VudHNBcGksXG4gIGFnZW50c0FwaSxcbiAgQWdlbnQsXG4gIENyZWF0ZUFnZW50UmVxdWVzdCxcbiAgQWN0aXZlSW5mZXJlbmNlQ29uZmlnLFxuICBQcmVjaXNpb25QYXJhbWV0ZXJzLFxufSBmcm9tIFwiLi4vLi4vLi4vbGliL2FwaS9hZ2VudHMtYXBpXCI7XG5cbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKTtcbmdsb2JhbC5mZXRjaCA9IG1vY2tGZXRjaDtcblxuZGVzY3JpYmUoXCJsaWIvYXBpL2FnZW50cy1hcGkudHMgLSBDb21wbGV0ZSBDb3ZlcmFnZVwiLCAoKSA9PiB7XG4gIGxldCBhcGk6IEFnZW50c0FwaTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBhcGkgPSBuZXcgQWdlbnRzQXBpKCk7XG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIC8vIENsZWFyIGNvbnNvbGUgc3BpZXNcbiAgICBqZXN0LnNweU9uKGNvbnNvbGUsIFwiZXJyb3JcIikubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZShcIkFnZW50c0FwaSBjbGFzcyBpbml0aWFsaXphdGlvblwiLCAoKSA9PiB7XG4gICAgdGVzdChcImNyZWF0ZXMgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IGJhc2VVcmxcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdEFwaSA9IG5ldyBBZ2VudHNBcGkoKTtcbiAgICAgIGV4cGVjdChkZWZhdWx0QXBpKS50b0JlSW5zdGFuY2VPZihBZ2VudHNBcGkpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImNyZWF0ZXMgaW5zdGFuY2Ugd2l0aCBjdXN0b20gYmFzZVVybFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21BcGkgPSBuZXcgQWdlbnRzQXBpKFwiL2N1c3RvbS9hcGkvYWdlbnRzXCIpO1xuICAgICAgZXhwZWN0KGN1c3RvbUFwaSkudG9CZUluc3RhbmNlT2YoQWdlbnRzQXBpKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaW5nbGV0b24gaW5zdGFuY2UgaXMgZXhwb3J0ZWRcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGFnZW50c0FwaSkudG9CZUluc3RhbmNlT2YoQWdlbnRzQXBpKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJoYW5kbGVSZXNwb25zZSBtZXRob2QgLSBhbGwgZXJyb3IgcGF0aHNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJoYW5kbGVzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RhdGEgPSB7IHN1Y2Nlc3M6IHRydWUsIGFnZW50OiB7IGlkOiBcIjFcIiwgbmFtZTogXCJUZXN0XCIgfSB9O1xuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tEYXRhKSxcbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICAvLyBBY2Nlc3MgcHJpdmF0ZSBtZXRob2QgdmlhIHJlZmxlY3Rpb24gZm9yIHRlc3RpbmdcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChhcGkgYXMgYW55KS5oYW5kbGVSZXNwb25zZShtb2NrUmVzcG9uc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrRGF0YSk7XG4gICAgICBleHBlY3QobW9ja1Jlc3BvbnNlLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIEhUVFAgZXJyb3Igd2l0aCBKU09OIGVycm9yIGRldGFpbHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgICAgICBlcnJvcjogXCJWYWxpZGF0aW9uIGZhaWxlZFwiLFxuICAgICAgICBkZXRhaWxzOiB7IGZpZWxkOiBcIm5hbWUgaXMgcmVxdWlyZWRcIiB9LFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJCYWQgUmVxdWVzdFwiLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoZXJyb3JEYXRhKSxcbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCBcImVycm9yXCIpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoKGFwaSBhcyBhbnkpLmhhbmRsZVJlc3BvbnNlKG1vY2tSZXNwb25zZSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgXCJWYWxpZGF0aW9uIGZhaWxlZFwiLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIkFQSSBFcnJvciBEZXRhaWxzOlwiLCB7XG4gICAgICAgIGZpZWxkOiBcIm5hbWUgaXMgcmVxdWlyZWRcIixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBIVFRQIGVycm9yIHdpdGhvdXQgZXJyb3IgbWVzc2FnZSBpbiByZXNwb25zZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSB7IHNvbWVPdGhlckZpZWxkOiBcInZhbHVlXCIgfTtcbiAgICAgIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKGVycm9yRGF0YSksXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgYXdhaXQgZXhwZWN0KChhcGkgYXMgYW55KS5oYW5kbGVSZXNwb25zZShtb2NrUmVzcG9uc2UpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiSFRUUCA1MDA6IEludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIEhUVFAgZXJyb3Igd2l0aCBKU09OIHBhcnNpbmcgZmFpbHVyZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCIsXG4gICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoXCJJbnZhbGlkIEpTT05cIikpLFxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCgoYXBpIGFzIGFueSkuaGFuZGxlUmVzcG9uc2UobW9ja1Jlc3BvbnNlKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBcIkhUVFAgNDA0OiBOb3QgRm91bmRcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpdGggSlNPTiBwYXJzaW5nIGZhaWx1cmVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcihcIkludmFsaWQgSlNPTlwiKSksXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgYXdhaXQgZXhwZWN0KChhcGkgYXMgYW55KS5oYW5kbGVSZXNwb25zZShtb2NrUmVzcG9uc2UpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiRmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIixcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiY3JlYXRlQWdlbnQgbWV0aG9kIC0gYWxsIHNjZW5hcmlvc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcImNyZWF0ZXMgYWdlbnQgc3VjY2Vzc2Z1bGx5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBZ2VudDogQWdlbnQgPSB7XG4gICAgICAgIGlkOiBcIjFcIixcbiAgICAgICAgbmFtZTogXCJUZXN0IEFnZW50XCIsXG4gICAgICAgIHN0YXR1czogXCJpZGxlXCIsXG4gICAgICAgIGNhcGFiaWxpdGllczogW1wibW92ZW1lbnRcIl0sXG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgICAgZW5lcmd5OiAxMDAsXG4gICAgICAgICAgaGVhbHRoOiAxMDAsXG4gICAgICAgICAgbWVtb3J5X3VzZWQ6IDAsXG4gICAgICAgICAgbWVtb3J5X2NhcGFjaXR5OiAxMDAwLFxuICAgICAgICB9LFxuICAgICAgICB0YWdzOiBbXCJ0ZXN0XCJdLFxuICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIGNyZWF0ZWRfYXQ6IFwiMjAyNC0wMS0wMVQwMDowMDowMFpcIixcbiAgICAgICAgdXBkYXRlZF9hdDogXCIyMDI0LTAxLTAxVDAwOjAwOjAwWlwiLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0geyBhZ2VudDogbW9ja0FnZW50IH07XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tSZXNwb25zZSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdDogQ3JlYXRlQWdlbnRSZXF1ZXN0ID0ge1xuICAgICAgICBuYW1lOiBcIlRlc3QgQWdlbnRcIixcbiAgICAgICAgY2FwYWJpbGl0aWVzOiBbXCJtb3ZlbWVudFwiXSxcbiAgICAgICAgdGFnczogW1widGVzdFwiXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaS5jcmVhdGVBZ2VudChyZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCIvYXBpL3Jlc3QvYWdlbnRzXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tSZXNwb25zZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiY3JlYXRlcyBhZ2VudCB3aXRoIGZ1bGwgY29uZmlndXJhdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVJbmZlcmVuY2VDb25maWc6IEFjdGl2ZUluZmVyZW5jZUNvbmZpZyA9IHtcbiAgICAgICAgdGVtcGxhdGU6IFwiZXhwbG9yZXJcIixcbiAgICAgICAgc3RhdGVMYWJlbHM6IFtcImV4cGxvcmluZ1wiLCBcInJlc3RpbmdcIl0sXG4gICAgICAgIG51bVN0YXRlczogMixcbiAgICAgICAgbnVtT2JzZXJ2YXRpb25zOiAyLFxuICAgICAgICBudW1BY3Rpb25zOiAyLFxuICAgICAgICBnZW5lcmF0aXZlTW9kZWw6IHtcbiAgICAgICAgICBBOiBbXG4gICAgICAgICAgICBbMSwgMF0sXG4gICAgICAgICAgICBbMCwgMV0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBCOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIFswLjgsIDAuMl0sXG4gICAgICAgICAgICAgIFswLjMsIDAuN10sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBbMC43LCAwLjNdLFxuICAgICAgICAgICAgICBbMC4yLCAwLjhdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIEM6IFswLjYsIDAuNF0sXG4gICAgICAgICAgRDogWzAuNSwgMC41XSxcbiAgICAgICAgfSxcbiAgICAgICAgcHJlY2lzaW9uUGFyYW1ldGVyczogeyBzZW5zb3J5OiAxLjAsIHBvbGljeTogMi4wLCBzdGF0ZTogMS41IH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXF1ZXN0OiBDcmVhdGVBZ2VudFJlcXVlc3QgPSB7XG4gICAgICAgIG5hbWU6IFwiQ29tcGxleCBBZ2VudFwiLFxuICAgICAgICBwZXJzb25hbGl0eToge1xuICAgICAgICAgIG9wZW5uZXNzOiAwLjgsXG4gICAgICAgICAgY29uc2NpZW50aW91c25lc3M6IDAuNyxcbiAgICAgICAgICBleHRyYXZlcnNpb246IDAuNixcbiAgICAgICAgICBhZ3JlZWFibGVuZXNzOiAwLjksXG4gICAgICAgICAgbmV1cm90aWNpc206IDAuMyxcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZlSW5mZXJlbmNlOiBhY3RpdmVJbmZlcmVuY2VDb25maWcsXG4gICAgICAgIGNhcGFiaWxpdGllczogW1wibW92ZW1lbnRcIiwgXCJwZXJjZXB0aW9uXCIsIFwicGxhbm5pbmdcIl0sXG4gICAgICAgIGluaXRpYWxQb3NpdGlvbjogeyB4OiAxMCwgeTogMjAsIHo6IDUgfSxcbiAgICAgICAgdGFnczogW1wiY29tcGxleFwiLCBcInRlc3RcIl0sXG4gICAgICAgIG1ldGFkYXRhOiB7IGN1c3RvbUZpZWxkOiBcInZhbHVlXCIgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBhZ2VudDogeyBpZDogXCIyXCIsIC4uLnJlcXVlc3QgfSB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcGkuY3JlYXRlQWdlbnQocmVxdWVzdCk7XG4gICAgICBleHBlY3QocmVzdWx0LmFnZW50LmlkKS50b0JlKFwiMlwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGZldGNoIGZhaWx1cmVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcihcIk5ldHdvcmsgZXJyb3JcIikpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0OiBDcmVhdGVBZ2VudFJlcXVlc3QgPSB7IG5hbWU6IFwiVGVzdCBBZ2VudFwiIH07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChhcGkuY3JlYXRlQWdlbnQocmVxdWVzdCkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgXCJGYWlsZWQgdG8gY3JlYXRlIGFnZW50OiBOZXR3b3JrIGVycm9yXCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgQVBJIGVycm9yIHJlc3BvbnNlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiQmFkIFJlcXVlc3RcIixcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZXJyb3I6IFwiSW52YWxpZCBuYW1lXCIgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdDogQ3JlYXRlQWdlbnRSZXF1ZXN0ID0geyBuYW1lOiBcIlwiIH07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChhcGkuY3JlYXRlQWdlbnQocmVxdWVzdCkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgXCJGYWlsZWQgdG8gY3JlYXRlIGFnZW50OiBJbnZhbGlkIG5hbWVcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyB1bmtub3duIGVycm9yIHR5cGVzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVqZWN0ZWRWYWx1ZShcIlN0cmluZyBlcnJvclwiKTtcblxuICAgICAgY29uc3QgcmVxdWVzdDogQ3JlYXRlQWdlbnRSZXF1ZXN0ID0geyBuYW1lOiBcIlRlc3QgQWdlbnRcIiB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QoYXBpLmNyZWF0ZUFnZW50KHJlcXVlc3QpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiRmFpbGVkIHRvIGNyZWF0ZSBhZ2VudDogVW5rbm93biBlcnJvclwiLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJjcmVhdGVBZ2VudEZyb21UZW1wbGF0ZSBtZXRob2QgLSBhbGwgdGVtcGxhdGVzIGFuZCBwYXRoc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcImNyZWF0ZXMgZXhwbG9yZXIgYWdlbnQgZnJvbSB0ZW1wbGF0ZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZUNvbmZpZyA9IHtcbiAgICAgICAgdGVtcGxhdGU6IFwiZXhwbG9yZXJcIiBhcyBjb25zdCxcbiAgICAgICAgbmFtZTogXCJFeHBsb3JlciBBZ2VudFwiLFxuICAgICAgICBzdGF0ZUxhYmVsczogW1wiaWRsZVwiLCBcImV4cGxvcmluZ1wiLCBcInJldHVybmluZ1wiXSxcbiAgICAgICAgcHJlY2lzaW9uUGFyYW1ldGVyczogeyBzZW5zb3J5OiAxLjAsIHBvbGljeTogMi4wLCBzdGF0ZTogMS41IH0sXG4gICAgICAgIHRhZ3M6IFtcImV4cGxvcmVyXCIsIFwidGVzdFwiXSxcbiAgICAgICAgbWV0YWRhdGE6IHsgcm9sZTogXCJzY291dFwiIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrQWdlbnQ6IEFnZW50ID0ge1xuICAgICAgICBpZDogXCJleHBsb3Jlci0xXCIsXG4gICAgICAgIG5hbWU6IFwiRXhwbG9yZXIgQWdlbnRcIixcbiAgICAgICAgc3RhdHVzOiBcImlkbGVcIixcbiAgICAgICAgY2FwYWJpbGl0aWVzOiBbXCJtb3ZlbWVudFwiLCBcInBlcmNlcHRpb25cIiwgXCJwbGFubmluZ1wiLCBcImxlYXJuaW5nXCJdLFxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIHJlc291cmNlczoge1xuICAgICAgICAgIGVuZXJneTogMTAwLFxuICAgICAgICAgIGhlYWx0aDogMTAwLFxuICAgICAgICAgIG1lbW9yeV91c2VkOiAwLFxuICAgICAgICAgIG1lbW9yeV9jYXBhY2l0eTogMTAwMCxcbiAgICAgICAgfSxcbiAgICAgICAgdGFnczogW1wiZXhwbG9yZXJcIiwgXCJ0ZXN0XCJdLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHJvbGU6IFwic2NvdXRcIixcbiAgICAgICAgICB0ZW1wbGF0ZVR5cGU6IFwiZXhwbG9yZXJcIixcbiAgICAgICAgICBtYXRoZW1hdGljYWxseVZhbGlkYXRlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlZF9hdDogXCIyMDI0LTAxLTAxVDAwOjAwOjAwWlwiLFxuICAgICAgICB1cGRhdGVkX2F0OiBcIjIwMjQtMDEtMDFUMDA6MDA6MDBaXCIsXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgYWdlbnQ6IG1vY2tBZ2VudCB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcGkuY3JlYXRlQWdlbnRGcm9tVGVtcGxhdGUodGVtcGxhdGVDb25maWcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmFnZW50LmNhcGFiaWxpdGllcykudG9FcXVhbChbXG4gICAgICAgIFwibW92ZW1lbnRcIixcbiAgICAgICAgXCJwZXJjZXB0aW9uXCIsXG4gICAgICAgIFwicGxhbm5pbmdcIixcbiAgICAgICAgXCJsZWFybmluZ1wiLFxuICAgICAgXSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFnZW50Lm1ldGFkYXRhPy50ZW1wbGF0ZVR5cGUpLnRvQmUoXCJleHBsb3JlclwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWdlbnQubWV0YWRhdGE/Lm1hdGhlbWF0aWNhbGx5VmFsaWRhdGVkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImNyZWF0ZXMgZ3VhcmRpYW4gYWdlbnQgZnJvbSB0ZW1wbGF0ZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZUNvbmZpZyA9IHtcbiAgICAgICAgdGVtcGxhdGU6IFwiZ3VhcmRpYW5cIiBhcyBjb25zdCxcbiAgICAgICAgbmFtZTogXCJHdWFyZGlhbiBBZ2VudFwiLFxuICAgICAgICBzdGF0ZUxhYmVsczogW1wicGF0cm9sbGluZ1wiLCBcImFsZXJ0XCIsIFwicmVzcG9uZGluZ1wiXSxcbiAgICAgICAgcHJlY2lzaW9uUGFyYW1ldGVyczogeyBzZW5zb3J5OiAyLjAsIHBvbGljeTogMS41LCBzdGF0ZTogMS4wIH0sXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICBhZ2VudDogeyBpZDogXCJndWFyZGlhbi0xXCIsIG5hbWU6IFwiR3VhcmRpYW4gQWdlbnRcIiB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcGkuY3JlYXRlQWdlbnRGcm9tVGVtcGxhdGUodGVtcGxhdGVDb25maWcpO1xuXG4gICAgICAvLyBWZXJpZnkgdGhlIGNvcnJlY3QgY2FwYWJpbGl0aWVzIGFyZSBzZXQgZm9yIGd1YXJkaWFuXG4gICAgICBjb25zdCBjYWxsQXJncyA9IG1vY2tGZXRjaC5tb2NrLmNhbGxzWzBdWzFdO1xuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSBKU09OLnBhcnNlKGNhbGxBcmdzLmJvZHkpO1xuICAgICAgZXhwZWN0KHJlcXVlc3RCb2R5LmNhcGFiaWxpdGllcykudG9FcXVhbChbXG4gICAgICAgIFwicGVyY2VwdGlvblwiLFxuICAgICAgICBcImNvbW11bmljYXRpb25cIixcbiAgICAgICAgXCJwbGFubmluZ1wiLFxuICAgICAgICBcIm1lbW9yeVwiLFxuICAgICAgXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiY3JlYXRlcyBtZXJjaGFudCBhZ2VudCBmcm9tIHRlbXBsYXRlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlQ29uZmlnID0ge1xuICAgICAgICB0ZW1wbGF0ZTogXCJtZXJjaGFudFwiIGFzIGNvbnN0LFxuICAgICAgICBuYW1lOiBcIk1lcmNoYW50IEFnZW50XCIsXG4gICAgICAgIHN0YXRlTGFiZWxzOiBbXCJ0cmFkaW5nXCIsIFwibmVnb3RpYXRpbmdcIiwgXCJjYWxjdWxhdGluZ1wiXSxcbiAgICAgICAgcHJlY2lzaW9uUGFyYW1ldGVyczogeyBzZW5zb3J5OiAxLjUsIHBvbGljeTogMi41LCBzdGF0ZTogMS4wIH0sXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICBhZ2VudDogeyBpZDogXCJtZXJjaGFudC0xXCIsIG5hbWU6IFwiTWVyY2hhbnQgQWdlbnRcIiB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBhcGkuY3JlYXRlQWdlbnRGcm9tVGVtcGxhdGUodGVtcGxhdGVDb25maWcpO1xuXG4gICAgICBjb25zdCBjYWxsQXJncyA9IG1vY2tGZXRjaC5tb2NrLmNhbGxzWzBdWzFdO1xuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSBKU09OLnBhcnNlKGNhbGxBcmdzLmJvZHkpO1xuICAgICAgZXhwZWN0KHJlcXVlc3RCb2R5LmNhcGFiaWxpdGllcykudG9FcXVhbChbXG4gICAgICAgIFwiY29tbXVuaWNhdGlvblwiLFxuICAgICAgICBcInNvY2lhbF9pbnRlcmFjdGlvblwiLFxuICAgICAgICBcInJlc291cmNlX21hbmFnZW1lbnRcIixcbiAgICAgICAgXCJwbGFubmluZ1wiLFxuICAgICAgXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiY3JlYXRlcyBzY2hvbGFyIGFnZW50IGZyb20gdGVtcGxhdGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVtcGxhdGVDb25maWcgPSB7XG4gICAgICAgIHRlbXBsYXRlOiBcInNjaG9sYXJcIiBhcyBjb25zdCxcbiAgICAgICAgbmFtZTogXCJTY2hvbGFyIEFnZW50XCIsXG4gICAgICAgIHN0YXRlTGFiZWxzOiBbXCJyZXNlYXJjaGluZ1wiLCBcImFuYWx5emluZ1wiLCBcImRvY3VtZW50aW5nXCJdLFxuICAgICAgICBwcmVjaXNpb25QYXJhbWV0ZXJzOiB7IHNlbnNvcnk6IDEuMCwgcG9saWN5OiAxLjAsIHN0YXRlOiAyLjAgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgIGFnZW50OiB7IGlkOiBcInNjaG9sYXItMVwiLCBuYW1lOiBcIlNjaG9sYXIgQWdlbnRcIiB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBhcGkuY3JlYXRlQWdlbnRGcm9tVGVtcGxhdGUodGVtcGxhdGVDb25maWcpO1xuXG4gICAgICBjb25zdCBjYWxsQXJncyA9IG1vY2tGZXRjaC5tb2NrLmNhbGxzWzBdWzFdO1xuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSBKU09OLnBhcnNlKGNhbGxBcmdzLmJvZHkpO1xuICAgICAgZXhwZWN0KHJlcXVlc3RCb2R5LmNhcGFiaWxpdGllcykudG9FcXVhbChbXG4gICAgICAgIFwibGVhcm5pbmdcIixcbiAgICAgICAgXCJtZW1vcnlcIixcbiAgICAgICAgXCJwbGFubmluZ1wiLFxuICAgICAgICBcImNvbW11bmljYXRpb25cIixcbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImdlbmVyYXRlcyBjb3JyZWN0IEFjdGl2ZSBJbmZlcmVuY2UgY29uZmlndXJhdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZUNvbmZpZyA9IHtcbiAgICAgICAgdGVtcGxhdGU6IFwiZXhwbG9yZXJcIiBhcyBjb25zdCxcbiAgICAgICAgbmFtZTogXCJUZXN0IEFnZW50XCIsXG4gICAgICAgIHN0YXRlTGFiZWxzOiBbXCJzdGF0ZTFcIiwgXCJzdGF0ZTJcIiwgXCJzdGF0ZTNcIl0sXG4gICAgICAgIHByZWNpc2lvblBhcmFtZXRlcnM6IHsgc2Vuc29yeTogMS4wLCBwb2xpY3k6IDIuMCwgc3RhdGU6IDEuNSB9LFxuICAgICAgfTtcblxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3RcbiAgICAgICAgICAuZm4oKVxuICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGFnZW50OiB7IGlkOiBcIjFcIiwgbmFtZTogXCJUZXN0IEFnZW50XCIgfSB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBhcGkuY3JlYXRlQWdlbnRGcm9tVGVtcGxhdGUodGVtcGxhdGVDb25maWcpO1xuXG4gICAgICBjb25zdCBjYWxsQXJncyA9IG1vY2tGZXRjaC5tb2NrLmNhbGxzWzBdWzFdO1xuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSBKU09OLnBhcnNlKGNhbGxBcmdzLmJvZHkpO1xuICAgICAgY29uc3QgYWN0aXZlSW5mZXJlbmNlID0gcmVxdWVzdEJvZHkuYWN0aXZlSW5mZXJlbmNlO1xuXG4gICAgICAvLyBWZXJpZnkgQWN0aXZlIEluZmVyZW5jZSBjb25maWd1cmF0aW9uIHN0cnVjdHVyZVxuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS50ZW1wbGF0ZSkudG9CZShcImV4cGxvcmVyXCIpO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5zdGF0ZUxhYmVscykudG9FcXVhbChbXG4gICAgICAgIFwic3RhdGUxXCIsXG4gICAgICAgIFwic3RhdGUyXCIsXG4gICAgICAgIFwic3RhdGUzXCIsXG4gICAgICBdKTtcbiAgICAgIGV4cGVjdChhY3RpdmVJbmZlcmVuY2UubnVtU3RhdGVzKS50b0JlKDMpO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5udW1PYnNlcnZhdGlvbnMpLnRvQmUoMyk7XG4gICAgICBleHBlY3QoYWN0aXZlSW5mZXJlbmNlLm51bUFjdGlvbnMpLnRvQmUoMyk7IC8vIG1pbigzLCA0KVxuXG4gICAgICAvLyBWZXJpZnkgZ2VuZXJhdGl2ZSBtb2RlbCBtYXRyaWNlc1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5nZW5lcmF0aXZlTW9kZWwuQSkudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5nZW5lcmF0aXZlTW9kZWwuQVswXSkudG9FcXVhbChbMS4wLCAwLjAsIDAuMF0pOyAvLyBJZGVudGl0eSBtYXRyaXhcbiAgICAgIGV4cGVjdChhY3RpdmVJbmZlcmVuY2UuZ2VuZXJhdGl2ZU1vZGVsLkFbMV0pLnRvRXF1YWwoWzAuMCwgMS4wLCAwLjBdKTtcbiAgICAgIGV4cGVjdChhY3RpdmVJbmZlcmVuY2UuZ2VuZXJhdGl2ZU1vZGVsLkFbMl0pLnRvRXF1YWwoWzAuMCwgMC4wLCAxLjBdKTtcblxuICAgICAgLy8gVmVyaWZ5IHRyYW5zaXRpb24gbW9kZWwgdGVuc29yIEJcbiAgICAgIGV4cGVjdChhY3RpdmVJbmZlcmVuY2UuZ2VuZXJhdGl2ZU1vZGVsLkIpLnRvSGF2ZUxlbmd0aCgzKTsgLy8gbnVtQWN0aW9uc1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5nZW5lcmF0aXZlTW9kZWwuQlswXSkudG9IYXZlTGVuZ3RoKDMpOyAvLyBudW1TdGF0ZXNcbiAgICAgIGV4cGVjdChhY3RpdmVJbmZlcmVuY2UuZ2VuZXJhdGl2ZU1vZGVsLkJbMF1bMF0pLnRvRXF1YWwoW1xuICAgICAgICAxIC8gMyxcbiAgICAgICAgMSAvIDMsXG4gICAgICAgIDEgLyAzLFxuICAgICAgXSk7IC8vIFVuaWZvcm0gZGlzdHJpYnV0aW9uXG5cbiAgICAgIC8vIFZlcmlmeSBwcmVmZXJlbmNlcyBDIGFuZCBpbml0aWFsIGJlbGllZnMgRFxuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5nZW5lcmF0aXZlTW9kZWwuQykudG9FcXVhbChbMSAvIDMsIDEgLyAzLCAxIC8gM10pO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5nZW5lcmF0aXZlTW9kZWwuRCkudG9FcXVhbChbMSAvIDMsIDEgLyAzLCAxIC8gM10pO1xuXG4gICAgICAvLyBWZXJpZnkgcHJlY2lzaW9uIHBhcmFtZXRlcnNcbiAgICAgIGV4cGVjdChhY3RpdmVJbmZlcmVuY2UucHJlY2lzaW9uUGFyYW1ldGVycykudG9FcXVhbCh7XG4gICAgICAgIHNlbnNvcnk6IDEuMCxcbiAgICAgICAgcG9saWN5OiAyLjAsXG4gICAgICAgIHN0YXRlOiAxLjUsXG4gICAgICB9KTtcblxuICAgICAgLy8gVmVyaWZ5IG1hdGhlbWF0aWNhbCBjb25zdHJhaW50c1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5tYXRoZW1hdGljYWxDb25zdHJhaW50cykudG9FcXVhbCh7XG4gICAgICAgIG5vcm1hbGl6ZWRCZWxpZWZzOiB0cnVlLFxuICAgICAgICBzdG9jaGFzdGljTWF0cmljZXM6IHRydWUsXG4gICAgICAgIHByZWNpc2lvbkJvdW5kczogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZWRnZSBjYXNlIHdpdGggbWFueSBzdGF0ZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVtcGxhdGVDb25maWcgPSB7XG4gICAgICAgIHRlbXBsYXRlOiBcImV4cGxvcmVyXCIgYXMgY29uc3QsXG4gICAgICAgIG5hbWU6IFwiTWFueSBTdGF0ZXMgQWdlbnRcIixcbiAgICAgICAgc3RhdGVMYWJlbHM6IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwIH0sIChfLCBpKSA9PiBgc3RhdGUke2l9YCksXG4gICAgICAgIHByZWNpc2lvblBhcmFtZXRlcnM6IHsgc2Vuc29yeTogMS4wLCBwb2xpY3k6IDIuMCwgc3RhdGU6IDEuNSB9LFxuICAgICAgfTtcblxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGplc3RcbiAgICAgICAgICAuZm4oKVxuICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGFnZW50OiB7IGlkOiBcIjFcIiwgbmFtZTogXCJNYW55IFN0YXRlcyBBZ2VudFwiIH0gfSksXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgYXBpLmNyZWF0ZUFnZW50RnJvbVRlbXBsYXRlKHRlbXBsYXRlQ29uZmlnKTtcblxuICAgICAgY29uc3QgY2FsbEFyZ3MgPSBtb2NrRmV0Y2gubW9jay5jYWxsc1swXVsxXTtcbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gSlNPTi5wYXJzZShjYWxsQXJncy5ib2R5KTtcbiAgICAgIGNvbnN0IGFjdGl2ZUluZmVyZW5jZSA9IHJlcXVlc3RCb2R5LmFjdGl2ZUluZmVyZW5jZTtcblxuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5udW1TdGF0ZXMpLnRvQmUoMTApO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5udW1PYnNlcnZhdGlvbnMpLnRvQmUoMTApO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5udW1BY3Rpb25zKS50b0JlKDQpOyAvLyBtaW4oMTAsIDQpXG4gICAgICBleHBlY3QoYWN0aXZlSW5mZXJlbmNlLmdlbmVyYXRpdmVNb2RlbC5CKS50b0hhdmVMZW5ndGgoNCk7IC8vIENhcHBlZCBhdCA0IGFjdGlvbnNcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIHRlbXBsYXRlIHdpdGhvdXQgY3VzdG9tIHRhZ3MvbWV0YWRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVtcGxhdGVDb25maWcgPSB7XG4gICAgICAgIHRlbXBsYXRlOiBcImd1YXJkaWFuXCIgYXMgY29uc3QsXG4gICAgICAgIG5hbWU6IFwiQmFzaWMgR3VhcmRpYW5cIixcbiAgICAgICAgc3RhdGVMYWJlbHM6IFtcImFsZXJ0XCIsIFwicGF0cm9sXCJdLFxuICAgICAgICBwcmVjaXNpb25QYXJhbWV0ZXJzOiB7IHNlbnNvcnk6IDEuMCwgcG9saWN5OiAxLjAsIHN0YXRlOiAxLjAgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0XG4gICAgICAgICAgLmZuKClcbiAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWUoeyBhZ2VudDogeyBpZDogXCIxXCIsIG5hbWU6IFwiQmFzaWMgR3VhcmRpYW5cIiB9IH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGFwaS5jcmVhdGVBZ2VudEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZUNvbmZpZyk7XG5cbiAgICAgIGNvbnN0IGNhbGxBcmdzID0gbW9ja0ZldGNoLm1vY2suY2FsbHNbMF1bMV07XG4gICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IEpTT04ucGFyc2UoY2FsbEFyZ3MuYm9keSk7XG5cbiAgICAgIGV4cGVjdChyZXF1ZXN0Qm9keS50YWdzKS50b0VxdWFsKFtcImd1YXJkaWFuXCJdKTsgLy8gRGVmYXVsdCB0YWdcbiAgICAgIGV4cGVjdChyZXF1ZXN0Qm9keS5tZXRhZGF0YSkudG9FcXVhbCh7XG4gICAgICAgIHRlbXBsYXRlVHlwZTogXCJndWFyZGlhblwiLFxuICAgICAgICBtYXRoZW1hdGljYWxseVZhbGlkYXRlZDogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImdldERlZmF1bHRDYXBhYmlsaXRpZXMgbWV0aG9kIC0gYWxsIHRlbXBsYXRlc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInJldHVybnMgY29ycmVjdCBjYXBhYmlsaXRpZXMgZm9yIGVhY2ggdGVtcGxhdGUgdHlwZVwiLCAoKSA9PiB7XG4gICAgICAvLyBBY2Nlc3MgcHJpdmF0ZSBtZXRob2QgZm9yIHRlc3RpbmdcbiAgICAgIGNvbnN0IGdldENhcGFiaWxpdGllcyA9IChhcGkgYXMgYW55KS5nZXREZWZhdWx0Q2FwYWJpbGl0aWVzO1xuXG4gICAgICBleHBlY3QoZ2V0Q2FwYWJpbGl0aWVzKFwiZXhwbG9yZXJcIikpLnRvRXF1YWwoW1xuICAgICAgICBcIm1vdmVtZW50XCIsXG4gICAgICAgIFwicGVyY2VwdGlvblwiLFxuICAgICAgICBcInBsYW5uaW5nXCIsXG4gICAgICAgIFwibGVhcm5pbmdcIixcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KGdldENhcGFiaWxpdGllcyhcImd1YXJkaWFuXCIpKS50b0VxdWFsKFtcbiAgICAgICAgXCJwZXJjZXB0aW9uXCIsXG4gICAgICAgIFwiY29tbXVuaWNhdGlvblwiLFxuICAgICAgICBcInBsYW5uaW5nXCIsXG4gICAgICAgIFwibWVtb3J5XCIsXG4gICAgICBdKTtcbiAgICAgIGV4cGVjdChnZXRDYXBhYmlsaXRpZXMoXCJtZXJjaGFudFwiKSkudG9FcXVhbChbXG4gICAgICAgIFwiY29tbXVuaWNhdGlvblwiLFxuICAgICAgICBcInNvY2lhbF9pbnRlcmFjdGlvblwiLFxuICAgICAgICBcInJlc291cmNlX21hbmFnZW1lbnRcIixcbiAgICAgICAgXCJwbGFubmluZ1wiLFxuICAgICAgXSk7XG4gICAgICBleHBlY3QoZ2V0Q2FwYWJpbGl0aWVzKFwic2Nob2xhclwiKSkudG9FcXVhbChbXG4gICAgICAgIFwibGVhcm5pbmdcIixcbiAgICAgICAgXCJtZW1vcnlcIixcbiAgICAgICAgXCJwbGFubmluZ1wiLFxuICAgICAgICBcImNvbW11bmljYXRpb25cIixcbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJldHVybnMgZGVmYXVsdCBjYXBhYmlsaXRpZXMgZm9yIHVua25vd24gdGVtcGxhdGVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZ2V0Q2FwYWJpbGl0aWVzID0gKGFwaSBhcyBhbnkpLmdldERlZmF1bHRDYXBhYmlsaXRpZXM7XG4gICAgICBleHBlY3QoZ2V0Q2FwYWJpbGl0aWVzKFwidW5rbm93blwiIGFzIGFueSkpLnRvRXF1YWwoW1xuICAgICAgICBcIm1vdmVtZW50XCIsXG4gICAgICAgIFwicGVyY2VwdGlvblwiLFxuICAgICAgICBcImNvbW11bmljYXRpb25cIixcbiAgICAgIF0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlR5cGUgZGVmaW5pdGlvbnMgYW5kIGludGVyZmFjZXNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJCZWxpZWZTdGF0ZSBpbnRlcmZhY2UgaGFzIGNvcnJlY3Qgc3RydWN0dXJlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGJlbGllZlN0YXRlID0ge1xuICAgICAgICBiZWxpZWZzOiBbMC41LCAwLjMsIDAuMl0sXG4gICAgICAgIGVudHJvcHk6IDEuMDMsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgICAgbW9zdExpa2VseVN0YXRlOiAwLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoYmVsaWVmU3RhdGUuYmVsaWVmcykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBiZWxpZWZTdGF0ZS5lbnRyb3B5KS50b0JlKFwibnVtYmVyXCIpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBiZWxpZWZTdGF0ZS5jb25maWRlbmNlKS50b0JlKFwibnVtYmVyXCIpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBiZWxpZWZTdGF0ZS5tb3N0TGlrZWx5U3RhdGUpLnRvQmUoXCJudW1iZXJcIik7XG4gICAgICBleHBlY3QodHlwZW9mIGJlbGllZlN0YXRlLnRpbWVzdGFtcCkudG9CZShcIm51bWJlclwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJBZ2VudCBpbnRlcmZhY2UgY292ZXJzIGFsbCBzdGF0dXMgdHlwZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHVzZXMgPSBbXG4gICAgICAgIFwiaWRsZVwiLFxuICAgICAgICBcIm1vdmluZ1wiLFxuICAgICAgICBcImludGVyYWN0aW5nXCIsXG4gICAgICAgIFwicGxhbm5pbmdcIixcbiAgICAgICAgXCJleGVjdXRpbmdcIixcbiAgICAgICAgXCJsZWFybmluZ1wiLFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIFwib2ZmbGluZVwiLFxuICAgICAgXTtcblxuICAgICAgc3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFnZW50ID0ge1xuICAgICAgICAgIGlkOiBcIjFcIixcbiAgICAgICAgICBuYW1lOiBcIlRlc3RcIixcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyBhcyBhbnksXG4gICAgICAgICAgY2FwYWJpbGl0aWVzOiBbXSxcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgICAgICBlbmVyZ3k6IDEwMCxcbiAgICAgICAgICAgIGhlYWx0aDogMTAwLFxuICAgICAgICAgICAgbWVtb3J5X3VzZWQ6IDAsXG4gICAgICAgICAgICBtZW1vcnlfY2FwYWNpdHk6IDEwMDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgICAgY3JlYXRlZF9hdDogXCIyMDI0LTAxLTAxVDAwOjAwOjAwWlwiLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IFwiMjAyNC0wMS0wMVQwMDowMDowMFpcIixcbiAgICAgICAgfTtcblxuICAgICAgICBleHBlY3QoYWdlbnQuc3RhdHVzKS50b0JlKHN0YXR1cyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJBY3RpdmVJbmZlcmVuY2VDb25maWcgY292ZXJzIGFsbCB0ZW1wbGF0ZSB0eXBlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZXMgPSBbXCJleHBsb3JlclwiLCBcImd1YXJkaWFuXCIsIFwibWVyY2hhbnRcIiwgXCJzY2hvbGFyXCJdO1xuXG4gICAgICB0ZW1wbGF0ZXMuZm9yRWFjaCgodGVtcGxhdGUpID0+IHtcbiAgICAgICAgY29uc3QgY29uZmlnOiBBY3RpdmVJbmZlcmVuY2VDb25maWcgPSB7XG4gICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlIGFzIGFueSxcbiAgICAgICAgICBzdGF0ZUxhYmVsczogW1wic3RhdGUxXCJdLFxuICAgICAgICAgIG51bVN0YXRlczogMSxcbiAgICAgICAgICBudW1PYnNlcnZhdGlvbnM6IDEsXG4gICAgICAgICAgbnVtQWN0aW9uczogMSxcbiAgICAgICAgICBnZW5lcmF0aXZlTW9kZWw6IHtcbiAgICAgICAgICAgIEE6IFtbMV1dLFxuICAgICAgICAgICAgQjogW1tbMV1dXSxcbiAgICAgICAgICAgIEM6IFsxXSxcbiAgICAgICAgICAgIEQ6IFsxXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZWNpc2lvblBhcmFtZXRlcnM6IHsgc2Vuc29yeTogMSwgcG9saWN5OiAxLCBzdGF0ZTogMSB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGV4cGVjdChjb25maWcudGVtcGxhdGUpLnRvQmUodGVtcGxhdGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRXJyb3IgaGFuZGxpbmcgYW5kIGVkZ2UgY2FzZXNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJoYW5kbGVzIG1hbGZvcm1lZCBwcmVjaXNpb24gcGFyYW1ldGVyc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZUNvbmZpZyA9IHtcbiAgICAgICAgdGVtcGxhdGU6IFwiZXhwbG9yZXJcIiBhcyBjb25zdCxcbiAgICAgICAgbmFtZTogXCJUZXN0IEFnZW50XCIsXG4gICAgICAgIHN0YXRlTGFiZWxzOiBbXCJzdGF0ZTFcIl0sXG4gICAgICAgIHByZWNpc2lvblBhcmFtZXRlcnM6IHsgc2Vuc29yeTogLTEsIHBvbGljeTogMCwgc3RhdGU6IEluZmluaXR5IH0sXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdFxuICAgICAgICAgIC5mbigpXG4gICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlKHsgYWdlbnQ6IHsgaWQ6IFwiMVwiLCBuYW1lOiBcIlRlc3QgQWdlbnRcIiB9IH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgLSBBUEkgYWNjZXB0cyBhbnkgbnVtZXJpYyB2YWx1ZXNcbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgYXBpLmNyZWF0ZUFnZW50RnJvbVRlbXBsYXRlKHRlbXBsYXRlQ29uZmlnKSxcbiAgICAgICkucmVzb2x2ZXMudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGVtcHR5IHN0YXRlIGxhYmVscyBhcnJheVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZUNvbmZpZyA9IHtcbiAgICAgICAgdGVtcGxhdGU6IFwiZXhwbG9yZXJcIiBhcyBjb25zdCxcbiAgICAgICAgbmFtZTogXCJFbXB0eSBTdGF0ZXMgQWdlbnRcIixcbiAgICAgICAgc3RhdGVMYWJlbHM6IFtdLFxuICAgICAgICBwcmVjaXNpb25QYXJhbWV0ZXJzOiB7IHNlbnNvcnk6IDEuMCwgcG9saWN5OiAxLjAsIHN0YXRlOiAxLjAgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgIGFnZW50OiB7IGlkOiBcIjFcIiwgbmFtZTogXCJFbXB0eSBTdGF0ZXMgQWdlbnRcIiB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBhcGkuY3JlYXRlQWdlbnRGcm9tVGVtcGxhdGUodGVtcGxhdGVDb25maWcpO1xuXG4gICAgICBjb25zdCBjYWxsQXJncyA9IG1vY2tGZXRjaC5tb2NrLmNhbGxzWzBdWzFdO1xuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSBKU09OLnBhcnNlKGNhbGxBcmdzLmJvZHkpO1xuICAgICAgY29uc3QgYWN0aXZlSW5mZXJlbmNlID0gcmVxdWVzdEJvZHkuYWN0aXZlSW5mZXJlbmNlO1xuXG4gICAgICBleHBlY3QoYWN0aXZlSW5mZXJlbmNlLm51bVN0YXRlcykudG9CZSgwKTtcbiAgICAgIGV4cGVjdChhY3RpdmVJbmZlcmVuY2UubnVtT2JzZXJ2YXRpb25zKS50b0JlKDApO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5udW1BY3Rpb25zKS50b0JlKDApO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5nZW5lcmF0aXZlTW9kZWwuQSkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QoYWN0aXZlSW5mZXJlbmNlLmdlbmVyYXRpdmVNb2RlbC5CKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChhY3RpdmVJbmZlcmVuY2UuZ2VuZXJhdGl2ZU1vZGVsLkMpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KGFjdGl2ZUluZmVyZW5jZS5nZW5lcmF0aXZlTW9kZWwuRCkudG9FcXVhbChbXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBuZXR3b3JrIHRpbWVvdXQgc2ltdWxhdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcblxuICAgICAgY29uc3QgcmVxdWVzdDogQ3JlYXRlQWdlbnRSZXF1ZXN0ID0geyBuYW1lOiBcIlRpbWVvdXQgQWdlbnRcIiB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0IHRpbWVvdXRcIikpLCA1MDAwKSxcbiAgICAgICAgICApLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgY3JlYXRlUHJvbWlzZSA9IGFwaS5jcmVhdGVBZ2VudChyZXF1ZXN0KTtcblxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDUwMDApO1xuXG4gICAgICBhd2FpdCBleHBlY3QoY3JlYXRlUHJvbWlzZSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBcIkZhaWxlZCB0byBjcmVhdGUgYWdlbnQ6IFJlcXVlc3QgdGltZW91dFwiLFxuICAgICAgKTtcblxuICAgICAgamVzdC51c2VSZWFsVGltZXJzKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiSW50ZWdyYXRpb24gc2NlbmFyaW9zXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiY3JlYXRlcyBtdWx0aXBsZSBhZ2VudHMgaW4gc2VxdWVuY2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWdlbnRzID0gW1xuICAgICAgICB7IG5hbWU6IFwiQWdlbnQgMVwiLCB0ZW1wbGF0ZTogXCJleHBsb3JlclwiIGFzIGNvbnN0IH0sXG4gICAgICAgIHsgbmFtZTogXCJBZ2VudCAyXCIsIHRlbXBsYXRlOiBcImd1YXJkaWFuXCIgYXMgY29uc3QgfSxcbiAgICAgICAgeyBuYW1lOiBcIkFnZW50IDNcIiwgdGVtcGxhdGU6IFwibWVyY2hhbnRcIiBhcyBjb25zdCB9LFxuICAgICAgXTtcblxuICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY2FsbENvdW50Kys7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBhZ2VudDogeyBpZDogYGFnZW50LSR7Y2FsbENvdW50fWAsIG5hbWU6IGBBZ2VudCAke2NhbGxDb3VudH1gIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgYWdlbnQgb2YgYWdlbnRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaS5jcmVhdGVBZ2VudEZyb21UZW1wbGF0ZSh7XG4gICAgICAgICAgdGVtcGxhdGU6IGFnZW50LnRlbXBsYXRlLFxuICAgICAgICAgIG5hbWU6IGFnZW50Lm5hbWUsXG4gICAgICAgICAgc3RhdGVMYWJlbHM6IFtcInN0YXRlMVwiLCBcInN0YXRlMlwiXSxcbiAgICAgICAgICBwcmVjaXNpb25QYXJhbWV0ZXJzOiB7IHNlbnNvcnk6IDEuMCwgcG9saWN5OiAxLjAsIHN0YXRlOiAxLjAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5hZ2VudC5uYW1lKS50b0NvbnRhaW4oXCJBZ2VudFwiKTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgY29uY3VycmVudCBhZ2VudCBjcmVhdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICBhZ2VudDogeyBpZDogXCJjb25jdXJyZW50XCIsIG5hbWU6IFwiQ29uY3VycmVudCBBZ2VudFwiIH0sXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNSB9LCAoXywgaSkgPT5cbiAgICAgICAgYXBpLmNyZWF0ZUFnZW50KHsgbmFtZTogYENvbmN1cnJlbnQgQWdlbnQgJHtpfWAgfSksXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDUpO1xuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDUpO1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5hZ2VudC5uYW1lKS50b0JlKFwiQ29uY3VycmVudCBBZ2VudFwiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vY2tGZXRjaCIsImplc3QiLCJmbiIsImdsb2JhbCIsImZldGNoIiwiZGVzY3JpYmUiLCJhcGkiLCJiZWZvcmVFYWNoIiwiQWdlbnRzQXBpIiwibW9ja0NsZWFyIiwiY2xlYXJBbGxNb2NrcyIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImFmdGVyRWFjaCIsInJlc3RvcmVBbGxNb2NrcyIsInRlc3QiLCJkZWZhdWx0QXBpIiwiZXhwZWN0IiwidG9CZUluc3RhbmNlT2YiLCJjdXN0b21BcGkiLCJhZ2VudHNBcGkiLCJtb2NrRGF0YSIsInN1Y2Nlc3MiLCJhZ2VudCIsImlkIiwibmFtZSIsIm1vY2tSZXNwb25zZSIsIm9rIiwianNvbiIsIm1vY2tSZXNvbHZlZFZhbHVlIiwicmVzdWx0IiwiaGFuZGxlUmVzcG9uc2UiLCJ0b0VxdWFsIiwidG9IYXZlQmVlbkNhbGxlZCIsImVycm9yRGF0YSIsImVycm9yIiwiZGV0YWlscyIsImZpZWxkIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImNvbnNvbGVTcHkiLCJyZWplY3RzIiwidG9UaHJvdyIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibW9ja1Jlc3RvcmUiLCJzb21lT3RoZXJGaWVsZCIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJtb2NrQWdlbnQiLCJjYXBhYmlsaXRpZXMiLCJwb3NpdGlvbiIsIngiLCJ5IiwicmVzb3VyY2VzIiwiZW5lcmd5IiwiaGVhbHRoIiwibWVtb3J5X3VzZWQiLCJtZW1vcnlfY2FwYWNpdHkiLCJ0YWdzIiwibWV0YWRhdGEiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsInJlcXVlc3QiLCJjcmVhdGVBZ2VudCIsIm1ldGhvZCIsImhlYWRlcnMiLCJjcmVkZW50aWFscyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiYWN0aXZlSW5mZXJlbmNlQ29uZmlnIiwidGVtcGxhdGUiLCJzdGF0ZUxhYmVscyIsIm51bVN0YXRlcyIsIm51bU9ic2VydmF0aW9ucyIsIm51bUFjdGlvbnMiLCJnZW5lcmF0aXZlTW9kZWwiLCJBIiwiQiIsIkMiLCJEIiwicHJlY2lzaW9uUGFyYW1ldGVycyIsInNlbnNvcnkiLCJwb2xpY3kiLCJzdGF0ZSIsInBlcnNvbmFsaXR5Iiwib3Blbm5lc3MiLCJjb25zY2llbnRpb3VzbmVzcyIsImV4dHJhdmVyc2lvbiIsImFncmVlYWJsZW5lc3MiLCJuZXVyb3RpY2lzbSIsImFjdGl2ZUluZmVyZW5jZSIsImluaXRpYWxQb3NpdGlvbiIsInoiLCJjdXN0b21GaWVsZCIsInRvQmUiLCJ0ZW1wbGF0ZUNvbmZpZyIsInJvbGUiLCJ0ZW1wbGF0ZVR5cGUiLCJtYXRoZW1hdGljYWxseVZhbGlkYXRlZCIsImNyZWF0ZUFnZW50RnJvbVRlbXBsYXRlIiwiY2FsbEFyZ3MiLCJtb2NrIiwiY2FsbHMiLCJyZXF1ZXN0Qm9keSIsInBhcnNlIiwidG9IYXZlTGVuZ3RoIiwibWF0aGVtYXRpY2FsQ29uc3RyYWludHMiLCJub3JtYWxpemVkQmVsaWVmcyIsInN0b2NoYXN0aWNNYXRyaWNlcyIsInByZWNpc2lvbkJvdW5kcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwiZ2V0Q2FwYWJpbGl0aWVzIiwiZ2V0RGVmYXVsdENhcGFiaWxpdGllcyIsImJlbGllZlN0YXRlIiwiYmVsaWVmcyIsImVudHJvcHkiLCJjb25maWRlbmNlIiwibW9zdExpa2VseVN0YXRlIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInN0YXR1c2VzIiwiZm9yRWFjaCIsInRlbXBsYXRlcyIsImNvbmZpZyIsIkluZmluaXR5IiwicmVzb2x2ZXMiLCJ0b0JlRGVmaW5lZCIsInVzZUZha2VUaW1lcnMiLCJQcm9taXNlIiwicmVqZWN0Iiwic2V0VGltZW91dCIsImNyZWF0ZVByb21pc2UiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwidXNlUmVhbFRpbWVycyIsImFnZW50cyIsImNhbGxDb3VudCIsInJlc29sdmUiLCJ0b0NvbnRhaW4iLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJwcm9taXNlcyIsInJlc3VsdHMiLCJhbGwiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7Ozs7MkJBU007QUFFUCxzQkFBc0I7QUFDdEIsTUFBTUEsWUFBWUMsS0FBS0MsRUFBRTtBQUN6QkMsT0FBT0MsS0FBSyxHQUFHSjtBQUVmSyxTQUFTLDZDQUE2QztJQUNwRCxJQUFJQztJQUVKQyxXQUFXO1FBQ1RELE1BQU0sSUFBSUUsb0JBQVM7UUFDbkJSLFVBQVVTLFNBQVM7UUFDbkJSLEtBQUtTLGFBQWE7UUFDbEIsc0JBQXNCO1FBQ3RCVCxLQUFLVSxLQUFLLENBQUNDLFNBQVMsU0FBU0Msa0JBQWtCLENBQUMsS0FBTztJQUN6RDtJQUVBQyxVQUFVO1FBQ1JiLEtBQUtjLGVBQWU7SUFDdEI7SUFFQVYsU0FBUyxrQ0FBa0M7UUFDekNXLEtBQUsseUNBQXlDO1lBQzVDLE1BQU1DLGFBQWEsSUFBSVQsb0JBQVM7WUFDaENVLE9BQU9ELFlBQVlFLGNBQWMsQ0FBQ1gsb0JBQVM7UUFDN0M7UUFFQVEsS0FBSyx3Q0FBd0M7WUFDM0MsTUFBTUksWUFBWSxJQUFJWixvQkFBUyxDQUFDO1lBQ2hDVSxPQUFPRSxXQUFXRCxjQUFjLENBQUNYLG9CQUFTO1FBQzVDO1FBRUFRLEtBQUssa0NBQWtDO1lBQ3JDRSxPQUFPRyxvQkFBUyxFQUFFRixjQUFjLENBQUNYLG9CQUFTO1FBQzVDO0lBQ0Y7SUFFQUgsU0FBUywyQ0FBMkM7UUFDbERXLEtBQUssK0JBQStCO1lBQ2xDLE1BQU1NLFdBQVc7Z0JBQUVDLFNBQVM7Z0JBQU1DLE9BQU87b0JBQUVDLElBQUk7b0JBQUtDLE1BQU07Z0JBQU87WUFBRTtZQUNuRSxNQUFNQyxlQUFlO2dCQUNuQkMsSUFBSTtnQkFDSkMsTUFBTTVCLEtBQUtDLEVBQUUsR0FBRzRCLGlCQUFpQixDQUFDUjtZQUNwQztZQUVB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