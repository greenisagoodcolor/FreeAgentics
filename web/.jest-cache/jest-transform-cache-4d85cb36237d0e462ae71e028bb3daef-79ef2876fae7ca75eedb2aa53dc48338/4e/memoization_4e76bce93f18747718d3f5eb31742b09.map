{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/performance/memoization.ts"],"sourcesContent":["\"use client\";\n\nimport * as React from \"react\";\nimport { memo, useMemo, useCallback, useRef, DependencyList } from \"react\";\n\nexport interface MemoizationConfig {\n  maxCacheSize?: number;\n  ttl?: number; // Time to live in milliseconds\n  keyGenerator?: (...args: any[]) => string;\n  onCacheHit?: (key: string) => void;\n  onCacheMiss?: (key: string) => void;\n  onCacheEvict?: (key: string, reason: \"size\" | \"ttl\") => void;\n}\n\nexport interface CacheEntry<T> {\n  value: T;\n  timestamp: number;\n  accessCount: number;\n  lastAccessed: number;\n}\n\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  evictions: number;\n  size: number;\n  hitRate: number;\n}\n\n// Advanced LRU cache with TTL support\nexport class AdvancedCache<T> {\n  private cache = new Map<string, CacheEntry<T>>();\n  private accessOrder: string[] = [];\n  private stats: CacheStats = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    size: 0,\n    hitRate: 0,\n  };\n\n  constructor(\n    private maxSize: number = 100,\n    private ttl: number = 5 * 60 * 1000, // 5 minutes default\n    private config: MemoizationConfig = {},\n  ) {}\n\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      this.stats.misses++;\n      this.config.onCacheMiss?.(key);\n      this.updateHitRate();\n      return undefined;\n    }\n\n    // Check TTL\n    if (Date.now() - entry.timestamp > this.ttl) {\n      this.delete(key, \"ttl\");\n      this.stats.misses++;\n      this.config.onCacheMiss?.(key);\n      this.updateHitRate();\n      return undefined;\n    }\n\n    // Update access tracking\n    entry.accessCount++;\n    entry.lastAccessed = Date.now();\n\n    // Move to end (most recently used)\n    const index = this.accessOrder.indexOf(key);\n    if (index > -1) {\n      this.accessOrder.splice(index, 1);\n    }\n    this.accessOrder.push(key);\n\n    this.stats.hits++;\n    this.config.onCacheHit?.(key);\n    this.updateHitRate();\n\n    return entry.value;\n  }\n\n  set(key: string, value: T): void {\n    const existing = this.cache.get(key);\n\n    if (existing) {\n      existing.value = value;\n      existing.timestamp = Date.now();\n      existing.lastAccessed = Date.now();\n      return;\n    }\n\n    // Check if we need to evict\n    if (this.cache.size >= this.maxSize) {\n      this.evictLeastRecentlyUsed();\n    }\n\n    const entry: CacheEntry<T> = {\n      value,\n      timestamp: Date.now(),\n      accessCount: 1,\n      lastAccessed: Date.now(),\n    };\n\n    this.cache.set(key, entry);\n    this.accessOrder.push(key);\n    this.stats.size = this.cache.size;\n  }\n\n  private delete(key: string, reason: \"size\" | \"ttl\"): boolean {\n    const deleted = this.cache.delete(key);\n    if (deleted) {\n      const index = this.accessOrder.indexOf(key);\n      if (index > -1) {\n        this.accessOrder.splice(index, 1);\n      }\n      this.stats.evictions++;\n      this.stats.size = this.cache.size;\n      this.config.onCacheEvict?.(key, reason);\n    }\n    return deleted;\n  }\n\n  private evictLeastRecentlyUsed(): void {\n    if (this.accessOrder.length > 0) {\n      const lruKey = this.accessOrder[0];\n      this.delete(lruKey, \"size\");\n    }\n  }\n\n  private updateHitRate(): void {\n    const total = this.stats.hits + this.stats.misses;\n    this.stats.hitRate = total > 0 ? (this.stats.hits / total) * 100 : 0;\n  }\n\n  clear(): void {\n    this.cache.clear();\n    this.accessOrder = [];\n    this.stats = { hits: 0, misses: 0, evictions: 0, size: 0, hitRate: 0 };\n  }\n\n  getStats(): CacheStats {\n    return { ...this.stats };\n  }\n\n  // Clean expired entries\n  cleanup(): number {\n    const now = Date.now();\n    let cleaned = 0;\n\n    const entries = Array.from(this.cache.entries());\n    for (const [key, entry] of entries) {\n      if (now - entry.timestamp > this.ttl) {\n        this.delete(key, \"ttl\");\n        cleaned++;\n      }\n    }\n\n    return cleaned;\n  }\n}\n\n// Global cache instances\nconst componentCache = new AdvancedCache<any>(200, 10 * 60 * 1000); // 10 minutes\nconst computationCache = new AdvancedCache<any>(500, 5 * 60 * 1000); // 5 minutes\n\n// Enhanced useMemo with caching\nexport function useAdvancedMemo<T>(\n  factory: () => T,\n  deps: DependencyList,\n  cacheKey?: string,\n): T {\n  const key = cacheKey || `memo_${JSON.stringify(deps)}`;\n\n  // Use a more stable dependency approach - serialize deps to ensure consistency\n  const depsString = JSON.stringify(deps);\n\n  return useMemo(() => {\n    // Try to get from cache first\n    const cached = computationCache.get(key);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    // Compute new value\n    const result = factory();\n\n    // Cache the result\n    computationCache.set(key, result);\n\n    return result;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [factory, key, depsString]);\n}\n\n// Enhanced useCallback with caching\nexport function useAdvancedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  deps: DependencyList,\n  cacheKey?: string,\n): T {\n  const key = cacheKey || `callback_${JSON.stringify(deps)}`;\n\n  // Use a more stable dependency approach - serialize deps to ensure consistency\n  const depsString = JSON.stringify(deps);\n\n  return useCallback(\n    (...args: any[]) => {\n      const argKey = `${key}_${JSON.stringify(args)}`;\n\n      // Try to get from cache\n      const cached = computationCache.get(argKey);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      // Execute callback\n      const result = callback(...args);\n\n      // Cache result if it's serializable\n      try {\n        JSON.stringify(result);\n        computationCache.set(argKey, result);\n      } catch {\n        // Don't cache non-serializable results\n      }\n\n      return result;\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    },\n    [callback, key, depsString],\n  ) as T;\n}\n\n// Smart component memoization\nexport function smartMemo<P extends Record<string, any>>(\n  Component: React.ComponentType<P>,\n  config: MemoizationConfig = {},\n): React.MemoExoticComponent<React.ComponentType<P>> {\n  const {\n    keyGenerator = (props: P) => JSON.stringify(props),\n    maxCacheSize = 50,\n    ttl = 5 * 60 * 1000,\n  } = config;\n\n  const cache = new AdvancedCache<React.ReactElement>(\n    maxCacheSize,\n    ttl,\n    config,\n  );\n\n  const MemoizedComponent = memo(\n    (props: P) => {\n      const key = keyGenerator(props);\n\n      // Try cache first\n      const cached = cache.get(key);\n      if (cached) {\n        return cached;\n      }\n\n      // Render new\n      const element = React.createElement(Component, props);\n      cache.set(key, element);\n\n      return element;\n    },\n    (prevProps, nextProps) => {\n      // Custom comparison based on generated keys\n      const prevKey = keyGenerator(prevProps);\n      const nextKey = keyGenerator(nextProps);\n      return prevKey === nextKey;\n    },\n  );\n\n  MemoizedComponent.displayName = `SmartMemo(${Component.displayName || Component.name || \"Component\"})`;\n\n  return MemoizedComponent;\n}\n\n// Batched state updates utility\nexport function useBatchedUpdates<T>(\n  initialState: T,\n  batchDelay: number = 16, // One frame\n): [T, (updater: T | ((prev: T) => T)) => void, () => void] {\n  const [state, setState] = React.useState(initialState);\n  const batchRef = useRef<{\n    updates: Array<T | ((prev: T) => T)>;\n    timeoutId?: NodeJS.Timeout;\n  }>({ updates: [] });\n\n  const flushUpdates = useCallback(() => {\n    if (batchRef.current.updates.length === 0) return;\n\n    const updates = [...batchRef.current.updates];\n    batchRef.current.updates = [];\n\n    setState((prevState) => {\n      let currentState = prevState;\n      for (const update of updates) {\n        if (typeof update === \"function\") {\n          currentState = (update as (prev: T) => T)(currentState);\n        } else {\n          currentState = update;\n        }\n      }\n      return currentState;\n    });\n\n    if (batchRef.current.timeoutId) {\n      clearTimeout(batchRef.current.timeoutId);\n      batchRef.current.timeoutId = undefined;\n    }\n  }, []);\n\n  const batchedSetState = useCallback(\n    (updater: T | ((prev: T) => T)) => {\n      batchRef.current.updates.push(updater);\n\n      if (batchRef.current.timeoutId) {\n        clearTimeout(batchRef.current.timeoutId);\n      }\n\n      batchRef.current.timeoutId = setTimeout(flushUpdates, batchDelay);\n    },\n    [flushUpdates, batchDelay],\n  );\n\n  const forceFlush = useCallback(() => {\n    if (batchRef.current.timeoutId) {\n      clearTimeout(batchRef.current.timeoutId);\n      batchRef.current.timeoutId = undefined;\n    }\n    flushUpdates();\n  }, [flushUpdates]);\n\n  // Cleanup on unmount\n  React.useEffect(() => {\n    const batchRefCurrent = batchRef.current;\n    return () => {\n      if (batchRefCurrent?.timeoutId) {\n        clearTimeout(batchRefCurrent.timeoutId);\n      }\n    };\n  }, []);\n\n  return [state, batchedSetState, forceFlush];\n}\n\n// Performance-optimized list renderer\nexport function useVirtualizedList<T>(\n  items: T[],\n  renderItem: (item: T, index: number) => React.ReactNode,\n  config: {\n    itemHeight: number;\n    containerHeight: number;\n    overscan?: number;\n    cacheSize?: number;\n  },\n) {\n  const { itemHeight, containerHeight, overscan = 5, cacheSize = 100 } = config;\n\n  const [scrollTop, setScrollTop] = useState(0);\n  const cache = useRef(new AdvancedCache<React.ReactNode>(cacheSize));\n\n  const visibleRange = useMemo(() => {\n    const start = Math.floor(scrollTop / itemHeight);\n    const end = Math.min(\n      items.length - 1,\n      Math.ceil((scrollTop + containerHeight) / itemHeight),\n    );\n\n    return {\n      start: Math.max(0, start - overscan),\n      end: Math.min(items.length - 1, end + overscan),\n    };\n  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);\n\n  const visibleItems = useMemo(() => {\n    const rendered: Array<{ item: T; index: number; node: React.ReactNode }> =\n      [];\n\n    for (let i = visibleRange.start; i <= visibleRange.end; i++) {\n      const item = items[i];\n      const cacheKey = `item_${i}_${JSON.stringify(item)}`;\n\n      let node = cache.current.get(cacheKey);\n      if (!node) {\n        node = renderItem(item, i);\n        cache.current.set(cacheKey, node);\n      }\n\n      rendered.push({ item, index: i, node });\n    }\n\n    return rendered;\n  }, [items, visibleRange, renderItem]);\n\n  const handleScroll = useCallback((event: React.UIEvent<HTMLDivElement>) => {\n    setScrollTop(event.currentTarget.scrollTop);\n  }, []);\n\n  return {\n    visibleItems,\n    totalHeight: items.length * itemHeight,\n    offsetY: visibleRange.start * itemHeight,\n    handleScroll,\n    cacheStats: cache.current.getStats(),\n  };\n}\n\n// Cache management utilities\nexport const cacheManager = {\n  getComponentCacheStats: () => componentCache.getStats(),\n  getComputationCacheStats: () => computationCache.getStats(),\n  clearComponentCache: () => componentCache.clear(),\n  clearComputationCache: () => computationCache.clear(),\n  cleanupExpired: () => {\n    const componentCleaned = componentCache.cleanup();\n    const computationCleaned = computationCache.cleanup();\n    return { componentCleaned, computationCleaned };\n  },\n  getTotalCacheStats: () => {\n    const compStats = componentCache.getStats();\n    const compuStats = computationCache.getStats();\n\n    return {\n      totalHits: compStats.hits + compuStats.hits,\n      totalMisses: compStats.misses + compuStats.misses,\n      totalEvictions: compStats.evictions + compuStats.evictions,\n      totalSize: compStats.size + compuStats.size,\n      averageHitRate: (compStats.hitRate + compuStats.hitRate) / 2,\n    };\n  },\n};\n\n// Performance debugging utilities\nexport const performanceDebugger = {\n  logCacheStats: () => {\n    console.group(\"üöÄ Performance Cache Stats\");\n    console.table(cacheManager.getTotalCacheStats());\n    console.groupEnd();\n  },\n\n  measureRenderTime: <T extends (...args: any[]) => any>(\n    fn: T,\n    label: string = \"Render\",\n  ): T => {\n    return ((...args: any[]) => {\n      const start = performance.now();\n      const result = fn(...args);\n      const end = performance.now();\n      console.log(`‚è±Ô∏è ${label}: ${(end - start).toFixed(2)}ms`);\n      return result;\n    }) as T;\n  },\n\n  profileComponent: <P extends Record<string, any>>(\n    Component: React.ComponentType<P>,\n    componentName: string,\n  ) => {\n    const ProfiledComponent = memo((props: P) => {\n      const renderStart = performance.now();\n\n      React.useEffect(() => {\n        const renderEnd = performance.now();\n        console.log(\n          `üîç ${componentName} rendered in ${(renderEnd - renderStart).toFixed(2)}ms`,\n        );\n      });\n\n      return React.createElement(Component, props);\n    });\n\n    ProfiledComponent.displayName = `Profiled(${componentName})`;\n\n    return ProfiledComponent;\n  },\n};\n\nimport { useState, useEffect } from \"react\";\n"],"names":["AdvancedCache","cacheManager","performanceDebugger","smartMemo","useAdvancedCallback","useAdvancedMemo","useBatchedUpdates","useVirtualizedList","constructor","maxSize","ttl","config","cache","Map","accessOrder","stats","hits","misses","evictions","size","hitRate","get","key","entry","onCacheMiss","updateHitRate","undefined","Date","now","timestamp","delete","accessCount","lastAccessed","index","indexOf","splice","push","onCacheHit","value","set","existing","evictLeastRecentlyUsed","reason","deleted","onCacheEvict","length","lruKey","total","clear","getStats","cleanup","cleaned","entries","Array","from","componentCache","computationCache","factory","deps","cacheKey","JSON","stringify","depsString","useMemo","cached","result","callback","useCallback","args","argKey","Component","keyGenerator","props","maxCacheSize","MemoizedComponent","memo","element","React","createElement","prevProps","nextProps","prevKey","nextKey","displayName","name","initialState","batchDelay","state","setState","useState","batchRef","useRef","updates","flushUpdates","current","prevState","currentState","update","timeoutId","clearTimeout","batchedSetState","updater","setTimeout","forceFlush","useEffect","batchRefCurrent","items","renderItem","itemHeight","containerHeight","overscan","cacheSize","scrollTop","setScrollTop","visibleRange","start","Math","floor","end","min","ceil","max","visibleItems","rendered","i","item","node","handleScroll","event","currentTarget","totalHeight","offsetY","cacheStats","getComponentCacheStats","getComputationCacheStats","clearComponentCache","clearComputationCache","cleanupExpired","componentCleaned","computationCleaned","getTotalCacheStats","compStats","compuStats","totalHits","totalMisses","totalEvictions","totalSize","averageHitRate","logCacheStats","console","group","table","groupEnd","measureRenderTime","fn","label","performance","log","toFixed","profileComponent","componentName","ProfiledComponent","renderStart","renderEnd"],"mappings":"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"}