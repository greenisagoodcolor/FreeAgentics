1b46837e21b4e5e3131ee3608300a80d
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AdvancedCache: function() {
        return AdvancedCache;
    },
    cacheManager: function() {
        return cacheManager;
    },
    performanceDebugger: function() {
        return performanceDebugger;
    },
    smartMemo: function() {
        return smartMemo;
    },
    useAdvancedCallback: function() {
        return useAdvancedCallback;
    },
    useAdvancedMemo: function() {
        return useAdvancedMemo;
    },
    useBatchedUpdates: function() {
        return useBatchedUpdates;
    },
    useVirtualizedList: function() {
        return useVirtualizedList;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class AdvancedCache {
    constructor(maxSize = 100, ttl = 5 * 60 * 1000, config = {}){
        this.maxSize = maxSize;
        this.ttl = ttl;
        this.config = config;
        this.cache = new Map();
        this.accessOrder = [];
        this.stats = {
            hits: 0,
            misses: 0,
            evictions: 0,
            size: 0,
            hitRate: 0
        };
    }
    get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            this.stats.misses++;
            this.config.onCacheMiss?.(key);
            this.updateHitRate();
            return undefined;
        }
        // Check TTL
        if (Date.now() - entry.timestamp > this.ttl) {
            this.delete(key, "ttl");
            this.stats.misses++;
            this.config.onCacheMiss?.(key);
            this.updateHitRate();
            return undefined;
        }
        // Update access tracking
        entry.accessCount++;
        entry.lastAccessed = Date.now();
        // Move to end (most recently used)
        const index = this.accessOrder.indexOf(key);
        if (index > -1) {
            this.accessOrder.splice(index, 1);
        }
        this.accessOrder.push(key);
        this.stats.hits++;
        this.config.onCacheHit?.(key);
        this.updateHitRate();
        return entry.value;
    }
    set(key, value) {
        const existing = this.cache.get(key);
        if (existing) {
            existing.value = value;
            existing.timestamp = Date.now();
            existing.lastAccessed = Date.now();
            return;
        }
        // Check if we need to evict
        if (this.cache.size >= this.maxSize) {
            this.evictLeastRecentlyUsed();
        }
        const entry = {
            value,
            timestamp: Date.now(),
            accessCount: 1,
            lastAccessed: Date.now()
        };
        this.cache.set(key, entry);
        this.accessOrder.push(key);
        this.stats.size = this.cache.size;
    }
    delete(key, reason) {
        const deleted = this.cache.delete(key);
        if (deleted) {
            const index = this.accessOrder.indexOf(key);
            if (index > -1) {
                this.accessOrder.splice(index, 1);
            }
            this.stats.evictions++;
            this.stats.size = this.cache.size;
            this.config.onCacheEvict?.(key, reason);
        }
        return deleted;
    }
    evictLeastRecentlyUsed() {
        if (this.accessOrder.length > 0) {
            const lruKey = this.accessOrder[0];
            this.delete(lruKey, "size");
        }
    }
    updateHitRate() {
        const total = this.stats.hits + this.stats.misses;
        this.stats.hitRate = total > 0 ? this.stats.hits / total * 100 : 0;
    }
    clear() {
        this.cache.clear();
        this.accessOrder = [];
        this.stats = {
            hits: 0,
            misses: 0,
            evictions: 0,
            size: 0,
            hitRate: 0
        };
    }
    getStats() {
        return {
            ...this.stats
        };
    }
    // Clean expired entries
    cleanup() {
        const now = Date.now();
        let cleaned = 0;
        const entries = Array.from(this.cache.entries());
        for (const [key, entry] of entries){
            if (now - entry.timestamp > this.ttl) {
                this.delete(key, "ttl");
                cleaned++;
            }
        }
        return cleaned;
    }
}
// Global cache instances
const componentCache = new AdvancedCache(200, 10 * 60 * 1000); // 10 minutes
const computationCache = new AdvancedCache(500, 5 * 60 * 1000); // 5 minutes
function useAdvancedMemo(factory, deps, cacheKey) {
    const key = cacheKey || `memo_${JSON.stringify(deps)}`;
    // Use a more stable dependency approach - serialize deps to ensure consistency
    const depsString = JSON.stringify(deps);
    return (0, _react.useMemo)(()=>{
        // Try to get from cache first
        const cached = computationCache.get(key);
        if (cached !== undefined) {
            return cached;
        }
        // Compute new value
        const result = factory();
        // Cache the result
        computationCache.set(key, result);
        return result;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        factory,
        key,
        depsString
    ]);
}
function useAdvancedCallback(callback, deps, cacheKey) {
    const key = cacheKey || `callback_${JSON.stringify(deps)}`;
    // Use a more stable dependency approach - serialize deps to ensure consistency
    const depsString = JSON.stringify(deps);
    return (0, _react.useCallback)((...args)=>{
        const argKey = `${key}_${JSON.stringify(args)}`;
        // Try to get from cache
        const cached = computationCache.get(argKey);
        if (cached !== undefined) {
            return cached;
        }
        // Execute callback
        const result = callback(...args);
        // Cache result if it's serializable
        try {
            JSON.stringify(result);
            computationCache.set(argKey, result);
        } catch  {
        // Don't cache non-serializable results
        }
        return result;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        callback,
        key,
        depsString
    ]);
}
function smartMemo(Component, config = {}) {
    const { keyGenerator = (props)=>JSON.stringify(props), maxCacheSize = 50, ttl = 5 * 60 * 1000 } = config;
    const cache = new AdvancedCache(maxCacheSize, ttl, config);
    const MemoizedComponent = (0, _react.memo)((props)=>{
        const key = keyGenerator(props);
        // Try cache first
        const cached = cache.get(key);
        if (cached) {
            return cached;
        }
        // Render new
        const element = _react.createElement(Component, props);
        cache.set(key, element);
        return element;
    }, (prevProps, nextProps)=>{
        // Custom comparison based on generated keys
        const prevKey = keyGenerator(prevProps);
        const nextKey = keyGenerator(nextProps);
        return prevKey === nextKey;
    });
    MemoizedComponent.displayName = `SmartMemo(${Component.displayName || Component.name || "Component"})`;
    return MemoizedComponent;
}
function useBatchedUpdates(initialState, batchDelay = 16) {
    const [state, setState] = _react.useState(initialState);
    const batchRef = (0, _react.useRef)({
        updates: []
    });
    const flushUpdates = (0, _react.useCallback)(()=>{
        if (batchRef.current.updates.length === 0) return;
        const updates = [
            ...batchRef.current.updates
        ];
        batchRef.current.updates = [];
        setState((prevState)=>{
            let currentState = prevState;
            for (const update of updates){
                if (typeof update === "function") {
                    currentState = update(currentState);
                } else {
                    currentState = update;
                }
            }
            return currentState;
        });
        if (batchRef.current.timeoutId) {
            clearTimeout(batchRef.current.timeoutId);
            batchRef.current.timeoutId = undefined;
        }
    }, []);
    const batchedSetState = (0, _react.useCallback)((updater)=>{
        batchRef.current.updates.push(updater);
        if (batchRef.current.timeoutId) {
            clearTimeout(batchRef.current.timeoutId);
        }
        batchRef.current.timeoutId = setTimeout(flushUpdates, batchDelay);
    }, [
        flushUpdates,
        batchDelay
    ]);
    const forceFlush = (0, _react.useCallback)(()=>{
        if (batchRef.current.timeoutId) {
            clearTimeout(batchRef.current.timeoutId);
            batchRef.current.timeoutId = undefined;
        }
        flushUpdates();
    }, [
        flushUpdates
    ]);
    // Cleanup on unmount
    _react.useEffect(()=>{
        const batchRefCurrent = batchRef.current;
        return ()=>{
            if (batchRefCurrent?.timeoutId) {
                clearTimeout(batchRefCurrent.timeoutId);
            }
        };
    }, []);
    return [
        state,
        batchedSetState,
        forceFlush
    ];
}
function useVirtualizedList(items, renderItem, config) {
    const { itemHeight, containerHeight, overscan = 5, cacheSize = 100 } = config;
    const [scrollTop, setScrollTop] = (0, _react.useState)(0);
    const cache = (0, _react.useRef)(new AdvancedCache(cacheSize));
    const visibleRange = (0, _react.useMemo)(()=>{
        const start = Math.floor(scrollTop / itemHeight);
        const end = Math.min(items.length - 1, Math.ceil((scrollTop + containerHeight) / itemHeight));
        return {
            start: Math.max(0, start - overscan),
            end: Math.min(items.length - 1, end + overscan)
        };
    }, [
        scrollTop,
        itemHeight,
        containerHeight,
        items.length,
        overscan
    ]);
    const visibleItems = (0, _react.useMemo)(()=>{
        const rendered = [];
        for(let i = visibleRange.start; i <= visibleRange.end; i++){
            const item = items[i];
            const cacheKey = `item_${i}_${JSON.stringify(item)}`;
            let node = cache.current.get(cacheKey);
            if (!node) {
                node = renderItem(item, i);
                cache.current.set(cacheKey, node);
            }
            rendered.push({
                item,
                index: i,
                node
            });
        }
        return rendered;
    }, [
        items,
        visibleRange,
        renderItem
    ]);
    const handleScroll = (0, _react.useCallback)((event)=>{
        setScrollTop(event.currentTarget.scrollTop);
    }, []);
    return {
        visibleItems,
        totalHeight: items.length * itemHeight,
        offsetY: visibleRange.start * itemHeight,
        handleScroll,
        cacheStats: cache.current.getStats()
    };
}
const cacheManager = {
    getComponentCacheStats: ()=>componentCache.getStats(),
    getComputationCacheStats: ()=>computationCache.getStats(),
    clearComponentCache: ()=>componentCache.clear(),
    clearComputationCache: ()=>computationCache.clear(),
    cleanupExpired: ()=>{
        const componentCleaned = componentCache.cleanup();
        const computationCleaned = computationCache.cleanup();
        return {
            componentCleaned,
            computationCleaned
        };
    },
    getTotalCacheStats: ()=>{
        const compStats = componentCache.getStats();
        const compuStats = computationCache.getStats();
        return {
            totalHits: compStats.hits + compuStats.hits,
            totalMisses: compStats.misses + compuStats.misses,
            totalEvictions: compStats.evictions + compuStats.evictions,
            totalSize: compStats.size + compuStats.size,
            averageHitRate: (compStats.hitRate + compuStats.hitRate) / 2
        };
    }
};
const performanceDebugger = {
    logCacheStats: ()=>{
        console.group("\uD83D\uDE80 Performance Cache Stats");
        console.table(cacheManager.getTotalCacheStats());
        console.groupEnd();
    },
    measureRenderTime: (fn, label = "Render")=>{
        return (...args)=>{
            const start = performance.now();
            const result = fn(...args);
            const end = performance.now();
            console.log(`‚è±Ô∏è ${label}: ${(end - start).toFixed(2)}ms`);
            return result;
        };
    },
    profileComponent: (Component, componentName)=>{
        const ProfiledComponent = (0, _react.memo)((props)=>{
            const renderStart = performance.now();
            _react.useEffect(()=>{
                const renderEnd = performance.now();
                console.log(`üîç ${componentName} rendered in ${(renderEnd - renderStart).toFixed(2)}ms`);
            });
            return _react.createElement(Component, props);
        });
        ProfiledComponent.displayName = `Profiled(${componentName})`;
        return ProfiledComponent;
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvcGVyZm9ybWFuY2UvbWVtb2l6YXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbWVtbywgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgRGVwZW5kZW5jeUxpc3QgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNZW1vaXphdGlvbkNvbmZpZyB7XG4gIG1heENhY2hlU2l6ZT86IG51bWJlcjtcbiAgdHRsPzogbnVtYmVyOyAvLyBUaW1lIHRvIGxpdmUgaW4gbWlsbGlzZWNvbmRzXG4gIGtleUdlbmVyYXRvcj86ICguLi5hcmdzOiBhbnlbXSkgPT4gc3RyaW5nO1xuICBvbkNhY2hlSGl0PzogKGtleTogc3RyaW5nKSA9PiB2b2lkO1xuICBvbkNhY2hlTWlzcz86IChrZXk6IHN0cmluZykgPT4gdm9pZDtcbiAgb25DYWNoZUV2aWN0PzogKGtleTogc3RyaW5nLCByZWFzb246IFwic2l6ZVwiIHwgXCJ0dGxcIikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZUVudHJ5PFQ+IHtcbiAgdmFsdWU6IFQ7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBhY2Nlc3NDb3VudDogbnVtYmVyO1xuICBsYXN0QWNjZXNzZWQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZVN0YXRzIHtcbiAgaGl0czogbnVtYmVyO1xuICBtaXNzZXM6IG51bWJlcjtcbiAgZXZpY3Rpb25zOiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbiAgaGl0UmF0ZTogbnVtYmVyO1xufVxuXG4vLyBBZHZhbmNlZCBMUlUgY2FjaGUgd2l0aCBUVEwgc3VwcG9ydFxuZXhwb3J0IGNsYXNzIEFkdmFuY2VkQ2FjaGU8VD4ge1xuICBwcml2YXRlIGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIENhY2hlRW50cnk8VD4+KCk7XG4gIHByaXZhdGUgYWNjZXNzT3JkZXI6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgc3RhdHM6IENhY2hlU3RhdHMgPSB7XG4gICAgaGl0czogMCxcbiAgICBtaXNzZXM6IDAsXG4gICAgZXZpY3Rpb25zOiAwLFxuICAgIHNpemU6IDAsXG4gICAgaGl0UmF0ZTogMCxcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG1heFNpemU6IG51bWJlciA9IDEwMCxcbiAgICBwcml2YXRlIHR0bDogbnVtYmVyID0gNSAqIDYwICogMTAwMCwgLy8gNSBtaW51dGVzIGRlZmF1bHRcbiAgICBwcml2YXRlIGNvbmZpZzogTWVtb2l6YXRpb25Db25maWcgPSB7fSxcbiAgKSB7fVxuXG4gIGdldChrZXk6IHN0cmluZyk6IFQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHRoaXMuc3RhdHMubWlzc2VzKys7XG4gICAgICB0aGlzLmNvbmZpZy5vbkNhY2hlTWlzcz8uKGtleSk7XG4gICAgICB0aGlzLnVwZGF0ZUhpdFJhdGUoKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgVFRMXG4gICAgaWYgKERhdGUubm93KCkgLSBlbnRyeS50aW1lc3RhbXAgPiB0aGlzLnR0bCkge1xuICAgICAgdGhpcy5kZWxldGUoa2V5LCBcInR0bFwiKTtcbiAgICAgIHRoaXMuc3RhdHMubWlzc2VzKys7XG4gICAgICB0aGlzLmNvbmZpZy5vbkNhY2hlTWlzcz8uKGtleSk7XG4gICAgICB0aGlzLnVwZGF0ZUhpdFJhdGUoKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGFjY2VzcyB0cmFja2luZ1xuICAgIGVudHJ5LmFjY2Vzc0NvdW50Kys7XG4gICAgZW50cnkubGFzdEFjY2Vzc2VkID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIE1vdmUgdG8gZW5kIChtb3N0IHJlY2VudGx5IHVzZWQpXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmFjY2Vzc09yZGVyLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5hY2Nlc3NPcmRlci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0aGlzLmFjY2Vzc09yZGVyLnB1c2goa2V5KTtcblxuICAgIHRoaXMuc3RhdHMuaGl0cysrO1xuICAgIHRoaXMuY29uZmlnLm9uQ2FjaGVIaXQ/LihrZXkpO1xuICAgIHRoaXMudXBkYXRlSGl0UmF0ZSgpO1xuXG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICB9XG5cbiAgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcblxuICAgIGlmIChleGlzdGluZykge1xuICAgICAgZXhpc3RpbmcudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGV4aXN0aW5nLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBleGlzdGluZy5sYXN0QWNjZXNzZWQgPSBEYXRlLm5vdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gZXZpY3RcbiAgICBpZiAodGhpcy5jYWNoZS5zaXplID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgdGhpcy5ldmljdExlYXN0UmVjZW50bHlVc2VkKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZW50cnk6IENhY2hlRW50cnk8VD4gPSB7XG4gICAgICB2YWx1ZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIGFjY2Vzc0NvdW50OiAxLFxuICAgICAgbGFzdEFjY2Vzc2VkOiBEYXRlLm5vdygpLFxuICAgIH07XG5cbiAgICB0aGlzLmNhY2hlLnNldChrZXksIGVudHJ5KTtcbiAgICB0aGlzLmFjY2Vzc09yZGVyLnB1c2goa2V5KTtcbiAgICB0aGlzLnN0YXRzLnNpemUgPSB0aGlzLmNhY2hlLnNpemU7XG4gIH1cblxuICBwcml2YXRlIGRlbGV0ZShrZXk6IHN0cmluZywgcmVhc29uOiBcInNpemVcIiB8IFwidHRsXCIpOiBib29sZWFuIHtcbiAgICBjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmFjY2Vzc09yZGVyLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzT3JkZXIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdHMuZXZpY3Rpb25zKys7XG4gICAgICB0aGlzLnN0YXRzLnNpemUgPSB0aGlzLmNhY2hlLnNpemU7XG4gICAgICB0aGlzLmNvbmZpZy5vbkNhY2hlRXZpY3Q/LihrZXksIHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBldmljdExlYXN0UmVjZW50bHlVc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmFjY2Vzc09yZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxydUtleSA9IHRoaXMuYWNjZXNzT3JkZXJbMF07XG4gICAgICB0aGlzLmRlbGV0ZShscnVLZXksIFwic2l6ZVwiKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhpdFJhdGUoKTogdm9pZCB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLnN0YXRzLmhpdHMgKyB0aGlzLnN0YXRzLm1pc3NlcztcbiAgICB0aGlzLnN0YXRzLmhpdFJhdGUgPSB0b3RhbCA+IDAgPyAodGhpcy5zdGF0cy5oaXRzIC8gdG90YWwpICogMTAwIDogMDtcbiAgfVxuXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLmFjY2Vzc09yZGVyID0gW107XG4gICAgdGhpcy5zdGF0cyA9IHsgaGl0czogMCwgbWlzc2VzOiAwLCBldmljdGlvbnM6IDAsIHNpemU6IDAsIGhpdFJhdGU6IDAgfTtcbiAgfVxuXG4gIGdldFN0YXRzKCk6IENhY2hlU3RhdHMge1xuICAgIHJldHVybiB7IC4uLnRoaXMuc3RhdHMgfTtcbiAgfVxuXG4gIC8vIENsZWFuIGV4cGlyZWQgZW50cmllc1xuICBjbGVhbnVwKCk6IG51bWJlciB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgY2xlYW5lZCA9IDA7XG5cbiAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLmVudHJpZXMoKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgZW50cmllcykge1xuICAgICAgaWYgKG5vdyAtIGVudHJ5LnRpbWVzdGFtcCA+IHRoaXMudHRsKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKGtleSwgXCJ0dGxcIik7XG4gICAgICAgIGNsZWFuZWQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxufVxuXG4vLyBHbG9iYWwgY2FjaGUgaW5zdGFuY2VzXG5jb25zdCBjb21wb25lbnRDYWNoZSA9IG5ldyBBZHZhbmNlZENhY2hlPGFueT4oMjAwLCAxMCAqIDYwICogMTAwMCk7IC8vIDEwIG1pbnV0ZXNcbmNvbnN0IGNvbXB1dGF0aW9uQ2FjaGUgPSBuZXcgQWR2YW5jZWRDYWNoZTxhbnk+KDUwMCwgNSAqIDYwICogMTAwMCk7IC8vIDUgbWludXRlc1xuXG4vLyBFbmhhbmNlZCB1c2VNZW1vIHdpdGggY2FjaGluZ1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFkdmFuY2VkTWVtbzxUPihcbiAgZmFjdG9yeTogKCkgPT4gVCxcbiAgZGVwczogRGVwZW5kZW5jeUxpc3QsXG4gIGNhY2hlS2V5Pzogc3RyaW5nLFxuKTogVCB7XG4gIGNvbnN0IGtleSA9IGNhY2hlS2V5IHx8IGBtZW1vXyR7SlNPTi5zdHJpbmdpZnkoZGVwcyl9YDtcblxuICAvLyBVc2UgYSBtb3JlIHN0YWJsZSBkZXBlbmRlbmN5IGFwcHJvYWNoIC0gc2VyaWFsaXplIGRlcHMgdG8gZW5zdXJlIGNvbnNpc3RlbmN5XG4gIGNvbnN0IGRlcHNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkZXBzKTtcblxuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgLy8gVHJ5IHRvIGdldCBmcm9tIGNhY2hlIGZpcnN0XG4gICAgY29uc3QgY2FjaGVkID0gY29tcHV0YXRpb25DYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBuZXcgdmFsdWVcbiAgICBjb25zdCByZXN1bHQgPSBmYWN0b3J5KCk7XG5cbiAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XG4gICAgY29tcHV0YXRpb25DYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtmYWN0b3J5LCBrZXksIGRlcHNTdHJpbmddKTtcbn1cblxuLy8gRW5oYW5jZWQgdXNlQ2FsbGJhY2sgd2l0aCBjYWNoaW5nXG5leHBvcnQgZnVuY3Rpb24gdXNlQWR2YW5jZWRDYWxsYmFjazxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICBjYWxsYmFjazogVCxcbiAgZGVwczogRGVwZW5kZW5jeUxpc3QsXG4gIGNhY2hlS2V5Pzogc3RyaW5nLFxuKTogVCB7XG4gIGNvbnN0IGtleSA9IGNhY2hlS2V5IHx8IGBjYWxsYmFja18ke0pTT04uc3RyaW5naWZ5KGRlcHMpfWA7XG5cbiAgLy8gVXNlIGEgbW9yZSBzdGFibGUgZGVwZW5kZW5jeSBhcHByb2FjaCAtIHNlcmlhbGl6ZSBkZXBzIHRvIGVuc3VyZSBjb25zaXN0ZW5jeVxuICBjb25zdCBkZXBzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGVwcyk7XG5cbiAgcmV0dXJuIHVzZUNhbGxiYWNrKFxuICAgICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgY29uc3QgYXJnS2V5ID0gYCR7a2V5fV8ke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWA7XG5cbiAgICAgIC8vIFRyeSB0byBnZXQgZnJvbSBjYWNoZVxuICAgICAgY29uc3QgY2FjaGVkID0gY29tcHV0YXRpb25DYWNoZS5nZXQoYXJnS2V5KTtcbiAgICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgfVxuXG4gICAgICAvLyBFeGVjdXRlIGNhbGxiYWNrXG4gICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayguLi5hcmdzKTtcblxuICAgICAgLy8gQ2FjaGUgcmVzdWx0IGlmIGl0J3Mgc2VyaWFsaXphYmxlXG4gICAgICB0cnkge1xuICAgICAgICBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBjb21wdXRhdGlvbkNhY2hlLnNldChhcmdLZXksIHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gRG9uJ3QgY2FjaGUgbm9uLXNlcmlhbGl6YWJsZSByZXN1bHRzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSxcbiAgICBbY2FsbGJhY2ssIGtleSwgZGVwc1N0cmluZ10sXG4gICkgYXMgVDtcbn1cblxuLy8gU21hcnQgY29tcG9uZW50IG1lbW9pemF0aW9uXG5leHBvcnQgZnVuY3Rpb24gc21hcnRNZW1vPFAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihcbiAgQ29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPFA+LFxuICBjb25maWc6IE1lbW9pemF0aW9uQ29uZmlnID0ge30sXG4pOiBSZWFjdC5NZW1vRXhvdGljQ29tcG9uZW50PFJlYWN0LkNvbXBvbmVudFR5cGU8UD4+IHtcbiAgY29uc3Qge1xuICAgIGtleUdlbmVyYXRvciA9IChwcm9wczogUCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvcHMpLFxuICAgIG1heENhY2hlU2l6ZSA9IDUwLFxuICAgIHR0bCA9IDUgKiA2MCAqIDEwMDAsXG4gIH0gPSBjb25maWc7XG5cbiAgY29uc3QgY2FjaGUgPSBuZXcgQWR2YW5jZWRDYWNoZTxSZWFjdC5SZWFjdEVsZW1lbnQ+KFxuICAgIG1heENhY2hlU2l6ZSxcbiAgICB0dGwsXG4gICAgY29uZmlnLFxuICApO1xuXG4gIGNvbnN0IE1lbW9pemVkQ29tcG9uZW50ID0gbWVtbyhcbiAgICAocHJvcHM6IFApID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGtleUdlbmVyYXRvcihwcm9wcyk7XG5cbiAgICAgIC8vIFRyeSBjYWNoZSBmaXJzdFxuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBuZXdcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgcHJvcHMpO1xuICAgICAgY2FjaGUuc2V0KGtleSwgZWxlbWVudCk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0sXG4gICAgKHByZXZQcm9wcywgbmV4dFByb3BzKSA9PiB7XG4gICAgICAvLyBDdXN0b20gY29tcGFyaXNvbiBiYXNlZCBvbiBnZW5lcmF0ZWQga2V5c1xuICAgICAgY29uc3QgcHJldktleSA9IGtleUdlbmVyYXRvcihwcmV2UHJvcHMpO1xuICAgICAgY29uc3QgbmV4dEtleSA9IGtleUdlbmVyYXRvcihuZXh0UHJvcHMpO1xuICAgICAgcmV0dXJuIHByZXZLZXkgPT09IG5leHRLZXk7XG4gICAgfSxcbiAgKTtcblxuICBNZW1vaXplZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGBTbWFydE1lbW8oJHtDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIn0pYDtcblxuICByZXR1cm4gTWVtb2l6ZWRDb21wb25lbnQ7XG59XG5cbi8vIEJhdGNoZWQgc3RhdGUgdXBkYXRlcyB1dGlsaXR5XG5leHBvcnQgZnVuY3Rpb24gdXNlQmF0Y2hlZFVwZGF0ZXM8VD4oXG4gIGluaXRpYWxTdGF0ZTogVCxcbiAgYmF0Y2hEZWxheTogbnVtYmVyID0gMTYsIC8vIE9uZSBmcmFtZVxuKTogW1QsICh1cGRhdGVyOiBUIHwgKChwcmV2OiBUKSA9PiBUKSkgPT4gdm9pZCwgKCkgPT4gdm9pZF0ge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IGJhdGNoUmVmID0gdXNlUmVmPHtcbiAgICB1cGRhdGVzOiBBcnJheTxUIHwgKChwcmV2OiBUKSA9PiBUKT47XG4gICAgdGltZW91dElkPzogTm9kZUpTLlRpbWVvdXQ7XG4gIH0+KHsgdXBkYXRlczogW10gfSk7XG5cbiAgY29uc3QgZmx1c2hVcGRhdGVzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChiYXRjaFJlZi5jdXJyZW50LnVwZGF0ZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCB1cGRhdGVzID0gWy4uLmJhdGNoUmVmLmN1cnJlbnQudXBkYXRlc107XG4gICAgYmF0Y2hSZWYuY3VycmVudC51cGRhdGVzID0gW107XG5cbiAgICBzZXRTdGF0ZSgocHJldlN0YXRlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFN0YXRlID0gcHJldlN0YXRlO1xuICAgICAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY3VycmVudFN0YXRlID0gKHVwZGF0ZSBhcyAocHJldjogVCkgPT4gVCkoY3VycmVudFN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50U3RhdGUgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gICAgfSk7XG5cbiAgICBpZiAoYmF0Y2hSZWYuY3VycmVudC50aW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChiYXRjaFJlZi5jdXJyZW50LnRpbWVvdXRJZCk7XG4gICAgICBiYXRjaFJlZi5jdXJyZW50LnRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBiYXRjaGVkU2V0U3RhdGUgPSB1c2VDYWxsYmFjayhcbiAgICAodXBkYXRlcjogVCB8ICgocHJldjogVCkgPT4gVCkpID0+IHtcbiAgICAgIGJhdGNoUmVmLmN1cnJlbnQudXBkYXRlcy5wdXNoKHVwZGF0ZXIpO1xuXG4gICAgICBpZiAoYmF0Y2hSZWYuY3VycmVudC50aW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGJhdGNoUmVmLmN1cnJlbnQudGltZW91dElkKTtcbiAgICAgIH1cblxuICAgICAgYmF0Y2hSZWYuY3VycmVudC50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoVXBkYXRlcywgYmF0Y2hEZWxheSk7XG4gICAgfSxcbiAgICBbZmx1c2hVcGRhdGVzLCBiYXRjaERlbGF5XSxcbiAgKTtcblxuICBjb25zdCBmb3JjZUZsdXNoID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChiYXRjaFJlZi5jdXJyZW50LnRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGJhdGNoUmVmLmN1cnJlbnQudGltZW91dElkKTtcbiAgICAgIGJhdGNoUmVmLmN1cnJlbnQudGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmbHVzaFVwZGF0ZXMoKTtcbiAgfSwgW2ZsdXNoVXBkYXRlc10pO1xuXG4gIC8vIENsZWFudXAgb24gdW5tb3VudFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGJhdGNoUmVmQ3VycmVudCA9IGJhdGNoUmVmLmN1cnJlbnQ7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChiYXRjaFJlZkN1cnJlbnQ/LnRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoYmF0Y2hSZWZDdXJyZW50LnRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBbc3RhdGUsIGJhdGNoZWRTZXRTdGF0ZSwgZm9yY2VGbHVzaF07XG59XG5cbi8vIFBlcmZvcm1hbmNlLW9wdGltaXplZCBsaXN0IHJlbmRlcmVyXG5leHBvcnQgZnVuY3Rpb24gdXNlVmlydHVhbGl6ZWRMaXN0PFQ+KFxuICBpdGVtczogVFtdLFxuICByZW5kZXJJdGVtOiAoaXRlbTogVCwgaW5kZXg6IG51bWJlcikgPT4gUmVhY3QuUmVhY3ROb2RlLFxuICBjb25maWc6IHtcbiAgICBpdGVtSGVpZ2h0OiBudW1iZXI7XG4gICAgY29udGFpbmVySGVpZ2h0OiBudW1iZXI7XG4gICAgb3ZlcnNjYW4/OiBudW1iZXI7XG4gICAgY2FjaGVTaXplPzogbnVtYmVyO1xuICB9LFxuKSB7XG4gIGNvbnN0IHsgaXRlbUhlaWdodCwgY29udGFpbmVySGVpZ2h0LCBvdmVyc2NhbiA9IDUsIGNhY2hlU2l6ZSA9IDEwMCB9ID0gY29uZmlnO1xuXG4gIGNvbnN0IFtzY3JvbGxUb3AsIHNldFNjcm9sbFRvcF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgY2FjaGUgPSB1c2VSZWYobmV3IEFkdmFuY2VkQ2FjaGU8UmVhY3QuUmVhY3ROb2RlPihjYWNoZVNpemUpKTtcblxuICBjb25zdCB2aXNpYmxlUmFuZ2UgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3Ioc2Nyb2xsVG9wIC8gaXRlbUhlaWdodCk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4oXG4gICAgICBpdGVtcy5sZW5ndGggLSAxLFxuICAgICAgTWF0aC5jZWlsKChzY3JvbGxUb3AgKyBjb250YWluZXJIZWlnaHQpIC8gaXRlbUhlaWdodCksXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogTWF0aC5tYXgoMCwgc3RhcnQgLSBvdmVyc2NhbiksXG4gICAgICBlbmQ6IE1hdGgubWluKGl0ZW1zLmxlbmd0aCAtIDEsIGVuZCArIG92ZXJzY2FuKSxcbiAgICB9O1xuICB9LCBbc2Nyb2xsVG9wLCBpdGVtSGVpZ2h0LCBjb250YWluZXJIZWlnaHQsIGl0ZW1zLmxlbmd0aCwgb3ZlcnNjYW5dKTtcblxuICBjb25zdCB2aXNpYmxlSXRlbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCByZW5kZXJlZDogQXJyYXk8eyBpdGVtOiBUOyBpbmRleDogbnVtYmVyOyBub2RlOiBSZWFjdC5SZWFjdE5vZGUgfT4gPVxuICAgICAgW107XG5cbiAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLnN0YXJ0OyBpIDw9IHZpc2libGVSYW5nZS5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBgaXRlbV8ke2l9XyR7SlNPTi5zdHJpbmdpZnkoaXRlbSl9YDtcblxuICAgICAgbGV0IG5vZGUgPSBjYWNoZS5jdXJyZW50LmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgbm9kZSA9IHJlbmRlckl0ZW0oaXRlbSwgaSk7XG4gICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNhY2hlS2V5LCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZWQucHVzaCh7IGl0ZW0sIGluZGV4OiBpLCBub2RlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZDtcbiAgfSwgW2l0ZW1zLCB2aXNpYmxlUmFuZ2UsIHJlbmRlckl0ZW1dKTtcblxuICBjb25zdCBoYW5kbGVTY3JvbGwgPSB1c2VDYWxsYmFjaygoZXZlbnQ6IFJlYWN0LlVJRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgc2V0U2Nyb2xsVG9wKGV2ZW50LmN1cnJlbnRUYXJnZXQuc2Nyb2xsVG9wKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgdmlzaWJsZUl0ZW1zLFxuICAgIHRvdGFsSGVpZ2h0OiBpdGVtcy5sZW5ndGggKiBpdGVtSGVpZ2h0LFxuICAgIG9mZnNldFk6IHZpc2libGVSYW5nZS5zdGFydCAqIGl0ZW1IZWlnaHQsXG4gICAgaGFuZGxlU2Nyb2xsLFxuICAgIGNhY2hlU3RhdHM6IGNhY2hlLmN1cnJlbnQuZ2V0U3RhdHMoKSxcbiAgfTtcbn1cblxuLy8gQ2FjaGUgbWFuYWdlbWVudCB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBjYWNoZU1hbmFnZXIgPSB7XG4gIGdldENvbXBvbmVudENhY2hlU3RhdHM6ICgpID0+IGNvbXBvbmVudENhY2hlLmdldFN0YXRzKCksXG4gIGdldENvbXB1dGF0aW9uQ2FjaGVTdGF0czogKCkgPT4gY29tcHV0YXRpb25DYWNoZS5nZXRTdGF0cygpLFxuICBjbGVhckNvbXBvbmVudENhY2hlOiAoKSA9PiBjb21wb25lbnRDYWNoZS5jbGVhcigpLFxuICBjbGVhckNvbXB1dGF0aW9uQ2FjaGU6ICgpID0+IGNvbXB1dGF0aW9uQ2FjaGUuY2xlYXIoKSxcbiAgY2xlYW51cEV4cGlyZWQ6ICgpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRDbGVhbmVkID0gY29tcG9uZW50Q2FjaGUuY2xlYW51cCgpO1xuICAgIGNvbnN0IGNvbXB1dGF0aW9uQ2xlYW5lZCA9IGNvbXB1dGF0aW9uQ2FjaGUuY2xlYW51cCgpO1xuICAgIHJldHVybiB7IGNvbXBvbmVudENsZWFuZWQsIGNvbXB1dGF0aW9uQ2xlYW5lZCB9O1xuICB9LFxuICBnZXRUb3RhbENhY2hlU3RhdHM6ICgpID0+IHtcbiAgICBjb25zdCBjb21wU3RhdHMgPSBjb21wb25lbnRDYWNoZS5nZXRTdGF0cygpO1xuICAgIGNvbnN0IGNvbXB1U3RhdHMgPSBjb21wdXRhdGlvbkNhY2hlLmdldFN0YXRzKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxIaXRzOiBjb21wU3RhdHMuaGl0cyArIGNvbXB1U3RhdHMuaGl0cyxcbiAgICAgIHRvdGFsTWlzc2VzOiBjb21wU3RhdHMubWlzc2VzICsgY29tcHVTdGF0cy5taXNzZXMsXG4gICAgICB0b3RhbEV2aWN0aW9uczogY29tcFN0YXRzLmV2aWN0aW9ucyArIGNvbXB1U3RhdHMuZXZpY3Rpb25zLFxuICAgICAgdG90YWxTaXplOiBjb21wU3RhdHMuc2l6ZSArIGNvbXB1U3RhdHMuc2l6ZSxcbiAgICAgIGF2ZXJhZ2VIaXRSYXRlOiAoY29tcFN0YXRzLmhpdFJhdGUgKyBjb21wdVN0YXRzLmhpdFJhdGUpIC8gMixcbiAgICB9O1xuICB9LFxufTtcblxuLy8gUGVyZm9ybWFuY2UgZGVidWdnaW5nIHV0aWxpdGllc1xuZXhwb3J0IGNvbnN0IHBlcmZvcm1hbmNlRGVidWdnZXIgPSB7XG4gIGxvZ0NhY2hlU3RhdHM6ICgpID0+IHtcbiAgICBjb25zb2xlLmdyb3VwKFwi8J+agCBQZXJmb3JtYW5jZSBDYWNoZSBTdGF0c1wiKTtcbiAgICBjb25zb2xlLnRhYmxlKGNhY2hlTWFuYWdlci5nZXRUb3RhbENhY2hlU3RhdHMoKSk7XG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xuICB9LFxuXG4gIG1lYXN1cmVSZW5kZXJUaW1lOiA8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgICBmbjogVCxcbiAgICBsYWJlbDogc3RyaW5nID0gXCJSZW5kZXJcIixcbiAgKTogVCA9PiB7XG4gICAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc29sZS5sb2coYOKPse+4jyAke2xhYmVsfTogJHsoZW5kIC0gc3RhcnQpLnRvRml4ZWQoMil9bXNgKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkgYXMgVDtcbiAgfSxcblxuICBwcm9maWxlQ29tcG9uZW50OiA8UCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+KFxuICAgIENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxQPixcbiAgICBjb21wb25lbnROYW1lOiBzdHJpbmcsXG4gICkgPT4ge1xuICAgIGNvbnN0IFByb2ZpbGVkQ29tcG9uZW50ID0gbWVtbygocHJvcHM6IFApID0+IHtcbiAgICAgIGNvbnN0IHJlbmRlclN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbmRlckVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBg8J+UjSAke2NvbXBvbmVudE5hbWV9IHJlbmRlcmVkIGluICR7KHJlbmRlckVuZCAtIHJlbmRlclN0YXJ0KS50b0ZpeGVkKDIpfW1zYCxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKTtcbiAgICB9KTtcblxuICAgIFByb2ZpbGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gYFByb2ZpbGVkKCR7Y29tcG9uZW50TmFtZX0pYDtcblxuICAgIHJldHVybiBQcm9maWxlZENvbXBvbmVudDtcbiAgfSxcbn07XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbiJdLCJuYW1lcyI6WyJBZHZhbmNlZENhY2hlIiwiY2FjaGVNYW5hZ2VyIiwicGVyZm9ybWFuY2VEZWJ1Z2dlciIsInNtYXJ0TWVtbyIsInVzZUFkdmFuY2VkQ2FsbGJhY2siLCJ1c2VBZHZhbmNlZE1lbW8iLCJ1c2VCYXRjaGVkVXBkYXRlcyIsInVzZVZpcnR1YWxpemVkTGlzdCIsImNvbnN0cnVjdG9yIiwibWF4U2l6ZSIsInR0bCIsImNvbmZpZyIsImNhY2hlIiwiTWFwIiwiYWNjZXNzT3JkZXIiLCJzdGF0cyIsImhpdHMiLCJtaXNzZXMiLCJldmljdGlvbnMiLCJzaXplIiwiaGl0UmF0ZSIsImdldCIsImtleSIsImVudHJ5Iiwib25DYWNoZU1pc3MiLCJ1cGRhdGVIaXRSYXRlIiwidW5kZWZpbmVkIiwiRGF0ZSIsIm5vdyIsInRpbWVzdGFtcCIsImRlbGV0ZSIsImFjY2Vzc0NvdW50IiwibGFzdEFjY2Vzc2VkIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicHVzaCIsIm9uQ2FjaGVIaXQiLCJ2YWx1ZSIsInNldCIsImV4aXN0aW5nIiwiZXZpY3RMZWFzdFJlY2VudGx5VXNlZCIsInJlYXNvbiIsImRlbGV0ZWQiLCJvbkNhY2hlRXZpY3QiLCJsZW5ndGgiLCJscnVLZXkiLCJ0b3RhbCIsImNsZWFyIiwiZ2V0U3RhdHMiLCJjbGVhbnVwIiwiY2xlYW5lZCIsImVudHJpZXMiLCJBcnJheSIsImZyb20iLCJjb21wb25lbnRDYWNoZSIsImNvbXB1dGF0aW9uQ2FjaGUiLCJmYWN0b3J5IiwiZGVwcyIsImNhY2hlS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRlcHNTdHJpbmciLCJ1c2VNZW1vIiwiY2FjaGVkIiwicmVzdWx0IiwiY2FsbGJhY2siLCJ1c2VDYWxsYmFjayIsImFyZ3MiLCJhcmdLZXkiLCJDb21wb25lbnQiLCJrZXlHZW5lcmF0b3IiLCJwcm9wcyIsIm1heENhY2hlU2l6ZSIsIk1lbW9pemVkQ29tcG9uZW50IiwibWVtbyIsImVsZW1lbnQiLCJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJwcmV2UHJvcHMiLCJuZXh0UHJvcHMiLCJwcmV2S2V5IiwibmV4dEtleSIsImRpc3BsYXlOYW1lIiwibmFtZSIsImluaXRpYWxTdGF0ZSIsImJhdGNoRGVsYXkiLCJzdGF0ZSIsInNldFN0YXRlIiwidXNlU3RhdGUiLCJiYXRjaFJlZiIsInVzZVJlZiIsInVwZGF0ZXMiLCJmbHVzaFVwZGF0ZXMiLCJjdXJyZW50IiwicHJldlN0YXRlIiwiY3VycmVudFN0YXRlIiwidXBkYXRlIiwidGltZW91dElkIiwiY2xlYXJUaW1lb3V0IiwiYmF0Y2hlZFNldFN0YXRlIiwidXBkYXRlciIsInNldFRpbWVvdXQiLCJmb3JjZUZsdXNoIiwidXNlRWZmZWN0IiwiYmF0Y2hSZWZDdXJyZW50IiwiaXRlbXMiLCJyZW5kZXJJdGVtIiwiaXRlbUhlaWdodCIsImNvbnRhaW5lckhlaWdodCIsIm92ZXJzY2FuIiwiY2FjaGVTaXplIiwic2Nyb2xsVG9wIiwic2V0U2Nyb2xsVG9wIiwidmlzaWJsZVJhbmdlIiwic3RhcnQiLCJNYXRoIiwiZmxvb3IiLCJlbmQiLCJtaW4iLCJjZWlsIiwibWF4IiwidmlzaWJsZUl0ZW1zIiwicmVuZGVyZWQiLCJpIiwiaXRlbSIsIm5vZGUiLCJoYW5kbGVTY3JvbGwiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJ0b3RhbEhlaWdodCIsIm9mZnNldFkiLCJjYWNoZVN0YXRzIiwiZ2V0Q29tcG9uZW50Q2FjaGVTdGF0cyIsImdldENvbXB1dGF0aW9uQ2FjaGVTdGF0cyIsImNsZWFyQ29tcG9uZW50Q2FjaGUiLCJjbGVhckNvbXB1dGF0aW9uQ2FjaGUiLCJjbGVhbnVwRXhwaXJlZCIsImNvbXBvbmVudENsZWFuZWQiLCJjb21wdXRhdGlvbkNsZWFuZWQiLCJnZXRUb3RhbENhY2hlU3RhdHMiLCJjb21wU3RhdHMiLCJjb21wdVN0YXRzIiwidG90YWxIaXRzIiwidG90YWxNaXNzZXMiLCJ0b3RhbEV2aWN0aW9ucyIsInRvdGFsU2l6ZSIsImF2ZXJhZ2VIaXRSYXRlIiwibG9nQ2FjaGVTdGF0cyIsImNvbnNvbGUiLCJncm91cCIsInRhYmxlIiwiZ3JvdXBFbmQiLCJtZWFzdXJlUmVuZGVyVGltZSIsImZuIiwibGFiZWwiLCJwZXJmb3JtYW5jZSIsImxvZyIsInRvRml4ZWQiLCJwcm9maWxlQ29tcG9uZW50IiwiY29tcG9uZW50TmFtZSIsIlByb2ZpbGVkQ29tcG9uZW50IiwicmVuZGVyU3RhcnQiLCJyZW5kZXJFbmQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7SUE4QmFBLGFBQWE7ZUFBYkE7O0lBZ1lBQyxZQUFZO2VBQVpBOztJQXlCQUMsbUJBQW1CO2VBQW5CQTs7SUExTUdDLFNBQVM7ZUFBVEE7O0lBdkNBQyxtQkFBbUI7ZUFBbkJBOztJQTdCQUMsZUFBZTtlQUFmQTs7SUFrSEFDLGlCQUFpQjtlQUFqQkE7O0lBcUVBQyxrQkFBa0I7ZUFBbEJBOzs7K0RBOVZPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QmhCLE1BQU1QO0lBV1hRLFlBQ0UsQUFBUUMsVUFBa0IsR0FBRyxFQUM3QixBQUFRQyxNQUFjLElBQUksS0FBSyxJQUFJLEVBQ25DLEFBQVFDLFNBQTRCLENBQUMsQ0FBQyxDQUN0QzthQUhRRixVQUFBQTthQUNBQyxNQUFBQTthQUNBQyxTQUFBQTthQWJGQyxRQUFRLElBQUlDO2FBQ1pDLGNBQXdCLEVBQUU7YUFDMUJDLFFBQW9CO1lBQzFCQyxNQUFNO1lBQ05DLFFBQVE7WUFDUkMsV0FBVztZQUNYQyxNQUFNO1lBQ05DLFNBQVM7UUFDWDtJQU1HO0lBRUhDLElBQUlDLEdBQVcsRUFBaUI7UUFDOUIsTUFBTUMsUUFBUSxJQUFJLENBQUNYLEtBQUssQ0FBQ1MsR0FBRyxDQUFDQztRQUU3QixJQUFJLENBQUNDLE9BQU87WUFDVixJQUFJLENBQUNSLEtBQUssQ0FBQ0UsTUFBTTtZQUNqQixJQUFJLENBQUNOLE1BQU0sQ0FBQ2EsV0FBVyxHQUFHRjtZQUMxQixJQUFJLENBQUNHLGFBQWE7WUFDbEIsT0FBT0M7UUFDVDtRQUVBLFlBQVk7UUFDWixJQUFJQyxLQUFLQyxHQUFHLEtBQUtMLE1BQU1NLFNBQVMsR0FBRyxJQUFJLENBQUNuQixHQUFHLEVBQUU7WUFDM0MsSUFBSSxDQUFDb0IsTUFBTSxDQUFDUixLQUFLO1lBQ2pCLElBQUksQ0FBQ1AsS0FBSyxD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