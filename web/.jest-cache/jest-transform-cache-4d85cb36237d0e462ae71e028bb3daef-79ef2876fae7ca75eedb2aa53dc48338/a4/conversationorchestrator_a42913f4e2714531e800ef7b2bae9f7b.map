{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/conversation-orchestrator.ts"],"sourcesContent":["import type { Agent, Conversation, Message, KnowledgeEntry } from \"@/lib/types\";\nimport { KnowledgeRetriever } from \"@/lib/knowledge-retriever\";\nimport { LLMClient } from \"@/lib/llm-client\";\nimport { LLMSecureClient } from \"@/lib/llm-secure-client\";\nimport { ConversationLogger } from \"@/lib/conversation-logger\";\nimport { debugLog } from \"@/lib/debug-logger\";\n\ntype LLMClientType = LLMClient | LLMSecureClient;\n\nexport interface ResponseOptions {\n  maxKnowledgeEntries?: number;\n  includeAgentKnowledge?: boolean;\n  includeTags?: string[];\n  streamResponse?: boolean;\n  onChunk?: (text: string, isComplete: boolean) => void;\n  onMessageGenerated?: (message: Message) => void; // Callback for when a message is generated\n  messageToRespondTo?: Message; // Specific message to respond to\n  responseDelay?: number; // Override the default response delay\n  force?: boolean; // Force the agent to respond regardless of dynamics\n}\n\nexport interface OrchestratorOptions {\n  maxConcurrentResponses?: number;\n  responseDelay?: number | [number, number]; // Fixed delay or [min, max] range\n  autoSelectRespondents?: boolean;\n  onMessageGenerated?: (message: Message) => void; // Global callback for when a message is generated\n  onError?: (error: Error) => void; // Callback for errors\n}\n\n// Interface for queued response\ninterface QueuedResponse {\n  agentId: string;\n  messageId: string; // ID of the message to respond to\n  options: ResponseOptions;\n}\n\nexport class ConversationOrchestrator {\n  private conversation: Conversation;\n  private agents: Map<string, Agent>;\n  private llmClient: LLMClientType;\n  private knowledgeRetriever: KnowledgeRetriever;\n  private options: OrchestratorOptions;\n  private responseQueue: QueuedResponse[] = [];\n  private processingAgents: Set<string> = new Set();\n  private lastProcessedMessageId: string | null = null;\n  private messageCache: Map<string, Message> = new Map(); // Cache messages to handle race conditions\n  private queueProcessorInterval: NodeJS.Timeout | null = null;\n  private isProcessingQueue = false;\n  private logger: ReturnType<typeof ConversationLogger.init>;\n\n  constructor(\n    conversation: Conversation,\n    agents: Agent[],\n    llmClient: LLMClientType,\n    knowledgeRetriever: KnowledgeRetriever,\n    options: OrchestratorOptions = {},\n  ) {\n    this.logger = ConversationLogger.init(conversation.id);\n    // /* USEFUL FOR PRODUCTION TESTING: Log orchestrator initialization */\n    // this.logger.log(\"INIT\", \"ConversationOrchestrator constructor called\", {\n    //   conversationId: conversation.id,\n    //   agentsCount: agents.length,\n    //   llmClientAvailable: !!llmClient,\n    // })\n\n    this.conversation = conversation;\n    this.agents = new Map(agents.map((agent) => [agent.id, agent]));\n    this.llmClient = llmClient;\n    this.knowledgeRetriever = knowledgeRetriever;\n    this.options = {\n      maxConcurrentResponses: 1,\n      responseDelay: [500, 2000], // Random delay between 500ms and 2000ms\n      autoSelectRespondents: true,\n      ...options,\n    };\n\n    // Initialize lastProcessedMessageId if there are messages\n    if (conversation.messages.length > 0) {\n      this.lastProcessedMessageId =\n        conversation.messages[conversation.messages.length - 1].id;\n      // /* USEFUL FOR PRODUCTION TESTING: Log last processed message ID */\n      // this.logger.log(\"INIT\", \"Set last processed message ID\", {\n      //   messageId: this.lastProcessedMessageId,\n      // })\n    }\n\n    // Initialize message cache with current messages\n    this.updateMessageCache(conversation.messages);\n    // /* USEFUL FOR PRODUCTION TESTING: Log message cache initialization */\n    // this.logger.log(\"INIT\", \"Initialized message cache with existing messages\", {\n    //   messageCount: conversation.messages.length,\n    // })\n\n    // Start queue processor\n    this.startQueueProcessor();\n    // /* USEFUL FOR PRODUCTION TESTING: Log queue processor start */\n    // this.logger.log(\"INIT\", \"Started queue processor\")\n  }\n\n  /**\n   * Starts the queue processor interval\n   */\n  private startQueueProcessor(): void {\n    // Clear any existing interval\n    if (this.queueProcessorInterval) {\n      clearInterval(this.queueProcessorInterval);\n    }\n\n    // Process the queue every 100ms\n    this.queueProcessorInterval = setInterval(() => {\n      this.processQueue();\n    }, 100);\n  }\n\n  /**\n   * Updates the message cache with new messages\n   */\n  private updateMessageCache(messages: Message[]): void {\n    messages.forEach((message) => {\n      this.messageCache.set(message.id, message);\n    });\n  }\n\n  /**\n   * Updates the conversation reference\n   */\n  updateConversation(conversation: Conversation): void {\n    // /* USEFUL FOR PRODUCTION TESTING: Log conversation update */\n    // this.logger.log(\"UPDATE\", \"Updating conversation reference\", {\n    //   oldMessageCount: this.conversation.messages.length,\n    //   newMessageCount: conversation.messages.length,\n    // })\n\n    // Update message cache with any new messages\n    this.updateMessageCache(conversation.messages);\n\n    this.conversation = conversation;\n\n    // Update lastProcessedMessageId if there are new messages\n    if (conversation.messages.length > 0) {\n      const latestMessageId =\n        conversation.messages[conversation.messages.length - 1].id;\n      if (this.lastProcessedMessageId !== latestMessageId) {\n        // Only update if we're not currently processing this message\n        const isBeingProcessed =\n          this.responseQueue.some(\n            (item) => item.messageId === latestMessageId,\n          ) ||\n          Array.from(this.processingAgents).some((agentId) =>\n            this.responseQueue.some(\n              (item) =>\n                item.agentId === agentId && item.messageId === latestMessageId,\n            ),\n          );\n\n        if (!isBeingProcessed) {\n          this.lastProcessedMessageId = latestMessageId;\n          // /* USEFUL FOR PRODUCTION TESTING: Log last processed message ID update */\n          // this.logger.log(\"UPDATE\", \"Updated last processed message ID\", {\n          //   messageId: this.lastProcessedMessageId,\n          // })\n        }\n      }\n    }\n  }\n\n  /**\n   * Updates the agents map\n   */\n  updateAgents(agents: Agent[]): void {\n    // /* USEFUL FOR PRODUCTION TESTING: Log agents update */\n    // this.logger.log(\"UPDATE\", \"Updating agents\", {\n    //   oldAgentCount: this.agents.size,\n    //   newAgentCount: agents.length,\n    // })\n    this.agents = new Map(agents.map((agent) => [agent.id, agent]));\n  }\n\n  /**\n   * Determines which agents should respond to a message\n   */\n  determineRespondents(message: Message): string[] {\n    // If not auto-selecting, return empty array (manual selection)\n    if (!this.options.autoSelectRespondents) {\n      return [];\n    }\n\n    // Get all agents in the conversation\n    const conversationAgents = this.conversation.participants\n      .map((id) => this.agents.get(id))\n      .filter((agent): agent is Agent => agent !== undefined);\n\n    // Skip the agent who sent the message\n    const eligibleAgents = conversationAgents.filter(\n      (agent) => agent.id !== message.senderId,\n    );\n\n    if (eligibleAgents.length === 0) {\n      return [];\n    }\n\n    // Check if this is an autonomous conversation\n    const isAutonomousConversation = this.conversation.isAutonomous === true;\n\n    if (isAutonomousConversation) {\n      // Count non-system messages\n      const messageCount = this.conversation.messages.filter(\n        (msg) => !msg.metadata?.isSystemMessage,\n      ).length;\n\n      // Get the LLM client settings\n      const settings = this.llmClient.getSettings();\n      const maxMessages = settings.maxAutonomousMessages || 10;\n\n      // If we've reached the maximum, end the conversation by returning no respondents\n      if (messageCount >= maxMessages) {\n        this.logger.log(\n          \"RESPONDENTS\",\n          `Maximum conversation depth reached (${messageCount}/${maxMessages}), no more responses`,\n        );\n        return [];\n      }\n\n      // For autonomous conversations, always have at least one agent respond\n      // Choose the agent who hasn't spoken most recently\n      if (eligibleAgents.length > 1) {\n        // Find the agent who hasn't spoken in the longest time\n        const agentLastSpokenMap = new Map<string, number>();\n\n        // Initialize all agents as never having spoken\n        eligibleAgents.forEach((agent) => {\n          agentLastSpokenMap.set(agent.id, -1);\n        });\n\n        // Update with the last time each agent spoke\n        for (let i = this.conversation.messages.length - 1; i >= 0; i--) {\n          const msg = this.conversation.messages[i];\n          if (\n            agentLastSpokenMap.has(msg.senderId) &&\n            agentLastSpokenMap.get(msg.senderId) === -1\n          ) {\n            agentLastSpokenMap.set(msg.senderId, i);\n          }\n        }\n\n        // Sort agents by who spoke least recently\n        const sortedAgents = [...agentLastSpokenMap.entries()]\n          .sort((a, b) => a[1] - b[1])\n          .map((entry) => entry[0]);\n\n        // Return the agent who hasn't spoken in the longest time\n        return [sortedAgents[0]];\n      }\n\n      return eligibleAgents.map((agent) => agent.id);\n    }\n\n    // CRITICAL FIX: Special handling for conversation starters\n    if (message.metadata?.type === \"conversation_starter\") {\n      this.logger.log(\n        \"RESPONDENTS\",\n        \"Determining respondents for conversation starter message\",\n        {\n          eligibleAgents: eligibleAgents.map((a) => a.name),\n        },\n      );\n\n      // All eligible agents should respond to conversation starters\n      return eligibleAgents.map((agent) => agent.id);\n    }\n\n    // UPDATED: Check for mentions anywhere in the message, not just at the beginning\n    // First, check for the traditional format at the beginning: \"Agent X, [message]\" or \"@Agent X [message]\"\n    const beginningMentionMatch = message.content.match(/^(?:@?(.+?),?\\s+)/i);\n    const directedToNameAtBeginning = beginningMentionMatch\n      ? beginningMentionMatch[1]\n      : null;\n\n    // Then, check for mentions anywhere in the message\n    const mentionedAgents = new Set<string>();\n\n    // If there's a mention at the beginning, add it\n    if (directedToNameAtBeginning) {\n      mentionedAgents.add(directedToNameAtBeginning.toLowerCase());\n    }\n\n    // Check for other mentions in the format \"Agent X\" or \"@Agent X\" throughout the message\n    const allMentionsRegex = /\\b@?([A-Za-z0-9]+(?:\\s+[A-Za-z0-9]+)*)\\b/g;\n    const allMatches = [...message.content.matchAll(allMentionsRegex)];\n\n    for (const match of allMatches) {\n      const potentialName = match[1];\n      // Check if this potential name matches any agent\n      for (const agent of eligibleAgents) {\n        if (\n          agent.name.toLowerCase() === potentialName.toLowerCase() ||\n          agent.name.toLowerCase().startsWith(potentialName.toLowerCase())\n        ) {\n          mentionedAgents.add(potentialName.toLowerCase());\n          break;\n        }\n      }\n    }\n\n    // If we found mentions, determine which agents should respond\n    if (mentionedAgents.size > 0) {\n      const matchedAgents = eligibleAgents.filter((agent) => {\n        const agentNameLower = agent.name.toLowerCase();\n        return Array.from(mentionedAgents).some(\n          (mentionedName) =>\n            agentNameLower === mentionedName ||\n            agentNameLower.startsWith(mentionedName),\n        );\n      });\n\n      if (matchedAgents.length) {\n        // /* USEFUL FOR PRODUCTION TESTING: Log mentioned agents */\n        // this.logger.log(\"RESPONDENTS\", \"Found mentioned agents\", {\n        //   mentions: Array.from(mentionedAgents),\n        //   matchedAgents: matchedAgents.map((a) => a.name),\n        // })\n        return matchedAgents.map((agent) => agent.id);\n      }\n    }\n\n    // For the first message, have all agents respond\n    if (this.conversation.messages.length <= 1) {\n      // /* USEFUL FOR PRODUCTION TESTING: Log first message response */\n      // this.logger.log(\"RESPONDENTS\", \"First message in conversation, all agents will respond\")\n      return eligibleAgents.map((agent) => agent.id);\n    }\n\n    // For other messages, have a random subset respond\n    const respondents = eligibleAgents\n      .filter(() => Math.random() > 0.3) // 70% chance each agent responds\n      .map((agent) => agent.id);\n\n    // /* USEFUL FOR PRODUCTION TESTING: Log random respondents */\n    // this.logger.log(\"RESPONDENTS\", \"Selected random subset of agents to respond\", {\n    //   respondentCount: respondents.length,\n    //   respondents: respondents.map((id) => this.agents.get(id)?.name || id),\n    // })\n\n    return respondents;\n  }\n\n  /**\n   * Queues an agent to generate a response to a specific message\n   */\n  queueAgentResponse(agentId: string, options: ResponseOptions = {}): void {\n    const agentLogger = ConversationLogger.agent(agentId);\n\n    // Verify agent exists and is in the conversation\n    const agent = this.agents.get(agentId);\n    if (!agent || !this.conversation.participants.includes(agentId)) {\n      agentLogger.error(\n        \"QUEUE\",\n        `Agent ${agentId} is not valid or not in the conversation`,\n      );\n      return;\n    }\n\n    // Check if there are any messages in the conversation\n    if (this.conversation.messages.length === 0) {\n      agentLogger.error(\n        \"QUEUE\",\n        `Cannot queue agent response: No messages in conversation for agent ${agentId}`,\n      );\n      return;\n    }\n\n    // Determine which message to respond to\n    const messageToRespondTo =\n      options.messageToRespondTo ||\n      this.conversation.messages[this.conversation.messages.length - 1];\n\n    // Store the message in the cache to ensure we can access it later\n    this.messageCache.set(messageToRespondTo.id, messageToRespondTo);\n\n    // Check if this agent is already responding to this message\n    const isAlreadyQueued = this.responseQueue.some(\n      (item) =>\n        item.agentId === agentId && item.messageId === messageToRespondTo.id,\n    );\n\n    const isCurrentlyProcessing = this.processingAgents.has(agentId);\n\n    if (isAlreadyQueued) {\n      agentLogger.warn(\n        \"QUEUE\",\n        `Agent ${agentId} (${agent.name}) is already queued to respond to message ${messageToRespondTo.id}`,\n      );\n      return;\n    }\n\n    if (isCurrentlyProcessing) {\n      agentLogger.warn(\n        \"QUEUE\",\n        `Agent ${agentId} (${agent.name}) is currently processing another response`,\n      );\n      return;\n    }\n\n    // Add to queue\n    this.responseQueue.push({\n      agentId,\n      messageId: messageToRespondTo.id,\n      options,\n    });\n\n    agentLogger.log(\n      \"QUEUE\",\n      `Queued agent ${agentId} (${agent.name}) to respond to message ${messageToRespondTo.id}`,\n      {\n        isStarterMessage:\n          messageToRespondTo.metadata?.type === \"conversation_starter\",\n        force: options.force,\n      },\n    );\n\n    // Immediately try to process the queue\n    setTimeout(() => this.processQueue(), 0);\n  }\n\n  /**\n   * Checks if a conversation should be ended based on configured rules\n   */\n  shouldEndConversation(conversation: Conversation): boolean {\n    if (!conversation || !conversation.isAutonomous) return false;\n\n    // Count non-system messages\n    const messageCount = conversation.messages.filter(\n      (msg) => !msg.metadata?.isSystemMessage,\n    ).length;\n\n    // Get the max autonomous messages from LLM client settings\n    const settings = this.llmClient.getSettings();\n    const maxMessages = settings.maxAutonomousMessages || 10;\n\n    // Check if the conversation has reached the maximum message count\n    return messageCount >= maxMessages;\n  }\n\n  /**\n   * Processes the response queue\n   */\n  private processQueue(): void {\n    // Prevent concurrent processing\n    if (this.isProcessingQueue) {\n      return;\n    }\n\n    // If we're already at max concurrent responses, wait\n    if (\n      this.processingAgents.size >= (this.options.maxConcurrentResponses || 1)\n    ) {\n      // /* USEFUL FOR PRODUCTION TESTING: Log queue processing pause */\n      // this.logger.debug(\n      //   \"QUEUE\",\n      //   `Queue processing paused: ${this.processingAgents.size}/${this.options.maxConcurrentResponses} agents already processing`,\n      // )\n      return;\n    }\n\n    // If there are no items in the queue, nothing to do\n    if (this.responseQueue.length === 0) {\n      return;\n    }\n\n    // Set processing flag\n    this.isProcessingQueue = true;\n\n    try {\n      // Get the next item from the queue\n      const nextItem = this.responseQueue.shift();\n      if (!nextItem) {\n        this.isProcessingQueue = false;\n        return;\n      }\n\n      const { agentId, messageId, options } = nextItem;\n\n      // Mark agent as processing\n      this.processingAgents.add(agentId);\n\n      // Get the message to respond to from cache\n      const messageToRespondTo = this.messageCache.get(messageId);\n      if (!messageToRespondTo) {\n        this.logger.error(\"PROCESS\", `Message ${messageId} not found in cache`);\n        this.processingAgents.delete(agentId);\n        this.isProcessingQueue = false;\n        return;\n      }\n\n      // Get the agent\n      const agent = this.agents.get(agentId);\n      if (!agent) {\n        this.logger.error(\"PROCESS\", `Agent ${agentId} not found`);\n        this.processingAgents.delete(agentId);\n        this.isProcessingQueue = false;\n        return;\n      }\n\n      // Calculate response delay\n      let responseDelay = options.responseDelay;\n      if (responseDelay === undefined) {\n        if (Array.isArray(this.options.responseDelay)) {\n          const [min, max] = this.options.responseDelay;\n          responseDelay = Math.floor(Math.random() * (max - min + 1)) + min;\n        } else {\n          responseDelay = this.options.responseDelay || 0;\n        }\n      }\n\n      // Process the response after the delay\n      setTimeout(() => {\n        this.generateAgentResponse(agentId, messageToRespondTo, options)\n          .catch((error) => {\n            this.logger.error(\n              \"PROCESS\",\n              `Error generating response for agent ${agentId}:`,\n              error,\n            );\n            if (this.options.onError) {\n              this.options.onError(error);\n            }\n          })\n          .finally(() => {\n            // Mark agent as no longer processing\n            this.processingAgents.delete(agentId);\n          });\n      }, responseDelay);\n    } finally {\n      // Reset processing flag\n      this.isProcessingQueue = false;\n    }\n  }\n\n  /**\n   * Generates a response from an agent to a specific message\n   */\n  private async generateAgentResponse(\n    agentId: string,\n    messageToRespondTo: Message,\n    options: ResponseOptions = {},\n  ): Promise<void> {\n    const agent = this.agents.get(agentId);\n    if (!agent) {\n      throw new Error(`Agent ${agentId} not found`);\n    }\n\n    const agentLogger = ConversationLogger.agent(agentId);\n    agentLogger.log(\n      \"GENERATE\",\n      `Generating response for agent ${agentId} (${agent.name}) to message ${messageToRespondTo.id}`,\n      { messageContent: messageToRespondTo.content.substring(0, 50) + \"...\" },\n    );\n\n    try {\n      // Get conversation history for context\n      const conversationHistory = this.conversation.messages.slice(-10); // Last 10 messages for context\n      agentLogger.log(\n        \"GENERATE\",\n        `Using ${conversationHistory.length} messages for context`,\n      );\n\n      // Get relevant knowledge if requested\n      let relevantKnowledge: KnowledgeEntry[] = [];\n      if (options.includeAgentKnowledge !== false) {\n        // Get agent's knowledge\n        relevantKnowledge = agent.knowledge;\n        agentLogger.log(\n          \"GENERATE\",\n          `Agent has ${agent.knowledge.length} knowledge entries`,\n        );\n\n        // If we have a knowledge retriever, use it to find relevant knowledge\n        if (this.knowledgeRetriever && messageToRespondTo.content) {\n          agentLogger.log(\n            \"GENERATE\",\n            \"Using knowledge retriever to find relevant knowledge\",\n          );\n          try {\n            const retrievalResult = this.knowledgeRetriever.retrieveRelevant(\n              messageToRespondTo.content,\n              agent.knowledge,\n              {\n                maxResults: options.maxKnowledgeEntries || 3,\n                includeTags: options.includeTags,\n              },\n            );\n\n            if (retrievalResult.entries.length > 0) {\n              relevantKnowledge = retrievalResult.entries;\n              agentLogger.log(\n                \"GENERATE\",\n                `Found ${retrievalResult.entries.length} relevant knowledge entries`,\n              );\n            } else {\n              agentLogger.log(\n                \"GENERATE\",\n                \"No relevant knowledge entries found\",\n              );\n            }\n          } catch (retrievalError) {\n            agentLogger.error(\n              \"GENERATE\",\n              \"Error retrieving relevant knowledge:\",\n              retrievalError,\n            );\n          }\n        }\n      }\n\n      // Create a system prompt for the agent\n      const systemPrompt = `You are ${agent.name}, with the following biography: ${agent.biography}\n\nYou are participating in a multi-agent conversation with other AI agents.\nYour responses should be consistent with your character's knowledge, personality, and background.\nYou should respond naturally as if you are having a conversation with multiple participants.\n\nIMPORTANT: Always start your response with \"${agent.name}:\" followed by your message.\n\n${\n  messageToRespondTo.metadata?.type === \"conversation_starter\"\n    ? `IMPORTANT: This is the start of a new conversation. You should respond enthusiastically and engage with the topic.\nAsk questions and show interest in what the other agent has said.`\n    : \"\"\n}\n\n${\n  messageToRespondTo.metadata?.type === \"conversation_prompt\"\n    ? `IMPORTANT: You've been directly asked to respond. Please provide a thoughtful and engaging response.`\n    : \"\"\n}\n\nWhen a message is clearly directed at another agent (e.g., addressed by name), you should:\n1. Only respond if you have something valuable to add\n2. Acknowledge that the message was primarily for another agent\n3. Keep your response brief and relevant\n\nWhen a message is directed at you specifically, provide a complete and helpful response.\nWhen a message is directed at everyone or no one specific, respond naturally.\n\n${relevantKnowledge.length > 0 ? \"You have access to the following knowledge:\" : \"You have no specific knowledge on this topic.\"}`;\n\n      // Create a user prompt with conversation history and the message to respond to\n      const userPrompt = `${relevantKnowledge.length > 0 ? \"YOUR KNOWLEDGE:\\n\" + relevantKnowledge.map((k) => `- ${k.title}: ${k.content}`).join(\"\\n\") + \"\\n\\n\" : \"\"}CONVERSATION HISTORY:\n${conversationHistory\n  .map((msg) => {\n    const senderName =\n      msg.senderId === \"user\"\n        ? \"User\"\n        : this.agents.get(msg.senderId)?.name || \"Unknown Agent\";\n    return `${senderName}: ${msg.content}`;\n  })\n  .join(\"\\n\")}\n\nBased on the conversation history and your knowledge, provide a response as ${agent.name}.\nYour response should be a single message in a conversational tone.\nRemember to start your response with \"${agent.name}:\" followed by your message.\nIf the message was clearly directed at another agent and you don't have anything valuable to add, respond with \"SKIP_RESPONSE\" and I will not include your message.`;\n\n      agentLogger.log(\"GENERATE\", \"Prepared prompts for LLM\", {\n        systemPromptLength: systemPrompt.length,\n        userPromptLength: userPrompt.length,\n      });\n\n      // Check if LLM client is available\n      if (!this.llmClient) {\n        throw new Error(\"LLM client is not available\");\n      }\n\n      // Generate the response using the LLM client\n      let response: string;\n      agentLogger.log(\"GENERATE\", \"Calling LLM client to generate response\");\n\n      if (options.streamResponse && options.onChunk) {\n        // Use streaming if requested\n        agentLogger.log(\"GENERATE\", \"Using streaming response generation\");\n        try {\n          response = await this.llmClient.streamResponse(\n            systemPrompt,\n            userPrompt,\n            options.onChunk,\n          );\n          agentLogger.log(\"GENERATE\", \"Streaming response completed\", {\n            responseLength: response.length,\n          });\n        } catch (streamError) {\n          agentLogger.error(\n            \"GENERATE\",\n            \"Error in streaming response generation:\",\n            streamError,\n          );\n          throw streamError;\n        }\n      } else {\n        // Otherwise use regular generation\n        agentLogger.log(\"GENERATE\", \"Using regular response generation\");\n        try {\n          response = await this.llmClient.generateResponse(\n            systemPrompt,\n            userPrompt,\n          );\n          agentLogger.log(\"GENERATE\", \"Regular response completed\", {\n            responseLength: response.length,\n          });\n        } catch (genError) {\n          agentLogger.error(\n            \"GENERATE\",\n            \"Error in regular response generation:\",\n            genError,\n          );\n          throw genError;\n        }\n      }\n\n      // Skip empty responses or SKIP_RESPONSE\n      if (!response.trim() || response.includes(\"SKIP_RESPONSE\")) {\n        agentLogger.log(\n          \"GENERATE\",\n          `Agent ${agentId} (${agent.name}) decided to skip responding`,\n        );\n        return;\n      }\n\n      // CRITICAL FIX: Ensure agent name is prepended to the response if not already present\n      let processedResponse = response.trim();\n      const expectedPrefix = `${agent.name}:`;\n\n      // Check if the response already starts with the agent name\n      if (!processedResponse.startsWith(expectedPrefix)) {\n        // If it doesn't, add the prefix\n        processedResponse = `${expectedPrefix} ${processedResponse}`;\n        agentLogger.log(\n          \"GENERATE\",\n          `Added agent name prefix to response: ${expectedPrefix}`,\n        );\n      }\n\n      // Create the message\n      const message: Message = {\n        id: `msg-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,\n        content: processedResponse,\n        senderId: agentId,\n        timestamp: new Date(),\n        metadata: {\n          isGeneratedByLLM: true,\n          respondingTo: messageToRespondTo.id,\n        },\n      };\n\n      agentLogger.log(\"GENERATE\", \"Created message from response\", {\n        messageId: message.id,\n      });\n\n      // Call the onMessageGenerated callback\n      if (options.onMessageGenerated) {\n        agentLogger.log(\n          \"GENERATE\",\n          \"Calling options.onMessageGenerated callback\",\n        );\n        options.onMessageGenerated(message);\n      } else if (this.options.onMessageGenerated) {\n        agentLogger.log(\n          \"GENERATE\",\n          \"Calling this.options.onMessageGenerated callback\",\n        );\n        this.options.onMessageGenerated(message);\n      } else {\n        agentLogger.warn(\n          \"GENERATE\",\n          \"No onMessageGenerated callback available\",\n        );\n      }\n\n      agentLogger.log(\n        \"GENERATE\",\n        `Generated response for agent ${agentId} (${agent.name}):`,\n        {\n          messageId: message.id,\n          contentPreview:\n            message.content.substring(0, 50) +\n            (message.content.length > 50 ? \"...\" : \"\"),\n        },\n      );\n    } catch (error) {\n      agentLogger.error(\n        \"GENERATE\",\n        `Error generating response for agent ${agentId} (${agent.name}):`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Processes a new message in the conversation\n   */\n  processNewMessage(message: Message): void {\n    this.logger.log(\n      \"PROCESS\",\n      `Processing new message ${message.id} from ${message.senderId}`,\n    );\n\n    // Add to message cache\n    this.messageCache.set(message.id, message);\n\n    // Update last processed message ID\n    this.lastProcessedMessageId = message.id;\n\n    // Determine which agents should respond\n    const respondentIds = this.determineRespondents(message);\n\n    this.logger.log(\n      \"PROCESS\",\n      `Determined respondents for message ${message.id}:`,\n      {\n        respondentCount: respondentIds.length,\n        respondents: respondentIds.map((id) => this.agents.get(id)?.name || id),\n      },\n    );\n\n    // Queue responses for each respondent\n    respondentIds.forEach((agentId) => {\n      this.queueAgentResponse(agentId, {\n        messageToRespondTo: message,\n      });\n    });\n  }\n\n  /**\n   * Cancels all pending responses\n   */\n  cancelAllResponses(): void {\n    this.logger.log(\"CANCEL\", \"Cancelling all pending responses\");\n\n    // Clear the queue\n    this.responseQueue = [];\n\n    // Clear processing agents\n    this.processingAgents.clear();\n  }\n\n  /**\n   * Cleans up resources when the orchestrator is no longer needed\n   */\n  cleanup(): void {\n    this.logger.log(\"CLEANUP\", \"Cleaning up conversation orchestrator\");\n\n    // Clear the queue processor interval\n    if (this.queueProcessorInterval) {\n      clearInterval(this.queueProcessorInterval);\n      this.queueProcessorInterval = null;\n    }\n\n    // Cancel all responses\n    this.cancelAllResponses();\n  }\n\n  /**\n   * Returns the list of agents currently processing responses\n   */\n  getProcessingAgents(): string[] {\n    return Array.from(this.processingAgents);\n  }\n\n  /**\n   * Returns the list of agents queued to respond\n   */\n  getQueuedAgents(): string[] {\n    return this.responseQueue.map((item) => item.agentId);\n  }\n\n  /**\n   * Returns the list of message IDs currently being processed\n   */\n  getProcessingMessageIds(): string[] {\n    return Array.from(\n      new Set([\n        ...this.responseQueue.map((item) => item.messageId),\n        ...Array.from(this.processingAgents)\n          .map((agentId) => {\n            const queueItem = this.responseQueue.find(\n              (item) => item.agentId === agentId,\n            );\n            return queueItem ? queueItem.messageId : \"\";\n          })\n          .filter((id) => id !== \"\"),\n      ]),\n    );\n  }\n}\n"],"names":["ConversationOrchestrator","constructor","conversation","agents","llmClient","knowledgeRetriever","options","responseQueue","processingAgents","Set","lastProcessedMessageId","messageCache","Map","queueProcessorInterval","isProcessingQueue","logger","ConversationLogger","init","id","map","agent","maxConcurrentResponses","responseDelay","autoSelectRespondents","messages","length","updateMessageCache","startQueueProcessor","clearInterval","setInterval","processQueue","forEach","message","set","updateConversation","latestMessageId","isBeingProcessed","some","item","messageId","Array","from","agentId","updateAgents","determineRespondents","conversationAgents","participants","get","filter","undefined","eligibleAgents","senderId","isAutonomousConversation","isAutonomous","messageCount","msg","metadata","isSystemMessage","settings","getSettings","maxMessages","maxAutonomousMessages","log","agentLastSpokenMap","i","has","sortedAgents","entries","sort","a","b","entry","type","name","beginningMentionMatch","content","match","directedToNameAtBeginning","mentionedAgents","add","toLowerCase","allMentionsRegex","allMatches","matchAll","potentialName","startsWith","size","matchedAgents","agentNameLower","mentionedName","respondents","Math","random","queueAgentResponse","agentLogger","includes","error","messageToRespondTo","isAlreadyQueued","isCurrentlyProcessing","warn","push","isStarterMessage","force","setTimeout","shouldEndConversation","nextItem","shift","delete","isArray","min","max","floor","generateAgentResponse","catch","onError","finally","Error","messageContent","substring","conversationHistory","slice","relevantKnowledge","includeAgentKnowledge","knowledge","retrievalResult","retrieveRelevant","maxResults","maxKnowledgeEntries","includeTags","retrievalError","systemPrompt","biography","userPrompt","k","title","join","senderName","systemPromptLength","userPromptLength","response","streamResponse","onChunk","responseLength","streamError","generateResponse","genError","trim","processedResponse","expectedPrefix","Date","now","toString","timestamp","isGeneratedByLLM","respondingTo","onMessageGenerated","contentPreview","processNewMessage","respondentIds","respondentCount","cancelAllResponses","clear","cleanup","getProcessingAgents","getQueuedAgents","getProcessingMessageIds","queueItem","find"],"mappings":"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"}