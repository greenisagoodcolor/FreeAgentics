10c61e66474b4911c4453d2b62ed4aa1
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ConversationOrchestrator", {
    enumerable: true,
    get: function() {
        return ConversationOrchestrator;
    }
});
const _conversationlogger = require("./conversation-logger");
class ConversationOrchestrator {
    constructor(conversation, agents, llmClient, knowledgeRetriever, options = {}){
        this.responseQueue = [];
        this.processingAgents = new Set();
        this.lastProcessedMessageId = null;
        this.messageCache = new Map() // Cache messages to handle race conditions
        ;
        this.queueProcessorInterval = null;
        this.isProcessingQueue = false;
        this.logger = _conversationlogger.ConversationLogger.init(conversation.id);
        // /* USEFUL FOR PRODUCTION TESTING: Log orchestrator initialization */
        // this.logger.log("INIT", "ConversationOrchestrator constructor called", {
        //   conversationId: conversation.id,
        //   agentsCount: agents.length,
        //   llmClientAvailable: !!llmClient,
        // })
        this.conversation = conversation;
        this.agents = new Map(agents.map((agent)=>[
                agent.id,
                agent
            ]));
        this.llmClient = llmClient;
        this.knowledgeRetriever = knowledgeRetriever;
        this.options = {
            maxConcurrentResponses: 1,
            responseDelay: [
                500,
                2000
            ],
            autoSelectRespondents: true,
            ...options
        };
        // Initialize lastProcessedMessageId if there are messages
        if (conversation.messages.length > 0) {
            this.lastProcessedMessageId = conversation.messages[conversation.messages.length - 1].id;
        // /* USEFUL FOR PRODUCTION TESTING: Log last processed message ID */
        // this.logger.log("INIT", "Set last processed message ID", {
        //   messageId: this.lastProcessedMessageId,
        // })
        }
        // Initialize message cache with current messages
        this.updateMessageCache(conversation.messages);
        // /* USEFUL FOR PRODUCTION TESTING: Log message cache initialization */
        // this.logger.log("INIT", "Initialized message cache with existing messages", {
        //   messageCount: conversation.messages.length,
        // })
        // Start queue processor
        this.startQueueProcessor();
    // /* USEFUL FOR PRODUCTION TESTING: Log queue processor start */
    // this.logger.log("INIT", "Started queue processor")
    }
    /**
   * Starts the queue processor interval
   */ startQueueProcessor() {
        // Clear any existing interval
        if (this.queueProcessorInterval) {
            clearInterval(this.queueProcessorInterval);
        }
        // Process the queue every 100ms
        this.queueProcessorInterval = setInterval(()=>{
            this.processQueue();
        }, 100);
    }
    /**
   * Updates the message cache with new messages
   */ updateMessageCache(messages) {
        messages.forEach((message)=>{
            this.messageCache.set(message.id, message);
        });
    }
    /**
   * Updates the conversation reference
   */ updateConversation(conversation) {
        // /* USEFUL FOR PRODUCTION TESTING: Log conversation update */
        // this.logger.log("UPDATE", "Updating conversation reference", {
        //   oldMessageCount: this.conversation.messages.length,
        //   newMessageCount: conversation.messages.length,
        // })
        // Update message cache with any new messages
        this.updateMessageCache(conversation.messages);
        this.conversation = conversation;
        // Update lastProcessedMessageId if there are new messages
        if (conversation.messages.length > 0) {
            const latestMessageId = conversation.messages[conversation.messages.length - 1].id;
            if (this.lastProcessedMessageId !== latestMessageId) {
                // Only update if we're not currently processing this message
                const isBeingProcessed = this.responseQueue.some((item)=>item.messageId === latestMessageId) || Array.from(this.processingAgents).some((agentId)=>this.responseQueue.some((item)=>item.agentId === agentId && item.messageId === latestMessageId));
                if (!isBeingProcessed) {
                    this.lastProcessedMessageId = latestMessageId;
                // /* USEFUL FOR PRODUCTION TESTING: Log last processed message ID update */
                // this.logger.log("UPDATE", "Updated last processed message ID", {
                //   messageId: this.lastProcessedMessageId,
                // })
                }
            }
        }
    }
    /**
   * Updates the agents map
   */ updateAgents(agents) {
        // /* USEFUL FOR PRODUCTION TESTING: Log agents update */
        // this.logger.log("UPDATE", "Updating agents", {
        //   oldAgentCount: this.agents.size,
        //   newAgentCount: agents.length,
        // })
        this.agents = new Map(agents.map((agent)=>[
                agent.id,
                agent
            ]));
    }
    /**
   * Determines which agents should respond to a message
   */ determineRespondents(message) {
        // If not auto-selecting, return empty array (manual selection)
        if (!this.options.autoSelectRespondents) {
            return [];
        }
        // Get all agents in the conversation
        const conversationAgents = this.conversation.participants.map((id)=>this.agents.get(id)).filter((agent)=>agent !== undefined);
        // Skip the agent who sent the message
        const eligibleAgents = conversationAgents.filter((agent)=>agent.id !== message.senderId);
        if (eligibleAgents.length === 0) {
            return [];
        }
        // Check if this is an autonomous conversation
        const isAutonomousConversation = this.conversation.isAutonomous === true;
        if (isAutonomousConversation) {
            // Count non-system messages
            const messageCount = this.conversation.messages.filter((msg)=>!msg.metadata?.isSystemMessage).length;
            // Get the LLM client settings
            const settings = this.llmClient.getSettings();
            const maxMessages = settings.maxAutonomousMessages || 10;
            // If we've reached the maximum, end the conversation by returning no respondents
            if (messageCount >= maxMessages) {
                this.logger.log("RESPONDENTS", `Maximum conversation depth reached (${messageCount}/${maxMessages}), no more responses`);
                return [];
            }
            // For autonomous conversations, always have at least one agent respond
            // Choose the agent who hasn't spoken most recently
            if (eligibleAgents.length > 1) {
                // Find the agent who hasn't spoken in the longest time
                const agentLastSpokenMap = new Map();
                // Initialize all agents as never having spoken
                eligibleAgents.forEach((agent)=>{
                    agentLastSpokenMap.set(agent.id, -1);
                });
                // Update with the last time each agent spoke
                for(let i = this.conversation.messages.length - 1; i >= 0; i--){
                    const msg = this.conversation.messages[i];
                    if (agentLastSpokenMap.has(msg.senderId) && agentLastSpokenMap.get(msg.senderId) === -1) {
                        agentLastSpokenMap.set(msg.senderId, i);
                    }
                }
                // Sort agents by who spoke least recently
                const sortedAgents = [
                    ...agentLastSpokenMap.entries()
                ].sort((a, b)=>a[1] - b[1]).map((entry)=>entry[0]);
                // Return the agent who hasn't spoken in the longest time
                return [
                    sortedAgents[0]
                ];
            }
            return eligibleAgents.map((agent)=>agent.id);
        }
        // CRITICAL FIX: Special handling for conversation starters
        if (message.metadata?.type === "conversation_starter") {
            this.logger.log("RESPONDENTS", "Determining respondents for conversation starter message", {
                eligibleAgents: eligibleAgents.map((a)=>a.name)
            });
            // All eligible agents should respond to conversation starters
            return eligibleAgents.map((agent)=>agent.id);
        }
        // UPDATED: Check for mentions anywhere in the message, not just at the beginning
        // First, check for the traditional format at the beginning: "Agent X, [message]" or "@Agent X [message]"
        const beginningMentionMatch = message.content.match(/^(?:@?(.+?),?\s+)/i);
        const directedToNameAtBeginning = beginningMentionMatch ? beginningMentionMatch[1] : null;
        // Then, check for mentions anywhere in the message
        const mentionedAgents = new Set();
        // If there's a mention at the beginning, add it
        if (directedToNameAtBeginning) {
            mentionedAgents.add(directedToNameAtBeginning.toLowerCase());
        }
        // Check for other mentions in the format "Agent X" or "@Agent X" throughout the message
        const allMentionsRegex = /\b@?([A-Za-z0-9]+(?:\s+[A-Za-z0-9]+)*)\b/g;
        const allMatches = [
            ...message.content.matchAll(allMentionsRegex)
        ];
        for (const match of allMatches){
            const potentialName = match[1];
            // Check if this potential name matches any agent
            for (const agent of eligibleAgents){
                if (agent.name.toLowerCase() === potentialName.toLowerCase() || agent.name.toLowerCase().startsWith(potentialName.toLowerCase())) {
                    mentionedAgents.add(potentialName.toLowerCase());
                    break;
                }
            }
        }
        // If we found mentions, determine which agents should respond
        if (mentionedAgents.size > 0) {
            const matchedAgents = eligibleAgents.filter((agent)=>{
                const agentNameLower = agent.name.toLowerCase();
                return Array.from(mentionedAgents).some((mentionedName)=>agentNameLower === mentionedName || agentNameLower.startsWith(mentionedName));
            });
            if (matchedAgents.length) {
                // /* USEFUL FOR PRODUCTION TESTING: Log mentioned agents */
                // this.logger.log("RESPONDENTS", "Found mentioned agents", {
                //   mentions: Array.from(mentionedAgents),
                //   matchedAgents: matchedAgents.map((a) => a.name),
                // })
                return matchedAgents.map((agent)=>agent.id);
            }
        }
        // For the first message, have all agents respond
        if (this.conversation.messages.length <= 1) {
            // /* USEFUL FOR PRODUCTION TESTING: Log first message response */
            // this.logger.log("RESPONDENTS", "First message in conversation, all agents will respond")
            return eligibleAgents.map((agent)=>agent.id);
        }
        // For other messages, have a random subset respond
        const respondents = eligibleAgents.filter(()=>Math.random() > 0.3) // 70% chance each agent responds
        .map((agent)=>agent.id);
        // /* USEFUL FOR PRODUCTION TESTING: Log random respondents */
        // this.logger.log("RESPONDENTS", "Selected random subset of agents to respond", {
        //   respondentCount: respondents.length,
        //   respondents: respondents.map((id) => this.agents.get(id)?.name || id),
        // })
        return respondents;
    }
    /**
   * Queues an agent to generate a response to a specific message
   */ queueAgentResponse(agentId, options = {}) {
        const agentLogger = _conversationlogger.ConversationLogger.agent(agentId);
        // Verify agent exists and is in the conversation
        const agent = this.agents.get(agentId);
        if (!agent || !this.conversation.participants.includes(agentId)) {
            agentLogger.error("QUEUE", `Agent ${agentId} is not valid or not in the conversation`);
            return;
        }
        // Check if there are any messages in the conversation
        if (this.conversation.messages.length === 0) {
            agentLogger.error("QUEUE", `Cannot queue agent response: No messages in conversation for agent ${agentId}`);
            return;
        }
        // Determine which message to respond to
        const messageToRespondTo = options.messageToRespondTo || this.conversation.messages[this.conversation.messages.length - 1];
        // Store the message in the cache to ensure we can access it later
        this.messageCache.set(messageToRespondTo.id, messageToRespondTo);
        // Check if this agent is already responding to this message
        const isAlreadyQueued = this.responseQueue.some((item)=>item.agentId === agentId && item.messageId === messageToRespondTo.id);
        const isCurrentlyProcessing = this.processingAgents.has(agentId);
        if (isAlreadyQueued) {
            agentLogger.warn("QUEUE", `Agent ${agentId} (${agent.name}) is already queued to respond to message ${messageToRespondTo.id}`);
            return;
        }
        if (isCurrentlyProcessing) {
            agentLogger.warn("QUEUE", `Agent ${agentId} (${agent.name}) is currently processing another response`);
            return;
        }
        // Add to queue
        this.responseQueue.push({
            agentId,
            messageId: messageToRespondTo.id,
            options
        });
        agentLogger.log("QUEUE", `Queued agent ${agentId} (${agent.name}) to respond to message ${messageToRespondTo.id}`, {
            isStarterMessage: messageToRespondTo.metadata?.type === "conversation_starter",
            force: options.force
        });
        // Immediately try to process the queue
        setTimeout(()=>this.processQueue(), 0);
    }
    /**
   * Checks if a conversation should be ended based on configured rules
   */ shouldEndConversation(conversation) {
        if (!conversation || !conversation.isAutonomous) return false;
        // Count non-system messages
        const messageCount = conversation.messages.filter((msg)=>!msg.metadata?.isSystemMessage).length;
        // Get the max autonomous messages from LLM client settings
        const settings = this.llmClient.getSettings();
        const maxMessages = settings.maxAutonomousMessages || 10;
        // Check if the conversation has reached the maximum message count
        return messageCount >= maxMessages;
    }
    /**
   * Processes the response queue
   */ processQueue() {
        // Prevent concurrent processing
        if (this.isProcessingQueue) {
            return;
        }
        // If we're already at max concurrent responses, wait
        if (this.processingAgents.size >= (this.options.maxConcurrentResponses || 1)) {
            // /* USEFUL FOR PRODUCTION TESTING: Log queue processing pause */
            // this.logger.debug(
            //   "QUEUE",
            //   `Queue processing paused: ${this.processingAgents.size}/${this.options.maxConcurrentResponses} agents already processing`,
            // )
            return;
        }
        // If there are no items in the queue, nothing to do
        if (this.responseQueue.length === 0) {
            return;
        }
        // Set processing flag
        this.isProcessingQueue = true;
        try {
            // Get the next item from the queue
            const nextItem = this.responseQueue.shift();
            if (!nextItem) {
                this.isProcessingQueue = false;
                return;
            }
            const { agentId, messageId, options } = nextItem;
            // Mark agent as processing
            this.processingAgents.add(agentId);
            // Get the message to respond to from cache
            const messageToRespondTo = this.messageCache.get(messageId);
            if (!messageToRespondTo) {
                this.logger.error("PROCESS", `Message ${messageId} not found in cache`);
                this.processingAgents.delete(agentId);
                this.isProcessingQueue = false;
                return;
            }
            // Get the agent
            const agent = this.agents.get(agentId);
            if (!agent) {
                this.logger.error("PROCESS", `Agent ${agentId} not found`);
                this.processingAgents.delete(agentId);
                this.isProcessingQueue = false;
                return;
            }
            // Calculate response delay
            let responseDelay = options.responseDelay;
            if (responseDelay === undefined) {
                if (Array.isArray(this.options.responseDelay)) {
                    const [min, max] = this.options.responseDelay;
                    responseDelay = Math.floor(Math.random() * (max - min + 1)) + min;
                } else {
                    responseDelay = this.options.responseDelay || 0;
                }
            }
            // Process the response after the delay
            setTimeout(()=>{
                this.generateAgentResponse(agentId, messageToRespondTo, options).catch((error)=>{
                    this.logger.error("PROCESS", `Error generating response for agent ${agentId}:`, error);
                    if (this.options.onError) {
                        this.options.onError(error);
                    }
                }).finally(()=>{
                    // Mark agent as no longer processing
                    this.processingAgents.delete(agentId);
                });
            }, responseDelay);
        } finally{
            // Reset processing flag
            this.isProcessingQueue = false;
        }
    }
    /**
   * Generates a response from an agent to a specific message
   */ async generateAgentResponse(agentId, messageToRespondTo, options = {}) {
        const agent = this.agents.get(agentId);
        if (!agent) {
            throw new Error(`Agent ${agentId} not found`);
        }
        const agentLogger = _conversationlogger.ConversationLogger.agent(agentId);
        agentLogger.log("GENERATE", `Generating response for agent ${agentId} (${agent.name}) to message ${messageToRespondTo.id}`, {
            messageContent: messageToRespondTo.content.substring(0, 50) + "..."
        });
        try {
            // Get conversation history for context
            const conversationHistory = this.conversation.messages.slice(-10); // Last 10 messages for context
            agentLogger.log("GENERATE", `Using ${conversationHistory.length} messages for context`);
            // Get relevant knowledge if requested
            let relevantKnowledge = [];
            if (options.includeAgentKnowledge !== false) {
                // Get agent's knowledge
                relevantKnowledge = agent.knowledge;
                agentLogger.log("GENERATE", `Agent has ${agent.knowledge.length} knowledge entries`);
                // If we have a knowledge retriever, use it to find relevant knowledge
                if (this.knowledgeRetriever && messageToRespondTo.content) {
                    agentLogger.log("GENERATE", "Using knowledge retriever to find relevant knowledge");
                    try {
                        const retrievalResult = this.knowledgeRetriever.retrieveRelevant(messageToRespondTo.content, agent.knowledge, {
                            maxResults: options.maxKnowledgeEntries || 3,
                            includeTags: options.includeTags
                        });
                        if (retrievalResult.entries.length > 0) {
                            relevantKnowledge = retrievalResult.entries;
                            agentLogger.log("GENERATE", `Found ${retrievalResult.entries.length} relevant knowledge entries`);
                        } else {
                            agentLogger.log("GENERATE", "No relevant knowledge entries found");
                        }
                    } catch (retrievalError) {
                        agentLogger.error("GENERATE", "Error retrieving relevant knowledge:", retrievalError);
                    }
                }
            }
            // Create a system prompt for the agent
            const systemPrompt = `You are ${agent.name}, with the following biography: ${agent.biography}

You are participating in a multi-agent conversation with other AI agents.
Your responses should be consistent with your character's knowledge, personality, and background.
You should respond naturally as if you are having a conversation with multiple participants.

IMPORTANT: Always start your response with "${agent.name}:" followed by your message.

${messageToRespondTo.metadata?.type === "conversation_starter" ? `IMPORTANT: This is the start of a new conversation. You should respond enthusiastically and engage with the topic.
Ask questions and show interest in what the other agent has said.` : ""}

${messageToRespondTo.metadata?.type === "conversation_prompt" ? `IMPORTANT: You've been directly asked to respond. Please provide a thoughtful and engaging response.` : ""}

When a message is clearly directed at another agent (e.g., addressed by name), you should:
1. Only respond if you have something valuable to add
2. Acknowledge that the message was primarily for another agent
3. Keep your response brief and relevant

When a message is directed at you specifically, provide a complete and helpful response.
When a message is directed at everyone or no one specific, respond naturally.

${relevantKnowledge.length > 0 ? "You have access to the following knowledge:" : "You have no specific knowledge on this topic."}`;
            // Create a user prompt with conversation history and the message to respond to
            const userPrompt = `${relevantKnowledge.length > 0 ? "YOUR KNOWLEDGE:\n" + relevantKnowledge.map((k)=>`- ${k.title}: ${k.content}`).join("\n") + "\n\n" : ""}CONVERSATION HISTORY:
${conversationHistory.map((msg)=>{
                const senderName = msg.senderId === "user" ? "User" : this.agents.get(msg.senderId)?.name || "Unknown Agent";
                return `${senderName}: ${msg.content}`;
            }).join("\n")}

Based on the conversation history and your knowledge, provide a response as ${agent.name}.
Your response should be a single message in a conversational tone.
Remember to start your response with "${agent.name}:" followed by your message.
If the message was clearly directed at another agent and you don't have anything valuable to add, respond with "SKIP_RESPONSE" and I will not include your message.`;
            agentLogger.log("GENERATE", "Prepared prompts for LLM", {
                systemPromptLength: systemPrompt.length,
                userPromptLength: userPrompt.length
            });
            // Check if LLM client is available
            if (!this.llmClient) {
                throw new Error("LLM client is not available");
            }
            // Generate the response using the LLM client
            let response;
            agentLogger.log("GENERATE", "Calling LLM client to generate response");
            if (options.streamResponse && options.onChunk) {
                // Use streaming if requested
                agentLogger.log("GENERATE", "Using streaming response generation");
                try {
                    response = await this.llmClient.streamResponse(systemPrompt, userPrompt, options.onChunk);
                    agentLogger.log("GENERATE", "Streaming response completed", {
                        responseLength: response.length
                    });
                } catch (streamError) {
                    agentLogger.error("GENERATE", "Error in streaming response generation:", streamError);
                    throw streamError;
                }
            } else {
                // Otherwise use regular generation
                agentLogger.log("GENERATE", "Using regular response generation");
                try {
                    response = await this.llmClient.generateResponse(systemPrompt, userPrompt);
                    agentLogger.log("GENERATE", "Regular response completed", {
                        responseLength: response.length
                    });
                } catch (genError) {
                    agentLogger.error("GENERATE", "Error in regular response generation:", genError);
                    throw genError;
                }
            }
            // Skip empty responses or SKIP_RESPONSE
            if (!response.trim() || response.includes("SKIP_RESPONSE")) {
                agentLogger.log("GENERATE", `Agent ${agentId} (${agent.name}) decided to skip responding`);
                return;
            }
            // CRITICAL FIX: Ensure agent name is prepended to the response if not already present
            let processedResponse = response.trim();
            const expectedPrefix = `${agent.name}:`;
            // Check if the response already starts with the agent name
            if (!processedResponse.startsWith(expectedPrefix)) {
                // If it doesn't, add the prefix
                processedResponse = `${expectedPrefix} ${processedResponse}`;
                agentLogger.log("GENERATE", `Added agent name prefix to response: ${expectedPrefix}`);
            }
            // Create the message
            const message = {
                id: `msg-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
                content: processedResponse,
                senderId: agentId,
                timestamp: new Date(),
                metadata: {
                    isGeneratedByLLM: true,
                    respondingTo: messageToRespondTo.id
                }
            };
            agentLogger.log("GENERATE", "Created message from response", {
                messageId: message.id
            });
            // Call the onMessageGenerated callback
            if (options.onMessageGenerated) {
                agentLogger.log("GENERATE", "Calling options.onMessageGenerated callback");
                options.onMessageGenerated(message);
            } else if (this.options.onMessageGenerated) {
                agentLogger.log("GENERATE", "Calling this.options.onMessageGenerated callback");
                this.options.onMessageGenerated(message);
            } else {
                agentLogger.warn("GENERATE", "No onMessageGenerated callback available");
            }
            agentLogger.log("GENERATE", `Generated response for agent ${agentId} (${agent.name}):`, {
                messageId: message.id,
                contentPreview: message.content.substring(0, 50) + (message.content.length > 50 ? "..." : "")
            });
        } catch (error) {
            agentLogger.error("GENERATE", `Error generating response for agent ${agentId} (${agent.name}):`, error);
            throw error;
        }
    }
    /**
   * Processes a new message in the conversation
   */ processNewMessage(message) {
        this.logger.log("PROCESS", `Processing new message ${message.id} from ${message.senderId}`);
        // Add to message cache
        this.messageCache.set(message.id, message);
        // Update last processed message ID
        this.lastProcessedMessageId = message.id;
        // Determine which agents should respond
        const respondentIds = this.determineRespondents(message);
        this.logger.log("PROCESS", `Determined respondents for message ${message.id}:`, {
            respondentCount: respondentIds.length,
            respondents: respondentIds.map((id)=>this.agents.get(id)?.name || id)
        });
        // Queue responses for each respondent
        respondentIds.forEach((agentId)=>{
            this.queueAgentResponse(agentId, {
                messageToRespondTo: message
            });
        });
    }
    /**
   * Cancels all pending responses
   */ cancelAllResponses() {
        this.logger.log("CANCEL", "Cancelling all pending responses");
        // Clear the queue
        this.responseQueue = [];
        // Clear processing agents
        this.processingAgents.clear();
    }
    /**
   * Cleans up resources when the orchestrator is no longer needed
   */ cleanup() {
        this.logger.log("CLEANUP", "Cleaning up conversation orchestrator");
        // Clear the queue processor interval
        if (this.queueProcessorInterval) {
            clearInterval(this.queueProcessorInterval);
            this.queueProcessorInterval = null;
        }
        // Cancel all responses
        this.cancelAllResponses();
    }
    /**
   * Returns the list of agents currently processing responses
   */ getProcessingAgents() {
        return Array.from(this.processingAgents);
    }
    /**
   * Returns the list of agents queued to respond
   */ getQueuedAgents() {
        return this.responseQueue.map((item)=>item.agentId);
    }
    /**
   * Returns the list of message IDs currently being processed
   */ getProcessingMessageIds() {
        return Array.from(new Set([
            ...this.responseQueue.map((item)=>item.messageId),
            ...Array.from(this.processingAgents).map((agentId)=>{
                const queueItem = this.responseQueue.find((item)=>item.agentId === agentId);
                return queueItem ? queueItem.messageId : "";
            }).filter((id)=>id !== "")
        ]));
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvY29udmVyc2F0aW9uLW9yY2hlc3RyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFnZW50LCBDb252ZXJzYXRpb24sIE1lc3NhZ2UsIEtub3dsZWRnZUVudHJ5IH0gZnJvbSBcIkAvbGliL3R5cGVzXCI7XG5pbXBvcnQgeyBLbm93bGVkZ2VSZXRyaWV2ZXIgfSBmcm9tIFwiQC9saWIva25vd2xlZGdlLXJldHJpZXZlclwiO1xuaW1wb3J0IHsgTExNQ2xpZW50IH0gZnJvbSBcIkAvbGliL2xsbS1jbGllbnRcIjtcbmltcG9ydCB7IExMTVNlY3VyZUNsaWVudCB9IGZyb20gXCJAL2xpYi9sbG0tc2VjdXJlLWNsaWVudFwiO1xuaW1wb3J0IHsgQ29udmVyc2F0aW9uTG9nZ2VyIH0gZnJvbSBcIkAvbGliL2NvbnZlcnNhdGlvbi1sb2dnZXJcIjtcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIkAvbGliL2RlYnVnLWxvZ2dlclwiO1xuXG50eXBlIExMTUNsaWVudFR5cGUgPSBMTE1DbGllbnQgfCBMTE1TZWN1cmVDbGllbnQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VPcHRpb25zIHtcbiAgbWF4S25vd2xlZGdlRW50cmllcz86IG51bWJlcjtcbiAgaW5jbHVkZUFnZW50S25vd2xlZGdlPzogYm9vbGVhbjtcbiAgaW5jbHVkZVRhZ3M/OiBzdHJpbmdbXTtcbiAgc3RyZWFtUmVzcG9uc2U/OiBib29sZWFuO1xuICBvbkNodW5rPzogKHRleHQ6IHN0cmluZywgaXNDb21wbGV0ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgb25NZXNzYWdlR2VuZXJhdGVkPzogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQ7IC8vIENhbGxiYWNrIGZvciB3aGVuIGEgbWVzc2FnZSBpcyBnZW5lcmF0ZWRcbiAgbWVzc2FnZVRvUmVzcG9uZFRvPzogTWVzc2FnZTsgLy8gU3BlY2lmaWMgbWVzc2FnZSB0byByZXNwb25kIHRvXG4gIHJlc3BvbnNlRGVsYXk/OiBudW1iZXI7IC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHJlc3BvbnNlIGRlbGF5XG4gIGZvcmNlPzogYm9vbGVhbjsgLy8gRm9yY2UgdGhlIGFnZW50IHRvIHJlc3BvbmQgcmVnYXJkbGVzcyBvZiBkeW5hbWljc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9yY2hlc3RyYXRvck9wdGlvbnMge1xuICBtYXhDb25jdXJyZW50UmVzcG9uc2VzPzogbnVtYmVyO1xuICByZXNwb25zZURlbGF5PzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyXTsgLy8gRml4ZWQgZGVsYXkgb3IgW21pbiwgbWF4XSByYW5nZVxuICBhdXRvU2VsZWN0UmVzcG9uZGVudHM/OiBib29sZWFuO1xuICBvbk1lc3NhZ2VHZW5lcmF0ZWQ/OiAobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZDsgLy8gR2xvYmFsIGNhbGxiYWNrIGZvciB3aGVuIGEgbWVzc2FnZSBpcyBnZW5lcmF0ZWRcbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7IC8vIENhbGxiYWNrIGZvciBlcnJvcnNcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBxdWV1ZWQgcmVzcG9uc2VcbmludGVyZmFjZSBRdWV1ZWRSZXNwb25zZSB7XG4gIGFnZW50SWQ6IHN0cmluZztcbiAgbWVzc2FnZUlkOiBzdHJpbmc7IC8vIElEIG9mIHRoZSBtZXNzYWdlIHRvIHJlc3BvbmQgdG9cbiAgb3B0aW9uczogUmVzcG9uc2VPcHRpb25zO1xufVxuXG5leHBvcnQgY2xhc3MgQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yIHtcbiAgcHJpdmF0ZSBjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbjtcbiAgcHJpdmF0ZSBhZ2VudHM6IE1hcDxzdHJpbmcsIEFnZW50PjtcbiAgcHJpdmF0ZSBsbG1DbGllbnQ6IExMTUNsaWVudFR5cGU7XG4gIHByaXZhdGUga25vd2xlZGdlUmV0cmlldmVyOiBLbm93bGVkZ2VSZXRyaWV2ZXI7XG4gIHByaXZhdGUgb3B0aW9uczogT3JjaGVzdHJhdG9yT3B0aW9ucztcbiAgcHJpdmF0ZSByZXNwb25zZVF1ZXVlOiBRdWV1ZWRSZXNwb25zZVtdID0gW107XG4gIHByaXZhdGUgcHJvY2Vzc2luZ0FnZW50czogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgbGFzdFByb2Nlc3NlZE1lc3NhZ2VJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbWVzc2FnZUNhY2hlOiBNYXA8c3RyaW5nLCBNZXNzYWdlPiA9IG5ldyBNYXAoKTsgLy8gQ2FjaGUgbWVzc2FnZXMgdG8gaGFuZGxlIHJhY2UgY29uZGl0aW9uc1xuICBwcml2YXRlIHF1ZXVlUHJvY2Vzc29ySW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaXNQcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsb2dnZXI6IFJldHVyblR5cGU8dHlwZW9mIENvbnZlcnNhdGlvbkxvZ2dlci5pbml0PjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbixcbiAgICBhZ2VudHM6IEFnZW50W10sXG4gICAgbGxtQ2xpZW50OiBMTE1DbGllbnRUeXBlLFxuICAgIGtub3dsZWRnZVJldHJpZXZlcjogS25vd2xlZGdlUmV0cmlldmVyLFxuICAgIG9wdGlvbnM6IE9yY2hlc3RyYXRvck9wdGlvbnMgPSB7fSxcbiAgKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBDb252ZXJzYXRpb25Mb2dnZXIuaW5pdChjb252ZXJzYXRpb24uaWQpO1xuICAgIC8vIC8qIFVTRUZVTCBGT1IgUFJPRFVDVElPTiBURVNUSU5HOiBMb2cgb3JjaGVzdHJhdG9yIGluaXRpYWxpemF0aW9uICovXG4gICAgLy8gdGhpcy5sb2dnZXIubG9nKFwiSU5JVFwiLCBcIkNvbnZlcnNhdGlvbk9yY2hlc3RyYXRvciBjb25zdHJ1Y3RvciBjYWxsZWRcIiwge1xuICAgIC8vICAgY29udmVyc2F0aW9uSWQ6IGNvbnZlcnNhdGlvbi5pZCxcbiAgICAvLyAgIGFnZW50c0NvdW50OiBhZ2VudHMubGVuZ3RoLFxuICAgIC8vICAgbGxtQ2xpZW50QXZhaWxhYmxlOiAhIWxsbUNsaWVudCxcbiAgICAvLyB9KVxuXG4gICAgdGhpcy5jb252ZXJzYXRpb24gPSBjb252ZXJzYXRpb247XG4gICAgdGhpcy5hZ2VudHMgPSBuZXcgTWFwKGFnZW50cy5tYXAoKGFnZW50KSA9PiBbYWdlbnQuaWQsIGFnZW50XSkpO1xuICAgIHRoaXMubGxtQ2xpZW50ID0gbGxtQ2xpZW50O1xuICAgIHRoaXMua25vd2xlZGdlUmV0cmlldmVyID0ga25vd2xlZGdlUmV0cmlldmVyO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIG1heENvbmN1cnJlbnRSZXNwb25zZXM6IDEsXG4gICAgICByZXNwb25zZURlbGF5OiBbNTAwLCAyMDAwXSwgLy8gUmFuZG9tIGRlbGF5IGJldHdlZW4gNTAwbXMgYW5kIDIwMDBtc1xuICAgICAgYXV0b1NlbGVjdFJlc3BvbmRlbnRzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBsYXN0UHJvY2Vzc2VkTWVzc2FnZUlkIGlmIHRoZXJlIGFyZSBtZXNzYWdlc1xuICAgIGlmIChjb252ZXJzYXRpb24ubWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5sYXN0UHJvY2Vzc2VkTWVzc2FnZUlkID1cbiAgICAgICAgY29udmVyc2F0aW9uLm1lc3NhZ2VzW2NvbnZlcnNhdGlvbi5tZXNzYWdlcy5sZW5ndGggLSAxXS5pZDtcbiAgICAgIC8vIC8qIFVTRUZVTCBGT1IgUFJPRFVDVElPTiBURVNUSU5HOiBMb2cgbGFzdCBwcm9jZXNzZWQgbWVzc2FnZSBJRCAqL1xuICAgICAgLy8gdGhpcy5sb2dnZXIubG9nKFwiSU5JVFwiLCBcIlNldCBsYXN0IHByb2Nlc3NlZCBtZXNzYWdlIElEXCIsIHtcbiAgICAgIC8vICAgbWVzc2FnZUlkOiB0aGlzLmxhc3RQcm9jZXNzZWRNZXNzYWdlSWQsXG4gICAgICAvLyB9KVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgbWVzc2FnZSBjYWNoZSB3aXRoIGN1cnJlbnQgbWVzc2FnZXNcbiAgICB0aGlzLnVwZGF0ZU1lc3NhZ2VDYWNoZShjb252ZXJzYXRpb24ubWVzc2FnZXMpO1xuICAgIC8vIC8qIFVTRUZVTCBGT1IgUFJPRFVDVElPTiBURVNUSU5HOiBMb2cgbWVzc2FnZSBjYWNoZSBpbml0aWFsaXphdGlvbiAqL1xuICAgIC8vIHRoaXMubG9nZ2VyLmxvZyhcIklOSVRcIiwgXCJJbml0aWFsaXplZCBtZXNzYWdlIGNhY2hlIHdpdGggZXhpc3RpbmcgbWVzc2FnZXNcIiwge1xuICAgIC8vICAgbWVzc2FnZUNvdW50OiBjb252ZXJzYXRpb24ubWVzc2FnZXMubGVuZ3RoLFxuICAgIC8vIH0pXG5cbiAgICAvLyBTdGFydCBxdWV1ZSBwcm9jZXNzb3JcbiAgICB0aGlzLnN0YXJ0UXVldWVQcm9jZXNzb3IoKTtcbiAgICAvLyAvKiBVU0VGVUwgRk9SIFBST0RVQ1RJT04gVEVTVElORzogTG9nIHF1ZXVlIHByb2Nlc3NvciBzdGFydCAqL1xuICAgIC8vIHRoaXMubG9nZ2VyLmxvZyhcIklOSVRcIiwgXCJTdGFydGVkIHF1ZXVlIHByb2Nlc3NvclwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcXVldWUgcHJvY2Vzc29yIGludGVydmFsXG4gICAqL1xuICBwcml2YXRlIHN0YXJ0UXVldWVQcm9jZXNzb3IoKTogdm9pZCB7XG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGludGVydmFsXG4gICAgaWYgKHRoaXMucXVldWVQcm9jZXNzb3JJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnF1ZXVlUHJvY2Vzc29ySW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgdGhlIHF1ZXVlIGV2ZXJ5IDEwMG1zXG4gICAgdGhpcy5xdWV1ZVByb2Nlc3NvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzUXVldWUoKTtcbiAgICB9LCAxMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG1lc3NhZ2UgY2FjaGUgd2l0aCBuZXcgbWVzc2FnZXNcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlTWVzc2FnZUNhY2hlKG1lc3NhZ2VzOiBNZXNzYWdlW10pOiB2b2lkIHtcbiAgICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICB0aGlzLm1lc3NhZ2VDYWNoZS5zZXQobWVzc2FnZS5pZCwgbWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29udmVyc2F0aW9uIHJlZmVyZW5jZVxuICAgKi9cbiAgdXBkYXRlQ29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbjogQ29udmVyc2F0aW9uKTogdm9pZCB7XG4gICAgLy8gLyogVVNFRlVMIEZPUiBQUk9EVUNUSU9OIFRFU1RJTkc6IExvZyBjb252ZXJzYXRpb24gdXBkYXRlICovXG4gICAgLy8gdGhpcy5sb2dnZXIubG9nKFwiVVBEQVRFXCIsIFwiVXBkYXRpbmcgY29udmVyc2F0aW9uIHJlZmVyZW5jZVwiLCB7XG4gICAgLy8gICBvbGRNZXNzYWdlQ291bnQ6IHRoaXMuY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCxcbiAgICAvLyAgIG5ld01lc3NhZ2VDb3VudDogY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCxcbiAgICAvLyB9KVxuXG4gICAgLy8gVXBkYXRlIG1lc3NhZ2UgY2FjaGUgd2l0aCBhbnkgbmV3IG1lc3NhZ2VzXG4gICAgdGhpcy51cGRhdGVNZXNzYWdlQ2FjaGUoY29udmVyc2F0aW9uLm1lc3NhZ2VzKTtcblxuICAgIHRoaXMuY29udmVyc2F0aW9uID0gY29udmVyc2F0aW9uO1xuXG4gICAgLy8gVXBkYXRlIGxhc3RQcm9jZXNzZWRNZXNzYWdlSWQgaWYgdGhlcmUgYXJlIG5ldyBtZXNzYWdlc1xuICAgIGlmIChjb252ZXJzYXRpb24ubWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGF0ZXN0TWVzc2FnZUlkID1cbiAgICAgICAgY29udmVyc2F0aW9uLm1lc3NhZ2VzW2NvbnZlcnNhdGlvbi5tZXNzYWdlcy5sZW5ndGggLSAxXS5pZDtcbiAgICAgIGlmICh0aGlzLmxhc3RQcm9jZXNzZWRNZXNzYWdlSWQgIT09IGxhdGVzdE1lc3NhZ2VJZCkge1xuICAgICAgICAvLyBPbmx5IHVwZGF0ZSBpZiB3ZSdyZSBub3QgY3VycmVudGx5IHByb2Nlc3NpbmcgdGhpcyBtZXNzYWdlXG4gICAgICAgIGNvbnN0IGlzQmVpbmdQcm9jZXNzZWQgPVxuICAgICAgICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5zb21lKFxuICAgICAgICAgICAgKGl0ZW0pID0+IGl0ZW0ubWVzc2FnZUlkID09PSBsYXRlc3RNZXNzYWdlSWQsXG4gICAgICAgICAgKSB8fFxuICAgICAgICAgIEFycmF5LmZyb20odGhpcy5wcm9jZXNzaW5nQWdlbnRzKS5zb21lKChhZ2VudElkKSA9PlxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZVF1ZXVlLnNvbWUoXG4gICAgICAgICAgICAgIChpdGVtKSA9PlxuICAgICAgICAgICAgICAgIGl0ZW0uYWdlbnRJZCA9PT0gYWdlbnRJZCAmJiBpdGVtLm1lc3NhZ2VJZCA9PT0gbGF0ZXN0TWVzc2FnZUlkLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgIGlmICghaXNCZWluZ1Byb2Nlc3NlZCkge1xuICAgICAgICAgIHRoaXMubGFzdFByb2Nlc3NlZE1lc3NhZ2VJZCA9IGxhdGVzdE1lc3NhZ2VJZDtcbiAgICAgICAgICAvLyAvKiBVU0VGVUwgRk9SIFBST0RVQ1RJT04gVEVTVElORzogTG9nIGxhc3QgcHJvY2Vzc2VkIG1lc3NhZ2UgSUQgdXBkYXRlICovXG4gICAgICAgICAgLy8gdGhpcy5sb2dnZXIubG9nKFwiVVBEQVRFXCIsIFwiVXBkYXRlZCBsYXN0IHByb2Nlc3NlZCBtZXNzYWdlIElEXCIsIHtcbiAgICAgICAgICAvLyAgIG1lc3NhZ2VJZDogdGhpcy5sYXN0UHJvY2Vzc2VkTWVzc2FnZUlkLFxuICAgICAgICAgIC8vIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYWdlbnRzIG1hcFxuICAgKi9cbiAgdXBkYXRlQWdlbnRzKGFnZW50czogQWdlbnRbXSk6IHZvaWQge1xuICAgIC8vIC8qIFVTRUZVTCBGT1IgUFJPRFVDVElPTiBURVNUSU5HOiBMb2cgYWdlbnRzIHVwZGF0ZSAqL1xuICAgIC8vIHRoaXMubG9nZ2VyLmxvZyhcIlVQREFURVwiLCBcIlVwZGF0aW5nIGFnZW50c1wiLCB7XG4gICAgLy8gICBvbGRBZ2VudENvdW50OiB0aGlzLmFnZW50cy5zaXplLFxuICAgIC8vICAgbmV3QWdlbnRDb3VudDogYWdlbnRzLmxlbmd0aCxcbiAgICAvLyB9KVxuICAgIHRoaXMuYWdlbnRzID0gbmV3IE1hcChhZ2VudHMubWFwKChhZ2VudCkgPT4gW2FnZW50LmlkLCBhZ2VudF0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoaWNoIGFnZW50cyBzaG91bGQgcmVzcG9uZCB0byBhIG1lc3NhZ2VcbiAgICovXG4gIGRldGVybWluZVJlc3BvbmRlbnRzKG1lc3NhZ2U6IE1lc3NhZ2UpOiBzdHJpbmdbXSB7XG4gICAgLy8gSWYgbm90IGF1dG8tc2VsZWN0aW5nLCByZXR1cm4gZW1wdHkgYXJyYXkgKG1hbnVhbCBzZWxlY3Rpb24pXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYXV0b1NlbGVjdFJlc3BvbmRlbnRzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gR2V0IGFsbCBhZ2VudHMgaW4gdGhlIGNvbnZlcnNhdGlvblxuICAgIGNvbnN0IGNvbnZlcnNhdGlvbkFnZW50cyA9IHRoaXMuY29udmVyc2F0aW9uLnBhcnRpY2lwYW50c1xuICAgICAgLm1hcCgoaWQpID0+IHRoaXMuYWdlbnRzLmdldChpZCkpXG4gICAgICAuZmlsdGVyKChhZ2VudCk6IGFnZW50IGlzIEFnZW50ID0+IGFnZW50ICE9PSB1bmRlZmluZWQpO1xuXG4gICAgLy8gU2tpcCB0aGUgYWdlbnQgd2hvIHNlbnQgdGhlIG1lc3NhZ2VcbiAgICBjb25zdCBlbGlnaWJsZUFnZW50cyA9IGNvbnZlcnNhdGlvbkFnZW50cy5maWx0ZXIoXG4gICAgICAoYWdlbnQpID0+IGFnZW50LmlkICE9PSBtZXNzYWdlLnNlbmRlcklkLFxuICAgICk7XG5cbiAgICBpZiAoZWxpZ2libGVBZ2VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBhdXRvbm9tb3VzIGNvbnZlcnNhdGlvblxuICAgIGNvbnN0IGlzQXV0b25vbW91c0NvbnZlcnNhdGlvbiA9IHRoaXMuY29udmVyc2F0aW9uLmlzQXV0b25vbW91cyA9PT0gdHJ1ZTtcblxuICAgIGlmIChpc0F1dG9ub21vdXNDb252ZXJzYXRpb24pIHtcbiAgICAgIC8vIENvdW50IG5vbi1zeXN0ZW0gbWVzc2FnZXNcbiAgICAgIGNvbnN0IG1lc3NhZ2VDb3VudCA9IHRoaXMuY29udmVyc2F0aW9uLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgKG1zZykgPT4gIW1zZy5tZXRhZGF0YT8uaXNTeXN0ZW1NZXNzYWdlLFxuICAgICAgKS5sZW5ndGg7XG5cbiAgICAgIC8vIEdldCB0aGUgTExNIGNsaWVudCBzZXR0aW5nc1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLmxsbUNsaWVudC5nZXRTZXR0aW5ncygpO1xuICAgICAgY29uc3QgbWF4TWVzc2FnZXMgPSBzZXR0aW5ncy5tYXhBdXRvbm9tb3VzTWVzc2FnZXMgfHwgMTA7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhlIG1heGltdW0sIGVuZCB0aGUgY29udmVyc2F0aW9uIGJ5IHJldHVybmluZyBubyByZXNwb25kZW50c1xuICAgICAgaWYgKG1lc3NhZ2VDb3VudCA+PSBtYXhNZXNzYWdlcykge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXG4gICAgICAgICAgXCJSRVNQT05ERU5UU1wiLFxuICAgICAgICAgIGBNYXhpbXVtIGNvbnZlcnNhdGlvbiBkZXB0aCByZWFjaGVkICgke21lc3NhZ2VDb3VudH0vJHttYXhNZXNzYWdlc30pLCBubyBtb3JlIHJlc3BvbnNlc2AsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIGF1dG9ub21vdXMgY29udmVyc2F0aW9ucywgYWx3YXlzIGhhdmUgYXQgbGVhc3Qgb25lIGFnZW50IHJlc3BvbmRcbiAgICAgIC8vIENob29zZSB0aGUgYWdlbnQgd2hvIGhhc24ndCBzcG9rZW4gbW9zdCByZWNlbnRseVxuICAgICAgaWYgKGVsaWdpYmxlQWdlbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgYWdlbnQgd2hvIGhhc24ndCBzcG9rZW4gaW4gdGhlIGxvbmdlc3QgdGltZVxuICAgICAgICBjb25zdCBhZ2VudExhc3RTcG9rZW5NYXAgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWxsIGFnZW50cyBhcyBuZXZlciBoYXZpbmcgc3Bva2VuXG4gICAgICAgIGVsaWdpYmxlQWdlbnRzLmZvckVhY2goKGFnZW50KSA9PiB7XG4gICAgICAgICAgYWdlbnRMYXN0U3Bva2VuTWFwLnNldChhZ2VudC5pZCwgLTEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgd2l0aCB0aGUgbGFzdCB0aW1lIGVhY2ggYWdlbnQgc3Bva2VcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5jb252ZXJzYXRpb24ubWVzc2FnZXNbaV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYWdlbnRMYXN0U3Bva2VuTWFwLmhhcyhtc2cuc2VuZGVySWQpICYmXG4gICAgICAgICAgICBhZ2VudExhc3RTcG9rZW5NYXAuZ2V0KG1zZy5zZW5kZXJJZCkgPT09IC0xXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhZ2VudExhc3RTcG9rZW5NYXAuc2V0KG1zZy5zZW5kZXJJZCwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCBhZ2VudHMgYnkgd2hvIHNwb2tlIGxlYXN0IHJlY2VudGx5XG4gICAgICAgIGNvbnN0IHNvcnRlZEFnZW50cyA9IFsuLi5hZ2VudExhc3RTcG9rZW5NYXAuZW50cmllcygpXVxuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSlcbiAgICAgICAgICAubWFwKChlbnRyeSkgPT4gZW50cnlbMF0pO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgYWdlbnQgd2hvIGhhc24ndCBzcG9rZW4gaW4gdGhlIGxvbmdlc3QgdGltZVxuICAgICAgICByZXR1cm4gW3NvcnRlZEFnZW50c1swXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGlnaWJsZUFnZW50cy5tYXAoKGFnZW50KSA9PiBhZ2VudC5pZCk7XG4gICAgfVxuXG4gICAgLy8gQ1JJVElDQUwgRklYOiBTcGVjaWFsIGhhbmRsaW5nIGZvciBjb252ZXJzYXRpb24gc3RhcnRlcnNcbiAgICBpZiAobWVzc2FnZS5tZXRhZGF0YT8udHlwZSA9PT0gXCJjb252ZXJzYXRpb25fc3RhcnRlclwiKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXG4gICAgICAgIFwiUkVTUE9OREVOVFNcIixcbiAgICAgICAgXCJEZXRlcm1pbmluZyByZXNwb25kZW50cyBmb3IgY29udmVyc2F0aW9uIHN0YXJ0ZXIgbWVzc2FnZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgZWxpZ2libGVBZ2VudHM6IGVsaWdpYmxlQWdlbnRzLm1hcCgoYSkgPT4gYS5uYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICAgIC8vIEFsbCBlbGlnaWJsZSBhZ2VudHMgc2hvdWxkIHJlc3BvbmQgdG8gY29udmVyc2F0aW9uIHN0YXJ0ZXJzXG4gICAgICByZXR1cm4gZWxpZ2libGVBZ2VudHMubWFwKChhZ2VudCkgPT4gYWdlbnQuaWQpO1xuICAgIH1cblxuICAgIC8vIFVQREFURUQ6IENoZWNrIGZvciBtZW50aW9ucyBhbnl3aGVyZSBpbiB0aGUgbWVzc2FnZSwgbm90IGp1c3QgYXQgdGhlIGJlZ2lubmluZ1xuICAgIC8vIEZpcnN0LCBjaGVjayBmb3IgdGhlIHRyYWRpdGlvbmFsIGZvcm1hdCBhdCB0aGUgYmVnaW5uaW5nOiBcIkFnZW50IFgsIFttZXNzYWdlXVwiIG9yIFwiQEFnZW50IFggW21lc3NhZ2VdXCJcbiAgICBjb25zdCBiZWdpbm5pbmdNZW50aW9uTWF0Y2ggPSBtZXNzYWdlLmNvbnRlbnQubWF0Y2goL14oPzpAPyguKz8pLD9cXHMrKS9pKTtcbiAgICBjb25zdCBkaXJlY3RlZFRvTmFtZUF0QmVnaW5uaW5nID0gYmVnaW5uaW5nTWVudGlvbk1hdGNoXG4gICAgICA/IGJlZ2lubmluZ01lbnRpb25NYXRjaFsxXVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gVGhlbiwgY2hlY2sgZm9yIG1lbnRpb25zIGFueXdoZXJlIGluIHRoZSBtZXNzYWdlXG4gICAgY29uc3QgbWVudGlvbmVkQWdlbnRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgbWVudGlvbiBhdCB0aGUgYmVnaW5uaW5nLCBhZGQgaXRcbiAgICBpZiAoZGlyZWN0ZWRUb05hbWVBdEJlZ2lubmluZykge1xuICAgICAgbWVudGlvbmVkQWdlbnRzLmFkZChkaXJlY3RlZFRvTmFtZUF0QmVnaW5uaW5nLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBvdGhlciBtZW50aW9ucyBpbiB0aGUgZm9ybWF0IFwiQWdlbnQgWFwiIG9yIFwiQEFnZW50IFhcIiB0aHJvdWdob3V0IHRoZSBtZXNzYWdlXG4gICAgY29uc3QgYWxsTWVudGlvbnNSZWdleCA9IC9cXGJAPyhbQS1aYS16MC05XSsoPzpcXHMrW0EtWmEtejAtOV0rKSopXFxiL2c7XG4gICAgY29uc3QgYWxsTWF0Y2hlcyA9IFsuLi5tZXNzYWdlLmNvbnRlbnQubWF0Y2hBbGwoYWxsTWVudGlvbnNSZWdleCldO1xuXG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBhbGxNYXRjaGVzKSB7XG4gICAgICBjb25zdCBwb3RlbnRpYWxOYW1lID0gbWF0Y2hbMV07XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHBvdGVudGlhbCBuYW1lIG1hdGNoZXMgYW55IGFnZW50XG4gICAgICBmb3IgKGNvbnN0IGFnZW50IG9mIGVsaWdpYmxlQWdlbnRzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBhZ2VudC5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IHBvdGVudGlhbE5hbWUudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICAgIGFnZW50Lm5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHBvdGVudGlhbE5hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgbWVudGlvbmVkQWdlbnRzLmFkZChwb3RlbnRpYWxOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZm91bmQgbWVudGlvbnMsIGRldGVybWluZSB3aGljaCBhZ2VudHMgc2hvdWxkIHJlc3BvbmRcbiAgICBpZiAobWVudGlvbmVkQWdlbnRzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBtYXRjaGVkQWdlbnRzID0gZWxpZ2libGVBZ2VudHMuZmlsdGVyKChhZ2VudCkgPT4ge1xuICAgICAgICBjb25zdCBhZ2VudE5hbWVMb3dlciA9IGFnZW50Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obWVudGlvbmVkQWdlbnRzKS5zb21lKFxuICAgICAgICAgIChtZW50aW9uZWROYW1lKSA9PlxuICAgICAgICAgICAgYWdlbnROYW1lTG93ZXIgPT09IG1lbnRpb25lZE5hbWUgfHxcbiAgICAgICAgICAgIGFnZW50TmFtZUxvd2VyLnN0YXJ0c1dpdGgobWVudGlvbmVkTmFtZSksXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoZWRBZ2VudHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIC8qIFVTRUZVTCBGT1IgUFJPRFVDVElPTiBURVNUSU5HOiBMb2cgbWVudGlvbmVkIGFnZW50cyAqL1xuICAgICAgICAvLyB0aGlzLmxvZ2dlci5sb2coXCJSRVNQT05ERU5UU1wiLCBcIkZvdW5kIG1lbnRpb25lZCBhZ2VudHNcIiwge1xuICAgICAgICAvLyAgIG1lbnRpb25zOiBBcnJheS5mcm9tKG1lbnRpb25lZEFnZW50cyksXG4gICAgICAgIC8vICAgbWF0Y2hlZEFnZW50czogbWF0Y2hlZEFnZW50cy5tYXAoKGEpID0+IGEubmFtZSksXG4gICAgICAgIC8vIH0pXG4gICAgICAgIHJldHVybiBtYXRjaGVkQWdlbnRzLm1hcCgoYWdlbnQpID0+IGFnZW50LmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3IgdGhlIGZpcnN0IG1lc3NhZ2UsIGhhdmUgYWxsIGFnZW50cyByZXNwb25kXG4gICAgaWYgKHRoaXMuY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAvLyAvKiBVU0VGVUwgRk9SIFBST0RVQ1RJT04gVEVTVElORzogTG9nIGZpcnN0IG1lc3NhZ2UgcmVzcG9uc2UgKi9cbiAgICAgIC8vIHRoaXMubG9nZ2VyLmxvZyhcIlJFU1BPTkRFTlRTXCIsIFwiRmlyc3QgbWVzc2FnZSBpbiBjb252ZXJzYXRpb24sIGFsbCBhZ2VudHMgd2lsbCByZXNwb25kXCIpXG4gICAgICByZXR1cm4gZWxpZ2libGVBZ2VudHMubWFwKChhZ2VudCkgPT4gYWdlbnQuaWQpO1xuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBtZXNzYWdlcywgaGF2ZSBhIHJhbmRvbSBzdWJzZXQgcmVzcG9uZFxuICAgIGNvbnN0IHJlc3BvbmRlbnRzID0gZWxpZ2libGVBZ2VudHNcbiAgICAgIC5maWx0ZXIoKCkgPT4gTWF0aC5yYW5kb20oKSA+IDAuMykgLy8gNzAlIGNoYW5jZSBlYWNoIGFnZW50IHJlc3BvbmRzXG4gICAgICAubWFwKChhZ2VudCkgPT4gYWdlbnQuaWQpO1xuXG4gICAgLy8gLyogVVNFRlVMIEZPUiBQUk9EVUNUSU9OIFRFU1RJTkc6IExvZyByYW5kb20gcmVzcG9uZGVudHMgKi9cbiAgICAvLyB0aGlzLmxvZ2dlci5sb2coXCJSRVNQT05ERU5UU1wiLCBcIlNlbGVjdGVkIHJhbmRvbSBzdWJzZXQgb2YgYWdlbnRzIHRvIHJlc3BvbmRcIiwge1xuICAgIC8vICAgcmVzcG9uZGVudENvdW50OiByZXNwb25kZW50cy5sZW5ndGgsXG4gICAgLy8gICByZXNwb25kZW50czogcmVzcG9uZGVudHMubWFwKChpZCkgPT4gdGhpcy5hZ2VudHMuZ2V0KGlkKT8ubmFtZSB8fCBpZCksXG4gICAgLy8gfSlcblxuICAgIHJldHVybiByZXNwb25kZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZXMgYW4gYWdlbnQgdG8gZ2VuZXJhdGUgYSByZXNwb25zZSB0byBhIHNwZWNpZmljIG1lc3NhZ2VcbiAgICovXG4gIHF1ZXVlQWdlbnRSZXNwb25zZShhZ2VudElkOiBzdHJpbmcsIG9wdGlvbnM6IFJlc3BvbnNlT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgY29uc3QgYWdlbnRMb2dnZXIgPSBDb252ZXJzYXRpb25Mb2dnZXIuYWdlbnQoYWdlbnRJZCk7XG5cbiAgICAvLyBWZXJpZnkgYWdlbnQgZXhpc3RzIGFuZCBpcyBpbiB0aGUgY29udmVyc2F0aW9uXG4gICAgY29uc3QgYWdlbnQgPSB0aGlzLmFnZW50cy5nZXQoYWdlbnRJZCk7XG4gICAgaWYgKCFhZ2VudCB8fCAhdGhpcy5jb252ZXJzYXRpb24ucGFydGljaXBhbnRzLmluY2x1ZGVzKGFnZW50SWQpKSB7XG4gICAgICBhZ2VudExvZ2dlci5lcnJvcihcbiAgICAgICAgXCJRVUVVRVwiLFxuICAgICAgICBgQWdlbnQgJHthZ2VudElkfSBpcyBub3QgdmFsaWQgb3Igbm90IGluIHRoZSBjb252ZXJzYXRpb25gLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IG1lc3NhZ2VzIGluIHRoZSBjb252ZXJzYXRpb25cbiAgICBpZiAodGhpcy5jb252ZXJzYXRpb24ubWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhZ2VudExvZ2dlci5lcnJvcihcbiAgICAgICAgXCJRVUVVRVwiLFxuICAgICAgICBgQ2Fubm90IHF1ZXVlIGFnZW50IHJlc3BvbnNlOiBObyBtZXNzYWdlcyBpbiBjb252ZXJzYXRpb24gZm9yIGFnZW50ICR7YWdlbnRJZH1gLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggbWVzc2FnZSB0byByZXNwb25kIHRvXG4gICAgY29uc3QgbWVzc2FnZVRvUmVzcG9uZFRvID1cbiAgICAgIG9wdGlvbnMubWVzc2FnZVRvUmVzcG9uZFRvIHx8XG4gICAgICB0aGlzLmNvbnZlcnNhdGlvbi5tZXNzYWdlc1t0aGlzLmNvbnZlcnNhdGlvbi5tZXNzYWdlcy5sZW5ndGggLSAxXTtcblxuICAgIC8vIFN0b3JlIHRoZSBtZXNzYWdlIGluIHRoZSBjYWNoZSB0byBlbnN1cmUgd2UgY2FuIGFjY2VzcyBpdCBsYXRlclxuICAgIHRoaXMubWVzc2FnZUNhY2hlLnNldChtZXNzYWdlVG9SZXNwb25kVG8uaWQsIG1lc3NhZ2VUb1Jlc3BvbmRUbyk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGFnZW50IGlzIGFscmVhZHkgcmVzcG9uZGluZyB0byB0aGlzIG1lc3NhZ2VcbiAgICBjb25zdCBpc0FscmVhZHlRdWV1ZWQgPSB0aGlzLnJlc3BvbnNlUXVldWUuc29tZShcbiAgICAgIChpdGVtKSA9PlxuICAgICAgICBpdGVtLmFnZW50SWQgPT09IGFnZW50SWQgJiYgaXRlbS5tZXNzYWdlSWQgPT09IG1lc3NhZ2VUb1Jlc3BvbmRUby5pZCxcbiAgICApO1xuXG4gICAgY29uc3QgaXNDdXJyZW50bHlQcm9jZXNzaW5nID0gdGhpcy5wcm9jZXNzaW5nQWdlbnRzLmhhcyhhZ2VudElkKTtcblxuICAgIGlmIChpc0FscmVhZHlRdWV1ZWQpIHtcbiAgICAgIGFnZW50TG9nZ2VyLndhcm4oXG4gICAgICAgIFwiUVVFVUVcIixcbiAgICAgICAgYEFnZW50ICR7YWdlbnRJZH0gKCR7YWdlbnQubmFtZX0pIGlzIGFscmVhZHkgcXVldWVkIHRvIHJlc3BvbmQgdG8gbWVzc2FnZSAke21lc3NhZ2VUb1Jlc3BvbmRUby5pZH1gLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNDdXJyZW50bHlQcm9jZXNzaW5nKSB7XG4gICAgICBhZ2VudExvZ2dlci53YXJuKFxuICAgICAgICBcIlFVRVVFXCIsXG4gICAgICAgIGBBZ2VudCAke2FnZW50SWR9ICgke2FnZW50Lm5hbWV9KSBpcyBjdXJyZW50bHkgcHJvY2Vzc2luZyBhbm90aGVyIHJlc3BvbnNlYCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWRkIHRvIHF1ZXVlXG4gICAgdGhpcy5yZXNwb25zZVF1ZXVlLnB1c2goe1xuICAgICAgYWdlbnRJZCxcbiAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZVRvUmVzcG9uZFRvLmlkLFxuICAgICAgb3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGFnZW50TG9nZ2VyLmxvZyhcbiAgICAgIFwiUVVFVUVcIixcbiAgICAgIGBRdWV1ZWQgYWdlbnQgJHthZ2VudElkfSAoJHthZ2VudC5uYW1lfSkgdG8gcmVzcG9uZCB0byBtZXNzYWdlICR7bWVzc2FnZVRvUmVzcG9uZFRvLmlkfWAsXG4gICAgICB7XG4gICAgICAgIGlzU3RhcnRlck1lc3NhZ2U6XG4gICAgICAgICAgbWVzc2FnZVRvUmVzcG9uZFRvLm1ldGFkYXRhPy50eXBlID09PSBcImNvbnZlcnNhdGlvbl9zdGFydGVyXCIsXG4gICAgICAgIGZvcmNlOiBvcHRpb25zLmZvcmNlLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgdHJ5IHRvIHByb2Nlc3MgdGhlIHF1ZXVlXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NRdWV1ZSgpLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBjb252ZXJzYXRpb24gc2hvdWxkIGJlIGVuZGVkIGJhc2VkIG9uIGNvbmZpZ3VyZWQgcnVsZXNcbiAgICovXG4gIHNob3VsZEVuZENvbnZlcnNhdGlvbihjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbik6IGJvb2xlYW4ge1xuICAgIGlmICghY29udmVyc2F0aW9uIHx8ICFjb252ZXJzYXRpb24uaXNBdXRvbm9tb3VzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDb3VudCBub24tc3lzdGVtIG1lc3NhZ2VzXG4gICAgY29uc3QgbWVzc2FnZUNvdW50ID0gY29udmVyc2F0aW9uLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgIChtc2cpID0+ICFtc2cubWV0YWRhdGE/LmlzU3lzdGVtTWVzc2FnZSxcbiAgICApLmxlbmd0aDtcblxuICAgIC8vIEdldCB0aGUgbWF4IGF1dG9ub21vdXMgbWVzc2FnZXMgZnJvbSBMTE0gY2xpZW50IHNldHRpbmdzXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLmxsbUNsaWVudC5nZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IG1heE1lc3NhZ2VzID0gc2V0dGluZ3MubWF4QXV0b25vbW91c01lc3NhZ2VzIHx8IDEwO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnZlcnNhdGlvbiBoYXMgcmVhY2hlZCB0aGUgbWF4aW11bSBtZXNzYWdlIGNvdW50XG4gICAgcmV0dXJuIG1lc3NhZ2VDb3VudCA+PSBtYXhNZXNzYWdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgdGhlIHJlc3BvbnNlIHF1ZXVlXG4gICAqL1xuICBwcml2YXRlIHByb2Nlc3NRdWV1ZSgpOiB2b2lkIHtcbiAgICAvLyBQcmV2ZW50IGNvbmN1cnJlbnQgcHJvY2Vzc2luZ1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgYWxyZWFkeSBhdCBtYXggY29uY3VycmVudCByZXNwb25zZXMsIHdhaXRcbiAgICBpZiAoXG4gICAgICB0aGlzLnByb2Nlc3NpbmdBZ2VudHMuc2l6ZSA+PSAodGhpcy5vcHRpb25zLm1heENvbmN1cnJlbnRSZXNwb25zZXMgfHwgMSlcbiAgICApIHtcbiAgICAgIC8vIC8qIFVTRUZVTCBGT1IgUFJPRFVDVElPTiBURVNUSU5HOiBMb2cgcXVldWUgcHJvY2Vzc2luZyBwYXVzZSAqL1xuICAgICAgLy8gdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAvLyAgIFwiUVVFVUVcIixcbiAgICAgIC8vICAgYFF1ZXVlIHByb2Nlc3NpbmcgcGF1c2VkOiAke3RoaXMucHJvY2Vzc2luZ0FnZW50cy5zaXplfS8ke3RoaXMub3B0aW9ucy5tYXhDb25jdXJyZW50UmVzcG9uc2VzfSBhZ2VudHMgYWxyZWFkeSBwcm9jZXNzaW5nYCxcbiAgICAgIC8vIClcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gaXRlbXMgaW4gdGhlIHF1ZXVlLCBub3RoaW5nIHRvIGRvXG4gICAgaWYgKHRoaXMucmVzcG9uc2VRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZXQgcHJvY2Vzc2luZyBmbGFnXG4gICAgdGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IHRoZSBuZXh0IGl0ZW0gZnJvbSB0aGUgcXVldWVcbiAgICAgIGNvbnN0IG5leHRJdGVtID0gdGhpcy5yZXNwb25zZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAoIW5leHRJdGVtKSB7XG4gICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGFnZW50SWQsIG1lc3NhZ2VJZCwgb3B0aW9ucyB9ID0gbmV4dEl0ZW07XG5cbiAgICAgIC8vIE1hcmsgYWdlbnQgYXMgcHJvY2Vzc2luZ1xuICAgICAgdGhpcy5wcm9jZXNzaW5nQWdlbnRzLmFkZChhZ2VudElkKTtcblxuICAgICAgLy8gR2V0IHRoZSBtZXNzYWdlIHRvIHJlc3BvbmQgdG8gZnJvbSBjYWNoZVxuICAgICAgY29uc3QgbWVzc2FnZVRvUmVzcG9uZFRvID0gdGhpcy5tZXNzYWdlQ2FjaGUuZ2V0KG1lc3NhZ2VJZCk7XG4gICAgICBpZiAoIW1lc3NhZ2VUb1Jlc3BvbmRUbykge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlBST0NFU1NcIiwgYE1lc3NhZ2UgJHttZXNzYWdlSWR9IG5vdCBmb3VuZCBpbiBjYWNoZWApO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdBZ2VudHMuZGVsZXRlKGFnZW50SWQpO1xuICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBhZ2VudFxuICAgICAgY29uc3QgYWdlbnQgPSB0aGlzLmFnZW50cy5nZXQoYWdlbnRJZCk7XG4gICAgICBpZiAoIWFnZW50KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiUFJPQ0VTU1wiLCBgQWdlbnQgJHthZ2VudElkfSBub3QgZm91bmRgKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nQWdlbnRzLmRlbGV0ZShhZ2VudElkKTtcbiAgICAgICAgdGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSByZXNwb25zZSBkZWxheVxuICAgICAgbGV0IHJlc3BvbnNlRGVsYXkgPSBvcHRpb25zLnJlc3BvbnNlRGVsYXk7XG4gICAgICBpZiAocmVzcG9uc2VEZWxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5yZXNwb25zZURlbGF5KSkge1xuICAgICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSB0aGlzLm9wdGlvbnMucmVzcG9uc2VEZWxheTtcbiAgICAgICAgICByZXNwb25zZURlbGF5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNwb25zZURlbGF5ID0gdGhpcy5vcHRpb25zLnJlc3BvbnNlRGVsYXkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQcm9jZXNzIHRoZSByZXNwb25zZSBhZnRlciB0aGUgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQWdlbnRSZXNwb25zZShhZ2VudElkLCBtZXNzYWdlVG9SZXNwb25kVG8sIG9wdGlvbnMpXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUFJPQ0VTU1wiLFxuICAgICAgICAgICAgICBgRXJyb3IgZ2VuZXJhdGluZyByZXNwb25zZSBmb3IgYWdlbnQgJHthZ2VudElkfTpgLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgLy8gTWFyayBhZ2VudCBhcyBubyBsb25nZXIgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nQWdlbnRzLmRlbGV0ZShhZ2VudElkKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0sIHJlc3BvbnNlRGVsYXkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZXNldCBwcm9jZXNzaW5nIGZsYWdcbiAgICAgIHRoaXMuaXNQcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcmVzcG9uc2UgZnJvbSBhbiBhZ2VudCB0byBhIHNwZWNpZmljIG1lc3NhZ2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVBZ2VudFJlc3BvbnNlKFxuICAgIGFnZW50SWQ6IHN0cmluZyxcbiAgICBtZXNzYWdlVG9SZXNwb25kVG86IE1lc3NhZ2UsXG4gICAgb3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGFnZW50ID0gdGhpcy5hZ2VudHMuZ2V0KGFnZW50SWQpO1xuICAgIGlmICghYWdlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWdlbnQgJHthZ2VudElkfSBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZ2VudExvZ2dlciA9IENvbnZlcnNhdGlvbkxvZ2dlci5hZ2VudChhZ2VudElkKTtcbiAgICBhZ2VudExvZ2dlci5sb2coXG4gICAgICBcIkdFTkVSQVRFXCIsXG4gICAgICBgR2VuZXJhdGluZyByZXNwb25zZSBmb3IgYWdlbnQgJHthZ2VudElkfSAoJHthZ2VudC5uYW1lfSkgdG8gbWVzc2FnZSAke21lc3NhZ2VUb1Jlc3BvbmRUby5pZH1gLFxuICAgICAgeyBtZXNzYWdlQ29udGVudDogbWVzc2FnZVRvUmVzcG9uZFRvLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDUwKSArIFwiLi4uXCIgfSxcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjb252ZXJzYXRpb24gaGlzdG9yeSBmb3IgY29udGV4dFxuICAgICAgY29uc3QgY29udmVyc2F0aW9uSGlzdG9yeSA9IHRoaXMuY29udmVyc2F0aW9uLm1lc3NhZ2VzLnNsaWNlKC0xMCk7IC8vIExhc3QgMTAgbWVzc2FnZXMgZm9yIGNvbnRleHRcbiAgICAgIGFnZW50TG9nZ2VyLmxvZyhcbiAgICAgICAgXCJHRU5FUkFURVwiLFxuICAgICAgICBgVXNpbmcgJHtjb252ZXJzYXRpb25IaXN0b3J5Lmxlbmd0aH0gbWVzc2FnZXMgZm9yIGNvbnRleHRgLFxuICAgICAgKTtcblxuICAgICAgLy8gR2V0IHJlbGV2YW50IGtub3dsZWRnZSBpZiByZXF1ZXN0ZWRcbiAgICAgIGxldCByZWxldmFudEtub3dsZWRnZTogS25vd2xlZGdlRW50cnlbXSA9IFtdO1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUFnZW50S25vd2xlZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBHZXQgYWdlbnQncyBrbm93bGVkZ2VcbiAgICAgICAgcmVsZXZhbnRLbm93bGVkZ2UgPSBhZ2VudC5rbm93bGVkZ2U7XG4gICAgICAgIGFnZW50TG9nZ2VyLmxvZyhcbiAgICAgICAgICBcIkdFTkVSQVRFXCIsXG4gICAgICAgICAgYEFnZW50IGhhcyAke2FnZW50Lmtub3dsZWRnZS5sZW5ndGh9IGtub3dsZWRnZSBlbnRyaWVzYCxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEga25vd2xlZGdlIHJldHJpZXZlciwgdXNlIGl0IHRvIGZpbmQgcmVsZXZhbnQga25vd2xlZGdlXG4gICAgICAgIGlmICh0aGlzLmtub3dsZWRnZVJldHJpZXZlciAmJiBtZXNzYWdlVG9SZXNwb25kVG8uY29udGVudCkge1xuICAgICAgICAgIGFnZW50TG9nZ2VyLmxvZyhcbiAgICAgICAgICAgIFwiR0VORVJBVEVcIixcbiAgICAgICAgICAgIFwiVXNpbmcga25vd2xlZGdlIHJldHJpZXZlciB0byBmaW5kIHJlbGV2YW50IGtub3dsZWRnZVwiLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJpZXZhbFJlc3VsdCA9IHRoaXMua25vd2xlZGdlUmV0cmlldmVyLnJldHJpZXZlUmVsZXZhbnQoXG4gICAgICAgICAgICAgIG1lc3NhZ2VUb1Jlc3BvbmRUby5jb250ZW50LFxuICAgICAgICAgICAgICBhZ2VudC5rbm93bGVkZ2UsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRzOiBvcHRpb25zLm1heEtub3dsZWRnZUVudHJpZXMgfHwgMyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlVGFnczogb3B0aW9ucy5pbmNsdWRlVGFncyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChyZXRyaWV2YWxSZXN1bHQuZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJlbGV2YW50S25vd2xlZGdlID0gcmV0cmlldmFsUmVzdWx0LmVudHJpZXM7XG4gICAgICAgICAgICAgIGFnZW50TG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgICBcIkdFTkVSQVRFXCIsXG4gICAgICAgICAgICAgICAgYEZvdW5kICR7cmV0cmlldmFsUmVzdWx0LmVudHJpZXMubGVuZ3RofSByZWxldmFudCBrbm93bGVkZ2UgZW50cmllc2AsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZ2VudExvZ2dlci5sb2coXG4gICAgICAgICAgICAgICAgXCJHRU5FUkFURVwiLFxuICAgICAgICAgICAgICAgIFwiTm8gcmVsZXZhbnQga25vd2xlZGdlIGVudHJpZXMgZm91bmRcIixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChyZXRyaWV2YWxFcnJvcikge1xuICAgICAgICAgICAgYWdlbnRMb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIFwiR0VORVJBVEVcIixcbiAgICAgICAgICAgICAgXCJFcnJvciByZXRyaWV2aW5nIHJlbGV2YW50IGtub3dsZWRnZTpcIixcbiAgICAgICAgICAgICAgcmV0cmlldmFsRXJyb3IsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBzeXN0ZW0gcHJvbXB0IGZvciB0aGUgYWdlbnRcbiAgICAgIGNvbnN0IHN5c3RlbVByb21wdCA9IGBZb3UgYXJlICR7YWdlbnQubmFtZX0sIHdpdGggdGhlIGZvbGxvd2luZyBiaW9ncmFwaHk6ICR7YWdlbnQuYmlvZ3JhcGh5fVxuXG5Zb3UgYXJlIHBhcnRpY2lwYXRpbmcgaW4gYSBtdWx0aS1hZ2VudCBjb252ZXJzYXRpb24gd2l0aCBvdGhlciBBSSBhZ2VudHMuXG5Zb3VyIHJlc3BvbnNlcyBzaG91bGQgYmUgY29uc2lzdGVudCB3aXRoIHlvdXIgY2hhcmFjdGVyJ3Mga25vd2xlZGdlLCBwZXJzb25hbGl0eSwgYW5kIGJhY2tncm91bmQuXG5Zb3Ugc2hvdWxkIHJlc3BvbmQgbmF0dXJhbGx5IGFzIGlmIHlvdSBhcmUgaGF2aW5nIGEgY29udmVyc2F0aW9uIHdpdGggbXVsdGlwbGUgcGFydGljaXBhbnRzLlxuXG5JTVBPUlRBTlQ6IEFsd2F5cyBzdGFydCB5b3VyIHJlc3BvbnNlIHdpdGggXCIke2FnZW50Lm5hbWV9OlwiIGZvbGxvd2VkIGJ5IHlvdXIgbWVzc2FnZS5cblxuJHtcbiAgbWVzc2FnZVRvUmVzcG9uZFRvLm1ldGFkYXRhPy50eXBlID09PSBcImNvbnZlcnNhdGlvbl9zdGFydGVyXCJcbiAgICA/IGBJTVBPUlRBTlQ6IFRoaXMgaXMgdGhlIHN0YXJ0IG9mIGEgbmV3IGNvbnZlcnNhdGlvbi4gWW91IHNob3VsZCByZXNwb25kIGVudGh1c2lhc3RpY2FsbHkgYW5kIGVuZ2FnZSB3aXRoIHRoZSB0b3BpYy5cbkFzayBxdWVzdGlvbnMgYW5kIHNob3cgaW50ZXJlc3QgaW4gd2hhdCB0aGUgb3RoZXIgYWdlbnQgaGFzIHNhaWQuYFxuICAgIDogXCJcIlxufVxuXG4ke1xuICBtZXNzYWdlVG9SZXNwb25kVG8ubWV0YWRhdGE/LnR5cGUgPT09IFwiY29udmVyc2F0aW9uX3Byb21wdFwiXG4gICAgPyBgSU1QT1JUQU5UOiBZb3UndmUgYmVlbiBkaXJlY3RseSBhc2tlZCB0byByZXNwb25kLiBQbGVhc2UgcHJvdmlkZSBhIHRob3VnaHRmdWwgYW5kIGVuZ2FnaW5nIHJlc3BvbnNlLmBcbiAgICA6IFwiXCJcbn1cblxuV2hlbiBhIG1lc3NhZ2UgaXMgY2xlYXJseSBkaXJlY3RlZCBhdCBhbm90aGVyIGFnZW50IChlLmcuLCBhZGRyZXNzZWQgYnkgbmFtZSksIHlvdSBzaG91bGQ6XG4xLiBPbmx5IHJlc3BvbmQgaWYgeW91IGhhdmUgc29tZXRoaW5nIHZhbHVhYmxlIHRvIGFkZFxuMi4gQWNrbm93bGVkZ2UgdGhhdCB0aGUgbWVzc2FnZSB3YXMgcHJpbWFyaWx5IGZvciBhbm90aGVyIGFnZW50XG4zLiBLZWVwIHlvdXIgcmVzcG9uc2UgYnJpZWYgYW5kIHJlbGV2YW50XG5cbldoZW4gYSBtZXNzYWdlIGlzIGRpcmVjdGVkIGF0IHlvdSBzcGVjaWZpY2FsbHksIHByb3ZpZGUgYSBjb21wbGV0ZSBhbmQgaGVscGZ1bCByZXNwb25zZS5cbldoZW4gYSBtZXNzYWdlIGlzIGRpcmVjdGVkIGF0IGV2ZXJ5b25lIG9yIG5vIG9uZSBzcGVjaWZpYywgcmVzcG9uZCBuYXR1cmFsbHkuXG5cbiR7cmVsZXZhbnRLbm93bGVkZ2UubGVuZ3RoID4gMCA/IFwiWW91IGhhdmUgYWNjZXNzIHRvIHRoZSBmb2xsb3dpbmcga25vd2xlZGdlOlwiIDogXCJZb3UgaGF2ZSBubyBzcGVjaWZpYyBrbm93bGVkZ2Ugb24gdGhpcyB0b3BpYy5cIn1gO1xuXG4gICAgICAvLyBDcmVhdGUgYSB1c2VyIHByb21wdCB3aXRoIGNvbnZlcnNhdGlvbiBoaXN0b3J5IGFuZCB0aGUgbWVzc2FnZSB0byByZXNwb25kIHRvXG4gICAgICBjb25zdCB1c2VyUHJvbXB0ID0gYCR7cmVsZXZhbnRLbm93bGVkZ2UubGVuZ3RoID4gMCA/IFwiWU9VUiBLTk9XTEVER0U6XFxuXCIgKyByZWxldmFudEtub3dsZWRnZS5tYXAoKGspID0+IGAtICR7ay50aXRsZX06ICR7ay5jb250ZW50fWApLmpvaW4oXCJcXG5cIikgKyBcIlxcblxcblwiIDogXCJcIn1DT05WRVJTQVRJT04gSElTVE9SWTpcbiR7Y29udmVyc2F0aW9uSGlzdG9yeVxuICAubWFwKChtc2cpID0+IHtcbiAgICBjb25zdCBzZW5kZXJOYW1lID1cbiAgICAgIG1zZy5zZW5kZXJJZCA9PT0gXCJ1c2VyXCJcbiAgICAgICAgPyBcIlVzZXJcIlxuICAgICAgICA6IHRoaXMuYWdlbnRzLmdldChtc2cuc2VuZGVySWQpPy5uYW1lIHx8IFwiVW5rbm93biBBZ2VudFwiO1xuICAgIHJldHVybiBgJHtzZW5kZXJOYW1lfTogJHttc2cuY29udGVudH1gO1xuICB9KVxuICAuam9pbihcIlxcblwiKX1cblxuQmFzZWQgb24gdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5IGFuZCB5b3VyIGtub3dsZWRnZSwgcHJvdmlkZSBhIHJlc3BvbnNlIGFzICR7YWdlbnQubmFtZX0uXG5Zb3VyIHJlc3BvbnNlIHNob3VsZCBiZSBhIHNpbmdsZSBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uYWwgdG9uZS5cblJlbWVtYmVyIHRvIHN0YXJ0IHlvdXIgcmVzcG9uc2Ugd2l0aCBcIiR7YWdlbnQubmFtZX06XCIgZm9sbG93ZWQgYnkgeW91ciBtZXNzYWdlLlxuSWYgdGhlIG1lc3NhZ2Ugd2FzIGNsZWFybHkgZGlyZWN0ZWQgYXQgYW5vdGhlciBhZ2VudCBhbmQgeW91IGRvbid0IGhhdmUgYW55dGhpbmcgdmFsdWFibGUgdG8gYWRkLCByZXNwb25kIHdpdGggXCJTS0lQX1JFU1BPTlNFXCIgYW5kIEkgd2lsbCBub3QgaW5jbHVkZSB5b3VyIG1lc3NhZ2UuYDtcblxuICAgICAgYWdlbnRMb2dnZXIubG9nKFwiR0VORVJBVEVcIiwgXCJQcmVwYXJlZCBwcm9tcHRzIGZvciBMTE1cIiwge1xuICAgICAgICBzeXN0ZW1Qcm9tcHRMZW5ndGg6IHN5c3RlbVByb21wdC5sZW5ndGgsXG4gICAgICAgIHVzZXJQcm9tcHRMZW5ndGg6IHVzZXJQcm9tcHQubGVuZ3RoLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIExMTSBjbGllbnQgaXMgYXZhaWxhYmxlXG4gICAgICBpZiAoIXRoaXMubGxtQ2xpZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxMTSBjbGllbnQgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgdGhlIHJlc3BvbnNlIHVzaW5nIHRoZSBMTE0gY2xpZW50XG4gICAgICBsZXQgcmVzcG9uc2U6IHN0cmluZztcbiAgICAgIGFnZW50TG9nZ2VyLmxvZyhcIkdFTkVSQVRFXCIsIFwiQ2FsbGluZyBMTE0gY2xpZW50IHRvIGdlbmVyYXRlIHJlc3BvbnNlXCIpO1xuXG4gICAgICBpZiAob3B0aW9ucy5zdHJlYW1SZXNwb25zZSAmJiBvcHRpb25zLm9uQ2h1bmspIHtcbiAgICAgICAgLy8gVXNlIHN0cmVhbWluZyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgYWdlbnRMb2dnZXIubG9nKFwiR0VORVJBVEVcIiwgXCJVc2luZyBzdHJlYW1pbmcgcmVzcG9uc2UgZ2VuZXJhdGlvblwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMubGxtQ2xpZW50LnN0cmVhbVJlc3BvbnNlKFxuICAgICAgICAgICAgc3lzdGVtUHJvbXB0LFxuICAgICAgICAgICAgdXNlclByb21wdCxcbiAgICAgICAgICAgIG9wdGlvbnMub25DaHVuayxcbiAgICAgICAgICApO1xuICAgICAgICAgIGFnZW50TG9nZ2VyLmxvZyhcIkdFTkVSQVRFXCIsIFwiU3RyZWFtaW5nIHJlc3BvbnNlIGNvbXBsZXRlZFwiLCB7XG4gICAgICAgICAgICByZXNwb25zZUxlbmd0aDogcmVzcG9uc2UubGVuZ3RoLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChzdHJlYW1FcnJvcikge1xuICAgICAgICAgIGFnZW50TG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgXCJHRU5FUkFURVwiLFxuICAgICAgICAgICAgXCJFcnJvciBpbiBzdHJlYW1pbmcgcmVzcG9uc2UgZ2VuZXJhdGlvbjpcIixcbiAgICAgICAgICAgIHN0cmVhbUVycm9yLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgc3RyZWFtRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB1c2UgcmVndWxhciBnZW5lcmF0aW9uXG4gICAgICAgIGFnZW50TG9nZ2VyLmxvZyhcIkdFTkVSQVRFXCIsIFwiVXNpbmcgcmVndWxhciByZXNwb25zZSBnZW5lcmF0aW9uXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5sbG1DbGllbnQuZ2VuZXJhdGVSZXNwb25zZShcbiAgICAgICAgICAgIHN5c3RlbVByb21wdCxcbiAgICAgICAgICAgIHVzZXJQcm9tcHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhZ2VudExvZ2dlci5sb2coXCJHRU5FUkFURVwiLCBcIlJlZ3VsYXIgcmVzcG9uc2UgY29tcGxldGVkXCIsIHtcbiAgICAgICAgICAgIHJlc3BvbnNlTGVuZ3RoOiByZXNwb25zZS5sZW5ndGgsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGdlbkVycm9yKSB7XG4gICAgICAgICAgYWdlbnRMb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBcIkdFTkVSQVRFXCIsXG4gICAgICAgICAgICBcIkVycm9yIGluIHJlZ3VsYXIgcmVzcG9uc2UgZ2VuZXJhdGlvbjpcIixcbiAgICAgICAgICAgIGdlbkVycm9yLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgZ2VuRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBlbXB0eSByZXNwb25zZXMgb3IgU0tJUF9SRVNQT05TRVxuICAgICAgaWYgKCFyZXNwb25zZS50cmltKCkgfHwgcmVzcG9uc2UuaW5jbHVkZXMoXCJTS0lQX1JFU1BPTlNFXCIpKSB7XG4gICAgICAgIGFnZW50TG9nZ2VyLmxvZyhcbiAgICAgICAgICBcIkdFTkVSQVRFXCIsXG4gICAgICAgICAgYEFnZW50ICR7YWdlbnRJZH0gKCR7YWdlbnQubmFtZX0pIGRlY2lkZWQgdG8gc2tpcCByZXNwb25kaW5nYCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDUklUSUNBTCBGSVg6IEVuc3VyZSBhZ2VudCBuYW1lIGlzIHByZXBlbmRlZCB0byB0aGUgcmVzcG9uc2UgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgbGV0IHByb2Nlc3NlZFJlc3BvbnNlID0gcmVzcG9uc2UudHJpbSgpO1xuICAgICAgY29uc3QgZXhwZWN0ZWRQcmVmaXggPSBgJHthZ2VudC5uYW1lfTpgO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgcmVzcG9uc2UgYWxyZWFkeSBzdGFydHMgd2l0aCB0aGUgYWdlbnQgbmFtZVxuICAgICAgaWYgKCFwcm9jZXNzZWRSZXNwb25zZS5zdGFydHNXaXRoKGV4cGVjdGVkUHJlZml4KSkge1xuICAgICAgICAvLyBJZiBpdCBkb2Vzbid0LCBhZGQgdGhlIHByZWZpeFxuICAgICAgICBwcm9jZXNzZWRSZXNwb25zZSA9IGAke2V4cGVjdGVkUHJlZml4fSAke3Byb2Nlc3NlZFJlc3BvbnNlfWA7XG4gICAgICAgIGFnZW50TG9nZ2VyLmxvZyhcbiAgICAgICAgICBcIkdFTkVSQVRFXCIsXG4gICAgICAgICAgYEFkZGVkIGFnZW50IG5hbWUgcHJlZml4IHRvIHJlc3BvbnNlOiAke2V4cGVjdGVkUHJlZml4fWAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgbWVzc2FnZVxuICAgICAgY29uc3QgbWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgaWQ6IGBtc2ctJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA3KX1gLFxuICAgICAgICBjb250ZW50OiBwcm9jZXNzZWRSZXNwb25zZSxcbiAgICAgICAgc2VuZGVySWQ6IGFnZW50SWQsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpc0dlbmVyYXRlZEJ5TExNOiB0cnVlLFxuICAgICAgICAgIHJlc3BvbmRpbmdUbzogbWVzc2FnZVRvUmVzcG9uZFRvLmlkLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgYWdlbnRMb2dnZXIubG9nKFwiR0VORVJBVEVcIiwgXCJDcmVhdGVkIG1lc3NhZ2UgZnJvbSByZXNwb25zZVwiLCB7XG4gICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZS5pZCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxsIHRoZSBvbk1lc3NhZ2VHZW5lcmF0ZWQgY2FsbGJhY2tcbiAgICAgIGlmIChvcHRpb25zLm9uTWVzc2FnZUdlbmVyYXRlZCkge1xuICAgICAgICBhZ2VudExvZ2dlci5sb2coXG4gICAgICAgICAgXCJHRU5FUkFURVwiLFxuICAgICAgICAgIFwiQ2FsbGluZyBvcHRpb25zLm9uTWVzc2FnZUdlbmVyYXRlZCBjYWxsYmFja1wiLFxuICAgICAgICApO1xuICAgICAgICBvcHRpb25zLm9uTWVzc2FnZUdlbmVyYXRlZChtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm9uTWVzc2FnZUdlbmVyYXRlZCkge1xuICAgICAgICBhZ2VudExvZ2dlci5sb2coXG4gICAgICAgICAgXCJHRU5FUkFURVwiLFxuICAgICAgICAgIFwiQ2FsbGluZyB0aGlzLm9wdGlvbnMub25NZXNzYWdlR2VuZXJhdGVkIGNhbGxiYWNrXCIsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbk1lc3NhZ2VHZW5lcmF0ZWQobWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2VudExvZ2dlci53YXJuKFxuICAgICAgICAgIFwiR0VORVJBVEVcIixcbiAgICAgICAgICBcIk5vIG9uTWVzc2FnZUdlbmVyYXRlZCBjYWxsYmFjayBhdmFpbGFibGVcIixcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgYWdlbnRMb2dnZXIubG9nKFxuICAgICAgICBcIkdFTkVSQVRFXCIsXG4gICAgICAgIGBHZW5lcmF0ZWQgcmVzcG9uc2UgZm9yIGFnZW50ICR7YWdlbnRJZH0gKCR7YWdlbnQubmFtZX0pOmAsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2UuaWQsXG4gICAgICAgICAgY29udGVudFByZXZpZXc6XG4gICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDUwKSArXG4gICAgICAgICAgICAobWVzc2FnZS5jb250ZW50Lmxlbmd0aCA+IDUwID8gXCIuLi5cIiA6IFwiXCIpLFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYWdlbnRMb2dnZXIuZXJyb3IoXG4gICAgICAgIFwiR0VORVJBVEVcIixcbiAgICAgICAgYEVycm9yIGdlbmVyYXRpbmcgcmVzcG9uc2UgZm9yIGFnZW50ICR7YWdlbnRJZH0gKCR7YWdlbnQubmFtZX0pOmAsXG4gICAgICAgIGVycm9yLFxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSBuZXcgbWVzc2FnZSBpbiB0aGUgY29udmVyc2F0aW9uXG4gICAqL1xuICBwcm9jZXNzTmV3TWVzc2FnZShtZXNzYWdlOiBNZXNzYWdlKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgXCJQUk9DRVNTXCIsXG4gICAgICBgUHJvY2Vzc2luZyBuZXcgbWVzc2FnZSAke21lc3NhZ2UuaWR9IGZyb20gJHttZXNzYWdlLnNlbmRlcklkfWAsXG4gICAgKTtcblxuICAgIC8vIEFkZCB0byBtZXNzYWdlIGNhY2hlXG4gICAgdGhpcy5tZXNzYWdlQ2FjaGUuc2V0KG1lc3NhZ2UuaWQsIG1lc3NhZ2UpO1xuXG4gICAgLy8gVXBkYXRlIGxhc3QgcHJvY2Vzc2VkIG1lc3NhZ2UgSURcbiAgICB0aGlzLmxhc3RQcm9jZXNzZWRNZXNzYWdlSWQgPSBtZXNzYWdlLmlkO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGFnZW50cyBzaG91bGQgcmVzcG9uZFxuICAgIGNvbnN0IHJlc3BvbmRlbnRJZHMgPSB0aGlzLmRldGVybWluZVJlc3BvbmRlbnRzKG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgXCJQUk9DRVNTXCIsXG4gICAgICBgRGV0ZXJtaW5lZCByZXNwb25kZW50cyBmb3IgbWVzc2FnZSAke21lc3NhZ2UuaWR9OmAsXG4gICAgICB7XG4gICAgICAgIHJlc3BvbmRlbnRDb3VudDogcmVzcG9uZGVudElkcy5sZW5ndGgsXG4gICAgICAgIHJlc3BvbmRlbnRzOiByZXNwb25kZW50SWRzLm1hcCgoaWQpID0+IHRoaXMuYWdlbnRzLmdldChpZCk/Lm5hbWUgfHwgaWQpLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgLy8gUXVldWUgcmVzcG9uc2VzIGZvciBlYWNoIHJlc3BvbmRlbnRcbiAgICByZXNwb25kZW50SWRzLmZvckVhY2goKGFnZW50SWQpID0+IHtcbiAgICAgIHRoaXMucXVldWVBZ2VudFJlc3BvbnNlKGFnZW50SWQsIHtcbiAgICAgICAgbWVzc2FnZVRvUmVzcG9uZFRvOiBtZXNzYWdlLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhbGwgcGVuZGluZyByZXNwb25zZXNcbiAgICovXG4gIGNhbmNlbEFsbFJlc3BvbnNlcygpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJDQU5DRUxcIiwgXCJDYW5jZWxsaW5nIGFsbCBwZW5kaW5nIHJlc3BvbnNlc1wiKTtcblxuICAgIC8vIENsZWFyIHRoZSBxdWV1ZVxuICAgIHRoaXMucmVzcG9uc2VRdWV1ZSA9IFtdO1xuXG4gICAgLy8gQ2xlYXIgcHJvY2Vzc2luZyBhZ2VudHNcbiAgICB0aGlzLnByb2Nlc3NpbmdBZ2VudHMuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgcmVzb3VyY2VzIHdoZW4gdGhlIG9yY2hlc3RyYXRvciBpcyBubyBsb25nZXIgbmVlZGVkXG4gICAqL1xuICBjbGVhbnVwKCk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkNMRUFOVVBcIiwgXCJDbGVhbmluZyB1cCBjb252ZXJzYXRpb24gb3JjaGVzdHJhdG9yXCIpO1xuXG4gICAgLy8gQ2xlYXIgdGhlIHF1ZXVlIHByb2Nlc3NvciBpbnRlcnZhbFxuICAgIGlmICh0aGlzLnF1ZXVlUHJvY2Vzc29ySW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5xdWV1ZVByb2Nlc3NvckludGVydmFsKTtcbiAgICAgIHRoaXMucXVldWVQcm9jZXNzb3JJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2FuY2VsIGFsbCByZXNwb25zZXNcbiAgICB0aGlzLmNhbmNlbEFsbFJlc3BvbnNlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWdlbnRzIGN1cnJlbnRseSBwcm9jZXNzaW5nIHJlc3BvbnNlc1xuICAgKi9cbiAgZ2V0UHJvY2Vzc2luZ0FnZW50cygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm9jZXNzaW5nQWdlbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFnZW50cyBxdWV1ZWQgdG8gcmVzcG9uZFxuICAgKi9cbiAgZ2V0UXVldWVkQWdlbnRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZVF1ZXVlLm1hcCgoaXRlbSkgPT4gaXRlbS5hZ2VudElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIG1lc3NhZ2UgSURzIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWRcbiAgICovXG4gIGdldFByb2Nlc3NpbmdNZXNzYWdlSWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgIG5ldyBTZXQoW1xuICAgICAgICAuLi50aGlzLnJlc3BvbnNlUXVldWUubWFwKChpdGVtKSA9PiBpdGVtLm1lc3NhZ2VJZCksXG4gICAgICAgIC4uLkFycmF5LmZyb20odGhpcy5wcm9jZXNzaW5nQWdlbnRzKVxuICAgICAgICAgIC5tYXAoKGFnZW50SWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlSXRlbSA9IHRoaXMucmVzcG9uc2VRdWV1ZS5maW5kKFxuICAgICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5hZ2VudElkID09PSBhZ2VudElkLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZUl0ZW0gPyBxdWV1ZUl0ZW0ubWVzc2FnZUlkIDogXCJcIjtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gXCJcIiksXG4gICAgICBdKSxcbiAgICApO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yIiwiY29uc3RydWN0b3IiLCJjb252ZXJzYXRpb24iLCJhZ2VudHMiLCJsbG1DbGllbnQiLCJrbm93bGVkZ2VSZXRyaWV2ZXIiLCJvcHRpb25zIiwicmVzcG9uc2VRdWV1ZSIsInByb2Nlc3NpbmdBZ2VudHMiLCJTZXQiLCJsYXN0UHJvY2Vzc2VkTWVzc2FnZUlkIiwibWVzc2FnZUNhY2hlIiwiTWFwIiwicXVldWVQcm9jZXNzb3JJbnRlcnZhbCIsImlzUHJvY2Vzc2luZ1F1ZXVlIiwibG9nZ2VyIiwiQ29udmVyc2F0aW9uTG9nZ2VyIiwiaW5pdCIsImlkIiwibWFwIiwiYWdlbnQiLCJtYXhDb25jdXJyZW50UmVzcG9uc2VzIiwicmVzcG9uc2VEZWxheSIsImF1dG9TZWxlY3RSZXNwb25kZW50cyIsIm1lc3NhZ2VzIiwibGVuZ3RoIiwidXBkYXRlTWVzc2FnZUNhY2hlIiwic3RhcnRRdWV1ZVByb2Nlc3NvciIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByb2Nlc3NRdWV1ZSIsImZvckVhY2giLCJtZXNzYWdlIiwic2V0IiwidXBkYXRlQ29udmVyc2F0aW9uIiwibGF0ZXN0TWVzc2FnZUlkIiwiaXNCZWluZ1Byb2Nlc3NlZCIsInNvbWUiLCJpdGVtIiwibWVzc2FnZUlkIiwiQXJyYXkiLCJmcm9tIiwiYWdlbnRJZCIsInVwZGF0ZUFnZW50cyIsImRldGVybWluZVJlc3BvbmRlbnRzIiwiY29udmVyc2F0aW9uQWdlbnRzIiwicGFydGljaXBhbnRzIiwiZ2V0IiwiZmlsdGVyIiwidW5kZWZpbmVkIiwiZWxpZ2libGVBZ2VudHMiLCJzZW5kZXJJZCIsImlzQXV0b25vbW91c0NvbnZlcnNhdGlvbiIsImlzQXV0b25vbW91cyIsIm1lc3NhZ2VDb3VudCIsIm1zZyIsIm1ldGFkYXRhIiwiaXNTeXN0ZW1NZXNzYWdlIiwic2V0dGluZ3MiLCJnZXRTZXR0aW5ncyIsIm1heE1lc3NhZ2VzIiwibWF4QXV0b25vbW91c01lc3NhZ2VzIiwibG9nIiwiYWdlbnRMYXN0U3Bva2VuTWFwIiwiaSIsImhhcyIsInNvcnRlZEFnZW50cyIsImVudHJpZXMiLCJzb3J0IiwiYSIsImIiLCJlbnRyeSIsInR5cGUiLCJuYW1lIiwiYmVnaW5uaW5nTWVudGlvbk1hdGNoIiwiY29udGVudCIsIm1hdGNoIiwiZGlyZWN0ZWRUb05hbWVBdEJlZ2lubmluZyIsIm1lbnRpb25lZEFnZW50cyIsImFkZCIsInRvTG93ZXJDYXNlIiwiYWxsTWVudGlvbnNSZWdleCIsImFsbE1hdGNoZXMiLCJtYXRjaEFsbCIsInBvdGVudGlhbE5hbWUiLCJzdGFydHNXaXRoIiwic2l6ZSIsIm1hdGNoZWRBZ2VudHMiLCJhZ2VudE5hbWVMb3dlciIsIm1lbnRpb25lZE5hbWUiLCJyZXNwb25kZW50cyIsIk1hdGgiLCJyYW5kb20iLCJxdWV1ZUFnZW50UmVzcG9uc2UiLCJhZ2VudExvZ2dlciIsImluY2x1ZGVzIiwiZXJyb3IiLCJtZXNzYWdlVG9SZXNwb25kVG8iLCJpc0FscmVhZHlRdWV1ZWQiLCJpc0N1cnJlbnRseVByb2Nlc3NpbmciLCJ3YXJuIiwicHVzaCIsImlzU3RhcnRlck1lc3NhZ2UiLCJmb3JjZSIsInNldFRpbWVvdXQiLCJzaG91bGRFbmRDb252ZXJzYXRpb24iLCJuZXh0SXRlbSIsInNoaWZ0IiwiZGVsZXRlIiwiaXNBcnJheSIsIm1pbiIsIm1heCIsImZsb29yIiwiZ2VuZXJhdGVBZ2VudFJlc3BvbnNlIiwiY2F0Y2giLCJvbkVycm9yIiwiZmluYWxseSIsIkVycm9yIiwibWVzc2FnZUNvbnRlbnQiLCJzdWJzdHJpbmciLCJjb252ZXJzYXRpb25IaXN0b3J5Iiwic2xpY2UiLCJyZWxldmFudEtub3dsZWRnZSIsImluY2x1ZGVBZ2VudEtub3dsZWRnZSIsImtub3dsZWRnZSIsInJldHJpZXZhbFJlc3VsdCIsInJldHJpZXZlUmVsZXZhbnQiLCJtYXhSZXN1bHRzIiwibWF4S25vd2xlZGdlRW50cmllcyIsImluY2x1ZGVUYWdzIiwicmV0cmlldmFsRXJyb3IiLCJzeXN0ZW1Qcm9tcHQiLCJiaW9ncmFwaHkiLCJ1c2VyUHJvbXB0IiwiayIsInRpdGxlIiwiam9pbiIsInNlbmRlck5hbWUiLCJzeXN0ZW1Qcm9tcHRMZW5ndGgiLCJ1c2VyUHJvbXB0TGVuZ3RoIiwicmVzcG9uc2UiLCJzdHJlYW1SZXNwb25zZSIsIm9uQ2h1bmsiLCJyZXNwb25zZUxlbmd0aCIsInN0cmVhbUVycm9yIiwiZ2VuZXJhdGVSZXNwb25zZSIsImdlbkVycm9yIiwidHJpbSIsInByb2Nlc3NlZFJlc3BvbnNlIiwiZXhwZWN0ZWRQcmVmaXgiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJ0aW1lc3RhbXAiLCJpc0dlbmVyYXRlZEJ5TExNIiwicmVzcG9uZGluZ1RvIiwib25NZXNzYWdlR2VuZXJhdGVkIiwiY29udGVudFByZXZpZXciLCJwcm9jZXNzTmV3TWVzc2FnZSIsInJlc3BvbmRlbnRJZHMiLCJyZXNwb25kZW50Q291bnQiLCJjYW5jZWxBbGxSZXNwb25zZXMiLCJjbGVhciIsImNsZWFudXAiLCJnZXRQcm9jZXNzaW5nQWdlbnRzIiwiZ2V0UXVldWVkQWdlbnRzIiwiZ2V0UHJvY2Vzc2luZ01lc3NhZ2VJZHMiLCJxdWV1ZUl0ZW0iLCJmaW5kIl0sIm1hcHBpbmdzIjoiOzs7OytCQW9DYUE7OztlQUFBQTs7O29DQWhDc0I7QUFnQzVCLE1BQU1BO0lBY1hDLFlBQ0VDLFlBQTBCLEVBQzFCQyxNQUFlLEVBQ2ZDLFNBQXdCLEVBQ3hCQyxrQkFBc0MsRUFDdENDLFVBQStCLENBQUMsQ0FBQyxDQUNqQzthQWRNQyxnQkFBa0MsRUFBRTthQUNwQ0MsbUJBQWdDLElBQUlDO2FBQ3BDQyx5QkFBd0M7YUFDeENDLGVBQXFDLElBQUlDLE1BQU8sMkNBQTJDOzthQUMzRkMseUJBQWdEO2FBQ2hEQyxvQkFBb0I7UUFVMUIsSUFBSSxDQUFDQyxNQUFNLEdBQUdDLHNDQUFrQixDQUFDQyxJQUFJLENBQUNmLGFBQWFnQixFQUFFO1FBQ3JELHVFQUF1RTtRQUN2RSwyRUFBMkU7UUFDM0UscUNBQXFDO1FBQ3JDLGdDQUFnQztRQUNoQyxxQ0FBcUM7UUFDckMsS0FBSztRQUVMLElBQUksQ0FBQ2hCLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSVMsSUFBSVQsT0FBT2dCLEdBQUcsQ0FBQyxDQUFDQyxRQUFVO2dCQUFDQSxNQUFNRixFQUFFO2dCQUFFRTthQUFNO1FBQzdE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