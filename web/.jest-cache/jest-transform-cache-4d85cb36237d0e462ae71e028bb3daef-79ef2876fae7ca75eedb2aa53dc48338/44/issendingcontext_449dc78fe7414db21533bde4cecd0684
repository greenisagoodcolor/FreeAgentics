e3829dcf2e21ec3daa96a5fee1befdee
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    IsSendingProvider: function() {
        return IsSendingProvider;
    },
    useIsSending: function() {
        return useIsSending;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _debuglogger = require("../lib/debug-logger");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const logger = (0, _debuglogger.createLogger)("IS-SENDING-CONTEXT");
// Create default setIsSending function
const defaultSetIsSending = (value)=>{
    logger.warn("Default setIsSending called - context not yet initialized");
};
// Initialize with safe defaults
const IsSendingContext = /*#__PURE__*/ (0, _react.createContext)({
    isSending: false,
    setIsSending: defaultSetIsSending
});
function IsSendingProvider({ children }) {
    logger.info("IsSendingProvider rendering");
    // Initialize state here to avoid hydration issues
    const [isSending, setIsSending] = (0, _react.useState)(false);
    // Create the context value object only once per render
    const contextValue = {
        isSending,
        setIsSending: (value)=>{
            logger.info(`setIsSending called with value: ${value}`);
            try {
                setIsSending(value);
            } catch (error) {
                logger.error("Error in setIsSending:", error);
            }
        }
    };
    logger.info("IsSendingProvider created context value:", {
        isSending
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(IsSendingContext.Provider, {
        value: contextValue,
        children: children
    });
}
function useIsSending() {
    logger.info("useIsSending hook called");
    // Add safety check for SSR/hydration
    const context = (0, _react.useContext)(IsSendingContext);
    logger.info("useIsSending context retrieved:", {
        isSending: context?.isSending,
        setIsSendingType: typeof context?.setIsSending
    });
    // Ensure we never return undefined functions
    if (typeof context?.setIsSending !== "function") {
        logger.error("useIsSending: setIsSending is not a function!");
        return {
            isSending: context?.isSending || false,
            setIsSending: defaultSetIsSending
        };
    }
    return context;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9jb250ZXh0cy9pcy1zZW5kaW5nLWNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciB9IGZyb20gXCJAL2xpYi9kZWJ1Zy1sb2dnZXJcIjtcblxuY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwiSVMtU0VORElORy1DT05URVhUXCIpO1xuXG5pbnRlcmZhY2UgSXNTZW5kaW5nQ29udGV4dFR5cGUge1xuICBpc1NlbmRpbmc6IGJvb2xlYW47XG4gIHNldElzU2VuZGluZzogKHZhbHVlOiBib29sZWFuKSA9PiB2b2lkO1xufVxuXG4vLyBDcmVhdGUgZGVmYXVsdCBzZXRJc1NlbmRpbmcgZnVuY3Rpb25cbmNvbnN0IGRlZmF1bHRTZXRJc1NlbmRpbmcgPSAodmFsdWU6IGJvb2xlYW4pID0+IHtcbiAgbG9nZ2VyLndhcm4oXCJEZWZhdWx0IHNldElzU2VuZGluZyBjYWxsZWQgLSBjb250ZXh0IG5vdCB5ZXQgaW5pdGlhbGl6ZWRcIik7XG59O1xuXG4vLyBJbml0aWFsaXplIHdpdGggc2FmZSBkZWZhdWx0c1xuY29uc3QgSXNTZW5kaW5nQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8SXNTZW5kaW5nQ29udGV4dFR5cGU+KHtcbiAgaXNTZW5kaW5nOiBmYWxzZSxcbiAgc2V0SXNTZW5kaW5nOiBkZWZhdWx0U2V0SXNTZW5kaW5nLFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBJc1NlbmRpbmdQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGxvZ2dlci5pbmZvKFwiSXNTZW5kaW5nUHJvdmlkZXIgcmVuZGVyaW5nXCIpO1xuICAvLyBJbml0aWFsaXplIHN0YXRlIGhlcmUgdG8gYXZvaWQgaHlkcmF0aW9uIGlzc3Vlc1xuICBjb25zdCBbaXNTZW5kaW5nLCBzZXRJc1NlbmRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8vIENyZWF0ZSB0aGUgY29udGV4dCB2YWx1ZSBvYmplY3Qgb25seSBvbmNlIHBlciByZW5kZXJcbiAgY29uc3QgY29udGV4dFZhbHVlID0ge1xuICAgIGlzU2VuZGluZyxcbiAgICBzZXRJc1NlbmRpbmc6ICh2YWx1ZTogYm9vbGVhbikgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oYHNldElzU2VuZGluZyBjYWxsZWQgd2l0aCB2YWx1ZTogJHt2YWx1ZX1gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldElzU2VuZGluZyh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBpbiBzZXRJc1NlbmRpbmc6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIGxvZ2dlci5pbmZvKFwiSXNTZW5kaW5nUHJvdmlkZXIgY3JlYXRlZCBjb250ZXh0IHZhbHVlOlwiLCB7IGlzU2VuZGluZyB9KTtcbiAgcmV0dXJuIChcbiAgICA8SXNTZW5kaW5nQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0lzU2VuZGluZ0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJc1NlbmRpbmcoKSB7XG4gIGxvZ2dlci5pbmZvKFwidXNlSXNTZW5kaW5nIGhvb2sgY2FsbGVkXCIpO1xuICAvLyBBZGQgc2FmZXR5IGNoZWNrIGZvciBTU1IvaHlkcmF0aW9uXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KElzU2VuZGluZ0NvbnRleHQpO1xuXG4gIGxvZ2dlci5pbmZvKFwidXNlSXNTZW5kaW5nIGNvbnRleHQgcmV0cmlldmVkOlwiLCB7XG4gICAgaXNTZW5kaW5nOiBjb250ZXh0Py5pc1NlbmRpbmcsXG4gICAgc2V0SXNTZW5kaW5nVHlwZTogdHlwZW9mIGNvbnRleHQ/LnNldElzU2VuZGluZyxcbiAgfSk7XG5cbiAgLy8gRW5zdXJlIHdlIG5ldmVyIHJldHVybiB1bmRlZmluZWQgZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgY29udGV4dD8uc2V0SXNTZW5kaW5nICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsb2dnZXIuZXJyb3IoXCJ1c2VJc1NlbmRpbmc6IHNldElzU2VuZGluZyBpcyBub3QgYSBmdW5jdGlvbiFcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU2VuZGluZzogY29udGV4dD8uaXNTZW5kaW5nIHx8IGZhbHNlLFxuICAgICAgc2V0SXNTZW5kaW5nOiBkZWZhdWx0U2V0SXNTZW5kaW5nLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cbiJdLCJuYW1lcyI6WyJJc1NlbmRpbmdQcm92aWRlciIsInVzZUlzU2VuZGluZyIsImxvZ2dlciIsImNyZWF0ZUxvZ2dlciIsImRlZmF1bHRTZXRJc1NlbmRpbmciLCJ2YWx1ZSIsIndhcm4iLCJJc1NlbmRpbmdDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImlzU2VuZGluZyIsInNldElzU2VuZGluZyIsImNoaWxkcmVuIiwiaW5mbyIsInVzZVN0YXRlIiwiY29udGV4dFZhbHVlIiwiZXJyb3IiLCJQcm92aWRlciIsImNvbnRleHQiLCJ1c2VDb250ZXh0Iiwic2V0SXNTZW5kaW5nVHlwZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztJQXVCZ0JBLGlCQUFpQjtlQUFqQkE7O0lBMEJBQyxZQUFZO2VBQVpBOzs7OytEQS9DMkM7NkJBQzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFN0IsTUFBTUMsU0FBU0MsSUFBQUEseUJBQVksRUFBQztBQU81Qix1Q0FBdUM7QUFDdkMsTUFBTUMsc0JBQXNCLENBQUNDO0lBQzNCSCxPQUFPSSxJQUFJLENBQUM7QUFDZDtBQUVBLGdDQUFnQztBQUNoQyxNQUFNQyxpQ0FBbUJDLElBQUFBLG9CQUFhLEVBQXVCO0lBQzNEQyxXQUFXO0lBQ1hDLGNBQWNOO0FBQ2hCO0FBRU8sU0FBU0osa0JBQWtCLEVBQUVXLFFBQVEsRUFBaUM7SUFDM0VULE9BQU9VLElBQUksQ0FBQztJQUNaLGtEQUFrRDtJQUNsRCxNQUFNLENBQUNILFdBQVdDLGFBQWEsR0FBR0csSUFBQUEsZUFBUSxFQUFVO0lBRXBELHVEQUF1RDtJQUN2RCxNQUFNQyxlQUFlO1FBQ25CTDtRQUNBQyxjQUFjLENBQUNMO1lBQ2JILE9BQU9VLElBQUksQ0FBQyxDQUFDLGdDQUFnQyxFQUFFUCxNQUFNLENBQUM7WUFDdEQsSUFBSTtnQkFDRkssYUFBYUw7WUFDZixFQUFFLE9BQU9VLE9BQU87Z0JBQ2RiLE9BQU9hLEtBQUssQ0FBQywwQkFBMEJBO1lBQ3pDO1FBQ0Y7SUFDRjtJQUVBYixPQUFPVSxJQUFJLENBQUMsNENBQTRDO1FBQUVIO0lBQVU7SUFDcEUscUJBQ0UscUJBQUNGLGlCQUFpQlMsUUFBUTtRQUFDWCxPQUFPUztrQkFDL0JIOztBQUdQO0FBRU8sU0FBU1Y7SUFDZEMsT0FBT1UsSUFBSSxDQUFDO0lBQ1oscUNBQXFDO0lBQ3JDLE1BQU1LLFVBQVVDLElBQUFBLGlCQUFVLEVBQUNYO0lBRTNCTCxPQUFPVSxJQUFJLENBQUMsbUNBQW1DO1FBQzdDSCxXQUFXUSxTQUFTUjtRQUNwQlUsa0JBQWtCLE9BQU9GLFNBQVNQO0lBQ3BDO0lBRUEsNkNBQTZDO0lBQzdDLElBQUksT0FBT08sU0FBU1AsaUJBQWlCLFlBQVk7UUFDL0NSLE9BQU9hLEtBQUssQ0FBQztRQUNiLE9BQU87WUFDTE4sV0FBV1EsU0FBU1IsYUFBYTtZQUNqQ0MsY0FBY047UUFDaEI7SUFDRjtJQUVBLE9BQU9hO0FBQ1QifQ==