cbf598e8d85d9d133012558beaa60cfb
/**
 * Phase 1: lib/debug-logger.ts Comprehensive Test Suite
 * Target: Complete debug logging functionality
 * Goal: Maximum statement coverage for debugging utilities
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _debuglogger = require("../../lib/debug-logger");
describe("lib/debug-logger.ts - Complete Coverage", ()=>{
    // Store original console methods
    const originalConsole = {
        log: console.log,
        info: console.info,
        warn: console.warn,
        error: console.error,
        debug: console.debug
    };
    // Mock console methods
    let mockConsole;
    beforeEach(()=>{
        // Create fresh mocks for each test
        mockConsole = {
            log: jest.fn(),
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn(),
            debug: jest.fn()
        };
        // Replace global console methods
        global.console = {
            ...console,
            ...mockConsole
        };
    });
    afterAll(()=>{
        // Restore original console methods
        global.console = {
            ...console,
            ...originalConsole
        };
    });
    describe("createLogger function", ()=>{
        test("creates logger with correct namespace", ()=>{
            const logger = (0, _debuglogger.createLogger)("test-namespace");
            expect(typeof logger).toBe("object");
            expect(typeof logger.log).toBe("function");
            expect(typeof logger.info).toBe("function");
            expect(typeof logger.warn).toBe("function");
            expect(typeof logger.error).toBe("function");
            expect(typeof logger.debug).toBe("function");
        });
        test("log method works correctly", ()=>{
            const logger = (0, _debuglogger.createLogger)("test-module");
            logger.log("Test message", "arg1", 123);
            expect(mockConsole.log).toHaveBeenCalledTimes(1);
            expect(mockConsole.log).toHaveBeenCalledWith("[test-module] Test message", "arg1", 123);
        });
        test("info method works correctly", ()=>{
            const logger = (0, _debuglogger.createLogger)("info-module");
            logger.info("Info message", {
                data: "test"
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(1);
            expect(mockConsole.info).toHaveBeenCalledWith("[info-module] Info message", {
                data: "test"
            });
        });
        test("warn method works correctly", ()=>{
            const logger = (0, _debuglogger.createLogger)("warn-module");
            logger.warn("Warning message", null, undefined);
            expect(mockConsole.warn).toHaveBeenCalledTimes(1);
            expect(mockConsole.warn).toHaveBeenCalledWith("[warn-module] Warning message", null, undefined);
        });
        test("error method works correctly", ()=>{
            const logger = (0, _debuglogger.createLogger)("error-module");
            const testError = new Error("Test error");
            logger.error("Error message", testError);
            expect(mockConsole.error).toHaveBeenCalledTimes(1);
            expect(mockConsole.error).toHaveBeenCalledWith("[error-module] Error message", testError);
        });
        test("debug method works correctly", ()=>{
            const logger = (0, _debuglogger.createLogger)("debug-module");
            logger.debug("Debug message", [
                1,
                2,
                3
            ]);
            expect(mockConsole.debug).toHaveBeenCalledTimes(1);
            expect(mockConsole.debug).toHaveBeenCalledWith("[debug-module] Debug message", [
                1,
                2,
                3
            ]);
        });
        test("handles empty namespace", ()=>{
            const logger = (0, _debuglogger.createLogger)("");
            logger.log("Test message");
            expect(mockConsole.log).toHaveBeenCalledWith("[] Test message");
        });
        test("handles special characters in namespace", ()=>{
            const logger = (0, _debuglogger.createLogger)("test-module@v1.0.0");
            logger.log("Version message");
            expect(mockConsole.log).toHaveBeenCalledWith("[test-module@v1.0.0] Version message");
        });
        test("handles unicode characters in namespace", ()=>{
            const logger = (0, _debuglogger.createLogger)("测试模块");
            logger.log("Unicode test", "\uD83D\uDE80");
            expect(mockConsole.log).toHaveBeenCalledWith("[测试模块] Unicode test", "\uD83D\uDE80");
        });
        test("handles no additional arguments", ()=>{
            const logger = (0, _debuglogger.createLogger)("minimal");
            logger.log("Just message");
            logger.info("Just info");
            logger.warn("Just warning");
            logger.error("Just error");
            logger.debug("Just debug");
            expect(mockConsole.log).toHaveBeenCalledWith("[minimal] Just message");
            expect(mockConsole.info).toHaveBeenCalledWith("[minimal] Just info");
            expect(mockConsole.warn).toHaveBeenCalledWith("[minimal] Just warning");
            expect(mockConsole.error).toHaveBeenCalledWith("[minimal] Just error");
            expect(mockConsole.debug).toHaveBeenCalledWith("[minimal] Just debug");
        });
        test("handles multiple arguments of different types", ()=>{
            const logger = (0, _debuglogger.createLogger)("complex");
            const complexArgs = [
                "string",
                123,
                true,
                null,
                undefined,
                {
                    object: "value"
                },
                [
                    1,
                    2,
                    3
                ],
                new Error("test"),
                Symbol("test")
            ];
            logger.log("Complex message", ...complexArgs);
            expect(mockConsole.log).toHaveBeenCalledWith("[complex] Complex message", ...complexArgs);
        });
        test("handles very long namespace", ()=>{
            const longNamespace = "a".repeat(1000);
            const logger = (0, _debuglogger.createLogger)(longNamespace);
            logger.log("Long namespace test");
            expect(mockConsole.log).toHaveBeenCalledWith(`[${longNamespace}] Long namespace test`);
        });
        test("handles very long message", ()=>{
            const logger = (0, _debuglogger.createLogger)("long-message");
            const longMessage = "Very long message ".repeat(100);
            logger.log(longMessage);
            expect(mockConsole.log).toHaveBeenCalledWith(`[long-message] ${longMessage}`);
        });
        test("different logger instances are independent", ()=>{
            const logger1 = (0, _debuglogger.createLogger)("module1");
            const logger2 = (0, _debuglogger.createLogger)("module2");
            logger1.log("Message from module1");
            logger2.log("Message from module2");
            expect(mockConsole.log).toHaveBeenCalledTimes(2);
            expect(mockConsole.log).toHaveBeenNthCalledWith(1, "[module1] Message from module1");
            expect(mockConsole.log).toHaveBeenNthCalledWith(2, "[module2] Message from module2");
        });
        test("logger methods can be called multiple times", ()=>{
            const logger = (0, _debuglogger.createLogger)("repeated");
            logger.log("First log");
            logger.log("Second log");
            logger.info("First info");
            expect(mockConsole.log).toHaveBeenCalledTimes(2);
            expect(mockConsole.info).toHaveBeenCalledTimes(1);
        });
        test("logger handles circular references in objects", ()=>{
            const logger = (0, _debuglogger.createLogger)("circular");
            const obj = {
                name: "test"
            };
            obj.self = obj; // Create circular reference
            // Should not throw an error
            expect(()=>{
                logger.log("Circular object", obj);
            }).not.toThrow();
            expect(mockConsole.log).toHaveBeenCalledWith("[circular] Circular object", obj);
        });
    });
    describe("debugLog function", ()=>{
        test("logs with DEBUG prefix", ()=>{
            (0, _debuglogger.debugLog)("Global debug message");
            expect(mockConsole.log).toHaveBeenCalledTimes(1);
            expect(mockConsole.log).toHaveBeenCalledWith("[DEBUG] Global debug message");
        });
        test("handles multiple arguments", ()=>{
            (0, _debuglogger.debugLog)("Debug with args", "arg1", 42, {
                key: "value"
            });
            expect(mockConsole.log).toHaveBeenCalledWith("[DEBUG] Debug with args", "arg1", 42, {
                key: "value"
            });
        });
        test("handles no additional arguments", ()=>{
            (0, _debuglogger.debugLog)("Simple debug");
            expect(mockConsole.log).toHaveBeenCalledWith("[DEBUG] Simple debug");
        });
        test("handles empty message", ()=>{
            (0, _debuglogger.debugLog)("");
            expect(mockConsole.log).toHaveBeenCalledWith("[DEBUG] ");
        });
        test("handles unicode and special characters", ()=>{
            (0, _debuglogger.debugLog)("Debug 测试 \uD83D\uDE80", "特殊字符");
            expect(mockConsole.log).toHaveBeenCalledWith("[DEBUG] Debug 测试 \uD83D\uDE80", "特殊字符");
        });
        test("handles various data types", ()=>{
            const testArgs = [
                "string",
                123,
                true,
                false,
                null,
                undefined,
                {
                    nested: {
                        object: true
                    }
                },
                [
                    1,
                    "mixed",
                    {
                        array: true
                    }
                ],
                new Date(),
                new Error("test error")
            ];
            (0, _debuglogger.debugLog)("Type test", ...testArgs);
            expect(mockConsole.log).toHaveBeenCalledWith("[DEBUG] Type test", ...testArgs);
        });
        test("can be called multiple times", ()=>{
            (0, _debuglogger.debugLog)("First debug");
            (0, _debuglogger.debugLog)("Second debug");
            (0, _debuglogger.debugLog)("Third debug");
            expect(mockConsole.log).toHaveBeenCalledTimes(3);
            expect(mockConsole.log).toHaveBeenNthCalledWith(1, "[DEBUG] First debug");
            expect(mockConsole.log).toHaveBeenNthCalledWith(2, "[DEBUG] Second debug");
            expect(mockConsole.log).toHaveBeenNthCalledWith(3, "[DEBUG] Third debug");
        });
        test("handles large data structures", ()=>{
            const largeArray = Array.from({
                length: 1000
            }, (_, i)=>({
                    id: i,
                    name: `Item ${i}`,
                    data: `Data for item ${i}`
                }));
            (0, _debuglogger.debugLog)("Large data structure", largeArray);
            expect(mockConsole.log).toHaveBeenCalledWith("[DEBUG] Large data structure", largeArray);
        });
    });
    describe("integration and edge cases", ()=>{
        test("createLogger and debugLog work together", ()=>{
            const logger = (0, _debuglogger.createLogger)("integration");
            logger.log("From logger");
            (0, _debuglogger.debugLog)("From debugLog");
            expect(mockConsole.log).toHaveBeenCalledTimes(2);
            expect(mockConsole.log).toHaveBeenNthCalledWith(1, "[integration] From logger");
            expect(mockConsole.log).toHaveBeenNthCalledWith(2, "[DEBUG] From debugLog");
        });
        test("handles concurrent logger usage", ()=>{
            const loggers = Array.from({
                length: 10
            }, (_, i)=>(0, _debuglogger.createLogger)(`concurrent-${i}`));
            loggers.forEach((logger, i)=>{
                logger.log(`Message ${i}`);
            });
            expect(mockConsole.log).toHaveBeenCalledTimes(10);
            loggers.forEach((_, i)=>{
                expect(mockConsole.log).toHaveBeenNthCalledWith(i + 1, `[concurrent-${i}] Message ${i}`);
            });
        });
        test("performance with many log calls", ()=>{
            const logger = (0, _debuglogger.createLogger)("performance");
            const startTime = Date.now();
            for(let i = 0; i < 1000; i++){
                logger.log(`Performance test ${i}`);
            }
            const endTime = Date.now();
            expect(mockConsole.log).toHaveBeenCalledTimes(1000);
            expect(endTime - startTime).toBeLessThan(1000); // Should complete quickly
        });
        test("memory efficiency with multiple loggers", ()=>{
            const loggers = Array.from({
                length: 100
            }, (_, i)=>(0, _debuglogger.createLogger)(`memory-test-${i}`));
            // Should not cause memory issues
            loggers.forEach((logger)=>{
                logger.log("Memory test");
                logger.info("Memory test");
                logger.warn("Memory test");
                logger.error("Memory test");
                logger.debug("Memory test");
            });
            expect(mockConsole.log).toHaveBeenCalledTimes(100);
            expect(mockConsole.info).toHaveBeenCalledTimes(100);
            expect(mockConsole.warn).toHaveBeenCalledTimes(100);
            expect(mockConsole.error).toHaveBeenCalledTimes(100);
            expect(mockConsole.debug).toHaveBeenCalledTimes(100);
        });
        test("logger methods return undefined", ()=>{
            const logger = (0, _debuglogger.createLogger)("return-test");
            expect(logger.log("test")).toBeUndefined();
            expect(logger.info("test")).toBeUndefined();
            expect(logger.warn("test")).toBeUndefined();
            expect(logger.error("test")).toBeUndefined();
            expect(logger.debug("test")).toBeUndefined();
            expect((0, _debuglogger.debugLog)("test")).toBeUndefined();
        });
        test("functions handle malformed input gracefully", ()=>{
            const logger = (0, _debuglogger.createLogger)("malformed");
            // Should not throw errors for most cases
            expect(()=>{
                logger.log(null);
                logger.info(undefined);
                logger.warn(123);
            }).not.toThrow();
            // Symbol conversion will throw - this is expected behavior
            expect(()=>{
                (0, _debuglogger.debugLog)(Symbol("test"));
            }).toThrow("Cannot convert a Symbol value to a string");
            expect(mockConsole.log).toHaveBeenCalledTimes(1);
            expect(mockConsole.info).toHaveBeenCalledTimes(1);
            expect(mockConsole.warn).toHaveBeenCalledTimes(1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2RlYnVnLWxvZ2dlci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGhhc2UgMTogbGliL2RlYnVnLWxvZ2dlci50cyBDb21wcmVoZW5zaXZlIFRlc3QgU3VpdGVcbiAqIFRhcmdldDogQ29tcGxldGUgZGVidWcgbG9nZ2luZyBmdW5jdGlvbmFsaXR5XG4gKiBHb2FsOiBNYXhpbXVtIHN0YXRlbWVudCBjb3ZlcmFnZSBmb3IgZGVidWdnaW5nIHV0aWxpdGllc1xuICovXG5cbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciwgZGVidWdMb2cgfSBmcm9tIFwiLi4vLi4vbGliL2RlYnVnLWxvZ2dlclwiO1xuXG5kZXNjcmliZShcImxpYi9kZWJ1Zy1sb2dnZXIudHMgLSBDb21wbGV0ZSBDb3ZlcmFnZVwiLCAoKSA9PiB7XG4gIC8vIFN0b3JlIG9yaWdpbmFsIGNvbnNvbGUgbWV0aG9kc1xuICBjb25zdCBvcmlnaW5hbENvbnNvbGUgPSB7XG4gICAgbG9nOiBjb25zb2xlLmxvZyxcbiAgICBpbmZvOiBjb25zb2xlLmluZm8sXG4gICAgd2FybjogY29uc29sZS53YXJuLFxuICAgIGVycm9yOiBjb25zb2xlLmVycm9yLFxuICAgIGRlYnVnOiBjb25zb2xlLmRlYnVnLFxuICB9O1xuXG4gIC8vIE1vY2sgY29uc29sZSBtZXRob2RzXG4gIGxldCBtb2NrQ29uc29sZTogYW55O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIENyZWF0ZSBmcmVzaCBtb2NrcyBmb3IgZWFjaCB0ZXN0XG4gICAgbW9ja0NvbnNvbGUgPSB7XG4gICAgICBsb2c6IGplc3QuZm4oKSxcbiAgICAgIGluZm86IGplc3QuZm4oKSxcbiAgICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgICBkZWJ1ZzogamVzdC5mbigpLFxuICAgIH07XG5cbiAgICAvLyBSZXBsYWNlIGdsb2JhbCBjb25zb2xlIG1ldGhvZHNcbiAgICBnbG9iYWwuY29uc29sZSA9IHtcbiAgICAgIC4uLmNvbnNvbGUsXG4gICAgICAuLi5tb2NrQ29uc29sZSxcbiAgICB9O1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb25zb2xlIG1ldGhvZHNcbiAgICBnbG9iYWwuY29uc29sZSA9IHtcbiAgICAgIC4uLmNvbnNvbGUsXG4gICAgICAuLi5vcmlnaW5hbENvbnNvbGUsXG4gICAgfTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJjcmVhdGVMb2dnZXIgZnVuY3Rpb25cIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjcmVhdGVzIGxvZ2dlciB3aXRoIGNvcnJlY3QgbmFtZXNwYWNlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihcInRlc3QtbmFtZXNwYWNlXCIpO1xuXG4gICAgICBleHBlY3QodHlwZW9mIGxvZ2dlcikudG9CZShcIm9iamVjdFwiKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgbG9nZ2VyLmxvZykudG9CZShcImZ1bmN0aW9uXCIpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBsb2dnZXIuaW5mbykudG9CZShcImZ1bmN0aW9uXCIpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBsb2dnZXIud2FybikudG9CZShcImZ1bmN0aW9uXCIpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBsb2dnZXIuZXJyb3IpLnRvQmUoXCJmdW5jdGlvblwiKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgbG9nZ2VyLmRlYnVnKS50b0JlKFwiZnVuY3Rpb25cIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwibG9nIG1ldGhvZCB3b3JrcyBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwidGVzdC1tb2R1bGVcIik7XG5cbiAgICAgIGxvZ2dlci5sb2coXCJUZXN0IG1lc3NhZ2VcIiwgXCJhcmcxXCIsIDEyMyk7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIlt0ZXN0LW1vZHVsZV0gVGVzdCBtZXNzYWdlXCIsXG4gICAgICAgIFwiYXJnMVwiLFxuICAgICAgICAxMjMsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImluZm8gbWV0aG9kIHdvcmtzIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJpbmZvLW1vZHVsZVwiKTtcblxuICAgICAgbG9nZ2VyLmluZm8oXCJJbmZvIG1lc3NhZ2VcIiwgeyBkYXRhOiBcInRlc3RcIiB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbaW5mby1tb2R1bGVdIEluZm8gbWVzc2FnZVwiLFxuICAgICAgICB7IGRhdGE6IFwidGVzdFwiIH0sXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcIndhcm4gbWV0aG9kIHdvcmtzIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJ3YXJuLW1vZHVsZVwiKTtcblxuICAgICAgbG9nZ2VyLndhcm4oXCJXYXJuaW5nIG1lc3NhZ2VcIiwgbnVsbCwgdW5kZWZpbmVkKTtcblxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbd2Fybi1tb2R1bGVdIFdhcm5pbmcgbWVzc2FnZVwiLFxuICAgICAgICBudWxsLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImVycm9yIG1ldGhvZCB3b3JrcyBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwiZXJyb3ItbW9kdWxlXCIpO1xuICAgICAgY29uc3QgdGVzdEVycm9yID0gbmV3IEVycm9yKFwiVGVzdCBlcnJvclwiKTtcblxuICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgbWVzc2FnZVwiLCB0ZXN0RXJyb3IpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW2Vycm9yLW1vZHVsZV0gRXJyb3IgbWVzc2FnZVwiLFxuICAgICAgICB0ZXN0RXJyb3IsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImRlYnVnIG1ldGhvZCB3b3JrcyBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwiZGVidWctbW9kdWxlXCIpO1xuXG4gICAgICBsb2dnZXIuZGVidWcoXCJEZWJ1ZyBtZXNzYWdlXCIsIFsxLCAyLCAzXSk7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbZGVidWctbW9kdWxlXSBEZWJ1ZyBtZXNzYWdlXCIsXG4gICAgICAgIFsxLCAyLCAzXSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlbXB0eSBuYW1lc3BhY2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwiXCIpO1xuXG4gICAgICBsb2dnZXIubG9nKFwiVGVzdCBtZXNzYWdlXCIpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIltdIFRlc3QgbWVzc2FnZVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBuYW1lc3BhY2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwidGVzdC1tb2R1bGVAdjEuMC4wXCIpO1xuXG4gICAgICBsb2dnZXIubG9nKFwiVmVyc2lvbiBtZXNzYWdlXCIpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbdGVzdC1tb2R1bGVAdjEuMC4wXSBWZXJzaW9uIG1lc3NhZ2VcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyB1bmljb2RlIGNoYXJhY3RlcnMgaW4gbmFtZXNwYWNlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihcIua1i+ivleaooeWdl1wiKTtcblxuICAgICAgbG9nZ2VyLmxvZyhcIlVuaWNvZGUgdGVzdFwiLCBcIvCfmoBcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIlvmtYvor5XmqKHlnZddIFVuaWNvZGUgdGVzdFwiLFxuICAgICAgICBcIvCfmoBcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBubyBhZGRpdGlvbmFsIGFyZ3VtZW50c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJtaW5pbWFsXCIpO1xuXG4gICAgICBsb2dnZXIubG9nKFwiSnVzdCBtZXNzYWdlXCIpO1xuICAgICAgbG9nZ2VyLmluZm8oXCJKdXN0IGluZm9cIik7XG4gICAgICBsb2dnZXIud2FybihcIkp1c3Qgd2FybmluZ1wiKTtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkp1c3QgZXJyb3JcIik7XG4gICAgICBsb2dnZXIuZGVidWcoXCJKdXN0IGRlYnVnXCIpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIlttaW5pbWFsXSBKdXN0IG1lc3NhZ2VcIik7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJbbWluaW1hbF0gSnVzdCBpbmZvXCIpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiW21pbmltYWxdIEp1c3Qgd2FybmluZ1wiKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJbbWluaW1hbF0gSnVzdCBlcnJvclwiKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJbbWluaW1hbF0gSnVzdCBkZWJ1Z1wiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG11bHRpcGxlIGFyZ3VtZW50cyBvZiBkaWZmZXJlbnQgdHlwZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwiY29tcGxleFwiKTtcbiAgICAgIGNvbnN0IGNvbXBsZXhBcmdzID0gW1xuICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAxMjMsXG4gICAgICAgIHRydWUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgeyBvYmplY3Q6IFwidmFsdWVcIiB9LFxuICAgICAgICBbMSwgMiwgM10sXG4gICAgICAgIG5ldyBFcnJvcihcInRlc3RcIiksXG4gICAgICAgIFN5bWJvbChcInRlc3RcIiksXG4gICAgICBdO1xuXG4gICAgICBsb2dnZXIubG9nKFwiQ29tcGxleCBtZXNzYWdlXCIsIC4uLmNvbXBsZXhBcmdzKTtcblxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW2NvbXBsZXhdIENvbXBsZXggbWVzc2FnZVwiLFxuICAgICAgICAuLi5jb21wbGV4QXJncyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyB2ZXJ5IGxvbmcgbmFtZXNwYWNlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvbmdOYW1lc3BhY2UgPSBcImFcIi5yZXBlYXQoMTAwMCk7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIobG9uZ05hbWVzcGFjZSk7XG5cbiAgICAgIGxvZ2dlci5sb2coXCJMb25nIG5hbWVzcGFjZSB0ZXN0XCIpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgYFske2xvbmdOYW1lc3BhY2V9XSBMb25nIG5hbWVzcGFjZSB0ZXN0YCxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyB2ZXJ5IGxvbmcgbWVzc2FnZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJsb25nLW1lc3NhZ2VcIik7XG4gICAgICBjb25zdCBsb25nTWVzc2FnZSA9IFwiVmVyeSBsb25nIG1lc3NhZ2UgXCIucmVwZWF0KDEwMCk7XG5cbiAgICAgIGxvZ2dlci5sb2cobG9uZ01lc3NhZ2UpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgYFtsb25nLW1lc3NhZ2VdICR7bG9uZ01lc3NhZ2V9YCxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZGlmZmVyZW50IGxvZ2dlciBpbnN0YW5jZXMgYXJlIGluZGVwZW5kZW50XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlcjEgPSBjcmVhdGVMb2dnZXIoXCJtb2R1bGUxXCIpO1xuICAgICAgY29uc3QgbG9nZ2VyMiA9IGNyZWF0ZUxvZ2dlcihcIm1vZHVsZTJcIik7XG5cbiAgICAgIGxvZ2dlcjEubG9nKFwiTWVzc2FnZSBmcm9tIG1vZHVsZTFcIik7XG4gICAgICBsb2dnZXIyLmxvZyhcIk1lc3NhZ2UgZnJvbSBtb2R1bGUyXCIpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aChcbiAgICAgICAgMSxcbiAgICAgICAgXCJbbW9kdWxlMV0gTWVzc2FnZSBmcm9tIG1vZHVsZTFcIixcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aChcbiAgICAgICAgMixcbiAgICAgICAgXCJbbW9kdWxlMl0gTWVzc2FnZSBmcm9tIG1vZHVsZTJcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwibG9nZ2VyIG1ldGhvZHMgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJyZXBlYXRlZFwiKTtcblxuICAgICAgbG9nZ2VyLmxvZyhcIkZpcnN0IGxvZ1wiKTtcbiAgICAgIGxvZ2dlci5sb2coXCJTZWNvbmQgbG9nXCIpO1xuICAgICAgbG9nZ2VyLmluZm8oXCJGaXJzdCBpbmZvXCIpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImxvZ2dlciBoYW5kbGVzIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gb2JqZWN0c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJjaXJjdWxhclwiKTtcbiAgICAgIGNvbnN0IG9iajogYW55ID0geyBuYW1lOiBcInRlc3RcIiB9O1xuICAgICAgb2JqLnNlbGYgPSBvYmo7IC8vIENyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBhbiBlcnJvclxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkNpcmN1bGFyIG9iamVjdFwiLCBvYmopO1xuICAgICAgfSkubm90LnRvVGhyb3coKTtcblxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW2NpcmN1bGFyXSBDaXJjdWxhciBvYmplY3RcIixcbiAgICAgICAgb2JqLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJkZWJ1Z0xvZyBmdW5jdGlvblwiLCAoKSA9PiB7XG4gICAgdGVzdChcImxvZ3Mgd2l0aCBERUJVRyBwcmVmaXhcIiwgKCkgPT4ge1xuICAgICAgZGVidWdMb2coXCJHbG9iYWwgZGVidWcgbWVzc2FnZVwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmxvZykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0RFQlVHXSBHbG9iYWwgZGVidWcgbWVzc2FnZVwiLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG11bHRpcGxlIGFyZ3VtZW50c1wiLCAoKSA9PiB7XG4gICAgICBkZWJ1Z0xvZyhcIkRlYnVnIHdpdGggYXJnc1wiLCBcImFyZzFcIiwgNDIsIHsga2V5OiBcInZhbHVlXCIgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltERUJVR10gRGVidWcgd2l0aCBhcmdzXCIsXG4gICAgICAgIFwiYXJnMVwiLFxuICAgICAgICA0MixcbiAgICAgICAgeyBrZXk6IFwidmFsdWVcIiB9LFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG5vIGFkZGl0aW9uYWwgYXJndW1lbnRzXCIsICgpID0+IHtcbiAgICAgIGRlYnVnTG9nKFwiU2ltcGxlIGRlYnVnXCIpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIltERUJVR10gU2ltcGxlIGRlYnVnXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZW1wdHkgbWVzc2FnZVwiLCAoKSA9PiB7XG4gICAgICBkZWJ1Z0xvZyhcIlwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJbREVCVUddIFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIHVuaWNvZGUgYW5kIHNwZWNpYWwgY2hhcmFjdGVyc1wiLCAoKSA9PiB7XG4gICAgICBkZWJ1Z0xvZyhcIkRlYnVnIOa1i+ivlSDwn5qAXCIsIFwi54m55q6K5a2X56ymXCIpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbREVCVUddIERlYnVnIOa1i+ivlSDwn5qAXCIsXG4gICAgICAgIFwi54m55q6K5a2X56ymXCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgdmFyaW91cyBkYXRhIHR5cGVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RBcmdzID0gW1xuICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAxMjMsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBudWxsLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHsgbmVzdGVkOiB7IG9iamVjdDogdHJ1ZSB9IH0sXG4gICAgICAgIFsxLCBcIm1peGVkXCIsIHsgYXJyYXk6IHRydWUgfV0sXG4gICAgICAgIG5ldyBEYXRlKCksXG4gICAgICAgIG5ldyBFcnJvcihcInRlc3QgZXJyb3JcIiksXG4gICAgICBdO1xuXG4gICAgICBkZWJ1Z0xvZyhcIlR5cGUgdGVzdFwiLCAuLi50ZXN0QXJncyk7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltERUJVR10gVHlwZSB0ZXN0XCIsXG4gICAgICAgIC4uLnRlc3RBcmdzLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzXCIsICgpID0+IHtcbiAgICAgIGRlYnVnTG9nKFwiRmlyc3QgZGVidWdcIik7XG4gICAgICBkZWJ1Z0xvZyhcIlNlY29uZCBkZWJ1Z1wiKTtcbiAgICAgIGRlYnVnTG9nKFwiVGhpcmQgZGVidWdcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKDEsIFwiW0RFQlVHXSBGaXJzdCBkZWJ1Z1wiKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKFxuICAgICAgICAyLFxuICAgICAgICBcIltERUJVR10gU2Vjb25kIGRlYnVnXCIsXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmxvZykudG9IYXZlQmVlbk50aENhbGxlZFdpdGgoMywgXCJbREVCVUddIFRoaXJkIGRlYnVnXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgbGFyZ2UgZGF0YSBzdHJ1Y3R1cmVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlQXJyYXkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogaSxcbiAgICAgICAgbmFtZTogYEl0ZW0gJHtpfWAsXG4gICAgICAgIGRhdGE6IGBEYXRhIGZvciBpdGVtICR7aX1gLFxuICAgICAgfSkpO1xuXG4gICAgICBkZWJ1Z0xvZyhcIkxhcmdlIGRhdGEgc3RydWN0dXJlXCIsIGxhcmdlQXJyYXkpO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbREVCVUddIExhcmdlIGRhdGEgc3RydWN0dXJlXCIsXG4gICAgICAgIGxhcmdlQXJyYXksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImludGVncmF0aW9uIGFuZCBlZGdlIGNhc2VzXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiY3JlYXRlTG9nZ2VyIGFuZCBkZWJ1Z0xvZyB3b3JrIHRvZ2V0aGVyXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihcImludGVncmF0aW9uXCIpO1xuXG4gICAgICBsb2dnZXIubG9nKFwiRnJvbSBsb2dnZXJcIik7XG4gICAgICBkZWJ1Z0xvZyhcIkZyb20gZGVidWdMb2dcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKFxuICAgICAgICAxLFxuICAgICAgICBcIltpbnRlZ3JhdGlvbl0gRnJvbSBsb2dnZXJcIixcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aChcbiAgICAgICAgMixcbiAgICAgICAgXCJbREVCVUddIEZyb20gZGVidWdMb2dcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBjb25jdXJyZW50IGxvZ2dlciB1c2FnZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXJzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGkpID0+XG4gICAgICAgIGNyZWF0ZUxvZ2dlcihgY29uY3VycmVudC0ke2l9YCksXG4gICAgICApO1xuXG4gICAgICBsb2dnZXJzLmZvckVhY2goKGxvZ2dlciwgaSkgPT4ge1xuICAgICAgICBsb2dnZXIubG9nKGBNZXNzYWdlICR7aX1gKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMTApO1xuICAgICAgbG9nZ2Vycy5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKFxuICAgICAgICAgIGkgKyAxLFxuICAgICAgICAgIGBbY29uY3VycmVudC0ke2l9XSBNZXNzYWdlICR7aX1gLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicGVyZm9ybWFuY2Ugd2l0aCBtYW55IGxvZyBjYWxsc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJwZXJmb3JtYW5jZVwiKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYFBlcmZvcm1hbmNlIHRlc3QgJHtpfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxMDAwKTtcbiAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSBxdWlja2x5XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwibWVtb3J5IGVmZmljaWVuY3kgd2l0aCBtdWx0aXBsZSBsb2dnZXJzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+XG4gICAgICAgIGNyZWF0ZUxvZ2dlcihgbWVtb3J5LXRlc3QtJHtpfWApLFxuICAgICAgKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCBjYXVzZSBtZW1vcnkgaXNzdWVzXG4gICAgICBsb2dnZXJzLmZvckVhY2goKGxvZ2dlcikgPT4ge1xuICAgICAgICBsb2dnZXIubG9nKFwiTWVtb3J5IHRlc3RcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiTWVtb3J5IHRlc3RcIik7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiTWVtb3J5IHRlc3RcIik7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIk1lbW9yeSB0ZXN0XCIpO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJNZW1vcnkgdGVzdFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMTAwKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMTAwKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMTAwKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEwMCk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImxvZ2dlciBtZXRob2RzIHJldHVybiB1bmRlZmluZWRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwicmV0dXJuLXRlc3RcIik7XG5cbiAgICAgIGV4cGVjdChsb2dnZXIubG9nKFwidGVzdFwiKSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGxvZ2dlci5pbmZvKFwidGVzdFwiKSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGxvZ2dlci53YXJuKFwidGVzdFwiKSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGxvZ2dlci5lcnJvcihcInRlc3RcIikpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChsb2dnZXIuZGVidWcoXCJ0ZXN0XCIpKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGVidWdMb2coXCJ0ZXN0XCIpKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZnVuY3Rpb25zIGhhbmRsZSBtYWxmb3JtZWQgaW5wdXQgZ3JhY2VmdWxseVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJtYWxmb3JtZWRcIik7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgZXJyb3JzIGZvciBtb3N0IGNhc2VzXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBsb2dnZXIubG9nKG51bGwgYXMgYW55KTtcbiAgICAgICAgbG9nZ2VyLmluZm8odW5kZWZpbmVkIGFzIGFueSk7XG4gICAgICAgIGxvZ2dlci53YXJuKDEyMyBhcyBhbnkpO1xuICAgICAgfSkubm90LnRvVGhyb3coKTtcblxuICAgICAgLy8gU3ltYm9sIGNvbnZlcnNpb24gd2lsbCB0aHJvdyAtIHRoaXMgaXMgZXhwZWN0ZWQgYmVoYXZpb3JcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGRlYnVnTG9nKFN5bWJvbChcInRlc3RcIikgYXMgYW55KTtcbiAgICAgIH0pLnRvVGhyb3coXCJDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZ1wiKTtcblxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmxvZykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJvcmlnaW5hbENvbnNvbGUiLCJsb2ciLCJjb25zb2xlIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImRlYnVnIiwibW9ja0NvbnNvbGUiLCJiZWZvcmVFYWNoIiwiamVzdCIsImZuIiwiZ2xvYmFsIiwiYWZ0ZXJBbGwiLCJ0ZXN0IiwibG9nZ2VyIiwiY3JlYXRlTG9nZ2VyIiwiZXhwZWN0IiwidG9CZSIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiZGF0YSIsInVuZGVmaW5lZCIsInRlc3RFcnJvciIsIkVycm9yIiwiY29tcGxleEFyZ3MiLCJvYmplY3QiLCJTeW1ib2wiLCJsb25nTmFtZXNwYWNlIiwicmVwZWF0IiwibG9uZ01lc3NhZ2UiLCJsb2dnZXIxIiwibG9nZ2VyMiIsInRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoIiwib2JqIiwibmFtZSIsInNlbGYiLCJub3QiLCJ0b1Rocm93IiwiZGVidWdMb2ciLCJrZXkiLCJ0ZXN0QXJncyIsIm5lc3RlZCIsImFycmF5IiwiRGF0ZSIsImxhcmdlQXJyYXkiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImlkIiwibG9nZ2VycyIsImZvckVhY2giLCJzdGFydFRpbWUiLCJub3ciLCJlbmRUaW1lIiwidG9CZUxlc3NUaGFuIiwidG9CZVVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQzs7Ozs2QkFFc0M7QUFFdkNBLFNBQVMsMkNBQTJDO0lBQ2xE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