6ed7001bc299a1fce4233a96dd4506c0
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return AutonomousConversationManager;
    }
});
const _react = require("react");
const _useConversationorchestrator = require("../hooks/useConversationorchestrator");
const _llmcontext = require("../contexts/llm-context");
const _debuglogger = require("../lib/debug-logger");
// Create a logger for this component
const logger = (0, _debuglogger.createLogger)("AutonomousConversationManager");
function AutonomousConversationManager({ conversation, agents, onSendMessage }) {
    // Use the conversation orchestrator hook properly within a component
    const { queueAgentResponse, processNewMessage } = (0, _useConversationorchestrator.useConversationOrchestrator)(conversation, agents, {
        autoSelectRespondents: true,
        responseDelay: [
            800,
            2000
        ]
    }, onSendMessage);
    // Get LLM client for generating conversation starters
    const { settings, client: llmClient } = (0, _llmcontext.useLLM)();
    // Track if we've already sent a starter message
    const hasInitializedRef = (0, _react.useRef)(false);
    // Track if we're currently generating a starter message
    const isGeneratingStarterRef = (0, _react.useRef)(false);
    // Track the current message count for monitoring
    const [messageCount, setMessageCount] = (0, _react.useState)(0);
    // Update message count when conversation changes
    (0, _react.useEffect)(()=>{
        if (conversation) {
            const nonSystemMessages = conversation.messages.filter((msg)=>!msg.metadata?.isSystemMessage).length;
            setMessageCount(nonSystemMessages);
        }
    }, [
        conversation
    ]);
    // Function to generate a conversation starter message using the LLM
    const generateConversationStarter = (0, _react.useCallback)(async (firstAgent, participants, topic)=>{
        if (!llmClient) {
            logger.error("Cannot generate conversation starter: LLM client not available");
            return fallbackStarterMessage(firstAgent, topic);
        }
        // Collect all agents' information
        const agentInfos = participants.map((agent)=>({
                name: agent.name,
                biography: agent.biography,
                isStarter: agent.id === firstAgent.id
            }));
        // Create a system prompt that explains what we want
        const systemPrompt = `You are helping to start a conversation between AI agents.
Generate a conversation starter message from the perspective of ${firstAgent.name}.
The message should:
1. Be prefixed with "${firstAgent.name}: " (include the colon and space)
2. Acknowledge the other participants
3. Reference the agent's own background/expertise
4. Mention the other agents' backgrounds/expertise
5. ${topic ? `Relate to the provided topic: ${topic}` : "Suggest a relevant topic based on the agents' backgrounds"}
6. Encourage collaboration and brainstorming
7. Ask a question that invites response

IMPORTANT: Always start with "${firstAgent.name}: " followed by the message.`;
        // Create a user prompt with agent information
        const userPrompt = `Agents in conversation:
${agentInfos.map((info)=>`- ${info.name}: ${info.biography}`).join("\n")}

${topic ? `Conversation topic: ${topic}` : "No specific topic provided, but suggest something relevant to the agents' backgrounds."}

Write a conversation starter message from ${firstAgent.name}'s perspective that will engage the other agents.
Remember to start with "${firstAgent.name}: " followed by the message.`;
        try {
            logger.log("Generating conversation starter message", {
                firstAgent: firstAgent.name,
                participantCount: participants.length,
                topic
            });
            // Generate the starter message
            const response = await llmClient.generateResponse(systemPrompt, userPrompt);
            // Ensure the response starts with the agent name
            let formattedResponse = response.trim();
            const expectedPrefix = `${firstAgent.name}:`;
            if (!formattedResponse.startsWith(expectedPrefix)) {
                formattedResponse = `${expectedPrefix} ${formattedResponse}`;
                logger.log("Added missing agent name prefix to starter message");
            }
            logger.log("Successfully generated conversation starter", {
                messagePreview: formattedResponse.substring(0, 50) + "..."
            });
            return formattedResponse;
        } catch (error) {
            logger.error("Error generating conversation starter:", error);
            return fallbackStarterMessage(firstAgent, topic);
        }
    }, [
        llmClient
    ]);
    // Fallback message in case LLM generation fails
    function fallbackStarterMessage(agent, topic) {
        logger.log("Using fallback conversation starter message");
        return `${agent.name}: Hello everyone! I'm ${agent.name}, ${agent.biography.split(".")[0]}. ${topic ? `I'd love to discuss ${topic} with you all.` : "I'd love to discuss our backgrounds and see how we might collaborate."} What are your thoughts?`;
    }
    // Update the useEffect to use the enhanced conversation starter
    (0, _react.useEffect)(()=>{
        if (!conversation || !conversation.isAutonomous) return;
        // Check if we've already initialized this conversation
        if (hasInitializedRef.current || isGeneratingStarterRef.current) return;
        logger.log("Checking conversation state", {
            conversationId: conversation.id,
            messageCount: conversation.messages.length,
            participants: conversation.participants
        });
        // Check if there are any messages or only a system message
        const onlyHasSystemMessage = conversation.messages.length === 1 && conversation.messages[0].metadata?.isSystemMessage === true;
        if (conversation.messages.length === 0 || onlyHasSystemMessage) {
            logger.log("Initializing autonomous conversation", {
                conversationId: conversation.id,
                participants: conversation.participants,
                trigger: conversation.trigger,
                topic: conversation.topic
            });
            try {
                // Find the first agent to use as the starter
                const firstAgent = agents.find((agent)=>conversation.participants.includes(agent.id));
                if (firstAgent) {
                    // Get all participating agents
                    const participatingAgents = agents.filter((agent)=>conversation.participants.includes(agent.id));
                    // Set the generating flag to prevent duplicate attempts
                    isGeneratingStarterRef.current = true;
                    // Generate the conversation starter asynchronously
                    generateConversationStarter(firstAgent, participatingAgents, conversation.topic).then((starterContent)=>{
                        // Create a conversation starter message
                        const starterMessage = {
                            id: `msg-starter-${Date.now()}`,
                            content: starterContent,
                            senderId: firstAgent.id,
                            timestamp: new Date(),
                            metadata: {
                                isGeneratedByLLM: true,
                                type: "conversation_starter"
                            }
                        };
                        logger.log("Sending starter message", {
                            messageId: starterMessage.id,
                            sender: firstAgent.name,
                            contentPreview: starterMessage.content.substring(0, 50) + "..."
                        });
                        // Send the message
                        onSendMessage(starterContent, firstAgent.id);
                        // Mark as initialized to prevent duplicate messages
                        hasInitializedRef.current = true;
                        isGeneratingStarterRef.current = false;
                        // Process the message to trigger responses after a short delay
                        setTimeout(()=>{
                            try {
                                logger.log("Processing starter message to trigger responses");
                                processNewMessage(starterMessage);
                            } catch (error) {
                                logger.error("Error processing starter message:", error);
                            }
                        }, 1000);
                    }).catch((error)=>{
                        logger.error("Error in conversation starter generation:", error);
                        isGeneratingStarterRef.current = false;
                    });
                } else {
                    logger.error("No agents found for conversation");
                }
            } catch (error) {
                logger.error("Error initializing conversation:", error);
                isGeneratingStarterRef.current = false;
            }
        } else {
            // If there are already messages, mark as initialized
            logger.log("Conversation already has messages, marking as initialized");
            hasInitializedRef.current = true;
        }
    }, [
        conversation,
        agents,
        onSendMessage,
        processNewMessage,
        llmClient,
        generateConversationStarter
    ]);
    // Add a new effect to monitor conversation progress and ensure it reaches minimum message count
    (0, _react.useEffect)(()=>{
        if (!conversation || !conversation.isAutonomous || !hasInitializedRef.current) return;
        // Get the minimum and maximum message counts from settings
        const maxMessages = settings?.maxAutonomousMessages || 10;
        const minMessages = Math.max(2, Math.floor(maxMessages / 2)); // Set minimum to half of max, but at least 2
        // Count non-system messages
        const nonSystemMessages = conversation.messages.filter((msg)=>!msg.metadata?.isSystemMessage).length;
        // If we haven't reached the minimum message count, set up a monitoring interval
        if (nonSystemMessages < minMessages) {
            logger.log(`Setting up conversation progress monitor: ${nonSystemMessages}/${minMessages} messages`);
            // Set up an interval to check if the conversation needs to be continued
            const intervalId = setInterval(()=>{
                // Skip if conversation has been deleted or changed
                if (!conversation) {
                    clearInterval(intervalId);
                    return;
                }
                // Recount non-system messages (they might have changed)
                const currentNonSystemMessages = conversation.messages.filter((msg)=>!msg.metadata?.isSystemMessage).length;
                // If we've reached the minimum, clear the interval
                if (currentNonSystemMessages >= minMessages) {
                    logger.log(`Conversation reached minimum message count (${currentNonSystemMessages}/${minMessages}), stopping monitor`);
                    clearInterval(intervalId);
                    return;
                }
                // Get the last message
                const lastMessage = conversation.messages[conversation.messages.length - 1];
                if (!lastMessage) return;
                // Check if the last message was sent more than 5 seconds ago
                const timeSinceLastMessage = Date.now() - new Date(lastMessage.timestamp).getTime();
                if (timeSinceLastMessage > 5000) {
                    // 5 seconds
                    logger.log(`Conversation stalled at ${currentNonSystemMessages}/${minMessages} messages, prompting continuation`);
                    // Find an agent who hasn't spoken recently
                    const lastSpeaker = lastMessage.senderId;
                    const availableAgents = agents.filter((agent)=>conversation.participants.includes(agent.id) && agent.id !== lastSpeaker);
                    if (availableAgents.length > 0) {
                        // Pick a random agent to continue the conversation
                        const nextAgent = availableAgents[Math.floor(Math.random() * availableAgents.length)];
                        logger.log(`Prompting ${nextAgent.name} to continue the conversation`);
                        // Queue a response from this agent to keep the conversation going
                        queueAgentResponse(nextAgent.id, {
                            messageToRespondTo: lastMessage,
                            responseDelay: 500,
                            force: true
                        });
                    }
                }
            }, 3000); // Check every 3 seconds
            // Clean up the interval when the component unmounts or conversation changes
            return ()=>clearInterval(intervalId);
        }
    }, [
        conversation,
        messageCount,
        agents,
        settings,
        queueAgentResponse
    ]);
    // Reset initialization when conversation changes
    (0, _react.useEffect)(()=>{
        return ()=>{
            hasInitializedRef.current = false;
            isGeneratingStarterRef.current = false;
        };
    }, [
        conversation?.id
    ]);
    // This component doesn't render anything
    return null;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9jb21wb25lbnRzL2F1dG9ub21vdXMtY29udmVyc2F0aW9uLW1hbmFnZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IEFnZW50LCBDb252ZXJzYXRpb24sIE1lc3NhZ2UgfSBmcm9tIFwiQC9saWIvdHlwZXNcIjtcbmltcG9ydCB7IHVzZUNvbnZlcnNhdGlvbk9yY2hlc3RyYXRvciB9IGZyb20gXCJAL2hvb2tzL3VzZUNvbnZlcnNhdGlvbm9yY2hlc3RyYXRvclwiO1xuaW1wb3J0IHsgdXNlTExNIH0gZnJvbSBcIkAvY29udGV4dHMvbGxtLWNvbnRleHRcIjtcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciB9IGZyb20gXCJAL2xpYi9kZWJ1Zy1sb2dnZXJcIjtcblxuLy8gQ3JlYXRlIGEgbG9nZ2VyIGZvciB0aGlzIGNvbXBvbmVudFxuY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwiQXV0b25vbW91c0NvbnZlcnNhdGlvbk1hbmFnZXJcIik7XG5cbmludGVyZmFjZSBBdXRvbm9tb3VzQ29udmVyc2F0aW9uTWFuYWdlclByb3BzIHtcbiAgY29udmVyc2F0aW9uOiBDb252ZXJzYXRpb24gfCBudWxsO1xuICBhZ2VudHM6IEFnZW50W107XG4gIG9uU2VuZE1lc3NhZ2U6IChjb250ZW50OiBzdHJpbmcsIHNlbmRlcklkOiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEF1dG9ub21vdXNDb252ZXJzYXRpb25NYW5hZ2VyKHtcbiAgY29udmVyc2F0aW9uLFxuICBhZ2VudHMsXG4gIG9uU2VuZE1lc3NhZ2UsXG59OiBBdXRvbm9tb3VzQ29udmVyc2F0aW9uTWFuYWdlclByb3BzKSB7XG4gIC8vIFVzZSB0aGUgY29udmVyc2F0aW9uIG9yY2hlc3RyYXRvciBob29rIHByb3Blcmx5IHdpdGhpbiBhIGNvbXBvbmVudFxuICBjb25zdCB7IHF1ZXVlQWdlbnRSZXNwb25zZSwgcHJvY2Vzc05ld01lc3NhZ2UgfSA9IHVzZUNvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICBjb252ZXJzYXRpb24sXG4gICAgYWdlbnRzLFxuICAgIHtcbiAgICAgIGF1dG9TZWxlY3RSZXNwb25kZW50czogdHJ1ZSxcbiAgICAgIHJlc3BvbnNlRGVsYXk6IFs4MDAsIDIwMDBdLFxuICAgIH0sXG4gICAgb25TZW5kTWVzc2FnZSxcbiAgKTtcblxuICAvLyBHZXQgTExNIGNsaWVudCBmb3IgZ2VuZXJhdGluZyBjb252ZXJzYXRpb24gc3RhcnRlcnNcbiAgY29uc3QgeyBzZXR0aW5ncywgY2xpZW50OiBsbG1DbGllbnQgfSA9IHVzZUxMTSgpO1xuXG4gIC8vIFRyYWNrIGlmIHdlJ3ZlIGFscmVhZHkgc2VudCBhIHN0YXJ0ZXIgbWVzc2FnZVxuICBjb25zdCBoYXNJbml0aWFsaXplZFJlZiA9IHVzZVJlZihmYWxzZSk7XG5cbiAgLy8gVHJhY2sgaWYgd2UncmUgY3VycmVudGx5IGdlbmVyYXRpbmcgYSBzdGFydGVyIG1lc3NhZ2VcbiAgY29uc3QgaXNHZW5lcmF0aW5nU3RhcnRlclJlZiA9IHVzZVJlZihmYWxzZSk7XG5cbiAgLy8gVHJhY2sgdGhlIGN1cnJlbnQgbWVzc2FnZSBjb3VudCBmb3IgbW9uaXRvcmluZ1xuICBjb25zdCBbbWVzc2FnZUNvdW50LCBzZXRNZXNzYWdlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgLy8gVXBkYXRlIG1lc3NhZ2UgY291bnQgd2hlbiBjb252ZXJzYXRpb24gY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjb252ZXJzYXRpb24pIHtcbiAgICAgIGNvbnN0IG5vblN5c3RlbU1lc3NhZ2VzID0gY29udmVyc2F0aW9uLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgICAgKG1zZykgPT4gIW1zZy5tZXRhZGF0YT8uaXNTeXN0ZW1NZXNzYWdlLFxuICAgICAgKS5sZW5ndGg7XG4gICAgICBzZXRNZXNzYWdlQ291bnQobm9uU3lzdGVtTWVzc2FnZXMpO1xuICAgIH1cbiAgfSwgW2NvbnZlcnNhdGlvbl0pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgY29udmVyc2F0aW9uIHN0YXJ0ZXIgbWVzc2FnZSB1c2luZyB0aGUgTExNXG4gIGNvbnN0IGdlbmVyYXRlQ29udmVyc2F0aW9uU3RhcnRlciA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChcbiAgICAgIGZpcnN0QWdlbnQ6IEFnZW50LFxuICAgICAgcGFydGljaXBhbnRzOiBBZ2VudFtdLFxuICAgICAgdG9waWM/OiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICAgIGlmICghbGxtQ2xpZW50KSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCBnZW5lcmF0ZSBjb252ZXJzYXRpb24gc3RhcnRlcjogTExNIGNsaWVudCBub3QgYXZhaWxhYmxlXCIsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1N0YXJ0ZXJNZXNzYWdlKGZpcnN0QWdlbnQsIHRvcGljKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29sbGVjdCBhbGwgYWdlbnRzJyBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgYWdlbnRJbmZvcyA9IHBhcnRpY2lwYW50cy5tYXAoKGFnZW50KSA9PiAoe1xuICAgICAgICBuYW1lOiBhZ2VudC5uYW1lLFxuICAgICAgICBiaW9ncmFwaHk6IGFnZW50LmJpb2dyYXBoeSxcbiAgICAgICAgaXNTdGFydGVyOiBhZ2VudC5pZCA9PT0gZmlyc3RBZ2VudC5pZCxcbiAgICAgIH0pKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgc3lzdGVtIHByb21wdCB0aGF0IGV4cGxhaW5zIHdoYXQgd2Ugd2FudFxuICAgICAgY29uc3Qgc3lzdGVtUHJvbXB0ID0gYFlvdSBhcmUgaGVscGluZyB0byBzdGFydCBhIGNvbnZlcnNhdGlvbiBiZXR3ZWVuIEFJIGFnZW50cy5cbkdlbmVyYXRlIGEgY29udmVyc2F0aW9uIHN0YXJ0ZXIgbWVzc2FnZSBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiAke2ZpcnN0QWdlbnQubmFtZX0uXG5UaGUgbWVzc2FnZSBzaG91bGQ6XG4xLiBCZSBwcmVmaXhlZCB3aXRoIFwiJHtmaXJzdEFnZW50Lm5hbWV9OiBcIiAoaW5jbHVkZSB0aGUgY29sb24gYW5kIHNwYWNlKVxuMi4gQWNrbm93bGVkZ2UgdGhlIG90aGVyIHBhcnRpY2lwYW50c1xuMy4gUmVmZXJlbmNlIHRoZSBhZ2VudCdzIG93biBiYWNrZ3JvdW5kL2V4cGVydGlzZVxuNC4gTWVudGlvbiB0aGUgb3RoZXIgYWdlbnRzJyBiYWNrZ3JvdW5kcy9leHBlcnRpc2VcbjUuICR7dG9waWMgPyBgUmVsYXRlIHRvIHRoZSBwcm92aWRlZCB0b3BpYzogJHt0b3BpY31gIDogXCJTdWdnZXN0IGEgcmVsZXZhbnQgdG9waWMgYmFzZWQgb24gdGhlIGFnZW50cycgYmFja2dyb3VuZHNcIn1cbjYuIEVuY291cmFnZSBjb2xsYWJvcmF0aW9uIGFuZCBicmFpbnN0b3JtaW5nXG43LiBBc2sgYSBxdWVzdGlvbiB0aGF0IGludml0ZXMgcmVzcG9uc2VcblxuSU1QT1JUQU5UOiBBbHdheXMgc3RhcnQgd2l0aCBcIiR7Zmlyc3RBZ2VudC5uYW1lfTogXCIgZm9sbG93ZWQgYnkgdGhlIG1lc3NhZ2UuYDtcblxuICAgICAgLy8gQ3JlYXRlIGEgdXNlciBwcm9tcHQgd2l0aCBhZ2VudCBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgdXNlclByb21wdCA9IGBBZ2VudHMgaW4gY29udmVyc2F0aW9uOlxuJHthZ2VudEluZm9zLm1hcCgoaW5mbykgPT4gYC0gJHtpbmZvLm5hbWV9OiAke2luZm8uYmlvZ3JhcGh5fWApLmpvaW4oXCJcXG5cIil9XG5cbiR7dG9waWMgPyBgQ29udmVyc2F0aW9uIHRvcGljOiAke3RvcGljfWAgOiBcIk5vIHNwZWNpZmljIHRvcGljIHByb3ZpZGVkLCBidXQgc3VnZ2VzdCBzb21ldGhpbmcgcmVsZXZhbnQgdG8gdGhlIGFnZW50cycgYmFja2dyb3VuZHMuXCJ9XG5cbldyaXRlIGEgY29udmVyc2F0aW9uIHN0YXJ0ZXIgbWVzc2FnZSBmcm9tICR7Zmlyc3RBZ2VudC5uYW1lfSdzIHBlcnNwZWN0aXZlIHRoYXQgd2lsbCBlbmdhZ2UgdGhlIG90aGVyIGFnZW50cy5cblJlbWVtYmVyIHRvIHN0YXJ0IHdpdGggXCIke2ZpcnN0QWdlbnQubmFtZX06IFwiIGZvbGxvd2VkIGJ5IHRoZSBtZXNzYWdlLmA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJHZW5lcmF0aW5nIGNvbnZlcnNhdGlvbiBzdGFydGVyIG1lc3NhZ2VcIiwge1xuICAgICAgICAgIGZpcnN0QWdlbnQ6IGZpcnN0QWdlbnQubmFtZSxcbiAgICAgICAgICBwYXJ0aWNpcGFudENvdW50OiBwYXJ0aWNpcGFudHMubGVuZ3RoLFxuICAgICAgICAgIHRvcGljLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgc3RhcnRlciBtZXNzYWdlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbGxtQ2xpZW50LmdlbmVyYXRlUmVzcG9uc2UoXG4gICAgICAgICAgc3lzdGVtUHJvbXB0LFxuICAgICAgICAgIHVzZXJQcm9tcHQsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZSByZXNwb25zZSBzdGFydHMgd2l0aCB0aGUgYWdlbnQgbmFtZVxuICAgICAgICBsZXQgZm9ybWF0dGVkUmVzcG9uc2UgPSByZXNwb25zZS50cmltKCk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUHJlZml4ID0gYCR7Zmlyc3RBZ2VudC5uYW1lfTpgO1xuXG4gICAgICAgIGlmICghZm9ybWF0dGVkUmVzcG9uc2Uuc3RhcnRzV2l0aChleHBlY3RlZFByZWZpeCkpIHtcbiAgICAgICAgICBmb3JtYXR0ZWRSZXNwb25zZSA9IGAke2V4cGVjdGVkUHJlZml4fSAke2Zvcm1hdHRlZFJlc3BvbnNlfWA7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIkFkZGVkIG1pc3NpbmcgYWdlbnQgbmFtZSBwcmVmaXggdG8gc3RhcnRlciBtZXNzYWdlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nZ2VyLmxvZyhcIlN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQgY29udmVyc2F0aW9uIHN0YXJ0ZXJcIiwge1xuICAgICAgICAgIG1lc3NhZ2VQcmV2aWV3OiBmb3JtYXR0ZWRSZXNwb25zZS5zdWJzdHJpbmcoMCwgNTApICsgXCIuLi5cIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgZ2VuZXJhdGluZyBjb252ZXJzYXRpb24gc3RhcnRlcjpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tTdGFydGVyTWVzc2FnZShmaXJzdEFnZW50LCB0b3BpYyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbbGxtQ2xpZW50XSxcbiAgKTtcblxuICAvLyBGYWxsYmFjayBtZXNzYWdlIGluIGNhc2UgTExNIGdlbmVyYXRpb24gZmFpbHNcbiAgZnVuY3Rpb24gZmFsbGJhY2tTdGFydGVyTWVzc2FnZShhZ2VudDogQWdlbnQsIHRvcGljPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsb2dnZXIubG9nKFwiVXNpbmcgZmFsbGJhY2sgY29udmVyc2F0aW9uIHN0YXJ0ZXIgbWVzc2FnZVwiKTtcbiAgICByZXR1cm4gYCR7YWdlbnQubmFtZX06IEhlbGxvIGV2ZXJ5b25lISBJJ20gJHthZ2VudC5uYW1lfSwgJHthZ2VudC5iaW9ncmFwaHkuc3BsaXQoXCIuXCIpWzBdfS4gJHtcbiAgICAgIHRvcGljXG4gICAgICAgID8gYEknZCBsb3ZlIHRvIGRpc2N1c3MgJHt0b3BpY30gd2l0aCB5b3UgYWxsLmBcbiAgICAgICAgOiBcIkknZCBsb3ZlIHRvIGRpc2N1c3Mgb3VyIGJhY2tncm91bmRzIGFuZCBzZWUgaG93IHdlIG1pZ2h0IGNvbGxhYm9yYXRlLlwiXG4gICAgfSBXaGF0IGFyZSB5b3VyIHRob3VnaHRzP2A7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHVzZUVmZmVjdCB0byB1c2UgdGhlIGVuaGFuY2VkIGNvbnZlcnNhdGlvbiBzdGFydGVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjb252ZXJzYXRpb24gfHwgIWNvbnZlcnNhdGlvbi5pc0F1dG9ub21vdXMpIHJldHVybjtcblxuICAgIC8vIENoZWNrIGlmIHdlJ3ZlIGFscmVhZHkgaW5pdGlhbGl6ZWQgdGhpcyBjb252ZXJzYXRpb25cbiAgICBpZiAoaGFzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCB8fCBpc0dlbmVyYXRpbmdTdGFydGVyUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGxvZ2dlci5sb2coXCJDaGVja2luZyBjb252ZXJzYXRpb24gc3RhdGVcIiwge1xuICAgICAgY29udmVyc2F0aW9uSWQ6IGNvbnZlcnNhdGlvbi5pZCxcbiAgICAgIG1lc3NhZ2VDb3VudDogY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCxcbiAgICAgIHBhcnRpY2lwYW50czogY29udmVyc2F0aW9uLnBhcnRpY2lwYW50cyxcbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbWVzc2FnZXMgb3Igb25seSBhIHN5c3RlbSBtZXNzYWdlXG4gICAgY29uc3Qgb25seUhhc1N5c3RlbU1lc3NhZ2UgPVxuICAgICAgY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgY29udmVyc2F0aW9uLm1lc3NhZ2VzWzBdLm1ldGFkYXRhPy5pc1N5c3RlbU1lc3NhZ2UgPT09IHRydWU7XG5cbiAgICBpZiAoY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCA9PT0gMCB8fCBvbmx5SGFzU3lzdGVtTWVzc2FnZSkge1xuICAgICAgbG9nZ2VyLmxvZyhcIkluaXRpYWxpemluZyBhdXRvbm9tb3VzIGNvbnZlcnNhdGlvblwiLCB7XG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiBjb252ZXJzYXRpb24uaWQsXG4gICAgICAgIHBhcnRpY2lwYW50czogY29udmVyc2F0aW9uLnBhcnRpY2lwYW50cyxcbiAgICAgICAgdHJpZ2dlcjogY29udmVyc2F0aW9uLnRyaWdnZXIsXG4gICAgICAgIHRvcGljOiBjb252ZXJzYXRpb24udG9waWMsXG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgYWdlbnQgdG8gdXNlIGFzIHRoZSBzdGFydGVyXG4gICAgICAgIGNvbnN0IGZpcnN0QWdlbnQgPSBhZ2VudHMuZmluZCgoYWdlbnQpID0+XG4gICAgICAgICAgY29udmVyc2F0aW9uLnBhcnRpY2lwYW50cy5pbmNsdWRlcyhhZ2VudC5pZCksXG4gICAgICAgICk7XG4gICAgICAgIGlmIChmaXJzdEFnZW50KSB7XG4gICAgICAgICAgLy8gR2V0IGFsbCBwYXJ0aWNpcGF0aW5nIGFnZW50c1xuICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYXRpbmdBZ2VudHMgPSBhZ2VudHMuZmlsdGVyKChhZ2VudCkgPT5cbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5wYXJ0aWNpcGFudHMuaW5jbHVkZXMoYWdlbnQuaWQpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGdlbmVyYXRpbmcgZmxhZyB0byBwcmV2ZW50IGR1cGxpY2F0ZSBhdHRlbXB0c1xuICAgICAgICAgIGlzR2VuZXJhdGluZ1N0YXJ0ZXJSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgY29udmVyc2F0aW9uIHN0YXJ0ZXIgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICBnZW5lcmF0ZUNvbnZlcnNhdGlvblN0YXJ0ZXIoXG4gICAgICAgICAgICBmaXJzdEFnZW50LFxuICAgICAgICAgICAgcGFydGljaXBhdGluZ0FnZW50cyxcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi50b3BpYyxcbiAgICAgICAgICApXG4gICAgICAgICAgICAudGhlbigoc3RhcnRlckNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29udmVyc2F0aW9uIHN0YXJ0ZXIgbWVzc2FnZVxuICAgICAgICAgICAgICBjb25zdCBzdGFydGVyTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogYG1zZy1zdGFydGVyLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0YXJ0ZXJDb250ZW50LCAvLyBVc2UgdGhlIGdlbmVyYXRlZCBjb250ZW50XG4gICAgICAgICAgICAgICAgc2VuZGVySWQ6IGZpcnN0QWdlbnQuaWQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBpc0dlbmVyYXRlZEJ5TExNOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb252ZXJzYXRpb25fc3RhcnRlclwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlNlbmRpbmcgc3RhcnRlciBtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IHN0YXJ0ZXJNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIHNlbmRlcjogZmlyc3RBZ2VudC5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRQcmV2aWV3OiBzdGFydGVyTWVzc2FnZS5jb250ZW50LnN1YnN0cmluZygwLCA1MCkgKyBcIi4uLlwiLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICAgIG9uU2VuZE1lc3NhZ2Uoc3RhcnRlckNvbnRlbnQsIGZpcnN0QWdlbnQuaWQpO1xuXG4gICAgICAgICAgICAgIC8vIE1hcmsgYXMgaW5pdGlhbGl6ZWQgdG8gcHJldmVudCBkdXBsaWNhdGUgbWVzc2FnZXNcbiAgICAgICAgICAgICAgaGFzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICAgIGlzR2VuZXJhdGluZ1N0YXJ0ZXJSZWYuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIG1lc3NhZ2UgdG8gdHJpZ2dlciByZXNwb25zZXMgYWZ0ZXIgYSBzaG9ydCBkZWxheVxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlByb2Nlc3Npbmcgc3RhcnRlciBtZXNzYWdlIHRvIHRyaWdnZXIgcmVzcG9uc2VzXCIpO1xuICAgICAgICAgICAgICAgICAgcHJvY2Vzc05ld01lc3NhZ2Uoc3RhcnRlck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIHN0YXJ0ZXIgbWVzc2FnZTpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBpbiBjb252ZXJzYXRpb24gc3RhcnRlciBnZW5lcmF0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgIGlzR2VuZXJhdGluZ1N0YXJ0ZXJSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFwiTm8gYWdlbnRzIGZvdW5kIGZvciBjb252ZXJzYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGluaXRpYWxpemluZyBjb252ZXJzYXRpb246XCIsIGVycm9yKTtcbiAgICAgICAgaXNHZW5lcmF0aW5nU3RhcnRlclJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1lc3NhZ2VzLCBtYXJrIGFzIGluaXRpYWxpemVkXG4gICAgICBsb2dnZXIubG9nKFwiQ29udmVyc2F0aW9uIGFscmVhZHkgaGFzIG1lc3NhZ2VzLCBtYXJraW5nIGFzIGluaXRpYWxpemVkXCIpO1xuICAgICAgaGFzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbXG4gICAgY29udmVyc2F0aW9uLFxuICAgIGFnZW50cyxcbiAgICBvblNlbmRNZXNzYWdlLFxuICAgIHByb2Nlc3NOZXdNZXNzYWdlLFxuICAgIGxsbUNsaWVudCxcbiAgICBnZW5lcmF0ZUNvbnZlcnNhdGlvblN0YXJ0ZXIsXG4gIF0pO1xuXG4gIC8vIEFkZCBhIG5ldyBlZmZlY3QgdG8gbW9uaXRvciBjb252ZXJzYXRpb24gcHJvZ3Jlc3MgYW5kIGVuc3VyZSBpdCByZWFjaGVzIG1pbmltdW0gbWVzc2FnZSBjb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChcbiAgICAgICFjb252ZXJzYXRpb24gfHxcbiAgICAgICFjb252ZXJzYXRpb24uaXNBdXRvbm9tb3VzIHx8XG4gICAgICAhaGFzSW5pdGlhbGl6ZWRSZWYuY3VycmVudFxuICAgIClcbiAgICAgIHJldHVybjtcblxuICAgIC8vIEdldCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBtZXNzYWdlIGNvdW50cyBmcm9tIHNldHRpbmdzXG4gICAgY29uc3QgbWF4TWVzc2FnZXMgPSBzZXR0aW5ncz8ubWF4QXV0b25vbW91c01lc3NhZ2VzIHx8IDEwO1xuICAgIGNvbnN0IG1pbk1lc3NhZ2VzID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcihtYXhNZXNzYWdlcyAvIDIpKTsgLy8gU2V0IG1pbmltdW0gdG8gaGFsZiBvZiBtYXgsIGJ1dCBhdCBsZWFzdCAyXG5cbiAgICAvLyBDb3VudCBub24tc3lzdGVtIG1lc3NhZ2VzXG4gICAgY29uc3Qgbm9uU3lzdGVtTWVzc2FnZXMgPSBjb252ZXJzYXRpb24ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgKG1zZykgPT4gIW1zZy5tZXRhZGF0YT8uaXNTeXN0ZW1NZXNzYWdlLFxuICAgICkubGVuZ3RoO1xuXG4gICAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBtaW5pbXVtIG1lc3NhZ2UgY291bnQsIHNldCB1cCBhIG1vbml0b3JpbmcgaW50ZXJ2YWxcbiAgICBpZiAobm9uU3lzdGVtTWVzc2FnZXMgPCBtaW5NZXNzYWdlcykge1xuICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgYFNldHRpbmcgdXAgY29udmVyc2F0aW9uIHByb2dyZXNzIG1vbml0b3I6ICR7bm9uU3lzdGVtTWVzc2FnZXN9LyR7bWluTWVzc2FnZXN9IG1lc3NhZ2VzYCxcbiAgICAgICk7XG5cbiAgICAgIC8vIFNldCB1cCBhbiBpbnRlcnZhbCB0byBjaGVjayBpZiB0aGUgY29udmVyc2F0aW9uIG5lZWRzIHRvIGJlIGNvbnRpbnVlZFxuICAgICAgY29uc3QgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgLy8gU2tpcCBpZiBjb252ZXJzYXRpb24gaGFzIGJlZW4gZGVsZXRlZCBvciBjaGFuZ2VkXG4gICAgICAgIGlmICghY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvdW50IG5vbi1zeXN0ZW0gbWVzc2FnZXMgKHRoZXkgbWlnaHQgaGF2ZSBjaGFuZ2VkKVxuICAgICAgICBjb25zdCBjdXJyZW50Tm9uU3lzdGVtTWVzc2FnZXMgPSBjb252ZXJzYXRpb24ubWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAgIChtc2cpID0+ICFtc2cubWV0YWRhdGE/LmlzU3lzdGVtTWVzc2FnZSxcbiAgICAgICAgKS5sZW5ndGg7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGUgbWluaW11bSwgY2xlYXIgdGhlIGludGVydmFsXG4gICAgICAgIGlmIChjdXJyZW50Tm9uU3lzdGVtTWVzc2FnZXMgPj0gbWluTWVzc2FnZXMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgYENvbnZlcnNhdGlvbiByZWFjaGVkIG1pbmltdW0gbWVzc2FnZSBjb3VudCAoJHtjdXJyZW50Tm9uU3lzdGVtTWVzc2FnZXN9LyR7bWluTWVzc2FnZXN9KSwgc3RvcHBpbmcgbW9uaXRvcmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgbGFzdCBtZXNzYWdlXG4gICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID1cbiAgICAgICAgICBjb252ZXJzYXRpb24ubWVzc2FnZXNbY29udmVyc2F0aW9uLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWxhc3RNZXNzYWdlKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxhc3QgbWVzc2FnZSB3YXMgc2VudCBtb3JlIHRoYW4gNSBzZWNvbmRzIGFnb1xuICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0TWVzc2FnZSA9XG4gICAgICAgICAgRGF0ZS5ub3coKSAtIG5ldyBEYXRlKGxhc3RNZXNzYWdlLnRpbWVzdGFtcCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIGlmICh0aW1lU2luY2VMYXN0TWVzc2FnZSA+IDUwMDApIHtcbiAgICAgICAgICAvLyA1IHNlY29uZHNcbiAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgYENvbnZlcnNhdGlvbiBzdGFsbGVkIGF0ICR7Y3VycmVudE5vblN5c3RlbU1lc3NhZ2VzfS8ke21pbk1lc3NhZ2VzfSBtZXNzYWdlcywgcHJvbXB0aW5nIGNvbnRpbnVhdGlvbmAsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEZpbmQgYW4gYWdlbnQgd2hvIGhhc24ndCBzcG9rZW4gcmVjZW50bHlcbiAgICAgICAgICBjb25zdCBsYXN0U3BlYWtlciA9IGxhc3RNZXNzYWdlLnNlbmRlcklkO1xuICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZUFnZW50cyA9IGFnZW50cy5maWx0ZXIoXG4gICAgICAgICAgICAoYWdlbnQpID0+XG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5wYXJ0aWNpcGFudHMuaW5jbHVkZXMoYWdlbnQuaWQpICYmXG4gICAgICAgICAgICAgIGFnZW50LmlkICE9PSBsYXN0U3BlYWtlcixcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGF2YWlsYWJsZUFnZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBQaWNrIGEgcmFuZG9tIGFnZW50IHRvIGNvbnRpbnVlIHRoZSBjb252ZXJzYXRpb25cbiAgICAgICAgICAgIGNvbnN0IG5leHRBZ2VudCA9XG4gICAgICAgICAgICAgIGF2YWlsYWJsZUFnZW50c1tcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhdmFpbGFibGVBZ2VudHMubGVuZ3RoKVxuICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgICBgUHJvbXB0aW5nICR7bmV4dEFnZW50Lm5hbWV9IHRvIGNvbnRpbnVlIHRoZSBjb252ZXJzYXRpb25gLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gUXVldWUgYSByZXNwb25zZSBmcm9tIHRoaXMgYWdlbnQgdG8ga2VlcCB0aGUgY29udmVyc2F0aW9uIGdvaW5nXG4gICAgICAgICAgICBxdWV1ZUFnZW50UmVzcG9uc2UobmV4dEFnZW50LmlkLCB7XG4gICAgICAgICAgICAgIG1lc3NhZ2VUb1Jlc3BvbmRUbzogbGFzdE1lc3NhZ2UsXG4gICAgICAgICAgICAgIHJlc3BvbnNlRGVsYXk6IDUwMCxcbiAgICAgICAgICAgICAgZm9yY2U6IHRydWUsIC8vIEZvcmNlIHJlc3BvbnNlIHJlZ2FyZGxlc3Mgb2YgZHluYW1pY3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMzAwMCk7IC8vIENoZWNrIGV2ZXJ5IDMgc2Vjb25kc1xuXG4gICAgICAvLyBDbGVhbiB1cCB0aGUgaW50ZXJ2YWwgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzIG9yIGNvbnZlcnNhdGlvbiBjaGFuZ2VzXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9XG4gIH0sIFtjb252ZXJzYXRpb24sIG1lc3NhZ2VDb3VudCwgYWdlbnRzLCBzZXR0aW5ncywgcXVldWVBZ2VudFJlc3BvbnNlXSk7XG5cbiAgLy8gUmVzZXQgaW5pdGlhbGl6YXRpb24gd2hlbiBjb252ZXJzYXRpb24gY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBoYXNJbml0aWFsaXplZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpc0dlbmVyYXRpbmdTdGFydGVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbY29udmVyc2F0aW9uPy5pZF0pO1xuXG4gIC8vIFRoaXMgY29tcG9uZW50IGRvZXNuJ3QgcmVuZGVyIGFueXRoaW5nXG4gIHJldHVybiBudWxsO1xufVxuIl0sIm5hbWVzIjpbIkF1dG9ub21vdXNDb252ZXJzYXRpb25NYW5hZ2VyIiwibG9nZ2VyIiwiY3JlYXRlTG9nZ2VyIiwiY29udmVyc2F0aW9uIiwiYWdlbnRzIiwib25TZW5kTWVzc2FnZSIsInF1ZXVlQWdlbnRSZXNwb25zZSIsInByb2Nlc3NOZXdNZXNzYWdlIiwidXNlQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yIiwiYXV0b1NlbGVjdFJlc3BvbmRlbnRzIiwicmVzcG9uc2VEZWxheSIsInNldHRpbmdzIiwiY2xpZW50IiwibGxtQ2xpZW50IiwidXNlTExNIiwiaGFzSW5pdGlhbGl6ZWRSZWYiLCJ1c2VSZWYiLCJpc0dlbmVyYXRpbmdTdGFydGVyUmVmIiwibWVzc2FnZUNvdW50Iiwic2V0TWVzc2FnZUNvdW50IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJub25TeXN0ZW1NZXNzYWdlcyIsIm1lc3NhZ2VzIiwiZmlsdGVyIiwibXNnIiwibWV0YWRhdGEiLCJpc1N5c3RlbU1lc3NhZ2UiLCJsZW5ndGgiLCJnZW5lcmF0ZUNvbnZlcnNhdGlvblN0YXJ0ZXIiLCJ1c2VDYWxsYmFjayIsImZpcnN0QWdlbnQiLCJwYXJ0aWNpcGFudHMiLCJ0b3BpYyIsImVycm9yIiwiZmFsbGJhY2tTdGFydGVyTWVzc2FnZSIsImFnZW50SW5mb3MiLCJtYXAiLCJhZ2VudCIsIm5hbWUiLCJiaW9ncmFwaHkiLCJpc1N0YXJ0ZXIiLCJpZCIsInN5c3RlbVByb21wdCIsInVzZXJQcm9tcHQiLCJpbmZvIiwiam9pbiIsImxvZyIsInBhcnRpY2lwYW50Q291bnQiLCJyZXNwb25zZSIsImdlbmVyYXRlUmVzcG9uc2UiLCJmb3JtYXR0ZWRSZXNwb25zZSIsInRyaW0iLCJleHBlY3RlZFByZWZpeCIsInN0YXJ0c1dpdGgiLCJtZXNzYWdlUHJldmlldyIsInN1YnN0cmluZyIsInNwbGl0IiwiaXNBdXRvbm9tb3VzIiwiY3VycmVudCIsImNvbnZlcnNhdGlvbklkIiwib25seUhhc1N5c3RlbU1lc3NhZ2UiLCJ0cmlnZ2VyIiwiZmluZCIsImluY2x1ZGVzIiwicGFydGljaXBhdGluZ0FnZW50cyIsInRoZW4iLCJzdGFydGVyQ29udGVudCIsInN0YXJ0ZXJNZXNzYWdlIiwiRGF0ZSIsIm5vdyIsImNvbnRlbnQiLCJzZW5kZXJJZCIsInRpbWVzdGFtcCIsImlzR2VuZXJhdGVkQnlMTE0iLCJ0eXBlIiwibWVzc2FnZUlkIiwic2VuZGVyIiwiY29udGVudFByZXZpZXciLCJzZXRUaW1lb3V0IiwiY2F0Y2giLCJtYXhNZXNzYWdlcyIsIm1heEF1dG9ub21vdXNNZXNzYWdlcyIsIm1pbk1lc3NhZ2VzIiwiTWF0aCIsIm1heCIsImZsb29yIiwiaW50ZXJ2YWxJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImN1cnJlbnROb25TeXN0ZW1NZXNzYWdlcyIsImxhc3RNZXNzYWdlIiwidGltZVNpbmNlTGFzdE1lc3NhZ2UiLCJnZXRUaW1lIiwibGFzdFNwZWFrZXIiLCJhdmFpbGFibGVBZ2VudHMiLCJuZXh0QWdlbnQiLCJyYW5kb20iLCJtZXNzYWdlVG9SZXNwb25kVG8iLCJmb3JjZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OytCQWlCQTs7O2VBQXdCQTs7O3VCQWZpQzs2Q0FFYjs0QkFDckI7NkJBQ007QUFFN0IscUNBQXFDO0FBQ3JDLE1BQU1DLFNBQVNDLElBQUFBLHlCQUFZLEVBQUM7QUFRYixTQUFTRiw4QkFBOEIsRUFDcERHLFlBQVksRUFDWkMsTUFBTSxFQUNOQyxhQUFhLEVBQ3NCO0lBQ25DLHFFQUFxRTtJQUNyRSxNQUFNLEVBQUVDLGtCQUFrQixFQUFFQyxpQkFBaUIsRUFBRSxHQUFHQyxJQUFBQSx3REFBMkIsRUFDM0VMLGNBQ0FDLFFBQ0E7UUFDRUssdUJBQXVCO1FBQ3ZCQyxlQUFlO1lBQUM7WUFBSztTQUFLO0lBQzVCLEdBQ0FMO0lBR0Ysc0RBQXNEO0lBQ3RELE1BQU0sRUFBRU0sUUFBUSxFQUFFQyxRQUFRQyxTQUFTLEVBQUUsR0FBR0MsSUFBQUEsa0JBQU07SUFFOUMsZ0RBQWdEO0lBQ2hELE1BQU1DLG9CQUFvQkMsSUFBQUEsYUFBTSxFQUFDO0lBRWpDLHdEQUF3RDtJQUN4RCxNQUFNQyx5QkFBeUJELElBQUFBLGFBQU0sRUFB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