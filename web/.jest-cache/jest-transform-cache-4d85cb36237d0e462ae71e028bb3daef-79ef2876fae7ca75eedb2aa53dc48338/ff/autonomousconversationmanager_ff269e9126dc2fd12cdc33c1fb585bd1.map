{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/components/autonomous-conversation-manager.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useRef, useState, useCallback } from \"react\";\nimport type { Agent, Conversation, Message } from \"@/lib/types\";\nimport { useConversationOrchestrator } from \"@/hooks/useConversationorchestrator\";\nimport { useLLM } from \"@/contexts/llm-context\";\nimport { createLogger } from \"@/lib/debug-logger\";\n\n// Create a logger for this component\nconst logger = createLogger(\"AutonomousConversationManager\");\n\ninterface AutonomousConversationManagerProps {\n  conversation: Conversation | null;\n  agents: Agent[];\n  onSendMessage: (content: string, senderId: string) => void;\n}\n\nexport default function AutonomousConversationManager({\n  conversation,\n  agents,\n  onSendMessage,\n}: AutonomousConversationManagerProps) {\n  // Use the conversation orchestrator hook properly within a component\n  const { queueAgentResponse, processNewMessage } = useConversationOrchestrator(\n    conversation,\n    agents,\n    {\n      autoSelectRespondents: true,\n      responseDelay: [800, 2000],\n    },\n    onSendMessage,\n  );\n\n  // Get LLM client for generating conversation starters\n  const { settings, client: llmClient } = useLLM();\n\n  // Track if we've already sent a starter message\n  const hasInitializedRef = useRef(false);\n\n  // Track if we're currently generating a starter message\n  const isGeneratingStarterRef = useRef(false);\n\n  // Track the current message count for monitoring\n  const [messageCount, setMessageCount] = useState(0);\n\n  // Update message count when conversation changes\n  useEffect(() => {\n    if (conversation) {\n      const nonSystemMessages = conversation.messages.filter(\n        (msg) => !msg.metadata?.isSystemMessage,\n      ).length;\n      setMessageCount(nonSystemMessages);\n    }\n  }, [conversation]);\n\n  // Function to generate a conversation starter message using the LLM\n  const generateConversationStarter = useCallback(\n    async (\n      firstAgent: Agent,\n      participants: Agent[],\n      topic?: string,\n    ): Promise<string> => {\n      if (!llmClient) {\n        logger.error(\n          \"Cannot generate conversation starter: LLM client not available\",\n        );\n        return fallbackStarterMessage(firstAgent, topic);\n      }\n\n      // Collect all agents' information\n      const agentInfos = participants.map((agent) => ({\n        name: agent.name,\n        biography: agent.biography,\n        isStarter: agent.id === firstAgent.id,\n      }));\n\n      // Create a system prompt that explains what we want\n      const systemPrompt = `You are helping to start a conversation between AI agents.\nGenerate a conversation starter message from the perspective of ${firstAgent.name}.\nThe message should:\n1. Be prefixed with \"${firstAgent.name}: \" (include the colon and space)\n2. Acknowledge the other participants\n3. Reference the agent's own background/expertise\n4. Mention the other agents' backgrounds/expertise\n5. ${topic ? `Relate to the provided topic: ${topic}` : \"Suggest a relevant topic based on the agents' backgrounds\"}\n6. Encourage collaboration and brainstorming\n7. Ask a question that invites response\n\nIMPORTANT: Always start with \"${firstAgent.name}: \" followed by the message.`;\n\n      // Create a user prompt with agent information\n      const userPrompt = `Agents in conversation:\n${agentInfos.map((info) => `- ${info.name}: ${info.biography}`).join(\"\\n\")}\n\n${topic ? `Conversation topic: ${topic}` : \"No specific topic provided, but suggest something relevant to the agents' backgrounds.\"}\n\nWrite a conversation starter message from ${firstAgent.name}'s perspective that will engage the other agents.\nRemember to start with \"${firstAgent.name}: \" followed by the message.`;\n\n      try {\n        logger.log(\"Generating conversation starter message\", {\n          firstAgent: firstAgent.name,\n          participantCount: participants.length,\n          topic,\n        });\n\n        // Generate the starter message\n        const response = await llmClient.generateResponse(\n          systemPrompt,\n          userPrompt,\n        );\n\n        // Ensure the response starts with the agent name\n        let formattedResponse = response.trim();\n        const expectedPrefix = `${firstAgent.name}:`;\n\n        if (!formattedResponse.startsWith(expectedPrefix)) {\n          formattedResponse = `${expectedPrefix} ${formattedResponse}`;\n          logger.log(\"Added missing agent name prefix to starter message\");\n        }\n\n        logger.log(\"Successfully generated conversation starter\", {\n          messagePreview: formattedResponse.substring(0, 50) + \"...\",\n        });\n\n        return formattedResponse;\n      } catch (error) {\n        logger.error(\"Error generating conversation starter:\", error);\n        return fallbackStarterMessage(firstAgent, topic);\n      }\n    },\n    [llmClient],\n  );\n\n  // Fallback message in case LLM generation fails\n  function fallbackStarterMessage(agent: Agent, topic?: string): string {\n    logger.log(\"Using fallback conversation starter message\");\n    return `${agent.name}: Hello everyone! I'm ${agent.name}, ${agent.biography.split(\".\")[0]}. ${\n      topic\n        ? `I'd love to discuss ${topic} with you all.`\n        : \"I'd love to discuss our backgrounds and see how we might collaborate.\"\n    } What are your thoughts?`;\n  }\n\n  // Update the useEffect to use the enhanced conversation starter\n  useEffect(() => {\n    if (!conversation || !conversation.isAutonomous) return;\n\n    // Check if we've already initialized this conversation\n    if (hasInitializedRef.current || isGeneratingStarterRef.current) return;\n\n    logger.log(\"Checking conversation state\", {\n      conversationId: conversation.id,\n      messageCount: conversation.messages.length,\n      participants: conversation.participants,\n    });\n\n    // Check if there are any messages or only a system message\n    const onlyHasSystemMessage =\n      conversation.messages.length === 1 &&\n      conversation.messages[0].metadata?.isSystemMessage === true;\n\n    if (conversation.messages.length === 0 || onlyHasSystemMessage) {\n      logger.log(\"Initializing autonomous conversation\", {\n        conversationId: conversation.id,\n        participants: conversation.participants,\n        trigger: conversation.trigger,\n        topic: conversation.topic,\n      });\n\n      try {\n        // Find the first agent to use as the starter\n        const firstAgent = agents.find((agent) =>\n          conversation.participants.includes(agent.id),\n        );\n        if (firstAgent) {\n          // Get all participating agents\n          const participatingAgents = agents.filter((agent) =>\n            conversation.participants.includes(agent.id),\n          );\n\n          // Set the generating flag to prevent duplicate attempts\n          isGeneratingStarterRef.current = true;\n\n          // Generate the conversation starter asynchronously\n          generateConversationStarter(\n            firstAgent,\n            participatingAgents,\n            conversation.topic,\n          )\n            .then((starterContent) => {\n              // Create a conversation starter message\n              const starterMessage: Message = {\n                id: `msg-starter-${Date.now()}`,\n                content: starterContent, // Use the generated content\n                senderId: firstAgent.id,\n                timestamp: new Date(),\n                metadata: {\n                  isGeneratedByLLM: true,\n                  type: \"conversation_starter\",\n                },\n              };\n\n              logger.log(\"Sending starter message\", {\n                messageId: starterMessage.id,\n                sender: firstAgent.name,\n                contentPreview: starterMessage.content.substring(0, 50) + \"...\",\n              });\n\n              // Send the message\n              onSendMessage(starterContent, firstAgent.id);\n\n              // Mark as initialized to prevent duplicate messages\n              hasInitializedRef.current = true;\n              isGeneratingStarterRef.current = false;\n\n              // Process the message to trigger responses after a short delay\n              setTimeout(() => {\n                try {\n                  logger.log(\"Processing starter message to trigger responses\");\n                  processNewMessage(starterMessage);\n                } catch (error) {\n                  logger.error(\"Error processing starter message:\", error);\n                }\n              }, 1000);\n            })\n            .catch((error) => {\n              logger.error(\"Error in conversation starter generation:\", error);\n              isGeneratingStarterRef.current = false;\n            });\n        } else {\n          logger.error(\"No agents found for conversation\");\n        }\n      } catch (error) {\n        logger.error(\"Error initializing conversation:\", error);\n        isGeneratingStarterRef.current = false;\n      }\n    } else {\n      // If there are already messages, mark as initialized\n      logger.log(\"Conversation already has messages, marking as initialized\");\n      hasInitializedRef.current = true;\n    }\n  }, [\n    conversation,\n    agents,\n    onSendMessage,\n    processNewMessage,\n    llmClient,\n    generateConversationStarter,\n  ]);\n\n  // Add a new effect to monitor conversation progress and ensure it reaches minimum message count\n  useEffect(() => {\n    if (\n      !conversation ||\n      !conversation.isAutonomous ||\n      !hasInitializedRef.current\n    )\n      return;\n\n    // Get the minimum and maximum message counts from settings\n    const maxMessages = settings?.maxAutonomousMessages || 10;\n    const minMessages = Math.max(2, Math.floor(maxMessages / 2)); // Set minimum to half of max, but at least 2\n\n    // Count non-system messages\n    const nonSystemMessages = conversation.messages.filter(\n      (msg) => !msg.metadata?.isSystemMessage,\n    ).length;\n\n    // If we haven't reached the minimum message count, set up a monitoring interval\n    if (nonSystemMessages < minMessages) {\n      logger.log(\n        `Setting up conversation progress monitor: ${nonSystemMessages}/${minMessages} messages`,\n      );\n\n      // Set up an interval to check if the conversation needs to be continued\n      const intervalId = setInterval(() => {\n        // Skip if conversation has been deleted or changed\n        if (!conversation) {\n          clearInterval(intervalId);\n          return;\n        }\n\n        // Recount non-system messages (they might have changed)\n        const currentNonSystemMessages = conversation.messages.filter(\n          (msg) => !msg.metadata?.isSystemMessage,\n        ).length;\n\n        // If we've reached the minimum, clear the interval\n        if (currentNonSystemMessages >= minMessages) {\n          logger.log(\n            `Conversation reached minimum message count (${currentNonSystemMessages}/${minMessages}), stopping monitor`,\n          );\n          clearInterval(intervalId);\n          return;\n        }\n\n        // Get the last message\n        const lastMessage =\n          conversation.messages[conversation.messages.length - 1];\n        if (!lastMessage) return;\n\n        // Check if the last message was sent more than 5 seconds ago\n        const timeSinceLastMessage =\n          Date.now() - new Date(lastMessage.timestamp).getTime();\n\n        if (timeSinceLastMessage > 5000) {\n          // 5 seconds\n          logger.log(\n            `Conversation stalled at ${currentNonSystemMessages}/${minMessages} messages, prompting continuation`,\n          );\n\n          // Find an agent who hasn't spoken recently\n          const lastSpeaker = lastMessage.senderId;\n          const availableAgents = agents.filter(\n            (agent) =>\n              conversation.participants.includes(agent.id) &&\n              agent.id !== lastSpeaker,\n          );\n\n          if (availableAgents.length > 0) {\n            // Pick a random agent to continue the conversation\n            const nextAgent =\n              availableAgents[\n                Math.floor(Math.random() * availableAgents.length)\n              ];\n\n            logger.log(\n              `Prompting ${nextAgent.name} to continue the conversation`,\n            );\n\n            // Queue a response from this agent to keep the conversation going\n            queueAgentResponse(nextAgent.id, {\n              messageToRespondTo: lastMessage,\n              responseDelay: 500,\n              force: true, // Force response regardless of dynamics\n            });\n          }\n        }\n      }, 3000); // Check every 3 seconds\n\n      // Clean up the interval when the component unmounts or conversation changes\n      return () => clearInterval(intervalId);\n    }\n  }, [conversation, messageCount, agents, settings, queueAgentResponse]);\n\n  // Reset initialization when conversation changes\n  useEffect(() => {\n    return () => {\n      hasInitializedRef.current = false;\n      isGeneratingStarterRef.current = false;\n    };\n  }, [conversation?.id]);\n\n  // This component doesn't render anything\n  return null;\n}\n"],"names":["AutonomousConversationManager","logger","createLogger","conversation","agents","onSendMessage","queueAgentResponse","processNewMessage","useConversationOrchestrator","autoSelectRespondents","responseDelay","settings","client","llmClient","useLLM","hasInitializedRef","useRef","isGeneratingStarterRef","messageCount","setMessageCount","useState","useEffect","nonSystemMessages","messages","filter","msg","metadata","isSystemMessage","length","generateConversationStarter","useCallback","firstAgent","participants","topic","error","fallbackStarterMessage","agentInfos","map","agent","name","biography","isStarter","id","systemPrompt","userPrompt","info","join","log","participantCount","response","generateResponse","formattedResponse","trim","expectedPrefix","startsWith","messagePreview","substring","split","isAutonomous","current","conversationId","onlyHasSystemMessage","trigger","find","includes","participatingAgents","then","starterContent","starterMessage","Date","now","content","senderId","timestamp","isGeneratedByLLM","type","messageId","sender","contentPreview","setTimeout","catch","maxMessages","maxAutonomousMessages","minMessages","Math","max","floor","intervalId","setInterval","clearInterval","currentNonSystemMessages","lastMessage","timeSinceLastMessage","getTime","lastSpeaker","availableAgents","nextAgent","random","messageToRespondTo","force"],"mappings":"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"}