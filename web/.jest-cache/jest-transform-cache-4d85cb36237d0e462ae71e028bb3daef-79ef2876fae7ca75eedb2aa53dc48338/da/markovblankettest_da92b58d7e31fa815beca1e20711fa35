4cac12d2609d2e6d2da9979b7d4a0454
/**
 * Markov Blanket Tests
 *
 * Tests for Markov blanket calculations, configurations, and state management
 * following ADR-007 comprehensive testing requirements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _markovblanket = require("../../lib/markov-blanket");
describe("Markov Blanket Core", ()=>{
    let testBlanket;
    beforeEach(()=>{
        testBlanket = (0, _markovblanket.createMarkovBlanket)({
            id: "test-blanket-1",
            agentId: "agent-1",
            sensorStates: {
                visual: {
                    value: 0.5,
                    confidence: 0.8
                },
                auditory: {
                    value: 0.3,
                    confidence: 0.9
                }
            },
            activeStates: {
                movement: {
                    value: 0.7,
                    energy: 0.6
                },
                communication: {
                    value: 0.4,
                    energy: 0.8
                }
            },
            internalStates: {
                belief_exploration: 0.6,
                belief_cooperation: 0.8,
                energy_level: 0.75
            },
            externalStates: {
                environment_complexity: 0.4,
                agent_density: 0.3,
                resource_availability: 0.7
            }
        });
    });
    describe("Creation and Initialization", ()=>{
        it("creates a valid Markov blanket", ()=>{
            expect(testBlanket).toMatchObject({
                id: "test-blanket-1",
                agentId: "agent-1",
                sensorStates: expect.any(Object),
                activeStates: expect.any(Object),
                internalStates: expect.any(Object),
                externalStates: expect.any(Object)
            });
        });
        it("validates required fields", ()=>{
            expect(()=>{
                (0, _markovblanket.createMarkovBlanket)({
                    id: "",
                    agentId: "agent-1",
                    sensorStates: {},
                    activeStates: {},
                    internalStates: {},
                    externalStates: {}
                });
            }).toThrow("Invalid Markov blanket configuration");
        });
        it("initializes with default values when not provided", ()=>{
            const minimalBlanket = (0, _markovblanket.createMarkovBlanket)({
                id: "minimal-1",
                agentId: "agent-2"
            });
            expect(minimalBlanket.sensorStates).toBeDefined();
            expect(minimalBlanket.activeStates).toBeDefined();
            expect(minimalBlanket.internalStates).toBeDefined();
            expect(minimalBlanket.externalStates).toBeDefined();
        });
        it("preserves custom configuration", ()=>{
            const config = {
                learningRate: 0.01,
                precision: 0.001,
                maxIterations: 1000,
                convergenceThreshold: 0.0001
            };
            const blanketWithConfig = (0, _markovblanket.createMarkovBlanket)({
                id: "config-1",
                agentId: "agent-3",
                config
            });
            expect(blanketWithConfig.config).toMatchObject(config);
        });
    });
    describe("State Updates", ()=>{
        it("updates sensor states", ()=>{
            const updated = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                sensorStates: {
                    visual: {
                        value: 0.8,
                        confidence: 0.9
                    },
                    tactile: {
                        value: 0.2,
                        confidence: 0.7
                    }
                }
            });
            expect(updated.sensorStates.visual).toMatchObject({
                value: 0.8,
                confidence: 0.9
            });
            expect(updated.sensorStates.tactile).toBeDefined();
            expect(updated.sensorStates.auditory).toBeUndefined();
        });
        it("updates active states with energy constraints", ()=>{
            const updated = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                activeStates: {
                    movement: {
                        value: 0.9,
                        energy: 0.1
                    }
                }
            });
            // Should respect energy constraints
            expect(updated.activeStates.movement.value).toBeLessThanOrEqual(0.9);
            expect(updated.activeStates.movement.energy).toBeGreaterThanOrEqual(0);
        });
        it("updates internal states with normalization", ()=>{
            const updated = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                internalStates: {
                    belief_exploration: 1.5,
                    belief_cooperation: -0.2
                }
            });
            expect(updated.internalStates.belief_exploration).toBeLessThanOrEqual(1);
            expect(updated.internalStates.belief_cooperation).toBeGreaterThanOrEqual(0);
        });
        it("triggers recalculation on state change", ()=>{
            const initialFreeEnergy = testBlanket.freeEnergy;
            const updated = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                internalStates: {
                    belief_exploration: 0.9
                }
            });
            expect(updated.freeEnergy).not.toBe(initialFreeEnergy);
            expect(updated.lastUpdated).toBeGreaterThan(testBlanket.lastUpdated);
        });
    });
    describe("Free Energy Calculations", ()=>{
        it("calculates free energy correctly", ()=>{
            const freeEnergy = (0, _markovblanket.calculateFreeEnergy)(testBlanket);
            expect(freeEnergy).toBeGreaterThan(0);
            expect(Number.isFinite(freeEnergy)).toBe(true);
        });
        it("increases with prediction error", ()=>{
            const lowErrorBlanket = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                sensorStates: {
                    visual: {
                        value: 0.5,
                        confidence: 0.95
                    }
                },
                internalStates: {
                    belief_visual: 0.48
                }
            });
            const highErrorBlanket = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                sensorStates: {
                    visual: {
                        value: 0.5,
                        confidence: 0.95
                    }
                },
                internalStates: {
                    belief_visual: 0.1
                }
            });
            const lowFE = (0, _markovblanket.calculateFreeEnergy)(lowErrorBlanket);
            const highFE = (0, _markovblanket.calculateFreeEnergy)(highErrorBlanket);
            expect(highFE).toBeGreaterThan(lowFE);
        });
        it("includes entropy terms", ()=>{
            const certainBlanket = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                internalStates: {
                    belief_exploration: 0.99,
                    belief_cooperation: 0.01
                }
            });
            const uncertainBlanket = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                internalStates: {
                    belief_exploration: 0.5,
                    belief_cooperation: 0.5
                }
            });
            const certainFE = (0, _markovblanket.calculateFreeEnergy)(certainBlanket);
            const uncertainFE = (0, _markovblanket.calculateFreeEnergy)(uncertainBlanket);
            // Higher entropy (uncertainty) should contribute to free energy
            expect(Math.abs(certainFE - uncertainFE)).toBeGreaterThan(0.01);
        });
        it("handles edge cases", ()=>{
            const edgeCaseBlanket = (0, _markovblanket.createMarkovBlanket)({
                id: "edge-1",
                agentId: "agent-edge",
                internalStates: {
                    zero_state: 0,
                    one_state: 1
                }
            });
            const freeEnergy = (0, _markovblanket.calculateFreeEnergy)(edgeCaseBlanket);
            expect(Number.isFinite(freeEnergy)).toBe(true);
            expect(freeEnergy).not.toBeNaN();
        });
    });
    describe("Free Energy Minimization", ()=>{
        it("reduces free energy through optimization", async ()=>{
            const initialFE = (0, _markovblanket.calculateFreeEnergy)(testBlanket);
            const optimized = await (0, _markovblanket.minimizeFreeEnergy)(testBlanket);
            const finalFE = (0, _markovblanket.calculateFreeEnergy)(optimized);
            expect(finalFE).toBeLessThanOrEqual(initialFE);
        });
        it("converges within iteration limit", async ()=>{
            const optimized = await (0, _markovblanket.minimizeFreeEnergy)(testBlanket, {
                maxIterations: 100,
                convergenceThreshold: 0.001
            });
            expect(optimized.convergenceInfo).toBeDefined();
            expect(optimized.convergenceInfo.iterations).toBeLessThanOrEqual(100);
        });
        it("respects learning rate", async ()=>{
            const slowOptimized = await (0, _markovblanket.minimizeFreeEnergy)(testBlanket, {
                learningRate: 0.001,
                maxIterations: 10
            });
            const fastOptimized = await (0, _markovblanket.minimizeFreeEnergy)(testBlanket, {
                learningRate: 0.1,
                maxIterations: 10
            });
            const slowChange = Math.abs((0, _markovblanket.calculateFreeEnergy)(slowOptimized) - (0, _markovblanket.calculateFreeEnergy)(testBlanket));
            const fastChange = Math.abs((0, _markovblanket.calculateFreeEnergy)(fastOptimized) - (0, _markovblanket.calculateFreeEnergy)(testBlanket));
            expect(fastChange).toBeGreaterThan(slowChange);
        });
        it("maintains state constraints during optimization", async ()=>{
            const optimized = await (0, _markovblanket.minimizeFreeEnergy)(testBlanket);
            // Check all states are within valid ranges
            Object.values(optimized.internalStates).forEach((value)=>{
                expect(value).toBeGreaterThanOrEqual(0);
                expect(value).toBeLessThanOrEqual(1);
            });
            Object.values(optimized.activeStates).forEach((state)=>{
                expect(state.value).toBeGreaterThanOrEqual(0);
                expect(state.value).toBeLessThanOrEqual(1);
                expect(state.energy).toBeGreaterThanOrEqual(0);
            });
        });
    });
    describe("Markov Blanket Neighbors", ()=>{
        it("identifies neighboring blankets", ()=>{
            const blankets = [
                testBlanket,
                (0, _markovblanket.createMarkovBlanket)({
                    id: "neighbor-1",
                    agentId: "agent-2",
                    externalStates: {
                        proximity_to_agent1: 0.9
                    }
                }),
                (0, _markovblanket.createMarkovBlanket)({
                    id: "distant-1",
                    agentId: "agent-3",
                    externalStates: {
                        proximity_to_agent1: 0.1
                    }
                })
            ];
            const neighbors = (0, _markovblanket.getMarkovBlanketNeighbors)(testBlanket, blankets, {
                proximityThreshold: 0.5
            });
            expect(neighbors).toHaveLength(1);
            expect(neighbors[0].id).toBe("neighbor-1");
        });
        it("considers multiple interaction factors", ()=>{
            const blankets = [
                testBlanket,
                (0, _markovblanket.createMarkovBlanket)({
                    id: "interacting-1",
                    agentId: "agent-2",
                    activeStates: {
                        communication: {
                            value: 0.8,
                            energy: 0.7
                        }
                    }
                })
            ];
            const neighbors = (0, _markovblanket.getMarkovBlanketNeighbors)(testBlanket, blankets, {
                considerCommunication: true,
                considerSharedBeliefs: true
            });
            expect(neighbors).toHaveLength(1);
        });
    });
    describe("Markov Blanket Merging", ()=>{
        it("merges compatible blankets", ()=>{
            const blanket1 = testBlanket;
            const blanket2 = (0, _markovblanket.createMarkovBlanket)({
                id: "merge-2",
                agentId: "agent-2",
                internalStates: {
                    belief_exploration: 0.7,
                    belief_cooperation: 0.9
                }
            });
            const merged = (0, _markovblanket.mergeMarkovBlankets)([
                blanket1,
                blanket2
            ]);
            expect(merged.id).toContain("merged");
            expect(merged.internalStates.belief_cooperation).toBeGreaterThan(blanket1.internalStates.belief_cooperation);
        });
        it("preserves individual characteristics", ()=>{
            const blankets = [
                testBlanket,
                (0, _markovblanket.createMarkovBlanket)({
                    id: "unique-1",
                    agentId: "agent-2",
                    sensorStates: {
                        special_sensor: {
                            value: 0.99,
                            confidence: 1.0
                        }
                    }
                })
            ];
            const merged = (0, _markovblanket.mergeMarkovBlankets)(blankets);
            expect(merged.sensorStates.special_sensor).toBeDefined();
            expect(merged.sensorStates.visual).toBeDefined();
        });
        it("handles empty merge", ()=>{
            expect(()=>(0, _markovblanket.mergeMarkovBlankets)([])).toThrow();
        });
    });
    describe("Validation", ()=>{
        it("validates correct Markov blanket structure", ()=>{
            const validation = (0, _markovblanket.validateMarkovBlanket)(testBlanket);
            expect(validation.isValid).toBe(true);
            expect(validation.errors).toHaveLength(0);
        });
        it("detects invalid state values", ()=>{
            const invalidBlanket = {
                ...testBlanket,
                internalStates: {
                    invalid_state: 1.5,
                    negative_state: -0.1
                }
            };
            const validation = (0, _markovblanket.validateMarkovBlanket)(invalidBlanket);
            expect(validation.isValid).toBe(false);
            expect(validation.errors).toContain(expect.stringContaining("out of range"));
        });
        it("detects missing required fields", ()=>{
            const incompleteBlanket = {
                id: "incomplete-1",
                sensorStates: {}
            };
            const validation = (0, _markovblanket.validateMarkovBlanket)(incompleteBlanket);
            expect(validation.isValid).toBe(false);
            expect(validation.errors).toContain(expect.stringContaining("Missing required field"));
        });
        it("validates energy conservation", ()=>{
            const energyViolation = {
                ...testBlanket,
                activeStates: {
                    action1: {
                        value: 1.0,
                        energy: 0.0
                    },
                    action2: {
                        value: 1.0,
                        energy: 0.0
                    }
                }
            };
            const validation = (0, _markovblanket.validateMarkovBlanket)(energyViolation);
            expect(validation.warnings).toContain(expect.stringContaining("Energy conservation"));
        });
    });
    describe("Performance", ()=>{
        it("handles large state spaces efficiently", ()=>{
            const largeStates = {};
            for(let i = 0; i < 1000; i++){
                largeStates[`state_${i}`] = Math.random();
            }
            const largeBlanket = (0, _markovblanket.createMarkovBlanket)({
                id: "large-1",
                agentId: "agent-large",
                internalStates: largeStates
            });
            const startTime = Date.now();
            const freeEnergy = (0, _markovblanket.calculateFreeEnergy)(largeBlanket);
            const endTime = Date.now();
            expect(Number.isFinite(freeEnergy)).toBe(true);
            expect(endTime - startTime).toBeLessThan(100); // Should complete within 100ms
        });
        it("caches repeated calculations", ()=>{
            const startTime = Date.now();
            // First calculation
            (0, _markovblanket.calculateFreeEnergy)(testBlanket);
            const firstCalcTime = Date.now() - startTime;
            // Second calculation (should be cached)
            const cachedStart = Date.now();
            (0, _markovblanket.calculateFreeEnergy)(testBlanket);
            const cachedCalcTime = Date.now() - cachedStart;
            expect(cachedCalcTime).toBeLessThan(firstCalcTime);
        });
    });
    describe("Integration with Active Inference", ()=>{
        it("supports action selection based on free energy", async ()=>{
            const actionCandidates = [
                {
                    action: "explore",
                    expectedFE: 0.8
                },
                {
                    action: "exploit",
                    expectedFE: 0.6
                },
                {
                    action: "communicate",
                    expectedFE: 0.7
                }
            ];
            // Simulate action selection
            const bestAction = actionCandidates.reduce((best, current)=>current.expectedFE < best.expectedFE ? current : best);
            expect(bestAction.action).toBe("exploit");
        });
        it("updates beliefs based on sensory evidence", ()=>{
            const sensoryEvidence = {
                visual: {
                    value: 0.9,
                    confidence: 0.95
                }
            };
            const updatedBlanket = (0, _markovblanket.updateMarkovBlanket)(testBlanket, {
                sensorStates: sensoryEvidence
            });
            // Beliefs should move toward sensory evidence
            const optimized = (0, _markovblanket.minimizeFreeEnergy)(updatedBlanket, {
                maxIterations: 50
            });
            expect(optimized).toBeDefined();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL21hcmtvdi1ibGFua2V0LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYXJrb3YgQmxhbmtldCBUZXN0c1xuICpcbiAqIFRlc3RzIGZvciBNYXJrb3YgYmxhbmtldCBjYWxjdWxhdGlvbnMsIGNvbmZpZ3VyYXRpb25zLCBhbmQgc3RhdGUgbWFuYWdlbWVudFxuICogZm9sbG93aW5nIEFEUi0wMDcgY29tcHJlaGVuc2l2ZSB0ZXN0aW5nIHJlcXVpcmVtZW50cy5cbiAqL1xuXG5pbXBvcnQge1xuICBNYXJrb3ZCbGFua2V0LFxuICBNYXJrb3ZCbGFua2V0U3RhdGUsXG4gIGNyZWF0ZU1hcmtvdkJsYW5rZXQsXG4gIHVwZGF0ZU1hcmtvdkJsYW5rZXQsXG4gIGNhbGN1bGF0ZUZyZWVFbmVyZ3ksXG4gIG1pbmltaXplRnJlZUVuZXJneSxcbiAgZ2V0TWFya292QmxhbmtldE5laWdoYm9ycyxcbiAgbWVyZ2VNYXJrb3ZCbGFua2V0cyxcbiAgdmFsaWRhdGVNYXJrb3ZCbGFua2V0LFxuICBNYXJrb3ZCbGFua2V0Q29uZmlnLFxuICBTZW5zb3JTdGF0ZSxcbiAgQWN0aXZlU3RhdGUsXG4gIEludGVybmFsU3RhdGUsXG4gIEV4dGVybmFsU3RhdGUsXG59IGZyb20gXCJAL2xpYi9tYXJrb3YtYmxhbmtldFwiO1xuXG5kZXNjcmliZShcIk1hcmtvdiBCbGFua2V0IENvcmVcIiwgKCkgPT4ge1xuICBsZXQgdGVzdEJsYW5rZXQ6IE1hcmtvdkJsYW5rZXQ7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgdGVzdEJsYW5rZXQgPSBjcmVhdGVNYXJrb3ZCbGFua2V0KHtcbiAgICAgIGlkOiBcInRlc3QtYmxhbmtldC0xXCIsXG4gICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgIHNlbnNvclN0YXRlczoge1xuICAgICAgICB2aXN1YWw6IHsgdmFsdWU6IDAuNSwgY29uZmlkZW5jZTogMC44IH0sXG4gICAgICAgIGF1ZGl0b3J5OiB7IHZhbHVlOiAwLjMsIGNvbmZpZGVuY2U6IDAuOSB9LFxuICAgICAgfSxcbiAgICAgIGFjdGl2ZVN0YXRlczoge1xuICAgICAgICBtb3ZlbWVudDogeyB2YWx1ZTogMC43LCBlbmVyZ3k6IDAuNiB9LFxuICAgICAgICBjb21tdW5pY2F0aW9uOiB7IHZhbHVlOiAwLjQsIGVuZXJneTogMC44IH0sXG4gICAgICB9LFxuICAgICAgaW50ZXJuYWxTdGF0ZXM6IHtcbiAgICAgICAgYmVsaWVmX2V4cGxvcmF0aW9uOiAwLjYsXG4gICAgICAgIGJlbGllZl9jb29wZXJhdGlvbjogMC44LFxuICAgICAgICBlbmVyZ3lfbGV2ZWw6IDAuNzUsXG4gICAgICB9LFxuICAgICAgZXh0ZXJuYWxTdGF0ZXM6IHtcbiAgICAgICAgZW52aXJvbm1lbnRfY29tcGxleGl0eTogMC40LFxuICAgICAgICBhZ2VudF9kZW5zaXR5OiAwLjMsXG4gICAgICAgIHJlc291cmNlX2F2YWlsYWJpbGl0eTogMC43LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDcmVhdGlvbiBhbmQgSW5pdGlhbGl6YXRpb25cIiwgKCkgPT4ge1xuICAgIGl0KFwiY3JlYXRlcyBhIHZhbGlkIE1hcmtvdiBibGFua2V0XCIsICgpID0+IHtcbiAgICAgIGV4cGVjdCh0ZXN0QmxhbmtldCkudG9NYXRjaE9iamVjdCh7XG4gICAgICAgIGlkOiBcInRlc3QtYmxhbmtldC0xXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBzZW5zb3JTdGF0ZXM6IGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICAgYWN0aXZlU3RhdGVzOiBleHBlY3QuYW55KE9iamVjdCksXG4gICAgICAgIGludGVybmFsU3RhdGVzOiBleHBlY3QuYW55KE9iamVjdCksXG4gICAgICAgIGV4dGVybmFsU3RhdGVzOiBleHBlY3QuYW55KE9iamVjdCksXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwidmFsaWRhdGVzIHJlcXVpcmVkIGZpZWxkc1wiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBjcmVhdGVNYXJrb3ZCbGFua2V0KHtcbiAgICAgICAgICBpZDogXCJcIixcbiAgICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgICAgICBzZW5zb3JTdGF0ZXM6IHt9LFxuICAgICAgICAgIGFjdGl2ZVN0YXRlczoge30sXG4gICAgICAgICAgaW50ZXJuYWxTdGF0ZXM6IHt9LFxuICAgICAgICAgIGV4dGVybmFsU3RhdGVzOiB7fSxcbiAgICAgICAgfSk7XG4gICAgICB9KS50b1Rocm93KFwiSW52YWxpZCBNYXJrb3YgYmxhbmtldCBjb25maWd1cmF0aW9uXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJpbml0aWFsaXplcyB3aXRoIGRlZmF1bHQgdmFsdWVzIHdoZW4gbm90IHByb3ZpZGVkXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1pbmltYWxCbGFua2V0ID0gY3JlYXRlTWFya292QmxhbmtldCh7XG4gICAgICAgIGlkOiBcIm1pbmltYWwtMVwiLFxuICAgICAgICBhZ2VudElkOiBcImFnZW50LTJcIixcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobWluaW1hbEJsYW5rZXQuc2Vuc29yU3RhdGVzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG1pbmltYWxCbGFua2V0LmFjdGl2ZVN0YXRlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtaW5pbWFsQmxhbmtldC5pbnRlcm5hbFN0YXRlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtaW5pbWFsQmxhbmtldC5leHRlcm5hbFN0YXRlcykudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwicHJlc2VydmVzIGN1c3RvbSBjb25maWd1cmF0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZzogTWFya292QmxhbmtldENvbmZpZyA9IHtcbiAgICAgICAgbGVhcm5pbmdSYXRlOiAwLjAxLFxuICAgICAgICBwcmVjaXNpb246IDAuMDAxLFxuICAgICAgICBtYXhJdGVyYXRpb25zOiAxMDAwLFxuICAgICAgICBjb252ZXJnZW5jZVRocmVzaG9sZDogMC4wMDAxLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYmxhbmtldFdpdGhDb25maWcgPSBjcmVhdGVNYXJrb3ZCbGFua2V0KHtcbiAgICAgICAgaWQ6IFwiY29uZmlnLTFcIixcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0zXCIsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoYmxhbmtldFdpdGhDb25maWcuY29uZmlnKS50b01hdGNoT2JqZWN0KGNvbmZpZyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiU3RhdGUgVXBkYXRlc1wiLCAoKSA9PiB7XG4gICAgaXQoXCJ1cGRhdGVzIHNlbnNvciBzdGF0ZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHVwZGF0ZU1hcmtvdkJsYW5rZXQodGVzdEJsYW5rZXQsIHtcbiAgICAgICAgc2Vuc29yU3RhdGVzOiB7XG4gICAgICAgICAgdmlzdWFsOiB7IHZhbHVlOiAwLjgsIGNvbmZpZGVuY2U6IDAuOSB9LFxuICAgICAgICAgIHRhY3RpbGU6IHsgdmFsdWU6IDAuMiwgY29uZmlkZW5jZTogMC43IH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHVwZGF0ZWQuc2Vuc29yU3RhdGVzLnZpc3VhbCkudG9NYXRjaE9iamVjdCh7XG4gICAgICAgIHZhbHVlOiAwLjgsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KHVwZGF0ZWQuc2Vuc29yU3RhdGVzLnRhY3RpbGUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodXBkYXRlZC5zZW5zb3JTdGF0ZXMuYXVkaXRvcnkpLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwidXBkYXRlcyBhY3RpdmUgc3RhdGVzIHdpdGggZW5lcmd5IGNvbnN0cmFpbnRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB1cGRhdGVNYXJrb3ZCbGFua2V0KHRlc3RCbGFua2V0LCB7XG4gICAgICAgIGFjdGl2ZVN0YXRlczoge1xuICAgICAgICAgIG1vdmVtZW50OiB7IHZhbHVlOiAwLjksIGVuZXJneTogMC4xIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIHJlc3BlY3QgZW5lcmd5IGNvbnN0cmFpbnRzXG4gICAgICBleHBlY3QodXBkYXRlZC5hY3RpdmVTdGF0ZXMubW92ZW1lbnQudmFsdWUpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMC45KTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkLmFjdGl2ZVN0YXRlcy5tb3ZlbWVudC5lbmVyZ3kpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgfSk7XG5cbiAgICBpdChcInVwZGF0ZXMgaW50ZXJuYWwgc3RhdGVzIHdpdGggbm9ybWFsaXphdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkID0gdXBkYXRlTWFya292QmxhbmtldCh0ZXN0QmxhbmtldCwge1xuICAgICAgICBpbnRlcm5hbFN0YXRlczoge1xuICAgICAgICAgIGJlbGllZl9leHBsb3JhdGlvbjogMS41LCAvLyBTaG91bGQgYmUgbm9ybWFsaXplZFxuICAgICAgICAgIGJlbGllZl9jb29wZXJhdGlvbjogLTAuMiwgLy8gU2hvdWxkIGJlIGNsYW1wZWRcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QodXBkYXRlZC5pbnRlcm5hbFN0YXRlcy5iZWxpZWZfZXhwbG9yYXRpb24pLnRvQmVMZXNzVGhhbk9yRXF1YWwoMSk7XG4gICAgICBleHBlY3QodXBkYXRlZC5pbnRlcm5hbFN0YXRlcy5iZWxpZWZfY29vcGVyYXRpb24pLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoXG4gICAgICAgIDAsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoXCJ0cmlnZ2VycyByZWNhbGN1bGF0aW9uIG9uIHN0YXRlIGNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsRnJlZUVuZXJneSA9IHRlc3RCbGFua2V0LmZyZWVFbmVyZ3k7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB1cGRhdGVNYXJrb3ZCbGFua2V0KHRlc3RCbGFua2V0LCB7XG4gICAgICAgIGludGVybmFsU3RhdGVzOiB7XG4gICAgICAgICAgYmVsaWVmX2V4cGxvcmF0aW9uOiAwLjksXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHVwZGF0ZWQuZnJlZUVuZXJneSkubm90LnRvQmUoaW5pdGlhbEZyZWVFbmVyZ3kpO1xuICAgICAgZXhwZWN0KHVwZGF0ZWQubGFzdFVwZGF0ZWQpLnRvQmVHcmVhdGVyVGhhbih0ZXN0QmxhbmtldC5sYXN0VXBkYXRlZCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRnJlZSBFbmVyZ3kgQ2FsY3VsYXRpb25zXCIsICgpID0+IHtcbiAgICBpdChcImNhbGN1bGF0ZXMgZnJlZSBlbmVyZ3kgY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGZyZWVFbmVyZ3kgPSBjYWxjdWxhdGVGcmVlRW5lcmd5KHRlc3RCbGFua2V0KTtcblxuICAgICAgZXhwZWN0KGZyZWVFbmVyZ3kpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUoZnJlZUVuZXJneSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcImluY3JlYXNlcyB3aXRoIHByZWRpY3Rpb24gZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG93RXJyb3JCbGFua2V0ID0gdXBkYXRlTWFya292QmxhbmtldCh0ZXN0QmxhbmtldCwge1xuICAgICAgICBzZW5zb3JTdGF0ZXM6IHtcbiAgICAgICAgICB2aXN1YWw6IHsgdmFsdWU6IDAuNSwgY29uZmlkZW5jZTogMC45NSB9LFxuICAgICAgICB9LFxuICAgICAgICBpbnRlcm5hbFN0YXRlczoge1xuICAgICAgICAgIGJlbGllZl92aXN1YWw6IDAuNDgsIC8vIENsb3NlIHRvIHNlbnNvcnkgdmFsdWVcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBoaWdoRXJyb3JCbGFua2V0ID0gdXBkYXRlTWFya292QmxhbmtldCh0ZXN0QmxhbmtldCwge1xuICAgICAgICBzZW5zb3JTdGF0ZXM6IHtcbiAgICAgICAgICB2aXN1YWw6IHsgdmFsdWU6IDAuNSwgY29uZmlkZW5jZTogMC45NSB9LFxuICAgICAgICB9LFxuICAgICAgICBpbnRlcm5hbFN0YXRlczoge1xuICAgICAgICAgIGJlbGllZl92aXN1YWw6IDAuMSwgLy8gRmFyIGZyb20gc2Vuc29yeSB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxvd0ZFID0gY2FsY3VsYXRlRnJlZUVuZXJneShsb3dFcnJvckJsYW5rZXQpO1xuICAgICAgY29uc3QgaGlnaEZFID0gY2FsY3VsYXRlRnJlZUVuZXJneShoaWdoRXJyb3JCbGFua2V0KTtcblxuICAgICAgZXhwZWN0KGhpZ2hGRSkudG9CZUdyZWF0ZXJUaGFuKGxvd0ZFKTtcbiAgICB9KTtcblxuICAgIGl0KFwiaW5jbHVkZXMgZW50cm9weSB0ZXJtc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjZXJ0YWluQmxhbmtldCA9IHVwZGF0ZU1hcmtvdkJsYW5rZXQodGVzdEJsYW5rZXQsIHtcbiAgICAgICAgaW50ZXJuYWxTdGF0ZXM6IHtcbiAgICAgICAgICBiZWxpZWZfZXhwbG9yYXRpb246IDAuOTksXG4gICAgICAgICAgYmVsaWVmX2Nvb3BlcmF0aW9uOiAwLjAxLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHVuY2VydGFpbkJsYW5rZXQgPSB1cGRhdGVNYXJrb3ZCbGFua2V0KHRlc3RCbGFua2V0LCB7XG4gICAgICAgIGludGVybmFsU3RhdGVzOiB7XG4gICAgICAgICAgYmVsaWVmX2V4cGxvcmF0aW9uOiAwLjUsXG4gICAgICAgICAgYmVsaWVmX2Nvb3BlcmF0aW9uOiAwLjUsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY2VydGFpbkZFID0gY2FsY3VsYXRlRnJlZUVuZXJneShjZXJ0YWluQmxhbmtldCk7XG4gICAgICBjb25zdCB1bmNlcnRhaW5GRSA9IGNhbGN1bGF0ZUZyZWVFbmVyZ3kodW5jZXJ0YWluQmxhbmtldCk7XG5cbiAgICAgIC8vIEhpZ2hlciBlbnRyb3B5ICh1bmNlcnRhaW50eSkgc2hvdWxkIGNvbnRyaWJ1dGUgdG8gZnJlZSBlbmVyZ3lcbiAgICAgIGV4cGVjdChNYXRoLmFicyhjZXJ0YWluRkUgLSB1bmNlcnRhaW5GRSkpLnRvQmVHcmVhdGVyVGhhbigwLjAxKTtcbiAgICB9KTtcblxuICAgIGl0KFwiaGFuZGxlcyBlZGdlIGNhc2VzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGVkZ2VDYXNlQmxhbmtldCA9IGNyZWF0ZU1hcmtvdkJsYW5rZXQoe1xuICAgICAgICBpZDogXCJlZGdlLTFcIixcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC1lZGdlXCIsXG4gICAgICAgIGludGVybmFsU3RhdGVzOiB7XG4gICAgICAgICAgemVyb19zdGF0ZTogMCxcbiAgICAgICAgICBvbmVfc3RhdGU6IDEsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZnJlZUVuZXJneSA9IGNhbGN1bGF0ZUZyZWVFbmVyZ3koZWRnZUNhc2VCbGFua2V0KTtcbiAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUoZnJlZUVuZXJneSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZnJlZUVuZXJneSkubm90LnRvQmVOYU4oKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJGcmVlIEVuZXJneSBNaW5pbWl6YXRpb25cIiwgKCkgPT4ge1xuICAgIGl0KFwicmVkdWNlcyBmcmVlIGVuZXJneSB0aHJvdWdoIG9wdGltaXphdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsRkUgPSBjYWxjdWxhdGVGcmVlRW5lcmd5KHRlc3RCbGFua2V0KTtcbiAgICAgIGNvbnN0IG9wdGltaXplZCA9IGF3YWl0IG1pbmltaXplRnJlZUVuZXJneSh0ZXN0QmxhbmtldCk7XG4gICAgICBjb25zdCBmaW5hbEZFID0gY2FsY3VsYXRlRnJlZUVuZXJneShvcHRpbWl6ZWQpO1xuXG4gICAgICBleHBlY3QoZmluYWxGRSkudG9CZUxlc3NUaGFuT3JFcXVhbChpbml0aWFsRkUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJjb252ZXJnZXMgd2l0aGluIGl0ZXJhdGlvbiBsaW1pdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpbWl6ZWQgPSBhd2FpdCBtaW5pbWl6ZUZyZWVFbmVyZ3kodGVzdEJsYW5rZXQsIHtcbiAgICAgICAgbWF4SXRlcmF0aW9uczogMTAwLFxuICAgICAgICBjb252ZXJnZW5jZVRocmVzaG9sZDogMC4wMDEsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG9wdGltaXplZC5jb252ZXJnZW5jZUluZm8pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3Qob3B0aW1pemVkLmNvbnZlcmdlbmNlSW5mby5pdGVyYXRpb25zKS50b0JlTGVzc1RoYW5PckVxdWFsKDEwMCk7XG4gICAgfSk7XG5cbiAgICBpdChcInJlc3BlY3RzIGxlYXJuaW5nIHJhdGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2xvd09wdGltaXplZCA9IGF3YWl0IG1pbmltaXplRnJlZUVuZXJneSh0ZXN0QmxhbmtldCwge1xuICAgICAgICBsZWFybmluZ1JhdGU6IDAuMDAxLFxuICAgICAgICBtYXhJdGVyYXRpb25zOiAxMCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmYXN0T3B0aW1pemVkID0gYXdhaXQgbWluaW1pemVGcmVlRW5lcmd5KHRlc3RCbGFua2V0LCB7XG4gICAgICAgIGxlYXJuaW5nUmF0ZTogMC4xLFxuICAgICAgICBtYXhJdGVyYXRpb25zOiAxMCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzbG93Q2hhbmdlID0gTWF0aC5hYnMoXG4gICAgICAgIGNhbGN1bGF0ZUZyZWVFbmVyZ3koc2xvd09wdGltaXplZCkgLSBjYWxjdWxhdGVGcmVlRW5lcmd5KHRlc3RCbGFua2V0KSxcbiAgICAgICk7XG4gICAgICBjb25zdCBmYXN0Q2hhbmdlID0gTWF0aC5hYnMoXG4gICAgICAgIGNhbGN1bGF0ZUZyZWVFbmVyZ3koZmFzdE9wdGltaXplZCkgLSBjYWxjdWxhdGVGcmVlRW5lcmd5KHRlc3RCbGFua2V0KSxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChmYXN0Q2hhbmdlKS50b0JlR3JlYXRlclRoYW4oc2xvd0NoYW5nZSk7XG4gICAgfSk7XG5cbiAgICBpdChcIm1haW50YWlucyBzdGF0ZSBjb25zdHJhaW50cyBkdXJpbmcgb3B0aW1pemF0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGltaXplZCA9IGF3YWl0IG1pbmltaXplRnJlZUVuZXJneSh0ZXN0QmxhbmtldCk7XG5cbiAgICAgIC8vIENoZWNrIGFsbCBzdGF0ZXMgYXJlIHdpdGhpbiB2YWxpZCByYW5nZXNcbiAgICAgIE9iamVjdC52YWx1ZXMob3B0aW1pemVkLmludGVybmFsU3RhdGVzKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICBleHBlY3QodmFsdWUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgIGV4cGVjdCh2YWx1ZSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QudmFsdWVzKG9wdGltaXplZC5hY3RpdmVTdGF0ZXMpLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgICAgIGV4cGVjdChzdGF0ZS52YWx1ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgICAgZXhwZWN0KHN0YXRlLnZhbHVlKS50b0JlTGVzc1RoYW5PckVxdWFsKDEpO1xuICAgICAgICBleHBlY3Qoc3RhdGUuZW5lcmd5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiTWFya292IEJsYW5rZXQgTmVpZ2hib3JzXCIsICgpID0+IHtcbiAgICBpdChcImlkZW50aWZpZXMgbmVpZ2hib3JpbmcgYmxhbmtldHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYmxhbmtldHMgPSBbXG4gICAgICAgIHRlc3RCbGFua2V0LFxuICAgICAgICBjcmVhdGVNYXJrb3ZCbGFua2V0KHtcbiAgICAgICAgICBpZDogXCJuZWlnaGJvci0xXCIsXG4gICAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0yXCIsXG4gICAgICAgICAgZXh0ZXJuYWxTdGF0ZXM6IHtcbiAgICAgICAgICAgIHByb3hpbWl0eV90b19hZ2VudDE6IDAuOSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICAgY3JlYXRlTWFya292QmxhbmtldCh7XG4gICAgICAgICAgaWQ6IFwiZGlzdGFudC0xXCIsXG4gICAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0zXCIsXG4gICAgICAgICAgZXh0ZXJuYWxTdGF0ZXM6IHtcbiAgICAgICAgICAgIHByb3hpbWl0eV90b19hZ2VudDE6IDAuMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IG5laWdoYm9ycyA9IGdldE1hcmtvdkJsYW5rZXROZWlnaGJvcnModGVzdEJsYW5rZXQsIGJsYW5rZXRzLCB7XG4gICAgICAgIHByb3hpbWl0eVRocmVzaG9sZDogMC41LFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChuZWlnaGJvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChuZWlnaGJvcnNbMF0uaWQpLnRvQmUoXCJuZWlnaGJvci0xXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJjb25zaWRlcnMgbXVsdGlwbGUgaW50ZXJhY3Rpb24gZmFjdG9yc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBibGFua2V0cyA9IFtcbiAgICAgICAgdGVzdEJsYW5rZXQsXG4gICAgICAgIGNyZWF0ZU1hcmtvdkJsYW5rZXQoe1xuICAgICAgICAgIGlkOiBcImludGVyYWN0aW5nLTFcIixcbiAgICAgICAgICBhZ2VudElkOiBcImFnZW50LTJcIixcbiAgICAgICAgICBhY3RpdmVTdGF0ZXM6IHtcbiAgICAgICAgICAgIGNvbW11bmljYXRpb246IHsgdmFsdWU6IDAuOCwgZW5lcmd5OiAwLjcgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IG5laWdoYm9ycyA9IGdldE1hcmtvdkJsYW5rZXROZWlnaGJvcnModGVzdEJsYW5rZXQsIGJsYW5rZXRzLCB7XG4gICAgICAgIGNvbnNpZGVyQ29tbXVuaWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgY29uc2lkZXJTaGFyZWRCZWxpZWZzOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChuZWlnaGJvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJNYXJrb3YgQmxhbmtldCBNZXJnaW5nXCIsICgpID0+IHtcbiAgICBpdChcIm1lcmdlcyBjb21wYXRpYmxlIGJsYW5rZXRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGJsYW5rZXQxID0gdGVzdEJsYW5rZXQ7XG4gICAgICBjb25zdCBibGFua2V0MiA9IGNyZWF0ZU1hcmtvdkJsYW5rZXQoe1xuICAgICAgICBpZDogXCJtZXJnZS0yXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMlwiLFxuICAgICAgICBpbnRlcm5hbFN0YXRlczoge1xuICAgICAgICAgIGJlbGllZl9leHBsb3JhdGlvbjogMC43LFxuICAgICAgICAgIGJlbGllZl9jb29wZXJhdGlvbjogMC45LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlTWFya292QmxhbmtldHMoW2JsYW5rZXQxLCBibGFua2V0Ml0pO1xuXG4gICAgICBleHBlY3QobWVyZ2VkLmlkKS50b0NvbnRhaW4oXCJtZXJnZWRcIik7XG4gICAgICBleHBlY3QobWVyZ2VkLmludGVybmFsU3RhdGVzLmJlbGllZl9jb29wZXJhdGlvbikudG9CZUdyZWF0ZXJUaGFuKFxuICAgICAgICBibGFua2V0MS5pbnRlcm5hbFN0YXRlcy5iZWxpZWZfY29vcGVyYXRpb24sXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoXCJwcmVzZXJ2ZXMgaW5kaXZpZHVhbCBjaGFyYWN0ZXJpc3RpY3NcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYmxhbmtldHMgPSBbXG4gICAgICAgIHRlc3RCbGFua2V0LFxuICAgICAgICBjcmVhdGVNYXJrb3ZCbGFua2V0KHtcbiAgICAgICAgICBpZDogXCJ1bmlxdWUtMVwiLFxuICAgICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMlwiLFxuICAgICAgICAgIHNlbnNvclN0YXRlczoge1xuICAgICAgICAgICAgc3BlY2lhbF9zZW5zb3I6IHsgdmFsdWU6IDAuOTksIGNvbmZpZGVuY2U6IDEuMCB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgXTtcblxuICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VNYXJrb3ZCbGFua2V0cyhibGFua2V0cyk7XG5cbiAgICAgIGV4cGVjdChtZXJnZWQuc2Vuc29yU3RhdGVzLnNwZWNpYWxfc2Vuc29yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG1lcmdlZC5zZW5zb3JTdGF0ZXMudmlzdWFsKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJoYW5kbGVzIGVtcHR5IG1lcmdlXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiBtZXJnZU1hcmtvdkJsYW5rZXRzKFtdKSkudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlZhbGlkYXRpb25cIiwgKCkgPT4ge1xuICAgIGl0KFwidmFsaWRhdGVzIGNvcnJlY3QgTWFya292IGJsYW5rZXQgc3RydWN0dXJlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZU1hcmtvdkJsYW5rZXQodGVzdEJsYW5rZXQpO1xuXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICBpdChcImRldGVjdHMgaW52YWxpZCBzdGF0ZSB2YWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZEJsYW5rZXQgPSB7XG4gICAgICAgIC4uLnRlc3RCbGFua2V0LFxuICAgICAgICBpbnRlcm5hbFN0YXRlczoge1xuICAgICAgICAgIGludmFsaWRfc3RhdGU6IDEuNSxcbiAgICAgICAgICBuZWdhdGl2ZV9zdGF0ZTogLTAuMSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZU1hcmtvdkJsYW5rZXQoaW52YWxpZEJsYW5rZXQpO1xuXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9ycykudG9Db250YWluKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcIm91dCBvZiByYW5nZVwiKSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcImRldGVjdHMgbWlzc2luZyByZXF1aXJlZCBmaWVsZHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaW5jb21wbGV0ZUJsYW5rZXQgPSB7XG4gICAgICAgIGlkOiBcImluY29tcGxldGUtMVwiLFxuICAgICAgICBzZW5zb3JTdGF0ZXM6IHt9LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlTWFya292QmxhbmtldChpbmNvbXBsZXRlQmxhbmtldCBhcyBhbnkpO1xuXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9ycykudG9Db250YWluKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcIk1pc3NpbmcgcmVxdWlyZWQgZmllbGRcIiksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoXCJ2YWxpZGF0ZXMgZW5lcmd5IGNvbnNlcnZhdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBlbmVyZ3lWaW9sYXRpb24gPSB7XG4gICAgICAgIC4uLnRlc3RCbGFua2V0LFxuICAgICAgICBhY3RpdmVTdGF0ZXM6IHtcbiAgICAgICAgICBhY3Rpb24xOiB7IHZhbHVlOiAxLjAsIGVuZXJneTogMC4wIH0sXG4gICAgICAgICAgYWN0aW9uMjogeyB2YWx1ZTogMS4wLCBlbmVyZ3k6IDAuMCB9LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlTWFya292QmxhbmtldChlbmVyZ3lWaW9sYXRpb24pO1xuXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi53YXJuaW5ncykudG9Db250YWluKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcIkVuZXJneSBjb25zZXJ2YXRpb25cIiksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlBlcmZvcm1hbmNlXCIsICgpID0+IHtcbiAgICBpdChcImhhbmRsZXMgbGFyZ2Ugc3RhdGUgc3BhY2VzIGVmZmljaWVudGx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlU3RhdGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICBsYXJnZVN0YXRlc1tgc3RhdGVfJHtpfWBdID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFyZ2VCbGFua2V0ID0gY3JlYXRlTWFya292QmxhbmtldCh7XG4gICAgICAgIGlkOiBcImxhcmdlLTFcIixcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC1sYXJnZVwiLFxuICAgICAgICBpbnRlcm5hbFN0YXRlczogbGFyZ2VTdGF0ZXMsXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGZyZWVFbmVyZ3kgPSBjYWxjdWxhdGVGcmVlRW5lcmd5KGxhcmdlQmxhbmtldCk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShmcmVlRW5lcmd5KSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiAxMDBtc1xuICAgIH0pO1xuXG4gICAgaXQoXCJjYWNoZXMgcmVwZWF0ZWQgY2FsY3VsYXRpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgIC8vIEZpcnN0IGNhbGN1bGF0aW9uXG4gICAgICBjYWxjdWxhdGVGcmVlRW5lcmd5KHRlc3RCbGFua2V0KTtcbiAgICAgIGNvbnN0IGZpcnN0Q2FsY1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBTZWNvbmQgY2FsY3VsYXRpb24gKHNob3VsZCBiZSBjYWNoZWQpXG4gICAgICBjb25zdCBjYWNoZWRTdGFydCA9IERhdGUubm93KCk7XG4gICAgICBjYWxjdWxhdGVGcmVlRW5lcmd5KHRlc3RCbGFua2V0KTtcbiAgICAgIGNvbnN0IGNhY2hlZENhbGNUaW1lID0gRGF0ZS5ub3coKSAtIGNhY2hlZFN0YXJ0O1xuXG4gICAgICBleHBlY3QoY2FjaGVkQ2FsY1RpbWUpLnRvQmVMZXNzVGhhbihmaXJzdENhbGNUaW1lKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJJbnRlZ3JhdGlvbiB3aXRoIEFjdGl2ZSBJbmZlcmVuY2VcIiwgKCkgPT4ge1xuICAgIGl0KFwic3VwcG9ydHMgYWN0aW9uIHNlbGVjdGlvbiBiYXNlZCBvbiBmcmVlIGVuZXJneVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhY3Rpb25DYW5kaWRhdGVzID0gW1xuICAgICAgICB7IGFjdGlvbjogXCJleHBsb3JlXCIsIGV4cGVjdGVkRkU6IDAuOCB9LFxuICAgICAgICB7IGFjdGlvbjogXCJleHBsb2l0XCIsIGV4cGVjdGVkRkU6IDAuNiB9LFxuICAgICAgICB7IGFjdGlvbjogXCJjb21tdW5pY2F0ZVwiLCBleHBlY3RlZEZFOiAwLjcgfSxcbiAgICAgIF07XG5cbiAgICAgIC8vIFNpbXVsYXRlIGFjdGlvbiBzZWxlY3Rpb25cbiAgICAgIGNvbnN0IGJlc3RBY3Rpb24gPSBhY3Rpb25DYW5kaWRhdGVzLnJlZHVjZSgoYmVzdCwgY3VycmVudCkgPT5cbiAgICAgICAgY3VycmVudC5leHBlY3RlZEZFIDwgYmVzdC5leHBlY3RlZEZFID8gY3VycmVudCA6IGJlc3QsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoYmVzdEFjdGlvbi5hY3Rpb24pLnRvQmUoXCJleHBsb2l0XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJ1cGRhdGVzIGJlbGllZnMgYmFzZWQgb24gc2Vuc29yeSBldmlkZW5jZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZW5zb3J5RXZpZGVuY2UgPSB7XG4gICAgICAgIHZpc3VhbDogeyB2YWx1ZTogMC45LCBjb25maWRlbmNlOiAwLjk1IH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVkQmxhbmtldCA9IHVwZGF0ZU1hcmtvdkJsYW5rZXQodGVzdEJsYW5rZXQsIHtcbiAgICAgICAgc2Vuc29yU3RhdGVzOiBzZW5zb3J5RXZpZGVuY2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gQmVsaWVmcyBzaG91bGQgbW92ZSB0b3dhcmQgc2Vuc29yeSBldmlkZW5jZVxuICAgICAgY29uc3Qgb3B0aW1pemVkID0gbWluaW1pemVGcmVlRW5lcmd5KHVwZGF0ZWRCbGFua2V0LCB7XG4gICAgICAgIG1heEl0ZXJhdGlvbnM6IDUwLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChvcHRpbWl6ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJ0ZXN0QmxhbmtldCIsImJlZm9yZUVhY2giLCJjcmVhdGVNYXJrb3ZCbGFua2V0IiwiaWQiLCJhZ2VudElkIiwic2Vuc29yU3RhdGVzIiwidmlzdWFsIiwidmFsdWUiLCJjb25maWRlbmNlIiwiYXVkaXRvcnkiLCJhY3RpdmVTdGF0ZXMiLCJtb3ZlbWVudCIsImVuZXJneSIsImNvbW11bmljYXRpb24iLCJpbnRlcm5hbFN0YXRlcyIsImJlbGllZl9leHBsb3JhdGlvbiIsImJlbGllZl9jb29wZXJhdGlvbiIsImVuZXJneV9sZXZlbCIsImV4dGVybmFsU3RhdGVzIiwiZW52aXJvbm1lbnRfY29tcGxleGl0eSIsImFnZW50X2RlbnNpdHkiLCJyZXNvdXJjZV9hdmFpbGFiaWxpdHkiLCJpdCIsImV4cGVjdCIsInRvTWF0Y2hPYmplY3QiLCJhbnkiLCJPYmplY3QiLCJ0b1Rocm93IiwibWluaW1hbEJsYW5rZXQiLCJ0b0JlRGVmaW5lZCIsImNvbmZpZyIsImxlYXJuaW5nUmF0ZSIsInByZWNpc2lvbiIsIm1heEl0ZXJhdGlvbnMiLCJjb252ZXJnZW5jZVRocmVzaG9sZCIsImJsYW5rZXRXaXRoQ29uZmlnIiwidXBkYXRlZCIsInVwZGF0ZU1hcmtvdkJsYW5rZXQiLCJ0YWN0aWxlIiwidG9CZVVuZGVmaW5lZCIsInRvQmVMZXNzVGhhbk9yRXF1YWwiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwiaW5pdGlhbEZyZWVFbmVyZ3kiLCJmcmVlRW5lcmd5Iiwibm90IiwidG9CZSIsImxhc3RVcGRhdGVkIiwidG9CZUdyZWF0ZXJUaGFuIiwiY2FsY3VsYXRlRnJlZUVuZXJneSIsIk51bWJlciIsImlzRmluaXRlIiwibG93RXJyb3JCbGFua2V0IiwiYmVsaWVmX3Zpc3VhbCIsImhpZ2hFcnJvckJsYW5rZXQiLCJsb3dGRSIsImhpZ2hGRSIsImNlcnRhaW5CbGFua2V0IiwidW5jZXJ0YWluQmxhbmtldCIsImNlcnRhaW5GRSIsInVuY2VydGFpbkZFIiwiTWF0aCIsImFicyIsImVkZ2VDYXNlQmxhbmtldCIsInplcm9fc3RhdGUiLCJvbmVfc3RhdGUiLCJ0b0JlTmFOIiwiaW5pdGlhbEZFIiwib3B0aW1pemVkIiwibWluaW1pemVGcmVlRW5lcmd5IiwiZmluYWxGRSIsImNvbnZlcmdlbmNlSW5mbyIsIml0ZXJhdGlvbnMiLCJzbG93T3B0aW1pemVkIiwiZmFzdE9wdGltaXplZCIsInNsb3dDaGFuZ2UiLCJmYXN0Q2hhbmdlIiwidmFsdWVzIiwiZm9yRWFjaCIsInN0YXRlIiwiYmxhbmtldHMiLCJwcm94aW1pdHlfdG9fYWdlbnQxIiwibmVpZ2hib3JzIiwiZ2V0TWFya292QmxhbmtldE5laWdoYm9ycyIsInByb3hpbWl0eVRocmVzaG9sZCIsInRvSGF2ZUxlbmd0aCIsImNvbnNpZGVyQ29tbXVuaWNhdGlvbiIsImNvbnNpZGVyU2hhcmVkQmVsaWVmcyIsImJsYW5rZXQxIiwiYmxhbmtldDIiLCJtZXJnZWQiLCJtZXJnZU1hcmtvdkJsYW5rZXRzIiwidG9Db250YWluIiwic3BlY2lhbF9zZW5zb3IiLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGVNYXJrb3ZCbGFua2V0IiwiaXNWYWxpZCIsImVycm9ycyIsImludmFsaWRCbGFua2V0IiwiaW52YWxpZF9zdGF0ZSIsIm5lZ2F0aXZlX3N0YXRlIiwic3RyaW5nQ29udGFpbmluZyIsImluY29tcGxldGVCbGFua2V0IiwiZW5lcmd5VmlvbGF0aW9uIiwiYWN0aW9uMSIsImFjdGlvbjIiLCJ3YXJuaW5ncyIsImxhcmdlU3RhdGVzIiwiaSIsInJhbmRvbSIsImxhcmdlQmxhbmtldCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJlbmRUaW1lIiwidG9CZUxlc3NUaGFuIiwiZmlyc3RDYWxjVGltZSIsImNhY2hlZFN0YXJ0IiwiY2FjaGVkQ2FsY1RpbWUiLCJhY3Rpb25DYW5kaWRhdGVzIiwiYWN0aW9uIiwiZXhwZWN0ZWRGRSIsImJlc3RBY3Rpb24iLCJyZWR1Y2UiLCJiZXN0IiwiY3VycmVudCIsInNlbnNvcnlFdmlkZW5jZSIsInVwZGF0ZWRCbGFua2V0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7OzsrQkFpQk07QUFFUEEsU0FBUyx1QkFBdUI7SUFDOUIsSUFBSUM7SUFFSkMsV0FBVztRQUNURCxjQUFjRSxJQUFBQSxrQ0FBbUIsRUFBQztZQUNoQ0MsSUFBSTtZQUNKQyxTQUFTO1lBQ1RDLGNBQWM7Z0JBQ1pDLFFBQVE7b0JBQUVDLE9BQU87b0JBQUtDLFlBQVk7Z0JBQUk7Z0JBQ3RDQyxVQUFVO29CQUFFRixPQUFPO29CQUFLQyxZQUFZO2dCQUFJO1lBQzFDO1lBQ0FFLGNBQWM7Z0JBQ1pDLFVBQVU7b0JBQUVKLE9BQU87b0JBQUtLLFFBQVE7Z0JBQUk7Z0JBQ3BDQyxlQUFlO29CQUFFTixPQUFPO29CQUFLSyxRQUFRO2dCQUFJO1lBQzNDO1lBQ0FFLGdCQUFnQjtnQkFDZEMsb0JBQW9CO2dCQUNwQkMsb0JBQW9CO2dCQUNwQkMsY0FBYztZQUNoQjtZQUNBQyxnQkFBZ0I7Z0JBQ2RDLHdCQUF3QjtnQkFDeEJDLGVBQWU7Z0JBQ2ZDLHVCQUF1QjtZQUN6QjtRQUNGO0lBQ0Y7SUFFQXRCLFNBQVMsK0JBQStCO1FBQ3RDdUIsR0FBRyxrQ0FBa0M7WUFDbkNDLE9BQU92QixhQUFhd0IsYUFBYSxDQUFDO2dCQUNoQ3JCLElBQUk7Z0JBQ0pDLFNBQVM7Z0JBQ1RDLGNBQWNrQixPQUFPRSxHQUFHLENBQUNDO2dCQUN6QmhCLGNB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