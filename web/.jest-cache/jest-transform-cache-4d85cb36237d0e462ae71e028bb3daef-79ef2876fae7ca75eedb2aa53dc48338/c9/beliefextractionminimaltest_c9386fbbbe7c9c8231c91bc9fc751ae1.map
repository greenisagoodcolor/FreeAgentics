{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/__tests__/lib/belief-extraction-minimal.test.ts"],"sourcesContent":["/**\n * Phase 1: lib/belief-extraction.ts Minimal Test Suite\n * Target: Understand actual behavior and achieve coverage\n */\n\nimport {\n  parseBeliefs,\n  createFallbackRefinedBeliefs,\n  parseRefinedBeliefs,\n} from \"../../lib/belief-extraction\";\n\n// Mock the utils module\njest.mock(\"../../lib/utils\", () => ({\n  extractTagsFromMarkdown: jest.fn(() => [\"test-tag\"]),\n}));\n\ndescribe(\"lib/belief-extraction.ts - Minimal Coverage\", () => {\n  describe(\"parseBeliefs function\", () => {\n    test(\"shows what parseBeliefs actually does\", () => {\n      // Test exact format that should work\n      const response = \"- Test belief $$High$$\";\n      console.log(\"Input:\", JSON.stringify(response));\n\n      const beliefs = parseBeliefs(response);\n      console.log(\"Output:\", JSON.stringify(beliefs, null, 2));\n\n      expect(beliefs).toHaveLength(1);\n      // Just check that it returns something\n      expect(beliefs[0]).toHaveProperty(\"content\");\n      expect(beliefs[0]).toHaveProperty(\"confidence\");\n      expect(beliefs[0]).toHaveProperty(\"source\", \"conversation\");\n    });\n\n    test(\"tests line filtering\", () => {\n      const lines = [\n        \"- Valid bullet\",\n        \"Invalid line\",\n        \"• Valid bullet point\",\n        \"1. Valid numbered\",\n        \"10. Valid numbered\",\n        \"Another invalid line\",\n      ];\n\n      lines.forEach((line) => {\n        const beliefs = parseBeliefs(line);\n        const shouldMatch =\n          line.trim().startsWith(\"-\") ||\n          line.trim().startsWith(\"•\") ||\n          /^\\d+\\./.test(line.trim());\n\n        if (shouldMatch) {\n          expect(beliefs.length).toBeGreaterThan(0);\n        } else {\n          expect(beliefs.length).toBe(0);\n        }\n      });\n    });\n\n    test(\"empty input returns empty array\", () => {\n      expect(parseBeliefs(\"\")).toEqual([]);\n      expect(parseBeliefs(\"   \")).toEqual([]);\n      expect(parseBeliefs(\"\\n\\n\")).toEqual([]);\n    });\n  });\n\n  describe(\"createFallbackRefinedBeliefs function\", () => {\n    test(\"creates fallback beliefs\", () => {\n      const extractedBeliefs = [\n        {\n          content: \"Test belief\",\n          confidence: \"High\" as const,\n          source: \"conversation\" as const,\n          tags: [\"work\"],\n        },\n      ];\n\n      const fallbackBeliefs = createFallbackRefinedBeliefs(extractedBeliefs);\n\n      expect(fallbackBeliefs).toHaveLength(1);\n      expect(fallbackBeliefs[0]).toMatchObject({\n        originalIndex: 0,\n        accuracy: 3,\n        relevance: 3,\n        category: \"Fact\",\n        refined_content: \"Test belief\",\n        confidence: \"High\",\n        tags: [\"work\"],\n        selected: true,\n        novelty: \"Medium\",\n      });\n    });\n\n    test(\"handles empty input\", () => {\n      expect(createFallbackRefinedBeliefs([])).toEqual([]);\n    });\n\n    test(\"handles beliefs with no tags\", () => {\n      const extractedBeliefs = [\n        {\n          content: \"Test belief\",\n          confidence: \"Medium\" as const,\n          source: \"conversation\" as const,\n          tags: [],\n        },\n      ];\n\n      const fallbackBeliefs = createFallbackRefinedBeliefs(extractedBeliefs);\n      expect(fallbackBeliefs[0].title).toBe(\"Knowledge about topic\");\n    });\n  });\n\n  describe(\"parseRefinedBeliefs function\", () => {\n    const mockSourceBeliefs = [\n      {\n        content: \"Source belief\",\n        confidence: \"High\" as const,\n        source: \"conversation\" as const,\n        tags: [\"source\"],\n      },\n    ];\n\n    test(\"parses valid JSON\", () => {\n      const validJson = JSON.stringify([\n        {\n          originalIndex: 0,\n          accuracy: 4,\n          relevance: 5,\n          category: \"Fact\",\n          title: \"Test fact\",\n          refined_content: \"Refined content\",\n          confidence: \"High\",\n          tags: [\"test\"],\n        },\n      ]);\n\n      const result = parseRefinedBeliefs(validJson, mockSourceBeliefs);\n      expect(result).toHaveLength(1);\n      expect(result[0].title).toBe(\"Test fact\");\n    });\n\n    test(\"handles invalid JSON with fallback\", () => {\n      const consoleSpy = jest.spyOn(console, \"error\").mockImplementation();\n      const consoleLogSpy = jest.spyOn(console, \"log\").mockImplementation();\n\n      const result = parseRefinedBeliefs(\"invalid json\", mockSourceBeliefs);\n\n      expect(consoleSpy).toHaveBeenCalled();\n      expect(consoleLogSpy).toHaveBeenCalled();\n      expect(result).toHaveLength(1); // Fallback\n      expect(result[0].category).toBe(\"Fact\");\n\n      consoleSpy.mockRestore();\n      consoleLogSpy.mockRestore();\n    });\n\n    test(\"handles empty valid beliefs with fallback\", () => {\n      const consoleSpy = jest.spyOn(console, \"warn\").mockImplementation();\n\n      const invalidBeliefs = JSON.stringify([\n        {\n          // Missing required fields\n          accuracy: 3,\n        },\n      ]);\n\n      const result = parseRefinedBeliefs(invalidBeliefs, mockSourceBeliefs);\n\n      expect(consoleSpy).toHaveBeenCalledWith(\n        \"No valid beliefs found in parsed JSON\",\n      );\n      expect(result).toHaveLength(1); // Fallback\n\n      consoleSpy.mockRestore();\n    });\n\n    test(\"sets default values for missing fields\", () => {\n      const beliefWithoutOptionals = JSON.stringify([\n        {\n          originalIndex: 0,\n          accuracy: 3,\n          relevance: 4,\n          category: \"Opinion\",\n          title: \"Test Opinion\",\n          refined_content: \"Opinion content\",\n          confidence: \"Medium\",\n          // Missing tags, selected, novelty\n        },\n      ]);\n\n      const result = parseRefinedBeliefs(\n        beliefWithoutOptionals,\n        mockSourceBeliefs,\n      );\n\n      expect(result).toHaveLength(1);\n      expect(result[0].selected).toBe(true); // Default\n      expect(result[0].tags).toEqual([\"test-tag\"]); // From extractTagsFromMarkdown mock\n      expect(result[0].novelty).toBe(\"Medium\"); // Default\n    });\n\n    test(\"respects explicit selected false\", () => {\n      const beliefWithSelectedFalse = JSON.stringify([\n        {\n          originalIndex: 0,\n          accuracy: 3,\n          relevance: 4,\n          category: \"Fact\",\n          title: \"Test Fact\",\n          refined_content: \"Fact content\",\n          confidence: \"Low\",\n          selected: false,\n          tags: [\"explicit\"],\n        },\n      ]);\n\n      const result = parseRefinedBeliefs(\n        beliefWithSelectedFalse,\n        mockSourceBeliefs,\n      );\n\n      expect(result).toHaveLength(1);\n      expect(result[0].selected).toBe(false);\n    });\n  });\n\n  describe(\"edge cases\", () => {\n    test(\"parseBeliefs handles concurrent calls\", () => {\n      const input = \"- Concurrent test\";\n      const results = Array.from({ length: 10 }, () => parseBeliefs(input));\n\n      results.forEach((result) => {\n        expect(result).toHaveLength(1);\n        expect(result[0].source).toBe(\"conversation\");\n      });\n    });\n\n    test(\"createFallbackRefinedBeliefs with multiple beliefs\", () => {\n      const beliefs = Array.from({ length: 5 }, (_, i) => ({\n        content: `Belief ${i}`,\n        confidence: \"Medium\" as const,\n        source: \"conversation\" as const,\n        tags: [`tag${i}`],\n      }));\n\n      const fallbacks = createFallbackRefinedBeliefs(beliefs);\n\n      expect(fallbacks).toHaveLength(5);\n      fallbacks.forEach((fallback, i) => {\n        expect(fallback.originalIndex).toBe(i);\n        expect(fallback.title).toBe(`Knowledge about tag${i}`);\n      });\n    });\n  });\n});\n"],"names":["jest","mock","extractTagsFromMarkdown","fn","describe","test","response","console","log","JSON","stringify","beliefs","parseBeliefs","expect","toHaveLength","toHaveProperty","lines","forEach","line","shouldMatch","trim","startsWith","length","toBeGreaterThan","toBe","toEqual","extractedBeliefs","content","confidence","source","tags","fallbackBeliefs","createFallbackRefinedBeliefs","toMatchObject","originalIndex","accuracy","relevance","category","refined_content","selected","novelty","title","mockSourceBeliefs","validJson","result","parseRefinedBeliefs","consoleSpy","spyOn","mockImplementation","consoleLogSpy","toHaveBeenCalled","mockRestore","invalidBeliefs","toHaveBeenCalledWith","beliefWithoutOptionals","beliefWithSelectedFalse","input","results","Array","from","_","i","fallbacks","fallback"],"mappings":"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"}