bec8a20a0983aa4d0e755266505e2da7
/**
 * Web Workers Tests
 *
 * Tests for web worker implementations, background processing,
 * and worker communication following ADR-007 requirements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Mock Worker API
global.Worker = _globals.jest.fn(()=>({
        postMessage: _globals.jest.fn(),
        terminate: _globals.jest.fn(),
        onmessage: null,
        onerror: null,
        onmessageerror: null
    }));
// Mock SharedWorker API
global.SharedWorker = _globals.jest.fn(()=>({
        port: {
            postMessage: _globals.jest.fn(),
            onmessage: null,
            onmessageerror: null,
            start: _globals.jest.fn(),
            close: _globals.jest.fn()
        },
        onerror: null
    }));
// Mock ServiceWorker API
global.ServiceWorker = _globals.jest.fn(()=>({
        postMessage: _globals.jest.fn(),
        state: "activated",
        onstatechange: null,
        onerror: null
    }));
global.navigator = {
    ...global.navigator,
    serviceWorker: {
        register: _globals.jest.fn(()=>Promise.resolve({
                installing: null,
                waiting: null,
                active: {
                    postMessage: _globals.jest.fn(),
                    state: "activated"
                },
                scope: "/test-scope/",
                update: _globals.jest.fn(),
                unregister: _globals.jest.fn(),
                addEventListener: _globals.jest.fn(),
                removeEventListener: _globals.jest.fn()
            })),
        ready: Promise.resolve({
            installing: null,
            waiting: null,
            active: {
                postMessage: _globals.jest.fn(),
                state: "activated"
            },
            scope: "/test-scope/",
            update: _globals.jest.fn(),
            unregister: _globals.jest.fn(),
            addEventListener: _globals.jest.fn(),
            removeEventListener: _globals.jest.fn()
        }),
        controller: null,
        getRegistration: _globals.jest.fn(),
        getRegistrations: _globals.jest.fn(),
        addEventListener: _globals.jest.fn(),
        removeEventListener: _globals.jest.fn()
    }
};
class DataProcessingWorker {
    constructor(workerScript = "/workers/data-processing.js"){
        this.pendingTasks = new Map();
        this.worker = new Worker(workerScript);
        this.worker.onmessage = this.handleMessage.bind(this);
        this.worker.onerror = this.handleError.bind(this);
    }
    handleMessage(event) {
        const { id, result, processingTime, error } = event.data;
        const task = this.pendingTasks.get(id);
        if (task) {
            if (error) {
                task.reject(new Error(error));
            } else {
                task.resolve({
                    result,
                    processingTime
                });
            }
            this.pendingTasks.delete(id);
        }
    }
    handleError(error) {
        console.error("Data processing worker error:", error);
        // Reject all pending tasks
        this.pendingTasks.forEach(({ reject })=>{
            reject(new Error("Worker encountered an error"));
        });
        this.pendingTasks.clear();
    }
    async processData(task) {
        const taskId = task.id || Math.random().toString(36);
        const startTime = Date.now();
        return new Promise((resolve, reject)=>{
            this.pendingTasks.set(taskId, {
                resolve,
                reject,
                startTime
            });
            this.worker.postMessage({
                ...task,
                id: taskId
            });
            // Timeout after 30 seconds
            setTimeout(()=>{
                if (this.pendingTasks.has(taskId)) {
                    this.pendingTasks.delete(taskId);
                    reject(new Error("Task timeout"));
                }
            }, 30000);
        });
    }
    async filterData(data, predicate, options) {
        const task = {
            id: Math.random().toString(36),
            type: "filter",
            data,
            options: {
                predicate,
                ...options
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    async mapData(data, mapper, options) {
        const task = {
            id: Math.random().toString(36),
            type: "map",
            data,
            options: {
                mapper,
                ...options
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    async reduceData(data, reducer, initialValue) {
        const task = {
            id: Math.random().toString(36),
            type: "reduce",
            data,
            options: {
                reducer,
                initialValue
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    async sortData(data, compareFn) {
        const task = {
            id: Math.random().toString(36),
            type: "sort",
            data,
            options: {
                compareFn
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    async aggregateData(data, aggregations) {
        const task = {
            id: Math.random().toString(36),
            type: "aggregate",
            data,
            options: {
                aggregations
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    getQueueSize() {
        return this.pendingTasks.size;
    }
    terminate() {
        this.worker.terminate();
        this.pendingTasks.clear();
    }
}
class ImageProcessingWorker {
    constructor(){
        this.pendingTasks = new Map();
        this.worker = new Worker("/workers/image-processing.js");
        this.worker.onmessage = this.handleMessage.bind(this);
        this.worker.onerror = this.handleError.bind(this);
    }
    handleMessage(event) {
        const { id, result, error } = event.data;
        const task = this.pendingTasks.get(id);
        if (task) {
            if (error) {
                task.reject(new Error(error));
            } else {
                task.resolve(result);
            }
            this.pendingTasks.delete(id);
        }
    }
    handleError(error) {
        console.error("Image processing worker error:", error);
        this.pendingTasks.forEach(({ reject })=>{
            reject(new Error("Worker encountered an error"));
        });
        this.pendingTasks.clear();
    }
    async processImage(task) {
        const taskId = task.id || Math.random().toString(36);
        return new Promise((resolve, reject)=>{
            this.pendingTasks.set(taskId, {
                resolve,
                reject
            });
            this.worker.postMessage({
                ...task,
                id: taskId
            });
            // Timeout after 60 seconds for image processing
            setTimeout(()=>{
                if (this.pendingTasks.has(taskId)) {
                    this.pendingTasks.delete(taskId);
                    reject(new Error("Image processing timeout"));
                }
            }, 60000);
        });
    }
    async resizeImage(imageData, width, height) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "resize",
            imageData,
            options: {
                width,
                height
            }
        });
        return result;
    }
    async applyFilter(imageData, filterType, intensity = 1) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "filter",
            imageData,
            options: {
                filterType,
                intensity
            }
        });
        return result;
    }
    async cropImage(imageData, x, y, width, height) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "crop",
            imageData,
            options: {
                x,
                y,
                width,
                height
            }
        });
        return result;
    }
    async rotateImage(imageData, angle) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "rotate",
            imageData,
            options: {
                angle
            }
        });
        return result;
    }
    async adjustBrightness(imageData, brightness) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "brightness",
            imageData,
            options: {
                brightness
            }
        });
        return result;
    }
    async adjustContrast(imageData, contrast) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "contrast",
            imageData,
            options: {
                contrast
            }
        });
        return result;
    }
    terminate() {
        this.worker.terminate();
        this.pendingTasks.clear();
    }
}
class CrossTabCommunicator {
    constructor(){
        this.messageHandlers = new Map();
        this.tabId = Math.random().toString(36);
        this.sharedWorker = new SharedWorker("/workers/cross-tab.js");
        this.port = this.sharedWorker.port;
        this.port.onmessage = this.handleMessage.bind(this);
        this.port.onmessageerror = this.handleMessageError.bind(this);
        this.port.start();
        // Register this tab
        this.sendMessage({
            type: "sync",
            data: {
                action: "register",
                tabId: this.tabId
            },
            timestamp: Date.now()
        });
    }
    handleMessage(event) {
        const { type, data, tabId, timestamp } = event.data;
        // Don't handle our own messages
        if (tabId === this.tabId) return;
        const handler = this.messageHandlers.get(type);
        if (handler) {
            handler(data);
        }
        // Emit general message event
        const generalHandler = this.messageHandlers.get("*");
        if (generalHandler) {
            generalHandler({
                type,
                data,
                tabId,
                timestamp
            });
        }
    }
    handleMessageError(error) {
        console.error("Cross-tab communication error:", error);
    }
    sendMessage(message) {
        this.port.postMessage({
            ...message,
            tabId: this.tabId
        });
    }
    broadcast(data) {
        this.sendMessage({
            type: "broadcast",
            data,
            timestamp: Date.now()
        });
    }
    sync(data) {
        this.sendMessage({
            type: "sync",
            data,
            timestamp: Date.now()
        });
    }
    request(data) {
        const requestId = Math.random().toString(36);
        return new Promise((resolve, reject)=>{
            const responseHandler = (responseData)=>{
                if (responseData.requestId === requestId) {
                    this.off("response", responseHandler);
                    resolve(responseData.data);
                }
            };
            this.on("response", responseHandler);
            this.sendMessage({
                type: "request",
                data: {
                    ...data,
                    requestId
                },
                timestamp: Date.now()
            });
            // Timeout after 10 seconds
            setTimeout(()=>{
                this.off("response", responseHandler);
                reject(new Error("Request timeout"));
            }, 10000);
        });
    }
    respond(requestId, data) {
        this.sendMessage({
            type: "response",
            data: {
                requestId,
                data
            },
            timestamp: Date.now()
        });
    }
    on(messageType, handler) {
        this.messageHandlers.set(messageType, handler);
    }
    off(messageType, handler) {
        if (handler) {
            const currentHandler = this.messageHandlers.get(messageType);
            if (currentHandler === handler) {
                this.messageHandlers.delete(messageType);
            }
        } else {
            this.messageHandlers.delete(messageType);
        }
    }
    disconnect() {
        this.sendMessage({
            type: "sync",
            data: {
                action: "unregister",
                tabId: this.tabId
            },
            timestamp: Date.now()
        });
        this.port.close();
        this.messageHandlers.clear();
    }
}
class ServiceWorkerManager {
    async register(scriptUrl = "/sw.js") {
        if (!("serviceWorker" in navigator)) {
            throw new Error("Service Worker not supported");
        }
        try {
            this.registration = await navigator.serviceWorker.register(scriptUrl);
            this.isRegistered = true;
            this.registration.addEventListener("updatefound", this.handleUpdateFound.bind(this));
            return this.registration;
        } catch (error) {
            console.error("Service Worker registration failed:", error);
            throw error;
        }
    }
    handleUpdateFound() {
        if (!this.registration) return;
        const newWorker = this.registration.installing;
        if (newWorker) {
            newWorker.addEventListener("statechange", ()=>{
                if (newWorker.state === "installed" && navigator.serviceWorker.controller) {
                    console.log("New Service Worker available");
                // Could trigger update notification to user
                }
            });
        }
    }
    async unregister() {
        if (!this.registration) {
            return false;
        }
        try {
            const result = await this.registration.unregister();
            this.isRegistered = false;
            return result;
        } catch (error) {
            console.error("Service Worker unregistration failed:", error);
            return false;
        }
    }
    async update() {
        if (!this.registration) {
            throw new Error("Service Worker not registered");
        }
        await this.registration.update();
    }
    postMessage(message) {
        if (!this.registration?.active) {
            throw new Error("No active Service Worker");
        }
        this.registration.active.postMessage(message);
    }
    async configureCache(configs) {
        this.postMessage({
            type: "configure-cache",
            configs
        });
    }
    async clearCache(cacheName) {
        this.postMessage({
            type: "clear-cache",
            cacheName
        });
    }
    async getCacheStats() {
        return new Promise((resolve, reject)=>{
            const channel = new MessageChannel();
            channel.port1.onmessage = (event)=>{
                if (event.data.error) {
                    reject(new Error(event.data.error));
                } else {
                    resolve(event.data);
                }
            };
            this.postMessage({
                type: "get-cache-stats",
                port: channel.port2
            });
            setTimeout(()=>{
                reject(new Error("Cache stats request timeout"));
            }, 5000);
        });
    }
    getRegistration() {
        return this.registration;
    }
    isServiceWorkerRegistered() {
        return this.isRegistered;
    }
    constructor(){
        this.isRegistered = false;
    }
}
class BackgroundSyncManager {
    constructor(serviceWorkerManager){
        this.tasks = new Map();
        this.serviceWorkerManager = serviceWorkerManager;
    }
    async scheduleSync(type, data, options = {}) {
        const taskId = Math.random().toString(36);
        const task = {
            id: taskId,
            type,
            data,
            retryCount: 0,
            maxRetries: options.maxRetries || 3,
            createdAt: Date.now()
        };
        this.tasks.set(taskId, task);
        // Send to service worker for background processing
        this.serviceWorkerManager.postMessage({
            type: "schedule-sync",
            task
        });
        return taskId;
    }
    async cancelSync(taskId) {
        const task = this.tasks.get(taskId);
        if (!task) return false;
        this.tasks.delete(taskId);
        this.serviceWorkerManager.postMessage({
            type: "cancel-sync",
            taskId
        });
        return true;
    }
    async retryFailedTasks() {
        const failedTasks = Array.from(this.tasks.values()).filter((task)=>task.retryCount < task.maxRetries);
        for (const task of failedTasks){
            task.retryCount++;
            this.serviceWorkerManager.postMessage({
                type: "retry-sync",
                task
            });
        }
    }
    getPendingTasks() {
        return Array.from(this.tasks.values());
    }
    getTaskStatus(taskId) {
        return this.tasks.get(taskId);
    }
    clearCompletedTasks() {
        // This would typically be called after receiving success notifications
        // from the service worker
        const completedTasks = Array.from(this.tasks.entries()).filter(([_, task])=>task.retryCount >= task.maxRetries);
        completedTasks.forEach(([taskId])=>{
            this.tasks.delete(taskId);
        });
    }
}
// Tests
describe("Web Workers", ()=>{
    describe("DataProcessingWorker", ()=>{
        let worker;
        beforeEach(()=>{
            worker = new DataProcessingWorker();
        });
        afterEach(()=>{
            worker.terminate();
        });
        test("should create worker instance", ()=>{
            expect(Worker).toHaveBeenCalledWith("/workers/data-processing.js");
            expect(worker.getQueueSize()).toBe(0);
        });
        test("should process data with result", async ()=>{
            const testData = [
                1,
                2,
                3,
                4,
                5
            ];
            const task = {
                id: "test1",
                type: "filter",
                data: testData,
                options: {
                    predicate: "x => x > 2"
                }
            };
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: "test1",
                        result: [
                            3,
                            4,
                            5
                        ],
                        processingTime: 100
                    }
                });
            }, 10);
            const result = await worker.processData(task);
            expect(result.result).toEqual([
                3,
                4,
                5
            ]);
            expect(result.processingTime).toBe(100);
        });
        test("should handle worker errors", async ()=>{
            const testData = [
                1,
                2,
                3
            ];
            const task = {
                id: "test2",
                type: "map",
                data: testData
            };
            // Mock worker error response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: "test2",
                        error: "Processing failed"
                    }
                });
            }, 10);
            await expect(worker.processData(task)).rejects.toThrow("Processing failed");
        });
        test("should filter data", async ()=>{
            const testData = [
                1,
                2,
                3,
                4,
                5
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: [
                            4,
                            5
                        ],
                        processingTime: 50
                    }
                });
            }, 10);
            const result = await worker.filterData(testData, "x => x > 3");
            expect(result).toEqual([
                4,
                5
            ]);
        });
        test("should map data", async ()=>{
            const testData = [
                1,
                2,
                3
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: [
                            2,
                            4,
                            6
                        ],
                        processingTime: 30
                    }
                });
            }, 10);
            const result = await worker.mapData(testData, "x => x * 2");
            expect(result).toEqual([
                2,
                4,
                6
            ]);
        });
        test("should reduce data", async ()=>{
            const testData = [
                1,
                2,
                3,
                4
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: 10,
                        processingTime: 20
                    }
                });
            }, 10);
            const result = await worker.reduceData(testData, "(acc, val) => acc + val", 0);
            expect(result).toBe(10);
        });
        test("should sort data", async ()=>{
            const testData = [
                3,
                1,
                4,
                1,
                5
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: [
                            1,
                            1,
                            3,
                            4,
                            5
                        ],
                        processingTime: 25
                    }
                });
            }, 10);
            const result = await worker.sortData(testData);
            expect(result).toEqual([
                1,
                1,
                3,
                4,
                5
            ]);
        });
        test("should aggregate data", async ()=>{
            const testData = [
                {
                    category: "A",
                    value: 10
                },
                {
                    category: "B",
                    value: 20
                },
                {
                    category: "A",
                    value: 15
                }
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            A: 25,
                            B: 20
                        },
                        processingTime: 40
                    }
                });
            }, 10);
            const result = await worker.aggregateData(testData, {
                sum: "value"
            });
            expect(result).toEqual({
                A: 25,
                B: 20
            });
        });
        test("should handle task timeout", async ()=>{
            const testData = [
                1,
                2,
                3
            ];
            const task = {
                id: "timeout-test",
                type: "filter",
                data: testData
            };
            // Don't mock any response to trigger timeout
            await expect(worker.processData(task)).rejects.toThrow("Task timeout");
        }, 35000);
        test("should handle queue size tracking", ()=>{
            expect(worker.getQueueSize()).toBe(0);
            // Start a task (won't complete without mock response)
            worker.processData({
                id: "queue-test",
                type: "map",
                data: [
                    1,
                    2,
                    3
                ]
            }).catch(()=>{}); // Ignore the error
            expect(worker.getQueueSize()).toBe(1);
        });
    });
    describe("ImageProcessingWorker", ()=>{
        let worker;
        let mockImageData;
        beforeEach(()=>{
            worker = new ImageProcessingWorker();
            // Mock ImageData
            mockImageData = {
                data: new Uint8ClampedArray([
                    255,
                    0,
                    0,
                    255
                ]),
                width: 1,
                height: 1,
                colorSpace: "srgb"
            };
        });
        afterEach(()=>{
            worker.terminate();
        });
        test("should create image processing worker", ()=>{
            expect(Worker).toHaveBeenCalledWith("/workers/image-processing.js");
        });
        test("should resize image", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            data: new Uint8ClampedArray([
                                255,
                                0,
                                0,
                                255,
                                255,
                                0,
                                0,
                                255
                            ]),
                            width: 2,
                            height: 1
                        }
                    }
                });
            }, 10);
            const result = await worker.resizeImage(mockImageData, 2, 1);
            expect(result.width).toBe(2);
            expect(result.height).toBe(1);
        });
        test("should apply filter to image", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            data: new Uint8ClampedArray([
                                128,
                                128,
                                128,
                                255
                            ]),
                            width: 1,
                            height: 1
                        }
                    }
                });
            }, 10);
            const result = await worker.applyFilter(mockImageData, "grayscale", 1);
            expect(result.data[0]).toBe(128); // Should be grayscale
        });
        test("should crop image", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: mockImageData
                    }
                });
            }, 10);
            const result = await worker.cropImage(mockImageData, 0, 0, 1, 1);
            expect(result).toBeDefined();
        });
        test("should rotate image", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: mockImageData
                    }
                });
            }, 10);
            const result = await worker.rotateImage(mockImageData, 90);
            expect(result).toBeDefined();
        });
        test("should adjust brightness", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            data: new Uint8ClampedArray([
                                255,
                                100,
                                100,
                                255
                            ]),
                            width: 1,
                            height: 1
                        }
                    }
                });
            }, 10);
            const result = await worker.adjustBrightness(mockImageData, 1.5);
            expect(result.data[1]).toBe(100); // Modified brightness
        });
        test("should adjust contrast", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            data: new Uint8ClampedArray([
                                255,
                                50,
                                50,
                                255
                            ]),
                            width: 1,
                            height: 1
                        }
                    }
                });
            }, 10);
            const result = await worker.adjustContrast(mockImageData, 2);
            expect(result.data[1]).toBe(50); // Modified contrast
        });
        test("should handle processing errors", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        error: "Invalid image format"
                    }
                });
            }, 10);
            await expect(worker.resizeImage(mockImageData, 0, 0)).rejects.toThrow("Invalid image format");
        });
        test("should handle processing timeout", async ()=>{
            // Don't mock any response to trigger timeout
            await expect(worker.resizeImage(mockImageData, 100, 100)).rejects.toThrow("Image processing timeout");
        }, 65000);
    });
    describe("CrossTabCommunicator", ()=>{
        let communicator;
        beforeEach(()=>{
            communicator = new CrossTabCommunicator();
        });
        afterEach(()=>{
            communicator.disconnect();
        });
        test("should create shared worker for cross-tab communication", ()=>{
            expect(SharedWorker).toHaveBeenCalledWith("/workers/cross-tab.js");
        });
        test("should broadcast messages", ()=>{
            const testData = {
                message: "Hello from tab!"
            };
            communicator.broadcast(testData);
            const mockPort = SharedWorker.mock.results[0].value.port;
            expect(mockPort.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "broadcast",
                data: testData,
                tabId: expect.any(String),
                timestamp: expect.any(Number)
            }));
        });
        test("should sync data", ()=>{
            const syncData = {
                state: "updated"
            };
            communicator.sync(syncData);
            const mockPort = SharedWorker.mock.results[0].value.port;
            expect(mockPort.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "sync",
                data: syncData
            }));
        });
        test("should handle request-response pattern", async ()=>{
            const requestData = {
                query: "getUserData"
            };
            const responseData = {
                user: {
                    id: 1,
                    name: "Test User"
                }
            };
            // Mock response
            const mockPort = SharedWorker.mock.results[0].value.port;
            setTimeout(()=>{
                communicator.on("response", (data)=>{
                    if (data.requestId) {
                    // Simulate response from another tab
                    }
                });
                // Simulate receiving response
                if (mockPort.onmessage) {
                    mockPort.onmessage({
                        data: {
                            type: "response",
                            data: {
                                requestId: expect.any(String),
                                data: responseData
                            },
                            tabId: "other-tab",
                            timestamp: Date.now()
                        }
                    });
                }
            }, 10);
            const result = await communicator.request(requestData);
            expect(result).toEqual(responseData);
        });
        test("should handle message handlers", ()=>{
            const handler = _globals.jest.fn();
            communicator.on("broadcast", handler);
            // Simulate receiving message
            const mockPort = SharedWorker.mock.results[0].value.port;
            if (mockPort.onmessage) {
                mockPort.onmessage({
                    data: {
                        type: "broadcast",
                        data: {
                            test: "data"
                        },
                        tabId: "other-tab",
                        timestamp: Date.now()
                    }
                });
            }
            expect(handler).toHaveBeenCalledWith({
                test: "data"
            });
        });
        test("should remove message handlers", ()=>{
            const handler = _globals.jest.fn();
            communicator.on("broadcast", handler);
            communicator.off("broadcast", handler);
            // Simulate receiving message
            const mockPort = SharedWorker.mock.results[0].value.port;
            if (mockPort.onmessage) {
                mockPort.onmessage({
                    data: {
                        type: "broadcast",
                        data: {
                            test: "data"
                        },
                        tabId: "other-tab",
                        timestamp: Date.now()
                    }
                });
            }
            expect(handler).not.toHaveBeenCalled();
        });
        test("should ignore own messages", ()=>{
            const handler = _globals.jest.fn();
            communicator.on("broadcast", handler);
            // Simulate receiving our own message
            const mockPort = SharedWorker.mock.results[0].value.port;
            const tabId = communicator.tabId;
            if (mockPort.onmessage) {
                mockPort.onmessage({
                    data: {
                        type: "broadcast",
                        data: {
                            test: "data"
                        },
                        tabId: tabId,
                        timestamp: Date.now()
                    }
                });
            }
            expect(handler).not.toHaveBeenCalled();
        });
        test("should respond to requests", ()=>{
            const requestId = "test-request-123";
            const responseData = {
                result: "success"
            };
            communicator.respond(requestId, responseData);
            const mockPort = SharedWorker.mock.results[0].value.port;
            expect(mockPort.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "response",
                data: {
                    requestId,
                    data: responseData
                }
            }));
        });
    });
    describe("ServiceWorkerManager", ()=>{
        let manager;
        beforeEach(()=>{
            manager = new ServiceWorkerManager();
        });
        test("should register service worker", async ()=>{
            const registration = await manager.register("/test-sw.js");
            expect(navigator.serviceWorker.register).toHaveBeenCalledWith("/test-sw.js");
            expect(registration).toBeDefined();
            expect(manager.isServiceWorkerRegistered()).toBe(true);
        });
        test("should unregister service worker", async ()=>{
            await manager.register();
            const result = await manager.unregister();
            expect(result).toBe(true);
            expect(manager.isServiceWorkerRegistered()).toBe(false);
        });
        test("should update service worker", async ()=>{
            await manager.register();
            await manager.update();
            const registration = manager.getRegistration();
            expect(registration?.update).toHaveBeenCalled();
        });
        test("should post message to service worker", async ()=>{
            await manager.register();
            const message = {
                type: "test",
                data: "hello"
            };
            manager.postMessage(message);
            const registration = manager.getRegistration();
            expect(registration?.active?.postMessage).toHaveBeenCalledWith(message);
        });
        test("should configure cache", async ()=>{
            await manager.register();
            const configs = [
                {
                    name: "api-cache",
                    maxAge: 3600000,
                    maxEntries: 100,
                    strategy: "network-first"
                }
            ];
            await manager.configureCache(configs);
            const registration = manager.getRegistration();
            expect(registration?.active?.postMessage).toHaveBeenCalledWith({
                type: "configure-cache",
                configs
            });
        });
        test("should clear cache", async ()=>{
            await manager.register();
            await manager.clearCache("test-cache");
            const registration = manager.getRegistration();
            expect(registration?.active?.postMessage).toHaveBeenCalledWith({
                type: "clear-cache",
                cacheName: "test-cache"
            });
        });
        test("should get cache stats", async ()=>{
            await manager.register();
            // This would timeout in real implementation without proper response
            await expect(manager.getCacheStats()).rejects.toThrow("Cache stats request timeout");
        });
        test("should throw error when service worker not supported", async ()=>{
            // Mock unsupported environment
            const originalServiceWorker = global.navigator.serviceWorker;
            delete global.navigator.serviceWorker;
            const unsupportedManager = new ServiceWorkerManager();
            await expect(unsupportedManager.register()).rejects.toThrow("Service Worker not supported");
            // Restore
            global.navigator.serviceWorker = originalServiceWorker;
        });
        test("should throw error when posting message without active worker", async ()=>{
            expect(()=>{
                manager.postMessage({
                    test: "data"
                });
            }).toThrow("No active Service Worker");
        });
    });
    describe("BackgroundSyncManager", ()=>{
        let syncManager;
        let serviceWorkerManager;
        beforeEach(async ()=>{
            serviceWorkerManager = new ServiceWorkerManager();
            await serviceWorkerManager.register();
            syncManager = new BackgroundSyncManager(serviceWorkerManager);
        });
        test("should schedule sync task", async ()=>{
            const taskData = {
                action: "uploadFile",
                fileId: "123"
            };
            const taskId = await syncManager.scheduleSync("file-upload", taskData);
            expect(taskId).toBeDefined();
            expect(syncManager.getPendingTasks()).toHaveLength(1);
            expect(serviceWorkerManager.getRegistration()?.active?.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "schedule-sync",
                task: expect.objectContaining({
                    id: taskId,
                    type: "file-upload",
                    data: taskData
                })
            }));
        });
        test("should cancel sync task", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            });
            const cancelled = await syncManager.cancelSync(taskId);
            expect(cancelled).toBe(true);
            expect(syncManager.getPendingTasks()).toHaveLength(0);
            expect(serviceWorkerManager.getRegistration()?.active?.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "cancel-sync",
                taskId
            }));
        });
        test("should retry failed tasks", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            });
            await syncManager.retryFailedTasks();
            const task = syncManager.getTaskStatus(taskId);
            expect(task?.retryCount).toBe(1);
            expect(serviceWorkerManager.getRegistration()?.active?.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "retry-sync",
                task: expect.objectContaining({
                    id: taskId,
                    retryCount: 1
                })
            }));
        });
        test("should get task status", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            });
            const status = syncManager.getTaskStatus(taskId);
            expect(status).toBeDefined();
            expect(status?.id).toBe(taskId);
            expect(status?.type).toBe("test-sync");
        });
        test("should clear completed tasks", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            }, {
                maxRetries: 0
            });
            // Simulate task failure by setting retry count to max
            const task = syncManager.getTaskStatus(taskId);
            if (task) {
                task.retryCount = task.maxRetries;
            }
            syncManager.clearCompletedTasks();
            expect(syncManager.getTaskStatus(taskId)).toBeUndefined();
        });
        test("should handle task with custom max retries", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            }, {
                maxRetries: 5
            });
            const task = syncManager.getTaskStatus(taskId);
            expect(task?.maxRetries).toBe(5);
        });
        test("should not cancel non-existent task", async ()=>{
            const cancelled = await syncManager.cancelSync("non-existent-id");
            expect(cancelled).toBe(false);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vd29ya2Vycy93ZWItd29ya2Vycy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2ViIFdvcmtlcnMgVGVzdHNcbiAqXG4gKiBUZXN0cyBmb3Igd2ViIHdvcmtlciBpbXBsZW1lbnRhdGlvbnMsIGJhY2tncm91bmQgcHJvY2Vzc2luZyxcbiAqIGFuZCB3b3JrZXIgY29tbXVuaWNhdGlvbiBmb2xsb3dpbmcgQURSLTAwNyByZXF1aXJlbWVudHMuXG4gKi9cblxuaW1wb3J0IHsgamVzdCB9IGZyb20gXCJAamVzdC9nbG9iYWxzXCI7XG5cbi8vIE1vY2sgV29ya2VyIEFQSVxuZ2xvYmFsLldvcmtlciA9IGplc3QuZm4oKCkgPT4gKHtcbiAgcG9zdE1lc3NhZ2U6IGplc3QuZm4oKSxcbiAgdGVybWluYXRlOiBqZXN0LmZuKCksXG4gIG9ubWVzc2FnZTogbnVsbCxcbiAgb25lcnJvcjogbnVsbCxcbiAgb25tZXNzYWdlZXJyb3I6IG51bGwsXG59KSkgYXMgYW55O1xuXG4vLyBNb2NrIFNoYXJlZFdvcmtlciBBUElcbmdsb2JhbC5TaGFyZWRXb3JrZXIgPSBqZXN0LmZuKCgpID0+ICh7XG4gIHBvcnQ6IHtcbiAgICBwb3N0TWVzc2FnZTogamVzdC5mbigpLFxuICAgIG9ubWVzc2FnZTogbnVsbCxcbiAgICBvbm1lc3NhZ2VlcnJvcjogbnVsbCxcbiAgICBzdGFydDogamVzdC5mbigpLFxuICAgIGNsb3NlOiBqZXN0LmZuKCksXG4gIH0sXG4gIG9uZXJyb3I6IG51bGwsXG59KSkgYXMgYW55O1xuXG4vLyBNb2NrIFNlcnZpY2VXb3JrZXIgQVBJXG5nbG9iYWwuU2VydmljZVdvcmtlciA9IGplc3QuZm4oKCkgPT4gKHtcbiAgcG9zdE1lc3NhZ2U6IGplc3QuZm4oKSxcbiAgc3RhdGU6IFwiYWN0aXZhdGVkXCIsXG4gIG9uc3RhdGVjaGFuZ2U6IG51bGwsXG4gIG9uZXJyb3I6IG51bGwsXG59KSkgYXMgYW55O1xuXG5nbG9iYWwubmF2aWdhdG9yID0ge1xuICAuLi5nbG9iYWwubmF2aWdhdG9yLFxuICBzZXJ2aWNlV29ya2VyOiB7XG4gICAgcmVnaXN0ZXI6IGplc3QuZm4oKCkgPT5cbiAgICAgIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGluc3RhbGxpbmc6IG51bGwsXG4gICAgICAgIHdhaXRpbmc6IG51bGwsXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgIHBvc3RNZXNzYWdlOiBqZXN0LmZuKCksXG4gICAgICAgICAgc3RhdGU6IFwiYWN0aXZhdGVkXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlOiBcIi90ZXN0LXNjb3BlL1wiLFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICAgICAgdW5yZWdpc3RlcjogamVzdC5mbigpLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pLFxuICAgICksXG4gICAgcmVhZHk6IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBpbnN0YWxsaW5nOiBudWxsLFxuICAgICAgd2FpdGluZzogbnVsbCxcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICBwb3N0TWVzc2FnZTogamVzdC5mbigpLFxuICAgICAgICBzdGF0ZTogXCJhY3RpdmF0ZWRcIixcbiAgICAgIH0sXG4gICAgICBzY29wZTogXCIvdGVzdC1zY29wZS9cIixcbiAgICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICAgICAgdW5yZWdpc3RlcjogamVzdC5mbigpLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgIH0pLFxuICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgZ2V0UmVnaXN0cmF0aW9uOiBqZXN0LmZuKCksXG4gICAgZ2V0UmVnaXN0cmF0aW9uczogamVzdC5mbigpLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gIH0sXG59IGFzIGFueTtcblxuLy8gRGF0YSBQcm9jZXNzaW5nIFdvcmtlclxuaW50ZXJmYWNlIFByb2Nlc3NpbmdUYXNrIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogXCJmaWx0ZXJcIiB8IFwibWFwXCIgfCBcInJlZHVjZVwiIHwgXCJzb3J0XCIgfCBcImFnZ3JlZ2F0ZVwiO1xuICBkYXRhOiBhbnlbXTtcbiAgb3B0aW9ucz86IGFueTtcbn1cblxuaW50ZXJmYWNlIFByb2Nlc3NpbmdSZXN1bHQge1xuICBpZDogc3RyaW5nO1xuICByZXN1bHQ6IGFueTtcbiAgcHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmNsYXNzIERhdGFQcm9jZXNzaW5nV29ya2VyIHtcbiAgcHJpdmF0ZSB3b3JrZXI6IFdvcmtlcjtcbiAgcHJpdmF0ZSBwZW5kaW5nVGFza3M6IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgeyByZXNvbHZlOiBGdW5jdGlvbjsgcmVqZWN0OiBGdW5jdGlvbjsgc3RhcnRUaW1lOiBudW1iZXIgfVxuICA+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmtlclNjcmlwdDogc3RyaW5nID0gXCIvd29ya2Vycy9kYXRhLXByb2Nlc3NpbmcuanNcIikge1xuICAgIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMud29ya2VyLm9uZXJyb3IgPSB0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcyk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1lc3NhZ2UoZXZlbnQ6IE1lc3NhZ2VFdmVudDxQcm9jZXNzaW5nUmVzdWx0Pik6IHZvaWQge1xuICAgIGNvbnN0IHsgaWQsIHJlc3VsdCwgcHJvY2Vzc2luZ1RpbWUsIGVycm9yIH0gPSBldmVudC5kYXRhO1xuICAgIGNvbnN0IHRhc2sgPSB0aGlzLnBlbmRpbmdUYXNrcy5nZXQoaWQpO1xuXG4gICAgaWYgKHRhc2spIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0YXNrLnJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhc2sucmVzb2x2ZSh7IHJlc3VsdCwgcHJvY2Vzc2luZ1RpbWUgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUoaWQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRXJyb3IoZXJyb3I6IEVycm9yRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRGF0YSBwcm9jZXNzaW5nIHdvcmtlciBlcnJvcjpcIiwgZXJyb3IpO1xuXG4gICAgLy8gUmVqZWN0IGFsbCBwZW5kaW5nIHRhc2tzXG4gICAgdGhpcy5wZW5kaW5nVGFza3MuZm9yRWFjaCgoeyByZWplY3QgfSkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciBlbmNvdW50ZXJlZCBhbiBlcnJvclwiKSk7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nVGFza3MuY2xlYXIoKTtcbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NEYXRhKFxuICAgIHRhc2s6IFByb2Nlc3NpbmdUYXNrLFxuICApOiBQcm9taXNlPHsgcmVzdWx0OiBhbnk7IHByb2Nlc3NpbmdUaW1lOiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IHRhc2tJZCA9IHRhc2suaWQgfHwgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNik7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdUYXNrcy5zZXQodGFza0lkLCB7IHJlc29sdmUsIHJlamVjdCwgc3RhcnRUaW1lIH0pO1xuXG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIC4uLnRhc2ssXG4gICAgICAgIGlkOiB0YXNrSWQsXG4gICAgICB9KTtcblxuICAgICAgLy8gVGltZW91dCBhZnRlciAzMCBzZWNvbmRzXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1Rhc2tzLmhhcyh0YXNrSWQpKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKHRhc2tJZCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRhc2sgdGltZW91dFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMDAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZpbHRlckRhdGEoXG4gICAgZGF0YTogYW55W10sXG4gICAgcHJlZGljYXRlOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IGFueSxcbiAgKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IHRhc2s6IFByb2Nlc3NpbmdUYXNrID0ge1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJmaWx0ZXJcIixcbiAgICAgIGRhdGEsXG4gICAgICBvcHRpb25zOiB7IHByZWRpY2F0ZSwgLi4ub3B0aW9ucyB9LFxuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3NEYXRhKHRhc2spO1xuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgbWFwRGF0YShkYXRhOiBhbnlbXSwgbWFwcGVyOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgY29uc3QgdGFzazogUHJvY2Vzc2luZ1Rhc2sgPSB7XG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNiksXG4gICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgZGF0YSxcbiAgICAgIG9wdGlvbnM6IHsgbWFwcGVyLCAuLi5vcHRpb25zIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc0RhdGEodGFzayk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gIH1cblxuICBhc3luYyByZWR1Y2VEYXRhKFxuICAgIGRhdGE6IGFueVtdLFxuICAgIHJlZHVjZXI6IHN0cmluZyxcbiAgICBpbml0aWFsVmFsdWU/OiBhbnksXG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdGFzazogUHJvY2Vzc2luZ1Rhc2sgPSB7XG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNiksXG4gICAgICB0eXBlOiBcInJlZHVjZVwiLFxuICAgICAgZGF0YSxcbiAgICAgIG9wdGlvbnM6IHsgcmVkdWNlciwgaW5pdGlhbFZhbHVlIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc0RhdGEodGFzayk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gIH1cblxuICBhc3luYyBzb3J0RGF0YShkYXRhOiBhbnlbXSwgY29tcGFyZUZuPzogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IHRhc2s6IFByb2Nlc3NpbmdUYXNrID0ge1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJzb3J0XCIsXG4gICAgICBkYXRhLFxuICAgICAgb3B0aW9uczogeyBjb21wYXJlRm4gfSxcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzRGF0YSh0YXNrKTtcbiAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgfVxuXG4gIGFzeW5jIGFnZ3JlZ2F0ZURhdGEoXG4gICAgZGF0YTogYW55W10sXG4gICAgYWdncmVnYXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHRhc2s6IFByb2Nlc3NpbmdUYXNrID0ge1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICAgIGRhdGEsXG4gICAgICBvcHRpb25zOiB7IGFnZ3JlZ2F0aW9ucyB9LFxuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3NEYXRhKHRhc2spO1xuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICB9XG5cbiAgZ2V0UXVldWVTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1Rhc2tzLnNpemU7XG4gIH1cblxuICB0ZXJtaW5hdGUoKTogdm9pZCB7XG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy5wZW5kaW5nVGFza3MuY2xlYXIoKTtcbiAgfVxufVxuXG4vLyBJbWFnZSBQcm9jZXNzaW5nIFdvcmtlclxuaW50ZXJmYWNlIEltYWdlUHJvY2Vzc2luZ1Rhc2sge1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiBcInJlc2l6ZVwiIHwgXCJmaWx0ZXJcIiB8IFwiY3JvcFwiIHwgXCJyb3RhdGVcIiB8IFwiYnJpZ2h0bmVzc1wiIHwgXCJjb250cmFzdFwiO1xuICBpbWFnZURhdGE6IEltYWdlRGF0YSB8IHN0cmluZzsgLy8gQmFzZTY0IG9yIEltYWdlRGF0YVxuICBvcHRpb25zOiBhbnk7XG59XG5cbmNsYXNzIEltYWdlUHJvY2Vzc2luZ1dvcmtlciB7XG4gIHByaXZhdGUgd29ya2VyOiBXb3JrZXI7XG4gIHByaXZhdGUgcGVuZGluZ1Rhc2tzOiBNYXA8c3RyaW5nLCB7IHJlc29sdmU6IEZ1bmN0aW9uOyByZWplY3Q6IEZ1bmN0aW9uIH0+ID1cbiAgICBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKFwiL3dvcmtlcnMvaW1hZ2UtcHJvY2Vzc2luZy5qc1wiKTtcbiAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLndvcmtlci5vbmVycm9yID0gdGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNZXNzYWdlKGV2ZW50OiBNZXNzYWdlRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCB7IGlkLCByZXN1bHQsIGVycm9yIH0gPSBldmVudC5kYXRhO1xuICAgIGNvbnN0IHRhc2sgPSB0aGlzLnBlbmRpbmdUYXNrcy5nZXQoaWQpO1xuXG4gICAgaWYgKHRhc2spIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0YXNrLnJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhc2sucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBFcnJvckV2ZW50KTogdm9pZCB7XG4gICAgY29uc29sZS5lcnJvcihcIkltYWdlIHByb2Nlc3Npbmcgd29ya2VyIGVycm9yOlwiLCBlcnJvcik7XG5cbiAgICB0aGlzLnBlbmRpbmdUYXNrcy5mb3JFYWNoKCh7IHJlamVjdCB9KSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiV29ya2VyIGVuY291bnRlcmVkIGFuIGVycm9yXCIpKTtcbiAgICB9KTtcbiAgICB0aGlzLnBlbmRpbmdUYXNrcy5jbGVhcigpO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0ltYWdlKHRhc2s6IEltYWdlUHJvY2Vzc2luZ1Rhc2spOiBQcm9taXNlPEltYWdlRGF0YSB8IHN0cmluZz4ge1xuICAgIGNvbnN0IHRhc2tJZCA9IHRhc2suaWQgfHwgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHRhc2tJZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG5cbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgLi4udGFzayxcbiAgICAgICAgaWQ6IHRhc2tJZCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaW1lb3V0IGFmdGVyIDYwIHNlY29uZHMgZm9yIGltYWdlIHByb2Nlc3NpbmdcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nVGFza3MuaGFzKHRhc2tJZCkpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUodGFza0lkKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSW1hZ2UgcHJvY2Vzc2luZyB0aW1lb3V0XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSwgNjAwMDApO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVzaXplSW1hZ2UoXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gICAgd2lkdGg6IG51bWJlcixcbiAgICBoZWlnaHQ6IG51bWJlcixcbiAgKTogUHJvbWlzZTxJbWFnZURhdGE+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3NJbWFnZSh7XG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNiksXG4gICAgICB0eXBlOiBcInJlc2l6ZVwiLFxuICAgICAgaW1hZ2VEYXRhLFxuICAgICAgb3B0aW9uczogeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0IGFzIEltYWdlRGF0YTtcbiAgfVxuXG4gIGFzeW5jIGFwcGx5RmlsdGVyKFxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICAgIGZpbHRlclR5cGU6IHN0cmluZyxcbiAgICBpbnRlbnNpdHk6IG51bWJlciA9IDEsXG4gICk6IFByb21pc2U8SW1hZ2VEYXRhPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzSW1hZ2Uoe1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJmaWx0ZXJcIixcbiAgICAgIGltYWdlRGF0YSxcbiAgICAgIG9wdGlvbnM6IHsgZmlsdGVyVHlwZSwgaW50ZW5zaXR5IH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0IGFzIEltYWdlRGF0YTtcbiAgfVxuXG4gIGFzeW5jIGNyb3BJbWFnZShcbiAgICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgICB4OiBudW1iZXIsXG4gICAgeTogbnVtYmVyLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICk6IFByb21pc2U8SW1hZ2VEYXRhPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzSW1hZ2Uoe1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJjcm9wXCIsXG4gICAgICBpbWFnZURhdGEsXG4gICAgICBvcHRpb25zOiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQgYXMgSW1hZ2VEYXRhO1xuICB9XG5cbiAgYXN5bmMgcm90YXRlSW1hZ2UoaW1hZ2VEYXRhOiBJbWFnZURhdGEsIGFuZ2xlOiBudW1iZXIpOiBQcm9taXNlPEltYWdlRGF0YT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc0ltYWdlKHtcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIHR5cGU6IFwicm90YXRlXCIsXG4gICAgICBpbWFnZURhdGEsXG4gICAgICBvcHRpb25zOiB7IGFuZ2xlIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0IGFzIEltYWdlRGF0YTtcbiAgfVxuXG4gIGFzeW5jIGFkanVzdEJyaWdodG5lc3MoXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gICAgYnJpZ2h0bmVzczogbnVtYmVyLFxuICApOiBQcm9taXNlPEltYWdlRGF0YT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc0ltYWdlKHtcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIHR5cGU6IFwiYnJpZ2h0bmVzc1wiLFxuICAgICAgaW1hZ2VEYXRhLFxuICAgICAgb3B0aW9uczogeyBicmlnaHRuZXNzIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0IGFzIEltYWdlRGF0YTtcbiAgfVxuXG4gIGFzeW5jIGFkanVzdENvbnRyYXN0KFxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICAgIGNvbnRyYXN0OiBudW1iZXIsXG4gICk6IFByb21pc2U8SW1hZ2VEYXRhPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzSW1hZ2Uoe1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJjb250cmFzdFwiLFxuICAgICAgaW1hZ2VEYXRhLFxuICAgICAgb3B0aW9uczogeyBjb250cmFzdCB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdCBhcyBJbWFnZURhdGE7XG4gIH1cblxuICB0ZXJtaW5hdGUoKTogdm9pZCB7XG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy5wZW5kaW5nVGFza3MuY2xlYXIoKTtcbiAgfVxufVxuXG4vLyBTaGFyZWQgV29ya2VyIGZvciBDcm9zcy1UYWIgQ29tbXVuaWNhdGlvblxuaW50ZXJmYWNlIFRhYk1lc3NhZ2Uge1xuICB0eXBlOiBcInN5bmNcIiB8IFwiYnJvYWRjYXN0XCIgfCBcInJlcXVlc3RcIiB8IFwicmVzcG9uc2VcIjtcbiAgZGF0YTogYW55O1xuICB0YWJJZD86IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmNsYXNzIENyb3NzVGFiQ29tbXVuaWNhdG9yIHtcbiAgcHJpdmF0ZSBzaGFyZWRXb3JrZXI6IFNoYXJlZFdvcmtlcjtcbiAgcHJpdmF0ZSBwb3J0OiBNZXNzYWdlUG9ydDtcbiAgcHJpdmF0ZSB0YWJJZDogc3RyaW5nO1xuICBwcml2YXRlIG1lc3NhZ2VIYW5kbGVyczogTWFwPHN0cmluZywgKGRhdGE6IGFueSkgPT4gdm9pZD4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50YWJJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpO1xuICAgIHRoaXMuc2hhcmVkV29ya2VyID0gbmV3IFNoYXJlZFdvcmtlcihcIi93b3JrZXJzL2Nyb3NzLXRhYi5qc1wiKTtcbiAgICB0aGlzLnBvcnQgPSB0aGlzLnNoYXJlZFdvcmtlci5wb3J0O1xuXG4gICAgdGhpcy5wb3J0Lm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucG9ydC5vbm1lc3NhZ2VlcnJvciA9IHRoaXMuaGFuZGxlTWVzc2FnZUVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wb3J0LnN0YXJ0KCk7XG5cbiAgICAvLyBSZWdpc3RlciB0aGlzIHRhYlxuICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJzeW5jXCIsXG4gICAgICBkYXRhOiB7IGFjdGlvbjogXCJyZWdpc3RlclwiLCB0YWJJZDogdGhpcy50YWJJZCB9LFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNZXNzYWdlKGV2ZW50OiBNZXNzYWdlRXZlbnQ8VGFiTWVzc2FnZT4pOiB2b2lkIHtcbiAgICBjb25zdCB7IHR5cGUsIGRhdGEsIHRhYklkLCB0aW1lc3RhbXAgfSA9IGV2ZW50LmRhdGE7XG5cbiAgICAvLyBEb24ndCBoYW5kbGUgb3VyIG93biBtZXNzYWdlc1xuICAgIGlmICh0YWJJZCA9PT0gdGhpcy50YWJJZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMubWVzc2FnZUhhbmRsZXJzLmdldCh0eXBlKTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBFbWl0IGdlbmVyYWwgbWVzc2FnZSBldmVudFxuICAgIGNvbnN0IGdlbmVyYWxIYW5kbGVyID0gdGhpcy5tZXNzYWdlSGFuZGxlcnMuZ2V0KFwiKlwiKTtcbiAgICBpZiAoZ2VuZXJhbEhhbmRsZXIpIHtcbiAgICAgIGdlbmVyYWxIYW5kbGVyKHsgdHlwZSwgZGF0YSwgdGFiSWQsIHRpbWVzdGFtcCB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1lc3NhZ2VFcnJvcihlcnJvcjogTWVzc2FnZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc29sZS5lcnJvcihcIkNyb3NzLXRhYiBjb21tdW5pY2F0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gIH1cblxuICBwcml2YXRlIHNlbmRNZXNzYWdlKG1lc3NhZ2U6IFRhYk1lc3NhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIHRhYklkOiB0aGlzLnRhYklkLFxuICAgIH0pO1xuICB9XG5cbiAgYnJvYWRjYXN0KGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJicm9hZGNhc3RcIixcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfSk7XG4gIH1cblxuICBzeW5jKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJzeW5jXCIsXG4gICAgICBkYXRhLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH0pO1xuICB9XG5cbiAgcmVxdWVzdChkYXRhOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZURhdGE6IGFueSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2VEYXRhLnJlcXVlc3RJZCA9PT0gcmVxdWVzdElkKSB7XG4gICAgICAgICAgdGhpcy5vZmYoXCJyZXNwb25zZVwiLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUocmVzcG9uc2VEYXRhLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKFwicmVzcG9uc2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcblxuICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgICBkYXRhOiB7IC4uLmRhdGEsIHJlcXVlc3RJZCB9LFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB9KTtcblxuICAgICAgLy8gVGltZW91dCBhZnRlciAxMCBzZWNvbmRzXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoXCJyZXNwb25zZVwiLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCB0aW1lb3V0XCIpKTtcbiAgICAgIH0sIDEwMDAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlc3BvbmQocmVxdWVzdElkOiBzdHJpbmcsIGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJyZXNwb25zZVwiLFxuICAgICAgZGF0YTogeyByZXF1ZXN0SWQsIGRhdGEgfSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9KTtcbiAgfVxuXG4gIG9uKG1lc3NhZ2VUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5zZXQobWVzc2FnZVR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgb2ZmKG1lc3NhZ2VUeXBlOiBzdHJpbmcsIGhhbmRsZXI/OiAoZGF0YTogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRIYW5kbGVyID0gdGhpcy5tZXNzYWdlSGFuZGxlcnMuZ2V0KG1lc3NhZ2VUeXBlKTtcbiAgICAgIGlmIChjdXJyZW50SGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5kZWxldGUobWVzc2FnZVR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5kZWxldGUobWVzc2FnZVR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKTogdm9pZCB7XG4gICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICB0eXBlOiBcInN5bmNcIixcbiAgICAgIGRhdGE6IHsgYWN0aW9uOiBcInVucmVnaXN0ZXJcIiwgdGFiSWQ6IHRoaXMudGFiSWQgfSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9KTtcblxuICAgIHRoaXMucG9ydC5jbG9zZSgpO1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbn1cblxuLy8gU2VydmljZSBXb3JrZXIgTWFuYWdlclxuaW50ZXJmYWNlIENhY2hlQ29uZmlnIHtcbiAgbmFtZTogc3RyaW5nO1xuICBtYXhBZ2U6IG51bWJlcjtcbiAgbWF4RW50cmllczogbnVtYmVyO1xuICBzdHJhdGVneTogXCJjYWNoZS1maXJzdFwiIHwgXCJuZXR3b3JrLWZpcnN0XCIgfCBcInN0YWxlLXdoaWxlLXJldmFsaWRhdGVcIjtcbn1cblxuY2xhc3MgU2VydmljZVdvcmtlck1hbmFnZXIge1xuICBwcml2YXRlIHJlZ2lzdHJhdGlvbj86IFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb247XG4gIHByaXZhdGUgaXNSZWdpc3RlcmVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgYXN5bmMgcmVnaXN0ZXIoXG4gICAgc2NyaXB0VXJsOiBzdHJpbmcgPSBcIi9zdy5qc1wiLFxuICApOiBQcm9taXNlPFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24+IHtcbiAgICBpZiAoIShcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXJ2aWNlIFdvcmtlciBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbiA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKHNjcmlwdFVybCk7XG4gICAgICB0aGlzLmlzUmVnaXN0ZXJlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidXBkYXRlZm91bmRcIixcbiAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGVGb3VuZC5iaW5kKHRoaXMpLFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cmF0aW9uO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiU2VydmljZSBXb3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVVcGRhdGVGb3VuZCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucmVnaXN0cmF0aW9uKSByZXR1cm47XG5cbiAgICBjb25zdCBuZXdXb3JrZXIgPSB0aGlzLnJlZ2lzdHJhdGlvbi5pbnN0YWxsaW5nO1xuICAgIGlmIChuZXdXb3JrZXIpIHtcbiAgICAgIG5ld1dvcmtlci5hZGRFdmVudExpc3RlbmVyKFwic3RhdGVjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV3V29ya2VyLnN0YXRlID09PSBcImluc3RhbGxlZFwiICYmXG4gICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlclxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5ldyBTZXJ2aWNlIFdvcmtlciBhdmFpbGFibGVcIik7XG4gICAgICAgICAgLy8gQ291bGQgdHJpZ2dlciB1cGRhdGUgbm90aWZpY2F0aW9uIHRvIHVzZXJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdW5yZWdpc3RlcigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMucmVnaXN0cmF0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVnaXN0cmF0aW9uLnVucmVnaXN0ZXIoKTtcbiAgICAgIHRoaXMuaXNSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiU2VydmljZSBXb3JrZXIgdW5yZWdpc3RyYXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5yZWdpc3RyYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2UgV29ya2VyIG5vdCByZWdpc3RlcmVkXCIpO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucmVnaXN0cmF0aW9uLnVwZGF0ZSgpO1xuICB9XG5cbiAgcG9zdE1lc3NhZ2UobWVzc2FnZTogYW55KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnJlZ2lzdHJhdGlvbj8uYWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhY3RpdmUgU2VydmljZSBXb3JrZXJcIik7XG4gICAgfVxuXG4gICAgdGhpcy5yZWdpc3RyYXRpb24uYWN0aXZlLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG5cbiAgYXN5bmMgY29uZmlndXJlQ2FjaGUoY29uZmlnczogQ2FjaGVDb25maWdbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJjb25maWd1cmUtY2FjaGVcIixcbiAgICAgIGNvbmZpZ3MsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjbGVhckNhY2hlKGNhY2hlTmFtZT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJjbGVhci1jYWNoZVwiLFxuICAgICAgY2FjaGVOYW1lLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q2FjaGVTdGF0cygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG5cbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLmVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihldmVudC5kYXRhLmVycm9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiZ2V0LWNhY2hlLXN0YXRzXCIsXG4gICAgICAgIHBvcnQ6IGNoYW5uZWwucG9ydDIsXG4gICAgICB9KTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDYWNoZSBzdGF0cyByZXF1ZXN0IHRpbWVvdXRcIikpO1xuICAgICAgfSwgNTAwMCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRSZWdpc3RyYXRpb24oKTogU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cmF0aW9uO1xuICB9XG5cbiAgaXNTZXJ2aWNlV29ya2VyUmVnaXN0ZXJlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1JlZ2lzdGVyZWQ7XG4gIH1cbn1cblxuLy8gQmFja2dyb3VuZCBTeW5jIE1hbmFnZXJcbmludGVyZmFjZSBTeW5jVGFzayB7XG4gIGlkOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgZGF0YTogYW55O1xuICByZXRyeUNvdW50OiBudW1iZXI7XG4gIG1heFJldHJpZXM6IG51bWJlcjtcbiAgY3JlYXRlZEF0OiBudW1iZXI7XG59XG5cbmNsYXNzIEJhY2tncm91bmRTeW5jTWFuYWdlciB7XG4gIHByaXZhdGUgdGFza3M6IE1hcDxzdHJpbmcsIFN5bmNUYXNrPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBzZXJ2aWNlV29ya2VyTWFuYWdlcjogU2VydmljZVdvcmtlck1hbmFnZXI7XG5cbiAgY29uc3RydWN0b3Ioc2VydmljZVdvcmtlck1hbmFnZXI6IFNlcnZpY2VXb3JrZXJNYW5hZ2VyKSB7XG4gICAgdGhpcy5zZXJ2aWNlV29ya2VyTWFuYWdlciA9IHNlcnZpY2VXb3JrZXJNYW5hZ2VyO1xuICB9XG5cbiAgYXN5bmMgc2NoZWR1bGVTeW5jKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBkYXRhOiBhbnksXG4gICAgb3B0aW9uczogeyBtYXhSZXRyaWVzPzogbnVtYmVyIH0gPSB7fSxcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB0YXNrSWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KTtcbiAgICBjb25zdCB0YXNrOiBTeW5jVGFzayA9IHtcbiAgICAgIGlkOiB0YXNrSWQsXG4gICAgICB0eXBlLFxuICAgICAgZGF0YSxcbiAgICAgIHJldHJ5Q291bnQ6IDAsXG4gICAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMgfHwgMyxcbiAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICB9O1xuXG4gICAgdGhpcy50YXNrcy5zZXQodGFza0lkLCB0YXNrKTtcblxuICAgIC8vIFNlbmQgdG8gc2VydmljZSB3b3JrZXIgZm9yIGJhY2tncm91bmQgcHJvY2Vzc2luZ1xuICAgIHRoaXMuc2VydmljZVdvcmtlck1hbmFnZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJzY2hlZHVsZS1zeW5jXCIsXG4gICAgICB0YXNrLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhc2tJZDtcbiAgfVxuXG4gIGFzeW5jIGNhbmNlbFN5bmModGFza0lkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCB0YXNrID0gdGhpcy50YXNrcy5nZXQodGFza0lkKTtcbiAgICBpZiAoIXRhc2spIHJldHVybiBmYWxzZTtcblxuICAgIHRoaXMudGFza3MuZGVsZXRlKHRhc2tJZCk7XG5cbiAgICB0aGlzLnNlcnZpY2VXb3JrZXJNYW5hZ2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwiY2FuY2VsLXN5bmNcIixcbiAgICAgIHRhc2tJZCxcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgcmV0cnlGYWlsZWRUYXNrcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmYWlsZWRUYXNrcyA9IEFycmF5LmZyb20odGhpcy50YXNrcy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgKHRhc2spID0+IHRhc2sucmV0cnlDb3VudCA8IHRhc2subWF4UmV0cmllcyxcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCB0YXNrIG9mIGZhaWxlZFRhc2tzKSB7XG4gICAgICB0YXNrLnJldHJ5Q291bnQrKztcblxuICAgICAgdGhpcy5zZXJ2aWNlV29ya2VyTWFuYWdlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwicmV0cnktc3luY1wiLFxuICAgICAgICB0YXNrLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGVuZGluZ1Rhc2tzKCk6IFN5bmNUYXNrW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudGFza3MudmFsdWVzKCkpO1xuICB9XG5cbiAgZ2V0VGFza1N0YXR1cyh0YXNrSWQ6IHN0cmluZyk6IFN5bmNUYXNrIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy50YXNrcy5nZXQodGFza0lkKTtcbiAgfVxuXG4gIGNsZWFyQ29tcGxldGVkVGFza3MoKTogdm9pZCB7XG4gICAgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmluZyBzdWNjZXNzIG5vdGlmaWNhdGlvbnNcbiAgICAvLyBmcm9tIHRoZSBzZXJ2aWNlIHdvcmtlclxuICAgIGNvbnN0IGNvbXBsZXRlZFRhc2tzID0gQXJyYXkuZnJvbSh0aGlzLnRhc2tzLmVudHJpZXMoKSkuZmlsdGVyKFxuICAgICAgKFtfLCB0YXNrXSkgPT4gdGFzay5yZXRyeUNvdW50ID49IHRhc2subWF4UmV0cmllcyxcbiAgICApO1xuXG4gICAgY29tcGxldGVkVGFza3MuZm9yRWFjaCgoW3Rhc2tJZF0pID0+IHtcbiAgICAgIHRoaXMudGFza3MuZGVsZXRlKHRhc2tJZCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gVGVzdHNcbmRlc2NyaWJlKFwiV2ViIFdvcmtlcnNcIiwgKCkgPT4ge1xuICBkZXNjcmliZShcIkRhdGFQcm9jZXNzaW5nV29ya2VyXCIsICgpID0+IHtcbiAgICBsZXQgd29ya2VyOiBEYXRhUHJvY2Vzc2luZ1dvcmtlcjtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgd29ya2VyID0gbmV3IERhdGFQcm9jZXNzaW5nV29ya2VyKCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjcmVhdGUgd29ya2VyIGluc3RhbmNlXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChXb3JrZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiL3dvcmtlcnMvZGF0YS1wcm9jZXNzaW5nLmpzXCIpO1xuICAgICAgZXhwZWN0KHdvcmtlci5nZXRRdWV1ZVNpemUoKSkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcHJvY2VzcyBkYXRhIHdpdGggcmVzdWx0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gWzEsIDIsIDMsIDQsIDVdO1xuICAgICAgY29uc3QgdGFzazogUHJvY2Vzc2luZ1Rhc2sgPSB7XG4gICAgICAgIGlkOiBcInRlc3QxXCIsXG4gICAgICAgIHR5cGU6IFwiZmlsdGVyXCIsXG4gICAgICAgIGRhdGE6IHRlc3REYXRhLFxuICAgICAgICBvcHRpb25zOiB7IHByZWRpY2F0ZTogXCJ4ID0+IHggPiAyXCIgfSxcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgd29ya2VyIHJlc3BvbnNlXG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IFwidGVzdDFcIixcbiAgICAgICAgICAgIHJlc3VsdDogWzMsIDQsIDVdLFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDEwMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd29ya2VyLnByb2Nlc3NEYXRhKHRhc2spO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yZXN1bHQpLnRvRXF1YWwoWzMsIDQsIDVdKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucHJvY2Vzc2luZ1RpbWUpLnRvQmUoMTAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHdvcmtlciBlcnJvcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSBbMSwgMiwgM107XG4gICAgICBjb25zdCB0YXNrOiBQcm9jZXNzaW5nVGFzayA9IHtcbiAgICAgICAgaWQ6IFwidGVzdDJcIixcbiAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgZGF0YTogdGVzdERhdGEsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHdvcmtlciBlcnJvciByZXNwb25zZVxuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBcInRlc3QyXCIsXG4gICAgICAgICAgICBlcnJvcjogXCJQcm9jZXNzaW5nIGZhaWxlZFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBhd2FpdCBleHBlY3Qod29ya2VyLnByb2Nlc3NEYXRhKHRhc2spKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiUHJvY2Vzc2luZyBmYWlsZWRcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGZpbHRlciBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gWzEsIDIsIDMsIDQsIDVdO1xuXG4gICAgICAvLyBNb2NrIHdvcmtlciByZXNwb25zZVxuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IFs0LCA1XSxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lOiA1MCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd29ya2VyLmZpbHRlckRhdGEodGVzdERhdGEsIFwieCA9PiB4ID4gM1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoWzQsIDVdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgbWFwIGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSBbMSwgMiwgM107XG5cbiAgICAgIC8vIE1vY2sgd29ya2VyIHJlc3BvbnNlXG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDogWzIsIDQsIDZdLFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDMwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIubWFwRGF0YSh0ZXN0RGF0YSwgXCJ4ID0+IHggKiAyXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbMiwgNCwgNl0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCByZWR1Y2UgZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IFsxLCAyLCAzLCA0XTtcblxuICAgICAgLy8gTW9jayB3b3JrZXIgcmVzcG9uc2VcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiAxMCxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lOiAyMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd29ya2VyLnJlZHVjZURhdGEoXG4gICAgICAgIHRlc3REYXRhLFxuICAgICAgICBcIihhY2MsIHZhbCkgPT4gYWNjICsgdmFsXCIsXG4gICAgICAgIDAsXG4gICAgICApO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgxMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHNvcnQgZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IFszLCAxLCA0LCAxLCA1XTtcblxuICAgICAgLy8gTW9jayB3b3JrZXIgcmVzcG9uc2VcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiBbMSwgMSwgMywgNCwgNV0sXG4gICAgICAgICAgICBwcm9jZXNzaW5nVGltZTogMjUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdvcmtlci5zb3J0RGF0YSh0ZXN0RGF0YSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFsxLCAxLCAzLCA0LCA1XSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGFnZ3JlZ2F0ZSBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gW1xuICAgICAgICB7IGNhdGVnb3J5OiBcIkFcIiwgdmFsdWU6IDEwIH0sXG4gICAgICAgIHsgY2F0ZWdvcnk6IFwiQlwiLCB2YWx1ZTogMjAgfSxcbiAgICAgICAgeyBjYXRlZ29yeTogXCJBXCIsIHZhbHVlOiAxNSB9LFxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayB3b3JrZXIgcmVzcG9uc2VcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiB7IEE6IDI1LCBCOiAyMCB9LFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDQwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIuYWdncmVnYXRlRGF0YSh0ZXN0RGF0YSwgeyBzdW06IFwidmFsdWVcIiB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBBOiAyNSwgQjogMjAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSB0YXNrIHRpbWVvdXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSBbMSwgMiwgM107XG4gICAgICBjb25zdCB0YXNrOiBQcm9jZXNzaW5nVGFzayA9IHtcbiAgICAgICAgaWQ6IFwidGltZW91dC10ZXN0XCIsXG4gICAgICAgIHR5cGU6IFwiZmlsdGVyXCIsXG4gICAgICAgIGRhdGE6IHRlc3REYXRhLFxuICAgICAgfTtcblxuICAgICAgLy8gRG9uJ3QgbW9jayBhbnkgcmVzcG9uc2UgdG8gdHJpZ2dlciB0aW1lb3V0XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh3b3JrZXIucHJvY2Vzc0RhdGEodGFzaykpLnJlamVjdHMudG9UaHJvdyhcIlRhc2sgdGltZW91dFwiKTtcbiAgICB9LCAzNTAwMCk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBxdWV1ZSBzaXplIHRyYWNraW5nXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdCh3b3JrZXIuZ2V0UXVldWVTaXplKCkpLnRvQmUoMCk7XG5cbiAgICAgIC8vIFN0YXJ0IGEgdGFzayAod29uJ3QgY29tcGxldGUgd2l0aG91dCBtb2NrIHJlc3BvbnNlKVxuICAgICAgd29ya2VyXG4gICAgICAgIC5wcm9jZXNzRGF0YSh7XG4gICAgICAgICAgaWQ6IFwicXVldWUtdGVzdFwiLFxuICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgZGF0YTogWzEsIDIsIDNdLFxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4ge30pOyAvLyBJZ25vcmUgdGhlIGVycm9yXG5cbiAgICAgIGV4cGVjdCh3b3JrZXIuZ2V0UXVldWVTaXplKCkpLnRvQmUoMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiSW1hZ2VQcm9jZXNzaW5nV29ya2VyXCIsICgpID0+IHtcbiAgICBsZXQgd29ya2VyOiBJbWFnZVByb2Nlc3NpbmdXb3JrZXI7XG4gICAgbGV0IG1vY2tJbWFnZURhdGE6IEltYWdlRGF0YTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgd29ya2VyID0gbmV3IEltYWdlUHJvY2Vzc2luZ1dvcmtlcigpO1xuXG4gICAgICAvLyBNb2NrIEltYWdlRGF0YVxuICAgICAgbW9ja0ltYWdlRGF0YSA9IHtcbiAgICAgICAgZGF0YTogbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFsyNTUsIDAsIDAsIDI1NV0pLCAvLyBSZWQgcGl4ZWxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgY29sb3JTcGFjZTogXCJzcmdiXCIsXG4gICAgICB9IGFzIEltYWdlRGF0YTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGNyZWF0ZSBpbWFnZSBwcm9jZXNzaW5nIHdvcmtlclwiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoV29ya2VyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIi93b3JrZXJzL2ltYWdlLXByb2Nlc3NpbmcuanNcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHJlc2l6ZSBpbWFnZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICBkYXRhOiBuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwgMCwgMCwgMjU1LCAyNTUsIDAsIDAsIDI1NV0pLFxuICAgICAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd29ya2VyLnJlc2l6ZUltYWdlKG1vY2tJbWFnZURhdGEsIDIsIDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC53aWR0aCkudG9CZSgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuaGVpZ2h0KS50b0JlKDEpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBhcHBseSBmaWx0ZXIgdG8gaW1hZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgZGF0YTogbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFsxMjgsIDEyOCwgMTI4LCAyNTVdKSwgLy8gR3JheXNjYWxlXG4gICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIuYXBwbHlGaWx0ZXIobW9ja0ltYWdlRGF0YSwgXCJncmF5c2NhbGVcIiwgMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGFbMF0pLnRvQmUoMTI4KTsgLy8gU2hvdWxkIGJlIGdyYXlzY2FsZVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjcm9wIGltYWdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiBtb2NrSW1hZ2VEYXRhLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIuY3JvcEltYWdlKG1vY2tJbWFnZURhdGEsIDAsIDAsIDEsIDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcm90YXRlIGltYWdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiBtb2NrSW1hZ2VEYXRhLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIucm90YXRlSW1hZ2UobW9ja0ltYWdlRGF0YSwgOTApO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgYWRqdXN0IGJyaWdodG5lc3NcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgZGF0YTogbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFsyNTUsIDEwMCwgMTAwLCAyNTVdKSwgLy8gQnJpZ2h0ZXJcbiAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdvcmtlci5hZGp1c3RCcmlnaHRuZXNzKG1vY2tJbWFnZURhdGEsIDEuNSk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGFbMV0pLnRvQmUoMTAwKTsgLy8gTW9kaWZpZWQgYnJpZ2h0bmVzc1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBhZGp1c3QgY29udHJhc3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgZGF0YTogbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFsyNTUsIDUwLCA1MCwgMjU1XSksIC8vIEhpZ2hlciBjb250cmFzdFxuICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd29ya2VyLmFkanVzdENvbnRyYXN0KG1vY2tJbWFnZURhdGEsIDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhWzFdKS50b0JlKDUwKTsgLy8gTW9kaWZpZWQgY29udHJhc3RcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHByb2Nlc3NpbmcgZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgZXJyb3I6IFwiSW52YWxpZCBpbWFnZSBmb3JtYXRcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHdvcmtlci5yZXNpemVJbWFnZShtb2NrSW1hZ2VEYXRhLCAwLCAwKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBcIkludmFsaWQgaW1hZ2UgZm9ybWF0XCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgcHJvY2Vzc2luZyB0aW1lb3V0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIERvbid0IG1vY2sgYW55IHJlc3BvbnNlIHRvIHRyaWdnZXIgdGltZW91dFxuICAgICAgYXdhaXQgZXhwZWN0KHdvcmtlci5yZXNpemVJbWFnZShtb2NrSW1hZ2VEYXRhLCAxMDAsIDEwMCkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgXCJJbWFnZSBwcm9jZXNzaW5nIHRpbWVvdXRcIixcbiAgICAgICk7XG4gICAgfSwgNjUwMDApO1xuICB9KTtcblxuICBkZXNjcmliZShcIkNyb3NzVGFiQ29tbXVuaWNhdG9yXCIsICgpID0+IHtcbiAgICBsZXQgY29tbXVuaWNhdG9yOiBDcm9zc1RhYkNvbW11bmljYXRvcjtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgY29tbXVuaWNhdG9yID0gbmV3IENyb3NzVGFiQ29tbXVuaWNhdG9yKCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgY29tbXVuaWNhdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY3JlYXRlIHNoYXJlZCB3b3JrZXIgZm9yIGNyb3NzLXRhYiBjb21tdW5pY2F0aW9uXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChTaGFyZWRXb3JrZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiL3dvcmtlcnMvY3Jvc3MtdGFiLmpzXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBicm9hZGNhc3QgbWVzc2FnZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSB7IG1lc3NhZ2U6IFwiSGVsbG8gZnJvbSB0YWIhXCIgfTtcblxuICAgICAgY29tbXVuaWNhdG9yLmJyb2FkY2FzdCh0ZXN0RGF0YSk7XG5cbiAgICAgIGNvbnN0IG1vY2tQb3J0ID0gKFNoYXJlZFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZS5wb3J0O1xuICAgICAgZXhwZWN0KG1vY2tQb3J0LnBvc3RNZXNzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwiYnJvYWRjYXN0XCIsXG4gICAgICAgICAgZGF0YTogdGVzdERhdGEsXG4gICAgICAgICAgdGFiSWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBzeW5jIGRhdGFcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc3luY0RhdGEgPSB7IHN0YXRlOiBcInVwZGF0ZWRcIiB9O1xuXG4gICAgICBjb21tdW5pY2F0b3Iuc3luYyhzeW5jRGF0YSk7XG5cbiAgICAgIGNvbnN0IG1vY2tQb3J0ID0gKFNoYXJlZFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZS5wb3J0O1xuICAgICAgZXhwZWN0KG1vY2tQb3J0LnBvc3RNZXNzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwic3luY1wiLFxuICAgICAgICAgIGRhdGE6IHN5bmNEYXRhLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSByZXF1ZXN0LXJlc3BvbnNlIHBhdHRlcm5cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdERhdGEgPSB7IHF1ZXJ5OiBcImdldFVzZXJEYXRhXCIgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHsgdXNlcjogeyBpZDogMSwgbmFtZTogXCJUZXN0IFVzZXJcIiB9IH07XG5cbiAgICAgIC8vIE1vY2sgcmVzcG9uc2VcbiAgICAgIGNvbnN0IG1vY2tQb3J0ID0gKFNoYXJlZFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZS5wb3J0O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbW11bmljYXRvci5vbihcInJlc3BvbnNlXCIsIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGEucmVxdWVzdElkKSB7XG4gICAgICAgICAgICAvLyBTaW11bGF0ZSByZXNwb25zZSBmcm9tIGFub3RoZXIgdGFiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTaW11bGF0ZSByZWNlaXZpbmcgcmVzcG9uc2VcbiAgICAgICAgaWYgKG1vY2tQb3J0Lm9ubWVzc2FnZSkge1xuICAgICAgICAgIG1vY2tQb3J0Lm9ubWVzc2FnZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgZGF0YTogeyByZXF1ZXN0SWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSwgZGF0YTogcmVzcG9uc2VEYXRhIH0sXG4gICAgICAgICAgICAgIHRhYklkOiBcIm90aGVyLXRhYlwiLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbW11bmljYXRvci5yZXF1ZXN0KHJlcXVlc3REYXRhKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwocmVzcG9uc2VEYXRhKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIG1lc3NhZ2UgaGFuZGxlcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGplc3QuZm4oKTtcblxuICAgICAgY29tbXVuaWNhdG9yLm9uKFwiYnJvYWRjYXN0XCIsIGhhbmRsZXIpO1xuXG4gICAgICAvLyBTaW11bGF0ZSByZWNlaXZpbmcgbWVzc2FnZVxuICAgICAgY29uc3QgbW9ja1BvcnQgPSAoU2hhcmVkV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlLnBvcnQ7XG4gICAgICBpZiAobW9ja1BvcnQub25tZXNzYWdlKSB7XG4gICAgICAgIG1vY2tQb3J0Lm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdHlwZTogXCJicm9hZGNhc3RcIixcbiAgICAgICAgICAgIGRhdGE6IHsgdGVzdDogXCJkYXRhXCIgfSxcbiAgICAgICAgICAgIHRhYklkOiBcIm90aGVyLXRhYlwiLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QoaGFuZGxlcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyB0ZXN0OiBcImRhdGFcIiB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVtb3ZlIG1lc3NhZ2UgaGFuZGxlcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGplc3QuZm4oKTtcblxuICAgICAgY29tbXVuaWNhdG9yLm9uKFwiYnJvYWRjYXN0XCIsIGhhbmRsZXIpO1xuICAgICAgY29tbXVuaWNhdG9yLm9mZihcImJyb2FkY2FzdFwiLCBoYW5kbGVyKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcmVjZWl2aW5nIG1lc3NhZ2VcbiAgICAgIGNvbnN0IG1vY2tQb3J0ID0gKFNoYXJlZFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZS5wb3J0O1xuICAgICAgaWYgKG1vY2tQb3J0Lm9ubWVzc2FnZSkge1xuICAgICAgICBtb2NrUG9ydC5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJvYWRjYXN0XCIsXG4gICAgICAgICAgICBkYXRhOiB7IHRlc3Q6IFwiZGF0YVwiIH0sXG4gICAgICAgICAgICB0YWJJZDogXCJvdGhlci10YWJcIixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KGhhbmRsZXIpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGlnbm9yZSBvd24gbWVzc2FnZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGplc3QuZm4oKTtcbiAgICAgIGNvbW11bmljYXRvci5vbihcImJyb2FkY2FzdFwiLCBoYW5kbGVyKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcmVjZWl2aW5nIG91ciBvd24gbWVzc2FnZVxuICAgICAgY29uc3QgbW9ja1BvcnQgPSAoU2hhcmVkV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlLnBvcnQ7XG4gICAgICBjb25zdCB0YWJJZCA9IChjb21tdW5pY2F0b3IgYXMgYW55KS50YWJJZDtcblxuICAgICAgaWYgKG1vY2tQb3J0Lm9ubWVzc2FnZSkge1xuICAgICAgICBtb2NrUG9ydC5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJvYWRjYXN0XCIsXG4gICAgICAgICAgICBkYXRhOiB7IHRlc3Q6IFwiZGF0YVwiIH0sXG4gICAgICAgICAgICB0YWJJZDogdGFiSWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChoYW5kbGVyKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCByZXNwb25kIHRvIHJlcXVlc3RzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IFwidGVzdC1yZXF1ZXN0LTEyM1wiO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0geyByZXN1bHQ6IFwic3VjY2Vzc1wiIH07XG5cbiAgICAgIGNvbW11bmljYXRvci5yZXNwb25kKHJlcXVlc3RJZCwgcmVzcG9uc2VEYXRhKTtcblxuICAgICAgY29uc3QgbW9ja1BvcnQgPSAoU2hhcmVkV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlLnBvcnQ7XG4gICAgICBleHBlY3QobW9ja1BvcnQucG9zdE1lc3NhZ2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdHlwZTogXCJyZXNwb25zZVwiLFxuICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdElkLCBkYXRhOiByZXNwb25zZURhdGEgfSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlNlcnZpY2VXb3JrZXJNYW5hZ2VyXCIsICgpID0+IHtcbiAgICBsZXQgbWFuYWdlcjogU2VydmljZVdvcmtlck1hbmFnZXI7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1hbmFnZXIgPSBuZXcgU2VydmljZVdvcmtlck1hbmFnZXIoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVnaXN0ZXIgc2VydmljZSB3b3JrZXJcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVnaXN0cmF0aW9uID0gYXdhaXQgbWFuYWdlci5yZWdpc3RlcihcIi90ZXN0LXN3LmpzXCIpO1xuXG4gICAgICBleHBlY3QobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIi90ZXN0LXN3LmpzXCIsXG4gICAgICApO1xuICAgICAgZXhwZWN0KHJlZ2lzdHJhdGlvbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtYW5hZ2VyLmlzU2VydmljZVdvcmtlclJlZ2lzdGVyZWQoKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgdW5yZWdpc3RlciBzZXJ2aWNlIHdvcmtlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnJlZ2lzdGVyKCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtYW5hZ2VyLnVucmVnaXN0ZXIoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtYW5hZ2VyLmlzU2VydmljZVdvcmtlclJlZ2lzdGVyZWQoKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHVwZGF0ZSBzZXJ2aWNlIHdvcmtlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnJlZ2lzdGVyKCk7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnVwZGF0ZSgpO1xuXG4gICAgICBjb25zdCByZWdpc3RyYXRpb24gPSBtYW5hZ2VyLmdldFJlZ2lzdHJhdGlvbigpO1xuICAgICAgZXhwZWN0KHJlZ2lzdHJhdGlvbj8udXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHBvc3QgbWVzc2FnZSB0byBzZXJ2aWNlIHdvcmtlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnJlZ2lzdGVyKCk7XG4gICAgICBjb25zdCBtZXNzYWdlID0geyB0eXBlOiBcInRlc3RcIiwgZGF0YTogXCJoZWxsb1wiIH07XG5cbiAgICAgIG1hbmFnZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IG1hbmFnZXIuZ2V0UmVnaXN0cmF0aW9uKCk7XG4gICAgICBleHBlY3QocmVnaXN0cmF0aW9uPy5hY3RpdmU/LnBvc3RNZXNzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtZXNzYWdlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY29uZmlndXJlIGNhY2hlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG1hbmFnZXIucmVnaXN0ZXIoKTtcbiAgICAgIGNvbnN0IGNvbmZpZ3M6IENhY2hlQ29uZmlnW10gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFwaS1jYWNoZVwiLFxuICAgICAgICAgIG1heEFnZTogMzYwMDAwMCxcbiAgICAgICAgICBtYXhFbnRyaWVzOiAxMDAsXG4gICAgICAgICAgc3RyYXRlZ3k6IFwibmV0d29yay1maXJzdFwiLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgYXdhaXQgbWFuYWdlci5jb25maWd1cmVDYWNoZShjb25maWdzKTtcblxuICAgICAgY29uc3QgcmVnaXN0cmF0aW9uID0gbWFuYWdlci5nZXRSZWdpc3RyYXRpb24oKTtcbiAgICAgIGV4cGVjdChyZWdpc3RyYXRpb24/LmFjdGl2ZT8ucG9zdE1lc3NhZ2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgdHlwZTogXCJjb25maWd1cmUtY2FjaGVcIixcbiAgICAgICAgY29uZmlncyxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjbGVhciBjYWNoZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnJlZ2lzdGVyKCk7XG5cbiAgICAgIGF3YWl0IG1hbmFnZXIuY2xlYXJDYWNoZShcInRlc3QtY2FjaGVcIik7XG5cbiAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IG1hbmFnZXIuZ2V0UmVnaXN0cmF0aW9uKCk7XG4gICAgICBleHBlY3QocmVnaXN0cmF0aW9uPy5hY3RpdmU/LnBvc3RNZXNzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHR5cGU6IFwiY2xlYXItY2FjaGVcIixcbiAgICAgICAgY2FjaGVOYW1lOiBcInRlc3QtY2FjaGVcIixcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBnZXQgY2FjaGUgc3RhdHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbWFuYWdlci5yZWdpc3RlcigpO1xuXG4gICAgICAvLyBUaGlzIHdvdWxkIHRpbWVvdXQgaW4gcmVhbCBpbXBsZW1lbnRhdGlvbiB3aXRob3V0IHByb3BlciByZXNwb25zZVxuICAgICAgYXdhaXQgZXhwZWN0KG1hbmFnZXIuZ2V0Q2FjaGVTdGF0cygpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiQ2FjaGUgc3RhdHMgcmVxdWVzdCB0aW1lb3V0XCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0aHJvdyBlcnJvciB3aGVuIHNlcnZpY2Ugd29ya2VyIG5vdCBzdXBwb3J0ZWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1bnN1cHBvcnRlZCBlbnZpcm9ubWVudFxuICAgICAgY29uc3Qgb3JpZ2luYWxTZXJ2aWNlV29ya2VyID0gKGdsb2JhbC5uYXZpZ2F0b3IgYXMgYW55KS5zZXJ2aWNlV29ya2VyO1xuICAgICAgZGVsZXRlIChnbG9iYWwubmF2aWdhdG9yIGFzIGFueSkuc2VydmljZVdvcmtlcjtcblxuICAgICAgY29uc3QgdW5zdXBwb3J0ZWRNYW5hZ2VyID0gbmV3IFNlcnZpY2VXb3JrZXJNYW5hZ2VyKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh1bnN1cHBvcnRlZE1hbmFnZXIucmVnaXN0ZXIoKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBcIlNlcnZpY2UgV29ya2VyIG5vdCBzdXBwb3J0ZWRcIixcbiAgICAgICk7XG5cbiAgICAgIC8vIFJlc3RvcmVcbiAgICAgIChnbG9iYWwubmF2aWdhdG9yIGFzIGFueSkuc2VydmljZVdvcmtlciA9IG9yaWdpbmFsU2VydmljZVdvcmtlcjtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiBwb3N0aW5nIG1lc3NhZ2Ugd2l0aG91dCBhY3RpdmUgd29ya2VyXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIG1hbmFnZXIucG9zdE1lc3NhZ2UoeyB0ZXN0OiBcImRhdGFcIiB9KTtcbiAgICAgIH0pLnRvVGhyb3coXCJObyBhY3RpdmUgU2VydmljZSBXb3JrZXJcIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiQmFja2dyb3VuZFN5bmNNYW5hZ2VyXCIsICgpID0+IHtcbiAgICBsZXQgc3luY01hbmFnZXI6IEJhY2tncm91bmRTeW5jTWFuYWdlcjtcbiAgICBsZXQgc2VydmljZVdvcmtlck1hbmFnZXI6IFNlcnZpY2VXb3JrZXJNYW5hZ2VyO1xuXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICBzZXJ2aWNlV29ya2VyTWFuYWdlciA9IG5ldyBTZXJ2aWNlV29ya2VyTWFuYWdlcigpO1xuICAgICAgYXdhaXQgc2VydmljZVdvcmtlck1hbmFnZXIucmVnaXN0ZXIoKTtcbiAgICAgIHN5bmNNYW5hZ2VyID0gbmV3IEJhY2tncm91bmRTeW5jTWFuYWdlcihzZXJ2aWNlV29ya2VyTWFuYWdlcik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHNjaGVkdWxlIHN5bmMgdGFza1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0YXNrRGF0YSA9IHsgYWN0aW9uOiBcInVwbG9hZEZpbGVcIiwgZmlsZUlkOiBcIjEyM1wiIH07XG5cbiAgICAgIGNvbnN0IHRhc2tJZCA9IGF3YWl0IHN5bmNNYW5hZ2VyLnNjaGVkdWxlU3luYyhcImZpbGUtdXBsb2FkXCIsIHRhc2tEYXRhKTtcblxuICAgICAgZXhwZWN0KHRhc2tJZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzeW5jTWFuYWdlci5nZXRQZW5kaW5nVGFza3MoKSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlV29ya2VyTWFuYWdlci5nZXRSZWdpc3RyYXRpb24oKT8uYWN0aXZlPy5wb3N0TWVzc2FnZSxcbiAgICAgICkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICB0eXBlOiBcInNjaGVkdWxlLXN5bmNcIixcbiAgICAgICAgICB0YXNrOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBpZDogdGFza0lkLFxuICAgICAgICAgICAgdHlwZTogXCJmaWxlLXVwbG9hZFwiLFxuICAgICAgICAgICAgZGF0YTogdGFza0RhdGEsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY2FuY2VsIHN5bmMgdGFza1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0YXNrSWQgPSBhd2FpdCBzeW5jTWFuYWdlci5zY2hlZHVsZVN5bmMoXCJ0ZXN0LXN5bmNcIiwge1xuICAgICAgICBkYXRhOiBcInRlc3RcIixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjYW5jZWxsZWQgPSBhd2FpdCBzeW5jTWFuYWdlci5jYW5jZWxTeW5jKHRhc2tJZCk7XG5cbiAgICAgIGV4cGVjdChjYW5jZWxsZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qoc3luY01hbmFnZXIuZ2V0UGVuZGluZ1Rhc2tzKCkpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgc2VydmljZVdvcmtlck1hbmFnZXIuZ2V0UmVnaXN0cmF0aW9uKCk/LmFjdGl2ZT8ucG9zdE1lc3NhZ2UsXG4gICAgICApLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdHlwZTogXCJjYW5jZWwtc3luY1wiLFxuICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCByZXRyeSBmYWlsZWQgdGFza3NcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGFza0lkID0gYXdhaXQgc3luY01hbmFnZXIuc2NoZWR1bGVTeW5jKFwidGVzdC1zeW5jXCIsIHtcbiAgICAgICAgZGF0YTogXCJ0ZXN0XCIsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgc3luY01hbmFnZXIucmV0cnlGYWlsZWRUYXNrcygpO1xuXG4gICAgICBjb25zdCB0YXNrID0gc3luY01hbmFnZXIuZ2V0VGFza1N0YXR1cyh0YXNrSWQpO1xuICAgICAgZXhwZWN0KHRhc2s/LnJldHJ5Q291bnQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QoXG4gICAgICAgIHNlcnZpY2VXb3JrZXJNYW5hZ2VyLmdldFJlZ2lzdHJhdGlvbigpPy5hY3RpdmU/LnBvc3RNZXNzYWdlLFxuICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwicmV0cnktc3luY1wiLFxuICAgICAgICAgIHRhc2s6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGlkOiB0YXNrSWQsXG4gICAgICAgICAgICByZXRyeUNvdW50OiAxLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGdldCB0YXNrIHN0YXR1c1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0YXNrSWQgPSBhd2FpdCBzeW5jTWFuYWdlci5zY2hlZHVsZVN5bmMoXCJ0ZXN0LXN5bmNcIiwge1xuICAgICAgICBkYXRhOiBcInRlc3RcIixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGF0dXMgPSBzeW5jTWFuYWdlci5nZXRUYXNrU3RhdHVzKHRhc2tJZCk7XG5cbiAgICAgIGV4cGVjdChzdGF0dXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc3RhdHVzPy5pZCkudG9CZSh0YXNrSWQpO1xuICAgICAgZXhwZWN0KHN0YXR1cz8udHlwZSkudG9CZShcInRlc3Qtc3luY1wiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY2xlYXIgY29tcGxldGVkIHRhc2tzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRhc2tJZCA9IGF3YWl0IHN5bmNNYW5hZ2VyLnNjaGVkdWxlU3luYyhcbiAgICAgICAgXCJ0ZXN0LXN5bmNcIixcbiAgICAgICAgeyBkYXRhOiBcInRlc3RcIiB9LFxuICAgICAgICB7IG1heFJldHJpZXM6IDAgfSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIHRhc2sgZmFpbHVyZSBieSBzZXR0aW5nIHJldHJ5IGNvdW50IHRvIG1heFxuICAgICAgY29uc3QgdGFzayA9IHN5bmNNYW5hZ2VyLmdldFRhc2tTdGF0dXModGFza0lkKTtcbiAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgIHRhc2sucmV0cnlDb3VudCA9IHRhc2subWF4UmV0cmllcztcbiAgICAgIH1cblxuICAgICAgc3luY01hbmFnZXIuY2xlYXJDb21wbGV0ZWRUYXNrcygpO1xuXG4gICAgICBleHBlY3Qoc3luY01hbmFnZXIuZ2V0VGFza1N0YXR1cyh0YXNrSWQpKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSB0YXNrIHdpdGggY3VzdG9tIG1heCByZXRyaWVzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRhc2tJZCA9IGF3YWl0IHN5bmNNYW5hZ2VyLnNjaGVkdWxlU3luYyhcbiAgICAgICAgXCJ0ZXN0LXN5bmNcIixcbiAgICAgICAgeyBkYXRhOiBcInRlc3RcIiB9LFxuICAgICAgICB7IG1heFJldHJpZXM6IDUgfSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRhc2sgPSBzeW5jTWFuYWdlci5nZXRUYXNrU3RhdHVzKHRhc2tJZCk7XG4gICAgICBleHBlY3QodGFzaz8ubWF4UmV0cmllcykudG9CZSg1KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgbm90IGNhbmNlbCBub24tZXhpc3RlbnQgdGFza1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5jZWxsZWQgPSBhd2FpdCBzeW5jTWFuYWdlci5jYW5jZWxTeW5jKFwibm9uLWV4aXN0ZW50LWlkXCIpO1xuXG4gICAgICBleHBlY3QoY2FuY2VsbGVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJXb3JrZXIiLCJqZXN0IiwiZm4iLCJwb3N0TWVzc2FnZSIsInRlcm1pbmF0ZSIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJvbm1lc3NhZ2VlcnJvciIsIlNoYXJlZFdvcmtlciIsInBvcnQiLCJzdGFydCIsImNsb3NlIiwiU2VydmljZVdvcmtlciIsInN0YXRlIiwib25zdGF0ZWNoYW5nZSIsIm5hdmlnYXRvciIsInNlcnZpY2VXb3JrZXIiLCJyZWdpc3RlciIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW5zdGFsbGluZyIsIndhaXRpbmciLCJhY3RpdmUiLCJzY29wZSIsInVwZGF0ZSIsInVucmVnaXN0ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWR5IiwiY29udHJvbGxlciIsImdldFJlZ2lzdHJhdGlvbiIsImdldFJlZ2lzdHJhdGlvbnMiLCJEYXRhUHJvY2Vzc2luZ1dvcmtlciIsImNvbnN0cnVjdG9yIiwid29ya2VyU2NyaXB0IiwicGVuZGluZ1Rhc2tzIiwiTWFwIiwid29ya2VyIiwiaGFuZGxlTWVzc2FnZSIsImJpbmQiLCJoYW5kbGVFcnJvciIsImV2ZW50IiwiaWQiLCJyZXN1bHQiLCJwcm9jZXNzaW5nVGltZSIsImVycm9yIiwiZGF0YSIsInRhc2siLCJnZXQiLCJyZWplY3QiLCJFcnJvciIsImRlbGV0ZSIsImNvbnNvbGUiLCJmb3JFYWNoIiwiY2xlYXIiLCJwcm9jZXNzRGF0YSIsInRhc2tJZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJzZXQiLCJzZXRUaW1lb3V0IiwiaGFzIiwiZmlsdGVyRGF0YSIsInByZWRpY2F0ZSIsIm9wdGlvbnMiLCJ0eXBlIiwibWFwRGF0YSIsIm1hcHBlciIsInJlZHVjZURhdGEiLCJyZWR1Y2VyIiwiaW5pdGlhbFZhbHVlIiwic29ydERhdGEiLCJjb21wYXJlRm4iLCJhZ2dyZWdhdGVEYXRhIiwiYWdncmVnYXRpb25zIiwiZ2V0UXVldWVTaXplIiwic2l6ZSIsIkltYWdlUHJvY2Vzc2luZ1dvcmtlciIsInByb2Nlc3NJbWFnZSIsInJlc2l6ZUltYWdlIiwiaW1hZ2VEYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJhcHBseUZpbHRlciIsImZpbHRlclR5cGUiLCJpbnRlbnNpdHkiLCJjcm9wSW1hZ2UiLCJ4IiwieSIsInJvdGF0ZUltYWdlIiwiYW5nbGUiLCJhZGp1c3RCcmlnaHRuZXNzIiwiYnJpZ2h0bmVzcyIsImFkanVzdENvbnRyYXN0IiwiY29udHJhc3QiLCJDcm9zc1RhYkNvbW11bmljYXRvciIsIm1lc3NhZ2VIYW5kbGVycyIsInRhYklkIiwic2hhcmVkV29ya2VyIiwiaGFuZGxlTWVzc2FnZUVycm9yIiwic2VuZE1lc3NhZ2UiLCJhY3Rpb24iLCJ0aW1lc3RhbXAiLCJoYW5kbGVyIiwiZ2VuZXJhbEhhbmRsZXIiLCJtZXNzYWdlIiwiYnJvYWRjYXN0Iiwic3luYyIsInJlcXVlc3QiLCJyZXF1ZXN0SWQiLCJyZXNwb25zZUhhbmRsZXIiLCJyZXNwb25zZURhdGEiLCJvZmYiLCJvbiIsInJlc3BvbmQiLCJtZXNzYWdlVHlwZSIsImN1cnJlbnRIYW5kbGVyIiwiZGlzY29ubmVjdCIsIlNlcnZpY2VXb3JrZXJNYW5hZ2VyIiwic2NyaXB0VXJsIiwicmVnaXN0cmF0aW9uIiwiaXNSZWdpc3RlcmVkIiwiaGFuZGxlVXBkYXRlRm91bmQiLCJuZXdXb3JrZXIiLCJsb2ciLCJjb25maWd1cmVDYWNoZSIsImNvbmZpZ3MiLCJjbGVhckNhY2hlIiwiY2FjaGVOYW1lIiwiZ2V0Q2FjaGVTdGF0cyIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpc1NlcnZpY2VXb3JrZXJSZWdpc3RlcmVkIiwiQmFja2dyb3VuZFN5bmNNYW5hZ2VyIiwic2VydmljZVdvcmtlck1hbmFnZXIiLCJ0YXNrcyIsInNjaGVkdWxlU3luYyIsInJldHJ5Q291bnQiLCJtYXhSZXRyaWVzIiwiY3JlYXRlZEF0IiwiY2FuY2VsU3luYyIsInJldHJ5RmFpbGVkVGFza3MiLCJmYWlsZWRUYXNrcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImZpbHRlciIsImdldFBlbmRpbmdUYXNrcyIsImdldFRhc2tTdGF0dXMiLCJjbGVhckNvbXBsZXRlZFRhc2tzIiwiY29tcGxldGVkVGFza3MiLCJlbnRyaWVzIiwiXyIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImFmdGVyRWFjaCIsInRlc3QiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInRvQmUiLCJ0ZXN0RGF0YSIsIm1vY2tXb3JrZXIiLCJtb2NrIiwicmVzdWx0cyIsInZhbHVlIiwidG9FcXVhbCIsInJlamVjdHMiLCJ0b1Rocm93IiwiYW55IiwiU3RyaW5nIiwiY2F0ZWdvcnkiLCJBIiwiQiIsInN1bSIsImNhdGNoIiwibW9ja0ltYWdlRGF0YSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiY29sb3JTcGFjZSIsInRvQmVEZWZpbmVkIiwiY29tbXVuaWNhdG9yIiwibW9ja1BvcnQiLCJvYmplY3RDb250YWluaW5nIiwiTnVtYmVyIiwic3luY0RhdGEiLCJyZXF1ZXN0RGF0YSIsInF1ZXJ5IiwidXNlciIsIm5hbWUiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibWFuYWdlciIsIm1heEFnZSIsIm1heEVudHJpZXMiLCJzdHJhdGVneSIsIm9yaWdpbmFsU2VydmljZVdvcmtlciIsInVuc3VwcG9ydGVkTWFuYWdlciIsInN5bmNNYW5hZ2VyIiwidGFza0RhdGEiLCJmaWxlSWQiLCJ0b0hhdmVMZW5ndGgiLCJjYW5jZWxsZWQiLCJzdGF0dXMiLCJ0b0JlVW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozt5QkFFb0I7QUFFckIsa0JBQWtCO0FBQ2xCQSxPQUFPQyxNQUFNLEdBQUdDLGFBQUksQ0FBQ0MsRUFBRSxDQUFDLElBQU8sQ0FBQTtRQUM3QkMsYUFBYUYsYUFBSSxDQUFDQyxFQUFFO1FBQ3BCRSxXQUFXSCxhQUFJLENBQUNDLEVBQUU7UUFDbEJHLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxnQkFBZ0I7SUFDbEIsQ0FBQTtBQUVBLHdCQUF3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