{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/hooks/use-provider-monitoring.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport {\n  ProviderMonitoringData,\n  UsageMetrics,\n  HealthStatus,\n} from \"@/components/ui/provider-monitoring-dashboard\";\nimport {\n  ProviderMonitoringService,\n  AlertEvent,\n  MonitoringConfig,\n} from \"@/lib/services/provider-monitoring-service\";\n\nexport interface UseProviderMonitoringOptions {\n  autoStart?: boolean;\n  refreshInterval?: number;\n  enableAlerts?: boolean;\n  initialProviders?: ProviderMonitoringData[];\n  config?: Partial<MonitoringConfig>;\n}\n\nexport interface UseProviderMonitoringReturn {\n  // Data\n  providers: ProviderMonitoringData[];\n  alerts: AlertEvent[];\n  isMonitoring: boolean;\n  loading: boolean;\n  error: string | null;\n\n  // Controls\n  start: () => Promise<void>;\n  stop: () => void;\n  refresh: () => Promise<void>;\n\n  // Provider management\n  updateProvider: (\n    id: string,\n    updates: Partial<ProviderMonitoringData>,\n  ) => void;\n  recordRequest: (\n    providerId: string,\n    success: boolean,\n    inputTokens: number,\n    outputTokens: number,\n    latency: number,\n    cost: number,\n    errorType?: string,\n  ) => void;\n\n  // Health checks\n  performHealthCheck: (providerId?: string) => Promise<void>;\n\n  // Alerts\n  acknowledgeAlert: (alertId: string) => void;\n  getActiveAlerts: () => AlertEvent[];\n\n  // Statistics\n  getStats: () => {\n    totalProviders: number;\n    healthyProviders: number;\n    enabledProviders: number;\n    totalRequests: number;\n    totalCost: number;\n    averageLatency: number;\n    successRate: number;\n    activeAlerts: number;\n  };\n\n  // Export\n  exportData: (timeRange?: { start: Date; end: Date }) => any;\n}\n\n/**\n * Hook for real-time provider monitoring\n */\nexport function useProviderMonitoring(\n  options: UseProviderMonitoringOptions = {},\n): UseProviderMonitoringReturn {\n  const {\n    autoStart = true,\n    refreshInterval = 30000,\n    enableAlerts = true,\n    initialProviders = [],\n    config,\n  } = options;\n\n  const [providers, setProviders] =\n    useState<ProviderMonitoringData[]>(initialProviders);\n  const [alerts, setAlerts] = useState<AlertEvent[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const monitoringService = useRef<ProviderMonitoringService>();\n  const unsubscribeProviders = useRef<(() => void) | null>(null);\n  const unsubscribeAlerts = useRef<(() => void) | null>(null);\n\n  // Initialize monitoring service\n  useEffect(() => {\n    monitoringService.current = ProviderMonitoringService.getInstance();\n\n    // Subscribe to provider updates\n    unsubscribeProviders.current = monitoringService.current.subscribe(\n      (data) => {\n        setProviders(data);\n      },\n    );\n\n    // Subscribe to alerts if enabled\n    if (enableAlerts) {\n      unsubscribeAlerts.current = monitoringService.current.subscribeToAlerts(\n        (alert) => {\n          setAlerts((prev) => [alert, ...prev].slice(0, 50)); // Keep last 50 alerts\n        },\n      );\n    }\n\n    return () => {\n      unsubscribeProviders.current?.();\n      unsubscribeAlerts.current?.();\n    };\n  }, [enableAlerts]);\n\n  // Fetch initial provider data\n  const fetchProviderData = useCallback(async (): Promise<\n    ProviderMonitoringData[]\n  > => {\n    try {\n      const response = await fetch(\"/api/llm/providers\");\n      if (!response.ok) {\n        throw new Error(`Failed to fetch providers: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      if (!data.success) {\n        throw new Error(data.error || \"Failed to fetch providers\");\n      }\n\n      // Transform API data to monitoring format\n      return data.providers.map((provider: any) => ({\n        id: provider.id,\n        name: provider.name,\n        type: provider.type,\n        enabled: provider.enabled,\n        usage: {\n          totalRequests: provider.usage.totalRequests || 0,\n          successfulRequests: provider.usage.successfulRequests || 0,\n          failedRequests: provider.usage.failedRequests || 0,\n          totalInputTokens: provider.usage.totalInputTokens || 0,\n          totalOutputTokens: provider.usage.totalOutputTokens || 0,\n          totalCost: provider.usage.totalCost || 0,\n          averageLatency: provider.usage.averageLatency || 0,\n          requestsPerMinute: 0,\n          costPerHour: 0,\n          errorRate: 0,\n          lastUpdated: new Date(),\n        },\n        health: {\n          isHealthy: provider.status.isHealthy || false,\n          status: provider.status.isHealthy ? \"healthy\" : \"unhealthy\",\n          responseTime: provider.status.responseTimeMs || 0,\n          uptime: 100,\n          lastCheck: new Date(),\n          errorCount: provider.status.errorCount || 0,\n          consecutiveFailures: 0,\n        },\n        rateLimits: {\n          requestsPerMinute: provider.configuration.maxRequestsPerMinute || 60,\n          requestsRemaining: provider.configuration.maxRequestsPerMinute || 60,\n          tokensPerMinute: 100000,\n          tokensRemaining: 100000,\n        },\n        trends: {\n          requestsHistory: [],\n          latencyHistory: [],\n          costHistory: [],\n          errorHistory: [],\n        },\n      }));\n    } catch (err) {\n      console.error(\"[USE-MONITORING] Failed to fetch provider data:\", err);\n      throw err;\n    }\n  }, []);\n\n  // Start monitoring\n  const start = useCallback(async () => {\n    if (isMonitoring) return;\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      let providersToMonitor = providers;\n\n      // If no providers in state, fetch from API\n      if (providersToMonitor.length === 0) {\n        providersToMonitor = await fetchProviderData();\n        setProviders(providersToMonitor);\n      }\n\n      // Initialize monitoring service\n      await monitoringService.current?.initialize(providersToMonitor, config);\n      setIsMonitoring(true);\n\n      console.log(\n        \"[USE-MONITORING] Started monitoring for\",\n        providersToMonitor.length,\n        \"providers\",\n      );\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to start monitoring\";\n      setError(errorMessage);\n      console.error(\"[USE-MONITORING] Failed to start:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, [isMonitoring, providers, fetchProviderData, config]);\n\n  // Auto-start monitoring\n  useEffect(() => {\n    if (autoStart && initialProviders.length > 0) {\n      start();\n    }\n  }, [autoStart, initialProviders.length, start]);\n\n  // Stop monitoring\n  const stop = useCallback(() => {\n    monitoringService.current?.stop();\n    setIsMonitoring(false);\n    console.log(\"[USE-MONITORING] Stopped monitoring\");\n  }, []);\n\n  // Refresh data\n  const refresh = useCallback(async () => {\n    if (!isMonitoring) return;\n\n    setLoading(true);\n    try {\n      const freshData = await fetchProviderData();\n      setProviders(freshData);\n\n      // Update monitoring service with fresh data\n      for (const provider of freshData) {\n        monitoringService.current?.updateProvider(\n          provider.providerId,\n          provider,\n        );\n      }\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to refresh data\";\n      setError(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  }, [isMonitoring, fetchProviderData]);\n\n  // Update provider\n  const updateProvider = useCallback(\n    (id: string, updates: Partial<ProviderMonitoringData>) => {\n      monitoringService.current?.updateProvider(id, updates);\n    },\n    [],\n  );\n\n  // Record request\n  const recordRequest = useCallback(\n    (\n      providerId: string,\n      success: boolean,\n      inputTokens: number,\n      outputTokens: number,\n      latency: number,\n      cost: number,\n      errorType?: string,\n    ) => {\n      monitoringService.current?.recordRequest(\n        providerId,\n        success,\n        inputTokens,\n        outputTokens,\n        latency,\n        cost,\n        errorType,\n      );\n    },\n    [],\n  );\n\n  // Perform health check\n  const performHealthCheck = useCallback(\n    async (providerId?: string) => {\n      try {\n        const payload = providerId\n          ? { providerId }\n          : { providerIds: providers.map((p) => p.providerId) };\n\n        const response = await fetch(\"/api/llm/health-check\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify(payload),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Health check failed: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n\n        if (data.success && data.results) {\n          // Update provider health status\n          Object.entries(data.results).forEach(\n            ([id, result]: [string, any]) => {\n              const healthUpdate: Partial<ProviderMonitoringData> = {\n                health: {\n                  status: result.isHealthy ? \"healthy\" : \"unhealthy\",\n                  lastCheck: new Date(result.timestamp),\n                  uptime: result.isHealthy ? 99.9 : 0,\n                  incidents: [],\n                },\n              };\n              monitoringService.current?.updateProvider(id, healthUpdate);\n            },\n          );\n        }\n      } catch (err) {\n        console.error(\"[USE-MONITORING] Health check failed:\", err);\n        setError(err instanceof Error ? err.message : \"Health check failed\");\n      }\n    },\n    [providers],\n  );\n\n  // Acknowledge alert\n  const acknowledgeAlert = useCallback((alertId: string) => {\n    monitoringService.current?.acknowledgeAlert(alertId);\n    setAlerts((prev) =>\n      prev.map((alert) =>\n        alert.id === alertId ? { ...alert, acknowledged: true } : alert,\n      ),\n    );\n  }, []);\n\n  // Get active alerts\n  const getActiveAlerts = useCallback((): AlertEvent[] => {\n    return alerts.filter((alert) => !alert.acknowledged);\n  }, [alerts]);\n\n  // Get statistics\n  const getStats = useCallback(() => {\n    const totalProviders = providers.length;\n    const healthyProviders = providers.filter(\n      (p) => p.health.status === \"healthy\",\n    ).length;\n    const enabledProviders = providers.length; // All monitored providers are considered enabled\n    const totalRequests = providers.reduce(\n      (sum, p) => sum + p.metrics.requestCount,\n      0,\n    );\n    const successfulRequests = providers.reduce(\n      (sum, p) => sum + (p.metrics.requestCount * p.metrics.successRate) / 100,\n      0,\n    );\n    const totalCost = providers.reduce(\n      (sum, p) => sum + p.metrics.costEstimate,\n      0,\n    );\n    const totalLatency = providers.reduce(\n      (sum, p) => sum + p.metrics.averageLatency,\n      0,\n    );\n    const averageLatency =\n      totalProviders > 0 ? totalLatency / totalProviders : 0;\n    const successRate =\n      totalRequests > 0 ? (successfulRequests / totalRequests) * 100 : 0;\n    const activeAlerts = getActiveAlerts().length;\n\n    return {\n      totalProviders,\n      healthyProviders,\n      enabledProviders,\n      totalRequests,\n      totalCost,\n      averageLatency,\n      successRate,\n      activeAlerts,\n    };\n  }, [providers, getActiveAlerts]);\n\n  // Export data\n  const exportData = useCallback((timeRange?: { start: Date; end: Date }) => {\n    return monitoringService.current?.exportData(timeRange);\n  }, []);\n\n  // Get alerts from monitoring service on load\n  useEffect(() => {\n    if (isMonitoring && enableAlerts) {\n      const serviceAlerts = monitoringService.current?.getAlerts() || [];\n      setAlerts(serviceAlerts);\n    }\n  }, [isMonitoring, enableAlerts]);\n\n  return {\n    providers,\n    alerts,\n    isMonitoring,\n    loading,\n    error,\n    start,\n    stop,\n    refresh,\n    updateProvider,\n    recordRequest,\n    performHealthCheck,\n    acknowledgeAlert,\n    getActiveAlerts,\n    getStats,\n    exportData,\n  };\n}\n\n/**\n * Hook for monitoring a specific provider\n */\nexport function useProviderMonitoringById(providerId: string) {\n  const monitoring = useProviderMonitoring();\n\n  const provider = monitoring.providers.find(\n    (p) => p.providerId === providerId,\n  );\n  const providerAlerts = monitoring.alerts.filter(\n    (a) => a.providerId === providerId,\n  );\n\n  const updateProvider = useCallback(\n    (updates: Partial<ProviderMonitoringData>) => {\n      monitoring.updateProvider(providerId, updates);\n    },\n    [monitoring, providerId],\n  );\n\n  const performHealthCheck = useCallback(async () => {\n    await monitoring.performHealthCheck(providerId);\n  }, [monitoring, providerId]);\n\n  const recordRequest = useCallback(\n    (\n      success: boolean,\n      inputTokens: number,\n      outputTokens: number,\n      latency: number,\n      cost: number,\n      errorType?: string,\n    ) => {\n      monitoring.recordRequest(\n        providerId,\n        success,\n        inputTokens,\n        outputTokens,\n        latency,\n        cost,\n        errorType,\n      );\n    },\n    [monitoring, providerId],\n  );\n\n  return {\n    provider,\n    alerts: providerAlerts,\n    isMonitoring: monitoring.isMonitoring,\n    loading: monitoring.loading,\n    error: monitoring.error,\n    updateProvider,\n    performHealthCheck,\n    recordRequest,\n  };\n}\n"],"names":["useProviderMonitoring","useProviderMonitoringById","options","autoStart","refreshInterval","enableAlerts","initialProviders","config","providers","setProviders","useState","alerts","setAlerts","isMonitoring","setIsMonitoring","loading","setLoading","error","setError","monitoringService","useRef","unsubscribeProviders","unsubscribeAlerts","useEffect","current","ProviderMonitoringService","getInstance","subscribe","data","subscribeToAlerts","alert","prev","slice","fetchProviderData","useCallback","response","fetch","ok","Error","statusText","json","success","map","provider","id","name","type","enabled","usage","totalRequests","successfulRequests","failedRequests","totalInputTokens","totalOutputTokens","totalCost","averageLatency","requestsPerMinute","costPerHour","errorRate","lastUpdated","Date","health","isHealthy","status","responseTime","responseTimeMs","uptime","lastCheck","errorCount","consecutiveFailures","rateLimits","configuration","maxRequestsPerMinute","requestsRemaining","tokensPerMinute","tokensRemaining","trends","requestsHistory","latencyHistory","costHistory","errorHistory","err","console","start","providersToMonitor","length","initialize","log","errorMessage","message","stop","refresh","freshData","updateProvider","providerId","updates","recordRequest","inputTokens","outputTokens","latency","cost","errorType","performHealthCheck","payload","providerIds","p","method","headers","body","JSON","stringify","results","Object","entries","forEach","result","healthUpdate","timestamp","incidents","acknowledgeAlert","alertId","acknowledged","getActiveAlerts","filter","getStats","totalProviders","healthyProviders","enabledProviders","reduce","sum","metrics","requestCount","successRate","costEstimate","totalLatency","activeAlerts","exportData","timeRange","serviceAlerts","getAlerts","monitoring","find","providerAlerts","a"],"mappings":"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"}