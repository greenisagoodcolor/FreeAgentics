d1e1d64aa704e901cbb07311edae6ff1
/**
 * Markov Blanket Implementation
 *
 * Core implementation for Markov blanket calculations and state management
 * supporting active inference and free energy minimization.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    calculateFreeEnergy: function() {
        return calculateFreeEnergy;
    },
    createMarkovBlanket: function() {
        return createMarkovBlanket;
    },
    getMarkovBlanketNeighbors: function() {
        return getMarkovBlanketNeighbors;
    },
    mergeMarkovBlankets: function() {
        return mergeMarkovBlankets;
    },
    minimizeFreeEnergy: function() {
        return minimizeFreeEnergy;
    },
    updateMarkovBlanket: function() {
        return updateMarkovBlanket;
    },
    validateMarkovBlanket: function() {
        return validateMarkovBlanket;
    }
});
const DEFAULT_CONFIG = {
    learningRate: 0.01,
    precision: 0.001,
    maxIterations: 100,
    convergenceThreshold: 0.0001
};
// Cache for free energy calculations
const freeEnergyCache = new WeakMap();
const CACHE_DURATION = 100; // ms
function createMarkovBlanket(options) {
    if (!options.id || !options.agentId) {
        throw new Error("Invalid Markov blanket configuration");
    }
    const blanket = {
        id: options.id,
        agentId: options.agentId,
        sensorStates: options.sensorStates || {},
        activeStates: options.activeStates || {},
        internalStates: options.internalStates || {},
        externalStates: options.externalStates || {},
        config: {
            ...DEFAULT_CONFIG,
            ...options.config
        },
        lastUpdated: Date.now()
    };
    // Calculate initial free energy
    blanket.freeEnergy = calculateFreeEnergy(blanket);
    return blanket;
}
function updateMarkovBlanket(blanket, updates) {
    const updated = {
        ...blanket,
        lastUpdated: Date.now()
    };
    // Update sensor states
    if (updates.sensorStates) {
        updated.sensorStates = {
            ...updates.sensorStates
        };
    }
    // Update active states with energy constraints
    if (updates.activeStates) {
        updated.activeStates = Object.entries(updates.activeStates).reduce((acc, [key, state])=>{
            acc[key] = {
                value: Math.min(Math.max(state.value, 0), 1),
                energy: Math.max(state.energy, 0)
            };
            return acc;
        }, {});
    }
    // Update internal states with normalization
    if (updates.internalStates) {
        updated.internalStates = Object.entries(updates.internalStates).reduce((acc, [key, value])=>{
            acc[key] = Math.min(Math.max(value, 0), 1);
            return acc;
        }, {});
    }
    // Update external states
    if (updates.externalStates) {
        updated.externalStates = {
            ...updates.externalStates
        };
    }
    // Recalculate free energy
    updated.freeEnergy = calculateFreeEnergy(updated);
    return updated;
}
function calculateFreeEnergy(blanket) {
    // Check cache first
    const cached = freeEnergyCache.get(blanket);
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
        return cached.value;
    }
    let freeEnergy = 0;
    // Prediction error component
    Object.entries(blanket.sensorStates).forEach(([sensorKey, sensor])=>{
        const beliefKey = `belief_${sensorKey}`;
        const belief = blanket.internalStates[beliefKey] || 0.5;
        const predictionError = Math.pow(sensor.value - belief, 2);
        freeEnergy += predictionError * sensor.confidence;
    });
    // Entropy component
    Object.values(blanket.internalStates).forEach((value)=>{
        if (value > 0 && value < 1) {
            const entropy = -value * Math.log(value) - (1 - value) * Math.log(1 - value);
            freeEnergy += entropy * 0.1; // Weight the entropy contribution
        }
    });
    // Complexity component (deviation from priors)
    Object.entries(blanket.internalStates).forEach(([key, value])=>{
        const prior = 0.5; // Assume uniform prior
        const complexity = Math.pow(value - prior, 2);
        freeEnergy += complexity * 0.05;
    });
    // Energy constraints
    Object.values(blanket.activeStates).forEach((state)=>{
        if (state.value > 0) {
            const energyCost = state.value * (1 - state.energy);
            freeEnergy += energyCost * 0.2;
        }
    });
    // Cache the result
    freeEnergyCache.set(blanket, {
        value: freeEnergy,
        timestamp: Date.now()
    });
    return freeEnergy;
}
async function minimizeFreeEnergy(blanket, options) {
    const config = {
        ...blanket.config,
        ...options
    };
    let current = {
        ...blanket
    };
    let iterations = 0;
    let converged = false;
    let previousFE = calculateFreeEnergy(current);
    while(iterations < config.maxIterations && !converged){
        const gradient = {};
        // Calculate gradient for each internal state
        Object.keys(current.internalStates).forEach((key)=>{
            const epsilon = 0.001;
            const original = current.internalStates[key];
            // Forward difference
            current.internalStates[key] = Math.min(original + epsilon, 1);
            const feForward = calculateFreeEnergy(current);
            // Backward difference
            current.internalStates[key] = Math.max(original - epsilon, 0);
            const feBackward = calculateFreeEnergy(current);
            // Calculate gradient
            gradient[key] = (feForward - feBackward) / (2 * epsilon);
            // Restore original value
            current.internalStates[key] = original;
        });
        // Update internal states based on gradient
        Object.keys(gradient).forEach((key)=>{
            const update = -gradient[key] * config.learningRate;
            current.internalStates[key] = Math.min(Math.max(current.internalStates[key] + update, 0), 1);
        });
        // Check convergence
        const currentFE = calculateFreeEnergy(current);
        const improvement = previousFE - currentFE;
        if (Math.abs(improvement) < config.convergenceThreshold) {
            converged = true;
        }
        previousFE = currentFE;
        iterations++;
    }
    return {
        ...current,
        freeEnergy: previousFE,
        convergenceInfo: {
            iterations,
            converged,
            finalError: previousFE
        }
    };
}
function getMarkovBlanketNeighbors(blanket, allBlankets, options) {
    const opts = {
        proximityThreshold: 0.5,
        considerCommunication: false,
        considerSharedBeliefs: false,
        ...options
    };
    return allBlankets.filter((other)=>{
        if (other.id === blanket.id) return false;
        // Check proximity
        const proximityKey = `proximity_to_${blanket.agentId}`;
        const proximity = other.externalStates[proximityKey] || 0;
        if (proximity < opts.proximityThreshold) return false;
        // Additional checks if enabled
        if (opts.considerCommunication) {
            const communication = other.activeStates.communication?.value || 0;
            if (communication < 0.3) return false;
        }
        if (opts.considerSharedBeliefs) {
            // Check for similar beliefs
            const beliefSimilarity = Object.keys(blanket.internalStates).filter((key)=>key.startsWith("belief_")).reduce((sim, key)=>{
                const diff = Math.abs(blanket.internalStates[key] - (other.internalStates[key] || 0.5));
                return sim + (1 - diff);
            }, 0);
            if (beliefSimilarity < 1) return false;
        }
        return true;
    });
}
function mergeMarkovBlankets(blankets) {
    if (blankets.length === 0) {
        throw new Error("Cannot merge empty array of Markov blankets");
    }
    if (blankets.length === 1) {
        return blankets[0];
    }
    const merged = {
        id: `merged-${Date.now()}`,
        agentId: `coalition-${blankets.map((b)=>b.agentId).join("-")}`,
        sensorStates: {},
        activeStates: {},
        internalStates: {},
        externalStates: {},
        lastUpdated: Date.now()
    };
    // Merge sensor states (union)
    blankets.forEach((blanket)=>{
        Object.entries(blanket.sensorStates).forEach(([key, state])=>{
            if (!merged.sensorStates[key] || state.confidence > merged.sensorStates[key].confidence) {
                merged.sensorStates[key] = state;
            }
        });
    });
    // Merge active states (average)
    const activeStateKeys = new Set();
    blankets.forEach((blanket)=>{
        Object.keys(blanket.activeStates).forEach((key)=>activeStateKeys.add(key));
    });
    activeStateKeys.forEach((key)=>{
        const states = blankets.map((b)=>b.activeStates[key]).filter(Boolean);
        if (states.length > 0) {
            merged.activeStates[key] = {
                value: states.reduce((sum, s)=>sum + s.value, 0) / states.length,
                energy: states.reduce((sum, s)=>sum + s.energy, 0) / states.length
            };
        }
    });
    // Merge internal states (weighted average based on free energy)
    const weights = blankets.map((b)=>1 / (b.freeEnergy || 1));
    const totalWeight = weights.reduce((sum, w)=>sum + w, 0);
    const internalKeys = new Set();
    blankets.forEach((blanket)=>{
        Object.keys(blanket.internalStates).forEach((key)=>internalKeys.add(key));
    });
    internalKeys.forEach((key)=>{
        let weightedSum = 0;
        let weightSum = 0;
        blankets.forEach((blanket, i)=>{
            if (blanket.internalStates[key] !== undefined) {
                weightedSum += blanket.internalStates[key] * weights[i];
                weightSum += weights[i];
            }
        });
        if (weightSum > 0) {
            merged.internalStates[key] = weightedSum / weightSum;
        }
    });
    // Calculate free energy for merged blanket
    merged.freeEnergy = calculateFreeEnergy(merged);
    return merged;
}
function validateMarkovBlanket(blanket) {
    const errors = [];
    const warnings = [];
    // Check required fields
    if (!blanket.id) errors.push("Missing required field: id");
    if (!blanket.agentId) errors.push("Missing required field: agentId");
    if (!blanket.sensorStates) errors.push("Missing required field: sensorStates");
    if (!blanket.activeStates) errors.push("Missing required field: activeStates");
    if (!blanket.internalStates) errors.push("Missing required field: internalStates");
    if (!blanket.externalStates) errors.push("Missing required field: externalStates");
    // Validate state ranges
    if (blanket.internalStates) {
        Object.entries(blanket.internalStates).forEach(([key, value])=>{
            if (value < 0 || value > 1) {
                errors.push(`Internal state '${key}' out of range: ${value}`);
            }
        });
    }
    if (blanket.activeStates) {
        Object.entries(blanket.activeStates).forEach(([key, state])=>{
            if (state.value < 0 || state.value > 1) {
                errors.push(`Active state '${key}' value out of range: ${state.value}`);
            }
            if (state.energy < 0) {
                errors.push(`Active state '${key}' energy cannot be negative: ${state.energy}`);
            }
        });
        // Check energy conservation
        const totalActiveValue = Object.values(blanket.activeStates).reduce((sum, state)=>sum + state.value, 0);
        const totalEnergy = Object.values(blanket.activeStates).reduce((sum, state)=>sum + state.energy, 0);
        if (totalActiveValue > 1 && totalEnergy < 0.1) {
            warnings.push("Energy conservation warning: High activity with low energy");
        }
    }
    if (blanket.sensorStates) {
        Object.entries(blanket.sensorStates).forEach(([key, state])=>{
            if (state.value < 0 || state.value > 1) {
                errors.push(`Sensor state '${key}' value out of range: ${state.value}`);
            }
            if (state.confidence < 0 || state.confidence > 1) {
                errors.push(`Sensor state '${key}' confidence out of range: ${state.confidence}`);
            }
        });
    }
    return {
        isValid: errors.length === 0,
        errors,
        warnings
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvbWFya292LWJsYW5rZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYXJrb3YgQmxhbmtldCBJbXBsZW1lbnRhdGlvblxuICpcbiAqIENvcmUgaW1wbGVtZW50YXRpb24gZm9yIE1hcmtvdiBibGFua2V0IGNhbGN1bGF0aW9ucyBhbmQgc3RhdGUgbWFuYWdlbWVudFxuICogc3VwcG9ydGluZyBhY3RpdmUgaW5mZXJlbmNlIGFuZCBmcmVlIGVuZXJneSBtaW5pbWl6YXRpb24uXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBTZW5zb3JTdGF0ZSB7XG4gIHZhbHVlOiBudW1iZXI7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBY3RpdmVTdGF0ZSB7XG4gIHZhbHVlOiBudW1iZXI7XG4gIGVuZXJneTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsU3RhdGUge1xuICBba2V5OiBzdHJpbmddOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZXJuYWxTdGF0ZSB7XG4gIFtrZXk6IHN0cmluZ106IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXJrb3ZCbGFua2V0Q29uZmlnIHtcbiAgbGVhcm5pbmdSYXRlPzogbnVtYmVyO1xuICBwcmVjaXNpb24/OiBudW1iZXI7XG4gIG1heEl0ZXJhdGlvbnM/OiBudW1iZXI7XG4gIGNvbnZlcmdlbmNlVGhyZXNob2xkPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtvdkJsYW5rZXRTdGF0ZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGFnZW50SWQ6IHN0cmluZztcbiAgc2Vuc29yU3RhdGVzOiBSZWNvcmQ8c3RyaW5nLCBTZW5zb3JTdGF0ZT47XG4gIGFjdGl2ZVN0YXRlczogUmVjb3JkPHN0cmluZywgQWN0aXZlU3RhdGU+O1xuICBpbnRlcm5hbFN0YXRlczogSW50ZXJuYWxTdGF0ZTtcbiAgZXh0ZXJuYWxTdGF0ZXM6IEV4dGVybmFsU3RhdGU7XG4gIGNvbmZpZz86IE1hcmtvdkJsYW5rZXRDb25maWc7XG4gIGZyZWVFbmVyZ3k/OiBudW1iZXI7XG4gIGxhc3RVcGRhdGVkPzogbnVtYmVyO1xuICBjb252ZXJnZW5jZUluZm8/OiB7XG4gICAgaXRlcmF0aW9uczogbnVtYmVyO1xuICAgIGNvbnZlcmdlZDogYm9vbGVhbjtcbiAgICBmaW5hbEVycm9yOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCB0eXBlIE1hcmtvdkJsYW5rZXQgPSBNYXJrb3ZCbGFua2V0U3RhdGU7XG5cbmNvbnN0IERFRkFVTFRfQ09ORklHOiBNYXJrb3ZCbGFua2V0Q29uZmlnID0ge1xuICBsZWFybmluZ1JhdGU6IDAuMDEsXG4gIHByZWNpc2lvbjogMC4wMDEsXG4gIG1heEl0ZXJhdGlvbnM6IDEwMCxcbiAgY29udmVyZ2VuY2VUaHJlc2hvbGQ6IDAuMDAwMSxcbn07XG5cbi8vIENhY2hlIGZvciBmcmVlIGVuZXJneSBjYWxjdWxhdGlvbnNcbmNvbnN0IGZyZWVFbmVyZ3lDYWNoZSA9IG5ldyBXZWFrTWFwPFxuICBNYXJrb3ZCbGFua2V0LFxuICB7IHZhbHVlOiBudW1iZXI7IHRpbWVzdGFtcDogbnVtYmVyIH1cbj4oKTtcbmNvbnN0IENBQ0hFX0RVUkFUSU9OID0gMTAwOyAvLyBtc1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFya292QmxhbmtldChcbiAgb3B0aW9uczogUGFydGlhbDxNYXJrb3ZCbGFua2V0U3RhdGU+ICYgeyBpZDogc3RyaW5nOyBhZ2VudElkOiBzdHJpbmcgfSxcbik6IE1hcmtvdkJsYW5rZXQge1xuICBpZiAoIW9wdGlvbnMuaWQgfHwgIW9wdGlvbnMuYWdlbnRJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTWFya292IGJsYW5rZXQgY29uZmlndXJhdGlvblwiKTtcbiAgfVxuXG4gIGNvbnN0IGJsYW5rZXQ6IE1hcmtvdkJsYW5rZXQgPSB7XG4gICAgaWQ6IG9wdGlvbnMuaWQsXG4gICAgYWdlbnRJZDogb3B0aW9ucy5hZ2VudElkLFxuICAgIHNlbnNvclN0YXRlczogb3B0aW9ucy5zZW5zb3JTdGF0ZXMgfHwge30sXG4gICAgYWN0aXZlU3RhdGVzOiBvcHRpb25zLmFjdGl2ZVN0YXRlcyB8fCB7fSxcbiAgICBpbnRlcm5hbFN0YXRlczogb3B0aW9ucy5pbnRlcm5hbFN0YXRlcyB8fCB7fSxcbiAgICBleHRlcm5hbFN0YXRlczogb3B0aW9ucy5leHRlcm5hbFN0YXRlcyB8fCB7fSxcbiAgICBjb25maWc6IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLm9wdGlvbnMuY29uZmlnIH0sXG4gICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXG4gIH07XG5cbiAgLy8gQ2FsY3VsYXRlIGluaXRpYWwgZnJlZSBlbmVyZ3lcbiAgYmxhbmtldC5mcmVlRW5lcmd5ID0gY2FsY3VsYXRlRnJlZUVuZXJneShibGFua2V0KTtcblxuICByZXR1cm4gYmxhbmtldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU1hcmtvdkJsYW5rZXQoXG4gIGJsYW5rZXQ6IE1hcmtvdkJsYW5rZXQsXG4gIHVwZGF0ZXM6IFBhcnRpYWw8XG4gICAgUGljazxcbiAgICAgIE1hcmtvdkJsYW5rZXQsXG4gICAgICBcInNlbnNvclN0YXRlc1wiIHwgXCJhY3RpdmVTdGF0ZXNcIiB8IFwiaW50ZXJuYWxTdGF0ZXNcIiB8IFwiZXh0ZXJuYWxTdGF0ZXNcIlxuICAgID5cbiAgPixcbik6IE1hcmtvdkJsYW5rZXQge1xuICBjb25zdCB1cGRhdGVkOiBNYXJrb3ZCbGFua2V0ID0ge1xuICAgIC4uLmJsYW5rZXQsXG4gICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXG4gIH07XG5cbiAgLy8gVXBkYXRlIHNlbnNvciBzdGF0ZXNcbiAgaWYgKHVwZGF0ZXMuc2Vuc29yU3RhdGVzKSB7XG4gICAgdXBkYXRlZC5zZW5zb3JTdGF0ZXMgPSB7IC4uLnVwZGF0ZXMuc2Vuc29yU3RhdGVzIH07XG4gIH1cblxuICAvLyBVcGRhdGUgYWN0aXZlIHN0YXRlcyB3aXRoIGVuZXJneSBjb25zdHJhaW50c1xuICBpZiAodXBkYXRlcy5hY3RpdmVTdGF0ZXMpIHtcbiAgICB1cGRhdGVkLmFjdGl2ZVN0YXRlcyA9IE9iamVjdC5lbnRyaWVzKHVwZGF0ZXMuYWN0aXZlU3RhdGVzKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBba2V5LCBzdGF0ZV0pID0+IHtcbiAgICAgICAgYWNjW2tleV0gPSB7XG4gICAgICAgICAgdmFsdWU6IE1hdGgubWluKE1hdGgubWF4KHN0YXRlLnZhbHVlLCAwKSwgMSksXG4gICAgICAgICAgZW5lcmd5OiBNYXRoLm1heChzdGF0ZS5lbmVyZ3ksIDApLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIEFjdGl2ZVN0YXRlPixcbiAgICApO1xuICB9XG5cbiAgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlcyB3aXRoIG5vcm1hbGl6YXRpb25cbiAgaWYgKHVwZGF0ZXMuaW50ZXJuYWxTdGF0ZXMpIHtcbiAgICB1cGRhdGVkLmludGVybmFsU3RhdGVzID0gT2JqZWN0LmVudHJpZXModXBkYXRlcy5pbnRlcm5hbFN0YXRlcykucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGFjY1trZXldID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyBJbnRlcm5hbFN0YXRlLFxuICAgICk7XG4gIH1cblxuICAvLyBVcGRhdGUgZXh0ZXJuYWwgc3RhdGVzXG4gIGlmICh1cGRhdGVzLmV4dGVybmFsU3RhdGVzKSB7XG4gICAgdXBkYXRlZC5leHRlcm5hbFN0YXRlcyA9IHsgLi4udXBkYXRlcy5leHRlcm5hbFN0YXRlcyB9O1xuICB9XG5cbiAgLy8gUmVjYWxjdWxhdGUgZnJlZSBlbmVyZ3lcbiAgdXBkYXRlZC5mcmVlRW5lcmd5ID0gY2FsY3VsYXRlRnJlZUVuZXJneSh1cGRhdGVkKTtcblxuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUZyZWVFbmVyZ3koYmxhbmtldDogTWFya292QmxhbmtldCk6IG51bWJlciB7XG4gIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gIGNvbnN0IGNhY2hlZCA9IGZyZWVFbmVyZ3lDYWNoZS5nZXQoYmxhbmtldCk7XG4gIGlmIChjYWNoZWQgJiYgRGF0ZS5ub3coKSAtIGNhY2hlZC50aW1lc3RhbXAgPCBDQUNIRV9EVVJBVElPTikge1xuICAgIHJldHVybiBjYWNoZWQudmFsdWU7XG4gIH1cblxuICBsZXQgZnJlZUVuZXJneSA9IDA7XG5cbiAgLy8gUHJlZGljdGlvbiBlcnJvciBjb21wb25lbnRcbiAgT2JqZWN0LmVudHJpZXMoYmxhbmtldC5zZW5zb3JTdGF0ZXMpLmZvckVhY2goKFtzZW5zb3JLZXksIHNlbnNvcl0pID0+IHtcbiAgICBjb25zdCBiZWxpZWZLZXkgPSBgYmVsaWVmXyR7c2Vuc29yS2V5fWA7XG4gICAgY29uc3QgYmVsaWVmID0gYmxhbmtldC5pbnRlcm5hbFN0YXRlc1tiZWxpZWZLZXldIHx8IDAuNTtcbiAgICBjb25zdCBwcmVkaWN0aW9uRXJyb3IgPSBNYXRoLnBvdyhzZW5zb3IudmFsdWUgLSBiZWxpZWYsIDIpO1xuICAgIGZyZWVFbmVyZ3kgKz0gcHJlZGljdGlvbkVycm9yICogc2Vuc29yLmNvbmZpZGVuY2U7XG4gIH0pO1xuXG4gIC8vIEVudHJvcHkgY29tcG9uZW50XG4gIE9iamVjdC52YWx1ZXMoYmxhbmtldC5pbnRlcm5hbFN0YXRlcykuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPiAwICYmIHZhbHVlIDwgMSkge1xuICAgICAgY29uc3QgZW50cm9weSA9XG4gICAgICAgIC12YWx1ZSAqIE1hdGgubG9nKHZhbHVlKSAtICgxIC0gdmFsdWUpICogTWF0aC5sb2coMSAtIHZhbHVlKTtcbiAgICAgIGZyZWVFbmVyZ3kgKz0gZW50cm9weSAqIDAuMTsgLy8gV2VpZ2h0IHRoZSBlbnRyb3B5IGNvbnRyaWJ1dGlvblxuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29tcGxleGl0eSBjb21wb25lbnQgKGRldmlhdGlvbiBmcm9tIHByaW9ycylcbiAgT2JqZWN0LmVudHJpZXMoYmxhbmtldC5pbnRlcm5hbFN0YXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgcHJpb3IgPSAwLjU7IC8vIEFzc3VtZSB1bmlmb3JtIHByaW9yXG4gICAgY29uc3QgY29tcGxleGl0eSA9IE1hdGgucG93KHZhbHVlIC0gcHJpb3IsIDIpO1xuICAgIGZyZWVFbmVyZ3kgKz0gY29tcGxleGl0eSAqIDAuMDU7XG4gIH0pO1xuXG4gIC8vIEVuZXJneSBjb25zdHJhaW50c1xuICBPYmplY3QudmFsdWVzKGJsYW5rZXQuYWN0aXZlU3RhdGVzKS5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgIGlmIChzdGF0ZS52YWx1ZSA+IDApIHtcbiAgICAgIGNvbnN0IGVuZXJneUNvc3QgPSBzdGF0ZS52YWx1ZSAqICgxIC0gc3RhdGUuZW5lcmd5KTtcbiAgICAgIGZyZWVFbmVyZ3kgKz0gZW5lcmd5Q29zdCAqIDAuMjtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENhY2hlIHRoZSByZXN1bHRcbiAgZnJlZUVuZXJneUNhY2hlLnNldChibGFua2V0LCB7IHZhbHVlOiBmcmVlRW5lcmd5LCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XG5cbiAgcmV0dXJuIGZyZWVFbmVyZ3k7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtaW5pbWl6ZUZyZWVFbmVyZ3koXG4gIGJsYW5rZXQ6IE1hcmtvdkJsYW5rZXQsXG4gIG9wdGlvbnM/OiBQYXJ0aWFsPE1hcmtvdkJsYW5rZXRDb25maWc+LFxuKTogUHJvbWlzZTxNYXJrb3ZCbGFua2V0PiB7XG4gIGNvbnN0IGNvbmZpZyA9IHsgLi4uYmxhbmtldC5jb25maWcsIC4uLm9wdGlvbnMgfTtcbiAgbGV0IGN1cnJlbnQgPSB7IC4uLmJsYW5rZXQgfTtcbiAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICBsZXQgY29udmVyZ2VkID0gZmFsc2U7XG4gIGxldCBwcmV2aW91c0ZFID0gY2FsY3VsYXRlRnJlZUVuZXJneShjdXJyZW50KTtcblxuICB3aGlsZSAoaXRlcmF0aW9ucyA8IGNvbmZpZy5tYXhJdGVyYXRpb25zISAmJiAhY29udmVyZ2VkKSB7XG4gICAgY29uc3QgZ3JhZGllbnQ6IEludGVybmFsU3RhdGUgPSB7fTtcblxuICAgIC8vIENhbGN1bGF0ZSBncmFkaWVudCBmb3IgZWFjaCBpbnRlcm5hbCBzdGF0ZVxuICAgIE9iamVjdC5rZXlzKGN1cnJlbnQuaW50ZXJuYWxTdGF0ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgZXBzaWxvbiA9IDAuMDAxO1xuICAgICAgY29uc3Qgb3JpZ2luYWwgPSBjdXJyZW50LmludGVybmFsU3RhdGVzW2tleV07XG5cbiAgICAgIC8vIEZvcndhcmQgZGlmZmVyZW5jZVxuICAgICAgY3VycmVudC5pbnRlcm5hbFN0YXRlc1trZXldID0gTWF0aC5taW4ob3JpZ2luYWwgKyBlcHNpbG9uLCAxKTtcbiAgICAgIGNvbnN0IGZlRm9yd2FyZCA9IGNhbGN1bGF0ZUZyZWVFbmVyZ3koY3VycmVudCk7XG5cbiAgICAgIC8vIEJhY2t3YXJkIGRpZmZlcmVuY2VcbiAgICAgIGN1cnJlbnQuaW50ZXJuYWxTdGF0ZXNba2V5XSA9IE1hdGgubWF4KG9yaWdpbmFsIC0gZXBzaWxvbiwgMCk7XG4gICAgICBjb25zdCBmZUJhY2t3YXJkID0gY2FsY3VsYXRlRnJlZUVuZXJneShjdXJyZW50KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGdyYWRpZW50XG4gICAgICBncmFkaWVudFtrZXldID0gKGZlRm9yd2FyZCAtIGZlQmFja3dhcmQpIC8gKDIgKiBlcHNpbG9uKTtcblxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgY3VycmVudC5pbnRlcm5hbFN0YXRlc1trZXldID0gb3JpZ2luYWw7XG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgc3RhdGVzIGJhc2VkIG9uIGdyYWRpZW50XG4gICAgT2JqZWN0LmtleXMoZ3JhZGllbnQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlID0gLWdyYWRpZW50W2tleV0gKiBjb25maWcubGVhcm5pbmdSYXRlITtcbiAgICAgIGN1cnJlbnQuaW50ZXJuYWxTdGF0ZXNba2V5XSA9IE1hdGgubWluKFxuICAgICAgICBNYXRoLm1heChjdXJyZW50LmludGVybmFsU3RhdGVzW2tleV0gKyB1cGRhdGUsIDApLFxuICAgICAgICAxLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGNvbnZlcmdlbmNlXG4gICAgY29uc3QgY3VycmVudEZFID0gY2FsY3VsYXRlRnJlZUVuZXJneShjdXJyZW50KTtcbiAgICBjb25zdCBpbXByb3ZlbWVudCA9IHByZXZpb3VzRkUgLSBjdXJyZW50RkU7XG5cbiAgICBpZiAoTWF0aC5hYnMoaW1wcm92ZW1lbnQpIDwgY29uZmlnLmNvbnZlcmdlbmNlVGhyZXNob2xkISkge1xuICAgICAgY29udmVyZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcmV2aW91c0ZFID0gY3VycmVudEZFO1xuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uY3VycmVudCxcbiAgICBmcmVlRW5lcmd5OiBwcmV2aW91c0ZFLFxuICAgIGNvbnZlcmdlbmNlSW5mbzoge1xuICAgICAgaXRlcmF0aW9ucyxcbiAgICAgIGNvbnZlcmdlZCxcbiAgICAgIGZpbmFsRXJyb3I6IHByZXZpb3VzRkUsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtvdkJsYW5rZXROZWlnaGJvcnMoXG4gIGJsYW5rZXQ6IE1hcmtvdkJsYW5rZXQsXG4gIGFsbEJsYW5rZXRzOiBNYXJrb3ZCbGFua2V0W10sXG4gIG9wdGlvbnM/OiB7XG4gICAgcHJveGltaXR5VGhyZXNob2xkPzogbnVtYmVyO1xuICAgIGNvbnNpZGVyQ29tbXVuaWNhdGlvbj86IGJvb2xlYW47XG4gICAgY29uc2lkZXJTaGFyZWRCZWxpZWZzPzogYm9vbGVhbjtcbiAgfSxcbik6IE1hcmtvdkJsYW5rZXRbXSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJveGltaXR5VGhyZXNob2xkOiAwLjUsXG4gICAgY29uc2lkZXJDb21tdW5pY2F0aW9uOiBmYWxzZSxcbiAgICBjb25zaWRlclNoYXJlZEJlbGllZnM6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG5cbiAgcmV0dXJuIGFsbEJsYW5rZXRzLmZpbHRlcigob3RoZXIpID0+IHtcbiAgICBpZiAob3RoZXIuaWQgPT09IGJsYW5rZXQuaWQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIHByb3hpbWl0eVxuICAgIGNvbnN0IHByb3hpbWl0eUtleSA9IGBwcm94aW1pdHlfdG9fJHtibGFua2V0LmFnZW50SWR9YDtcbiAgICBjb25zdCBwcm94aW1pdHkgPSBvdGhlci5leHRlcm5hbFN0YXRlc1twcm94aW1pdHlLZXldIHx8IDA7XG5cbiAgICBpZiAocHJveGltaXR5IDwgb3B0cy5wcm94aW1pdHlUaHJlc2hvbGQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEFkZGl0aW9uYWwgY2hlY2tzIGlmIGVuYWJsZWRcbiAgICBpZiAob3B0cy5jb25zaWRlckNvbW11bmljYXRpb24pIHtcbiAgICAgIGNvbnN0IGNvbW11bmljYXRpb24gPSBvdGhlci5hY3RpdmVTdGF0ZXMuY29tbXVuaWNhdGlvbj8udmFsdWUgfHwgMDtcbiAgICAgIGlmIChjb21tdW5pY2F0aW9uIDwgMC4zKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuY29uc2lkZXJTaGFyZWRCZWxpZWZzKSB7XG4gICAgICAvLyBDaGVjayBmb3Igc2ltaWxhciBiZWxpZWZzXG4gICAgICBjb25zdCBiZWxpZWZTaW1pbGFyaXR5ID0gT2JqZWN0LmtleXMoYmxhbmtldC5pbnRlcm5hbFN0YXRlcylcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcImJlbGllZl9cIikpXG4gICAgICAgIC5yZWR1Y2UoKHNpbSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKFxuICAgICAgICAgICAgYmxhbmtldC5pbnRlcm5hbFN0YXRlc1trZXldIC0gKG90aGVyLmludGVybmFsU3RhdGVzW2tleV0gfHwgMC41KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzaW0gKyAoMSAtIGRpZmYpO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgaWYgKGJlbGllZlNpbWlsYXJpdHkgPCAxKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VNYXJrb3ZCbGFua2V0cyhibGFua2V0czogTWFya292QmxhbmtldFtdKTogTWFya292QmxhbmtldCB7XG4gIGlmIChibGFua2V0cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgZW1wdHkgYXJyYXkgb2YgTWFya292IGJsYW5rZXRzXCIpO1xuICB9XG5cbiAgaWYgKGJsYW5rZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBibGFua2V0c1swXTtcbiAgfVxuXG4gIGNvbnN0IG1lcmdlZDogTWFya292QmxhbmtldCA9IHtcbiAgICBpZDogYG1lcmdlZC0ke0RhdGUubm93KCl9YCxcbiAgICBhZ2VudElkOiBgY29hbGl0aW9uLSR7YmxhbmtldHMubWFwKChiKSA9PiBiLmFnZW50SWQpLmpvaW4oXCItXCIpfWAsXG4gICAgc2Vuc29yU3RhdGVzOiB7fSxcbiAgICBhY3RpdmVTdGF0ZXM6IHt9LFxuICAgIGludGVybmFsU3RhdGVzOiB7fSxcbiAgICBleHRlcm5hbFN0YXRlczoge30sXG4gICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXG4gIH07XG5cbiAgLy8gTWVyZ2Ugc2Vuc29yIHN0YXRlcyAodW5pb24pXG4gIGJsYW5rZXRzLmZvckVhY2goKGJsYW5rZXQpID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhibGFua2V0LnNlbnNvclN0YXRlcykuZm9yRWFjaCgoW2tleSwgc3RhdGVdKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFtZXJnZWQuc2Vuc29yU3RhdGVzW2tleV0gfHxcbiAgICAgICAgc3RhdGUuY29uZmlkZW5jZSA+IG1lcmdlZC5zZW5zb3JTdGF0ZXNba2V5XS5jb25maWRlbmNlXG4gICAgICApIHtcbiAgICAgICAgbWVyZ2VkLnNlbnNvclN0YXRlc1trZXldID0gc3RhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIE1lcmdlIGFjdGl2ZSBzdGF0ZXMgKGF2ZXJhZ2UpXG4gIGNvbnN0IGFjdGl2ZVN0YXRlS2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBibGFua2V0cy5mb3JFYWNoKChibGFua2V0KSA9PiB7XG4gICAgT2JqZWN0LmtleXMoYmxhbmtldC5hY3RpdmVTdGF0ZXMpLmZvckVhY2goKGtleSkgPT5cbiAgICAgIGFjdGl2ZVN0YXRlS2V5cy5hZGQoa2V5KSxcbiAgICApO1xuICB9KTtcblxuICBhY3RpdmVTdGF0ZUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3Qgc3RhdGVzID0gYmxhbmtldHMubWFwKChiKSA9PiBiLmFjdGl2ZVN0YXRlc1trZXldKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBpZiAoc3RhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lcmdlZC5hY3RpdmVTdGF0ZXNba2V5XSA9IHtcbiAgICAgICAgdmFsdWU6IHN0YXRlcy5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgcy52YWx1ZSwgMCkgLyBzdGF0ZXMubGVuZ3RoLFxuICAgICAgICBlbmVyZ3k6IHN0YXRlcy5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgcy5lbmVyZ3ksIDApIC8gc3RhdGVzLmxlbmd0aCxcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBNZXJnZSBpbnRlcm5hbCBzdGF0ZXMgKHdlaWdodGVkIGF2ZXJhZ2UgYmFzZWQgb24gZnJlZSBlbmVyZ3kpXG4gIGNvbnN0IHdlaWdodHMgPSBibGFua2V0cy5tYXAoKGIpID0+IDEgLyAoYi5mcmVlRW5lcmd5IHx8IDEpKTtcbiAgY29uc3QgdG90YWxXZWlnaHQgPSB3ZWlnaHRzLnJlZHVjZSgoc3VtLCB3KSA9PiBzdW0gKyB3LCAwKTtcblxuICBjb25zdCBpbnRlcm5hbEtleXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgYmxhbmtldHMuZm9yRWFjaCgoYmxhbmtldCkgPT4ge1xuICAgIE9iamVjdC5rZXlzKGJsYW5rZXQuaW50ZXJuYWxTdGF0ZXMpLmZvckVhY2goKGtleSkgPT4gaW50ZXJuYWxLZXlzLmFkZChrZXkpKTtcbiAgfSk7XG5cbiAgaW50ZXJuYWxLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGxldCB3ZWlnaHRlZFN1bSA9IDA7XG4gICAgbGV0IHdlaWdodFN1bSA9IDA7XG5cbiAgICBibGFua2V0cy5mb3JFYWNoKChibGFua2V0LCBpKSA9PiB7XG4gICAgICBpZiAoYmxhbmtldC5pbnRlcm5hbFN0YXRlc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2VpZ2h0ZWRTdW0gKz0gYmxhbmtldC5pbnRlcm5hbFN0YXRlc1trZXldICogd2VpZ2h0c1tpXTtcbiAgICAgICAgd2VpZ2h0U3VtICs9IHdlaWdodHNbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAod2VpZ2h0U3VtID4gMCkge1xuICAgICAgbWVyZ2VkLmludGVybmFsU3RhdGVzW2tleV0gPSB3ZWlnaHRlZFN1bSAvIHdlaWdodFN1bTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENhbGN1bGF0ZSBmcmVlIGVuZXJneSBmb3IgbWVyZ2VkIGJsYW5rZXRcbiAgbWVyZ2VkLmZyZWVFbmVyZ3kgPSBjYWxjdWxhdGVGcmVlRW5lcmd5KG1lcmdlZCk7XG5cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaXNWYWxpZDogYm9vbGVhbjtcbiAgZXJyb3JzOiBzdHJpbmdbXTtcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNYXJrb3ZCbGFua2V0KFxuICBibGFua2V0OiBQYXJ0aWFsPE1hcmtvdkJsYW5rZXQ+LFxuKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQ2hlY2sgcmVxdWlyZWQgZmllbGRzXG4gIGlmICghYmxhbmtldC5pZCkgZXJyb3JzLnB1c2goXCJNaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiBpZFwiKTtcbiAgaWYgKCFibGFua2V0LmFnZW50SWQpIGVycm9ycy5wdXNoKFwiTWlzc2luZyByZXF1aXJlZCBmaWVsZDogYWdlbnRJZFwiKTtcbiAgaWYgKCFibGFua2V0LnNlbnNvclN0YXRlcylcbiAgICBlcnJvcnMucHVzaChcIk1pc3NpbmcgcmVxdWlyZWQgZmllbGQ6IHNlbnNvclN0YXRlc1wiKTtcbiAgaWYgKCFibGFua2V0LmFjdGl2ZVN0YXRlcylcbiAgICBlcnJvcnMucHVzaChcIk1pc3NpbmcgcmVxdWlyZWQgZmllbGQ6IGFjdGl2ZVN0YXRlc1wiKTtcbiAgaWYgKCFibGFua2V0LmludGVybmFsU3RhdGVzKVxuICAgIGVycm9ycy5wdXNoKFwiTWlzc2luZyByZXF1aXJlZCBmaWVsZDogaW50ZXJuYWxTdGF0ZXNcIik7XG4gIGlmICghYmxhbmtldC5leHRlcm5hbFN0YXRlcylcbiAgICBlcnJvcnMucHVzaChcIk1pc3NpbmcgcmVxdWlyZWQgZmllbGQ6IGV4dGVybmFsU3RhdGVzXCIpO1xuXG4gIC8vIFZhbGlkYXRlIHN0YXRlIHJhbmdlc1xuICBpZiAoYmxhbmtldC5pbnRlcm5hbFN0YXRlcykge1xuICAgIE9iamVjdC5lbnRyaWVzKGJsYW5rZXQuaW50ZXJuYWxTdGF0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYEludGVybmFsIHN0YXRlICcke2tleX0nIG91dCBvZiByYW5nZTogJHt2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChibGFua2V0LmFjdGl2ZVN0YXRlcykge1xuICAgIE9iamVjdC5lbnRyaWVzKGJsYW5rZXQuYWN0aXZlU3RhdGVzKS5mb3JFYWNoKChba2V5LCBzdGF0ZV0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS52YWx1ZSA8IDAgfHwgc3RhdGUudmFsdWUgPiAxKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGBBY3RpdmUgc3RhdGUgJyR7a2V5fScgdmFsdWUgb3V0IG9mIHJhbmdlOiAke3N0YXRlLnZhbHVlfWApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVuZXJneSA8IDApIHtcbiAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgYEFjdGl2ZSBzdGF0ZSAnJHtrZXl9JyBlbmVyZ3kgY2Fubm90IGJlIG5lZ2F0aXZlOiAke3N0YXRlLmVuZXJneX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgZW5lcmd5IGNvbnNlcnZhdGlvblxuICAgIGNvbnN0IHRvdGFsQWN0aXZlVmFsdWUgPSBPYmplY3QudmFsdWVzKGJsYW5rZXQuYWN0aXZlU3RhdGVzKS5yZWR1Y2UoXG4gICAgICAoc3VtLCBzdGF0ZSkgPT4gc3VtICsgc3RhdGUudmFsdWUsXG4gICAgICAwLFxuICAgICk7XG4gICAgY29uc3QgdG90YWxFbmVyZ3kgPSBPYmplY3QudmFsdWVzKGJsYW5rZXQuYWN0aXZlU3RhdGVzKS5yZWR1Y2UoXG4gICAgICAoc3VtLCBzdGF0ZSkgPT4gc3VtICsgc3RhdGUuZW5lcmd5LFxuICAgICAgMCxcbiAgICApO1xuXG4gICAgaWYgKHRvdGFsQWN0aXZlVmFsdWUgPiAxICYmIHRvdGFsRW5lcmd5IDwgMC4xKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKFxuICAgICAgICBcIkVuZXJneSBjb25zZXJ2YXRpb24gd2FybmluZzogSGlnaCBhY3Rpdml0eSB3aXRoIGxvdyBlbmVyZ3lcIixcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGJsYW5rZXQuc2Vuc29yU3RhdGVzKSB7XG4gICAgT2JqZWN0LmVudHJpZXMoYmxhbmtldC5zZW5zb3JTdGF0ZXMpLmZvckVhY2goKFtrZXksIHN0YXRlXSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnZhbHVlIDwgMCB8fCBzdGF0ZS52YWx1ZSA+IDEpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYFNlbnNvciBzdGF0ZSAnJHtrZXl9JyB2YWx1ZSBvdXQgb2YgcmFuZ2U6ICR7c3RhdGUudmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuY29uZmlkZW5jZSA8IDAgfHwgc3RhdGUuY29uZmlkZW5jZSA+IDEpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgYFNlbnNvciBzdGF0ZSAnJHtrZXl9JyBjb25maWRlbmNlIG91dCBvZiByYW5nZTogJHtzdGF0ZS5jb25maWRlbmNlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgZXJyb3JzLFxuICAgIHdhcm5pbmdzLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZUZyZWVFbmVyZ3kiLCJjcmVhdGVNYXJrb3ZCbGFua2V0IiwiZ2V0TWFya292QmxhbmtldE5laWdoYm9ycyIsIm1lcmdlTWFya292QmxhbmtldHMiLCJtaW5pbWl6ZUZyZWVFbmVyZ3kiLCJ1cGRhdGVNYXJrb3ZCbGFua2V0IiwidmFsaWRhdGVNYXJrb3ZCbGFua2V0IiwiREVGQVVMVF9DT05GSUciLCJsZWFybmluZ1JhdGUiLCJwcmVjaXNpb24iLCJtYXhJdGVyYXRpb25zIiwiY29udmVyZ2VuY2VUaHJlc2hvbGQiLCJmcmVlRW5lcmd5Q2FjaGUiLCJXZWFrTWFwIiwiQ0FDSEVfRFVSQVRJT04iLCJvcHRpb25zIiwiaWQiLCJhZ2VudElkIiwiRXJyb3IiLCJibGFua2V0Iiwic2Vuc29yU3RhdGVzIiwiYWN0aXZlU3RhdGVzIiwiaW50ZXJuYWxTdGF0ZXMiLCJleHRlcm5hbFN0YXRlcyIsImNvbmZpZyIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsIm5vdyIsImZyZWVFbmVyZ3kiLCJ1cGRhdGVzIiwidXBkYXRlZCIsIk9iamVjdCIsImVudHJpZXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJzdGF0ZSIsInZhbHVlIiwiTWF0aCIsIm1pbiIsIm1heCIsImVuZXJneSIsImNhY2hlZCIsImdldCIsInRpbWVzdGFtcCIsImZvckVhY2giLCJzZW5zb3JLZXkiLCJzZW5zb3IiLCJiZWxpZWZLZXkiLCJiZWxpZWYiLCJwcmVkaWN0aW9uRXJyb3IiLCJwb3ciLCJjb25maWRlbmNlIiwidmFsdWVzIiwiZW50cm9weSIsImxvZyIsInByaW9yIiwiY29tcGxleGl0eSIsImVuZXJneUNvc3QiLCJzZXQiLCJjdXJyZW50IiwiaXRlcmF0aW9ucyIsImNvbnZlcmdlZCIsInByZXZpb3VzRkUiLCJncmFkaWVudCIsImtleXMiLCJlcHNpbG9uIiwib3JpZ2luYWwiLCJmZUZvcndhcmQiLCJmZUJhY2t3YXJkIiwidXBkYXRlIiwiY3VycmVudEZFIiwiaW1wcm92ZW1lbnQiLCJhYnMiLCJjb252ZXJnZW5jZUluZm8iLCJmaW5hbEVycm9yIiwiYWxsQmxhbmtldHMiLCJvcHRzIiwicHJveGltaXR5VGhyZXNob2xkIiwiY29uc2lkZXJDb21tdW5pY2F0aW9uIiwiY29uc2lkZXJTaGFyZWRCZWxpZWZzIiwiZmlsdGVyIiwib3RoZXIiLCJwcm94aW1pdHlLZXkiLCJwcm94aW1pdHkiLCJjb21tdW5pY2F0aW9uIiwiYmVsaWVmU2ltaWxhcml0eSIsInN0YXJ0c1dpdGgiLCJzaW0iLCJkaWZmIiwiYmxhbmtldHMiLCJsZW5ndGgiLCJtZXJnZWQiLCJtYXAiLCJiIiwiam9pbiIsImFjdGl2ZVN0YXRlS2V5cyIsIlNldCIsImFkZCIsInN0YXRlcyIsIkJvb2xlYW4iLCJzdW0iLCJzIiwid2VpZ2h0cyIsInRvdGFsV2VpZ2h0IiwidyIsImludGVybmFsS2V5cyIsIndlaWdodGVkU3VtIiwid2VpZ2h0U3VtIiwiaSIsInVuZGVmaW5lZCIsImVycm9ycyIsIndhcm5pbmdzIiwicHVzaCIsInRvdGFsQWN0aXZlVmFsdWUiLCJ0b3RhbEVuZXJneSIsImlzVmFsaWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDOzs7Ozs7Ozs7OztJQTJJZUEsbUJBQW1CO2VBQW5CQTs7SUEvRUFDLG1CQUFtQjtlQUFuQkE7O0lBK0xBQyx5QkFBeUI7ZUFBekJBOztJQWlEQUMsbUJBQW1CO2VBQW5CQTs7SUFsSE1DLGtCQUFrQjtlQUFsQkE7O0lBdEdOQyxtQkFBbUI7ZUFBbkJBOztJQStTQUMscUJBQXFCO2VBQXJCQTs7O0FBclZoQixNQUFNQyxpQkFBc0M7SUFDMUNDLGNBQWM7SUFDZEMsV0FBVztJQUNYQyxlQUFlO0lBQ2ZDLHNCQUFzQjtBQUN4QjtBQUVBLHFDQUFxQztBQUNyQyxNQUFNQyxrQkFBa0IsSUFBSUM7QUFJNUIsTUFBTUMsaUJBQWlCLEtBQUssS0FBSztBQUUxQixTQUFTYixvQkFDZGMsT0FBc0U7SUFFdEUsSUFBSSxDQUFDQSxRQUFRQyxFQUFFLElBQUksQ0FBQ0QsUUFBUUUsT0FBTyxFQUFFO1FBQ25DLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLE1BQU1DLFVBQXlCO1FBQzdCSCxJQUFJRCxRQUFRQyxFQUFFO1FBQ2RDLFNBQVNGLFFBQVFFLE9BQU87UUFDeEJHLGNBQWNMLFFBQVFLLFlBQVksSUFBSSxDQUFDO1FBQ3ZDQyxjQUFjTixR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