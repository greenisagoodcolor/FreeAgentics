{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/hooks/useConversationorchestrator.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport type { Agent, Conversation, Message } from \"@/lib/types\";\nimport {\n  ConversationOrchestrator,\n  type OrchestratorOptions,\n  type ResponseOptions,\n} from \"@/lib/conversation-orchestrator\";\nimport { KnowledgeRetriever } from \"@/lib/knowledge-retriever\";\nimport { useLLM } from \"@/contexts/llm-context\";\nimport { useIsSending } from \"@/contexts/is-sending-context\";\n\nexport function useConversationOrchestrator(\n  conversation: Conversation | null,\n  agents: Agent[],\n  options: OrchestratorOptions = {},\n  onSendMessage?: (content: string, senderId: string) => void,\n) {\n  const { client: llmClient } = useLLM();\n\n  // Add defensive check for isSending\n  const isSendingContext = useIsSending();\n  const isSending =\n    typeof isSendingContext?.isSending === \"boolean\"\n      ? isSendingContext.isSending\n      : false;\n\n  const [processingAgents, setProcessingAgents] = useState<string[]>([]);\n  const [queuedAgents, setQueuedAgents] = useState<string[]>([]);\n  const [typingAgents, setTypingAgents] = useState<\n    Record<string, { text: string; isComplete: boolean; messageId: string }>\n  >({});\n  const [error, setError] = useState<string | null>(null);\n  const [processingMessageIds, setProcessingMessageIds] = useState<string[]>(\n    [],\n  );\n  const [isProcessing, setIsProcessing] = useState(false);\n\n  // Create refs for stable values\n  const orchestratorRef = useRef<ConversationOrchestrator | null>(null);\n  const conversationRef = useRef(conversation);\n  const agentsRef = useRef(agents);\n  const onSendMessageRef = useRef(onSendMessage);\n  const optionsRef = useRef(options);\n  const processedMessageRef = useRef<string | null>(null); // useRef for processed message ID\n\n  // Create stable callback references\n  const handleMessageGenerated = useCallback((message: Message) => {\n    console.log(\"Message generated:\", message);\n\n    // Skip empty messages (when agent decided not to respond)\n    if (!message.content.trim()) {\n      console.log(`Skipping empty message from ${message.senderId}`);\n      return;\n    }\n\n    // Call the onSendMessage callback to add the message to the conversation\n    if (typeof onSendMessageRef.current === \"function\") {\n      onSendMessageRef.current(message.content, message.senderId);\n    } else {\n      console.warn(\n        \"onSendMessage is not a function\",\n        typeof onSendMessageRef.current,\n      );\n    }\n  }, []);\n\n  const handleOrchestratorError = useCallback((error: Error) => {\n    console.error(\"Orchestrator error:\", error);\n    setError(`Error: ${error.message}`);\n\n    // Clear error after 5 seconds\n    setTimeout(() => {\n      setError(null);\n    }, 5000);\n  }, []);\n\n  // Helper function to create orchestrator on demand - NOT a hook\n  const createOrchestratorOnDemand = () => {\n    if (!orchestratorRef.current && conversationRef.current && llmClient) {\n      console.log(\n        \"[HOOK] Creating orchestrator on demand for queueing response\",\n      );\n      const knowledgeRetriever = new KnowledgeRetriever();\n      orchestratorRef.current = new ConversationOrchestrator(\n        conversationRef.current,\n        agentsRef.current,\n        llmClient,\n        knowledgeRetriever,\n        {\n          ...optionsRef.current,\n          onMessageGenerated: handleMessageGenerated,\n          onError: handleOrchestratorError,\n        },\n      );\n      return true;\n    }\n    return false;\n  };\n\n  // Update refs when props change\n  useEffect(() => {\n    conversationRef.current = conversation;\n    agentsRef.current = agents;\n    onSendMessageRef.current = onSendMessage;\n    optionsRef.current = options;\n\n    // Update orchestrator if it exists\n    if (orchestratorRef.current && conversation) {\n      orchestratorRef.current.updateConversation(conversation);\n      orchestratorRef.current.updateAgents(agents);\n    }\n  }, [conversation, agents, onSendMessage, options]);\n\n  // Initialize orchestrator\n  useEffect(() => {\n    // Create or update the orchestrator when conversation changes\n    if (conversation && llmClient) {\n      // Create knowledge retriever if needed\n      const knowledgeRetriever = new KnowledgeRetriever();\n\n      // If orchestrator doesn't exist yet, create it\n      if (!orchestratorRef.current) {\n        console.log(\"Creating new conversation orchestrator\");\n        orchestratorRef.current = new ConversationOrchestrator(\n          conversation,\n          agents,\n          llmClient,\n          knowledgeRetriever,\n          {\n            ...options,\n            onMessageGenerated: handleMessageGenerated,\n            onError: handleOrchestratorError,\n          },\n        );\n      } else {\n        // Otherwise update the existing one\n        console.log(\"Updating existing conversation orchestrator\");\n        orchestratorRef.current.updateConversation(conversation);\n        orchestratorRef.current.updateAgents(agents);\n      }\n    } else if (orchestratorRef.current) {\n      // Clean up if conversation becomes null\n      console.log(\"Cleaning up conversation orchestrator\");\n      orchestratorRef.current.cleanup();\n      orchestratorRef.current = null;\n    }\n\n    // Set up polling to update processing state\n    const intervalId = setInterval(() => {\n      if (orchestratorRef.current) {\n        setProcessingAgents(orchestratorRef.current.getProcessingAgents());\n        setQueuedAgents(orchestratorRef.current.getQueuedAgents());\n        setProcessingMessageIds(\n          orchestratorRef.current.getProcessingMessageIds(),\n        );\n        setIsProcessing(\n          orchestratorRef.current.getProcessingAgents().length > 0 ||\n            orchestratorRef.current.getQueuedAgents().length > 0,\n        );\n      }\n    }, 200);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [\n    conversation,\n    agents,\n    options,\n    llmClient,\n    handleMessageGenerated,\n    handleOrchestratorError,\n  ]);\n\n  // Function to queue an agent response\n  const queueAgentResponse = useCallback(\n    (agentId: string, responseOptions: ResponseOptions = {}) => {\n      console.log(`[HOOK] queueAgentResponse called for agent ${agentId}`, {\n        hasMessageToRespondTo: !!responseOptions.messageToRespondTo,\n        force: responseOptions.force,\n        streamResponse: responseOptions.streamResponse,\n        hasOnChunk: !!responseOptions.onChunk,\n      });\n\n      // Create orchestrator if needed (using the helper function)\n      createOrchestratorOnDemand();\n\n      if (!orchestratorRef.current) {\n        console.error(\n          \"[HOOK] Cannot queue response: Conversation orchestrator not initialized\",\n        );\n        setError(\n          \"Cannot queue response: Conversation orchestrator not initialized\",\n        );\n        return;\n      }\n\n      // Check if there are messages in the conversation\n      if (\n        !conversationRef.current ||\n        conversationRef.current.messages.length === 0\n      ) {\n        console.error(\n          \"[HOOK] Cannot generate response: No messages in conversation\",\n        );\n        setError(\"Cannot generate response: No messages in conversation\");\n        return;\n      }\n\n      try {\n        // Get the message to respond to\n        const messageToRespondTo =\n          responseOptions.messageToRespondTo ||\n          conversationRef.current.messages[\n            conversationRef.current.messages.length - 1\n          ];\n\n        console.log(\"[HOOK] Message to respond to:\", {\n          id: messageToRespondTo.id,\n          sender: messageToRespondTo.senderId,\n          content: messageToRespondTo.content.substring(0, 30) + \"...\",\n          type: messageToRespondTo.metadata?.type,\n        });\n\n        // Create a typing indicator immediately\n        setTypingAgents((prev) => ({\n          ...prev,\n          [agentId]: {\n            text: \"...\",\n            isComplete: false,\n            messageId: messageToRespondTo.id,\n          },\n        }));\n\n        console.log(`[HOOK] Created typing indicator for agent ${agentId}`);\n\n        // Create a safe onChunk callback - NOT using useCallback\n        const safeOnChunk = (text: string, isComplete: boolean) => {\n          console.log(`[HOOK] onChunk called for agent ${agentId}:`, {\n            textLength: text?.length || 0,\n            isComplete,\n          });\n\n          try {\n            setTypingAgents((prevState) => {\n              // Safety check to ensure the agent is still in the typing state\n              if (!prevState[agentId]) {\n                console.log(\n                  `[HOOK] Agent ${agentId} no longer in typing state, creating new entry`,\n                );\n                // Create a new entry if it doesn't exist\n                return {\n                  ...prevState,\n                  [agentId]: {\n                    text: text || \"\",\n                    isComplete: isComplete,\n                    messageId: messageToRespondTo.id,\n                  },\n                };\n              }\n\n              const updated = { ...prevState };\n\n              if (isComplete) {\n                // Mark as complete but don't remove yet (will be removed by cleanup timer)\n                updated[agentId] = { ...updated[agentId], isComplete: true };\n              } else {\n                // Append text safely\n                const currentText = updated[agentId]?.text || \"\";\n                const newText = text || \"\";\n                updated[agentId] = {\n                  text: currentText + newText,\n                  isComplete: false,\n                  messageId: messageToRespondTo.id,\n                };\n              }\n\n              return updated;\n            });\n          } catch (error) {\n            console.error(\n              `[HOOK] Error in typing indicator update for agent ${agentId}:`,\n              error,\n            );\n          }\n        };\n\n        // Set up options with the safe onChunk callback\n        const options: ResponseOptions = {\n          ...responseOptions,\n          streamResponse: true,\n          messageToRespondTo,\n          onChunk: safeOnChunk,\n          onMessageGenerated: handleMessageGenerated,\n        };\n\n        console.log(\n          `[HOOK] Calling orchestratorRef.current.queueAgentResponse for agent ${agentId}`,\n        );\n\n        // Queue the response\n        orchestratorRef.current.queueAgentResponse(agentId, options);\n\n        console.log(`[HOOK] Successfully queued response for agent ${agentId}`);\n        setError(null); // Clear any previous errors\n      } catch (err) {\n        console.error(\"[HOOK] Error queueing agent response:\", err);\n        setError(\n          `Failed to queue response for ${agentId}: ${err instanceof Error ? err.message : String(err)}`,\n        );\n      }\n    },\n    [handleMessageGenerated],\n  );\n\n  // Function to process a new message\n  const processNewMessage = useCallback(\n    (message: Message) => {\n      // Create orchestrator if needed (using the helper function)\n      createOrchestratorOnDemand();\n\n      if (!orchestratorRef.current) {\n        console.error(\n          \"Cannot process message: Conversation orchestrator not initialized and no conversation available\",\n        );\n        setError(\"Cannot process message: No active conversation\");\n        return;\n      }\n\n      try {\n        // Add message to conversation reference first (safety check)\n        if (\n          conversationRef.current &&\n          !conversationRef.current.messages.some((m) => m.id === message.id)\n        ) {\n          console.log(`Adding message ${message.id} to conversation reference`);\n          conversationRef.current = {\n            ...conversationRef.current,\n            messages: [...conversationRef.current.messages, message],\n          };\n        }\n\n        // CRITICAL FIX: Add more detailed logging for conversation starter messages\n        if (message.metadata?.type === \"conversation_starter\") {\n          console.log(\"PROCESSING CONVERSATION STARTER MESSAGE:\", {\n            messageId: message.id,\n            senderId: message.senderId,\n            content: message.content,\n            metadata: message.metadata,\n            conversationId: conversationRef.current?.id,\n            participantCount: conversationRef.current?.participants.length,\n          });\n\n          // Double check that we have participants to respond\n          if (conversationRef.current) {\n            const respondingAgents = agentsRef.current.filter(\n              (agent) =>\n                conversationRef.current?.participants.includes(agent.id) &&\n                agent.id !== message.senderId,\n            );\n\n            console.log(\n              `Found ${respondingAgents.length} agents to respond to conversation starter:`,\n              respondingAgents.map((a) => a.name),\n            );\n\n            if (respondingAgents.length === 0) {\n              console.error(\n                \"No agents available to respond to conversation starter!\",\n              );\n            }\n          }\n        }\n\n        // Then process the message\n        console.log(`Triggering processNewMessage for message: ${message.id}`);\n        orchestratorRef.current.processNewMessage(message);\n        setError(null); // Clear any previous errors\n      } catch (err) {\n        console.error(\"Error processing message:\", err);\n        setError(\n          `Failed to process message: ${err instanceof Error ? err.message : String(err)}`,\n        );\n      }\n    },\n    [handleMessageGenerated, handleOrchestratorError],\n  );\n\n  // Function to cancel all responses\n  const cancelAllResponses = useCallback(() => {\n    if (orchestratorRef.current) {\n      orchestratorRef.current.cancelAllResponses();\n    }\n    // Clear typing indicators\n    setTypingAgents({});\n    setError(null); // Clear any previous errors\n  }, []);\n\n  // Clean up completed typing indicators\n  useEffect(() => {\n    const cleanupTimer = setInterval(() => {\n      setTypingAgents((prev) => {\n        const updated = { ...prev };\n        let changed = false;\n\n        // Remove completed typing indicators that are no longer processing\n        Object.entries(updated).forEach(([agentId, state]) => {\n          // Remove if complete or if the text contains SKIP_RESPONSE\n          if (\n            state.isComplete ||\n            (state.text && state.text.includes(\"SKIP_RESPONSE\")) ||\n            (!processingAgents.includes(agentId) &&\n              !queuedAgents.includes(agentId))\n          ) {\n            delete updated[agentId];\n            changed = true;\n          }\n        });\n\n        return changed ? updated : prev;\n      });\n    }, 300); // Check more frequently\n\n    return () => clearInterval(cleanupTimer);\n  }, [processingAgents, queuedAgents]);\n\n  // CRITICAL FIX: Update the useEffect that checks for conversation starter messages\n  useEffect(() => {\n    if (\n      !conversation ||\n      !conversation.messages ||\n      conversation.messages.length === 0\n    )\n      return;\n\n    const latestMessage =\n      conversation.messages[conversation.messages.length - 1];\n    if (!latestMessage) return;\n\n    // Create a stable reference to the latest message ID to prevent infinite loops\n    const latestMessageId = latestMessage.id;\n\n    // Check if we've already processed this message\n    if (processedMessageRef.current === latestMessageId) {\n      return; // Skip processing if already processed\n    }\n\n    // Log conversation starter messages with more detail\n    if (latestMessage.metadata?.type === \"conversation_starter\") {\n      console.log(\n        \"CONVERSATION ORCHESTRATOR: Detected conversation starter message:\",\n        {\n          messageId: latestMessage.id,\n          content: latestMessage.content,\n          senderId: latestMessage.senderId,\n          metadata: latestMessage.metadata,\n          conversationId: conversation?.id,\n          participantCount: conversation?.participants.length,\n          orchestratorExists: !!orchestratorRef.current,\n          isProcessing: isProcessing,\n          isSending: isSending,\n        },\n      );\n\n      // If we're not already processing, trigger responses\n      if (!isProcessing && !isSending && orchestratorRef.current) {\n        console.log(\n          \"CONVERSATION ORCHESTRATOR: Triggering responses to conversation starter message\",\n        );\n\n        // Get all agents in the conversation except the sender\n        const respondingAgents = agents.filter(\n          (agent) =>\n            conversation.participants.includes(agent.id) &&\n            agent.id !== latestMessage.senderId,\n        );\n\n        console.log(\n          `CONVERSATION ORCHESTRATOR: Found ${respondingAgents.length} agents to respond to conversation starter:`,\n          respondingAgents.map((a) => a.name),\n        );\n\n        if (respondingAgents.length === 0) {\n          console.error(\n            \"CONVERSATION ORCHESTRATOR: No agents available to respond to conversation starter!\",\n          );\n        } else {\n          // Queue responses from all agents with slight delays\n          respondingAgents.forEach((agent, index) => {\n            console.log(\n              `CONVERSATION ORCHESTRATOR: Queueing response from ${agent.name} to conversation starter`,\n            );\n            try {\n              // Force response and use a longer delay to ensure proper processing\n              queueAgentResponse(agent.id, {\n                messageToRespondTo: latestMessage,\n                responseDelay: 1000 + index * 1500, // Longer staggered delays\n                force: true, // Force response regardless of dynamics\n              });\n            } catch (error) {\n              console.error(\n                `CONVERSATION ORCHESTRATOR: Error queueing response for ${agent.name}:`,\n                error,\n              );\n            }\n          });\n        }\n\n        // Mark this message as processed\n        processedMessageRef.current = latestMessageId;\n      } else {\n        console.log(\n          `CONVERSATION ORCHESTRATOR: Not triggering responses to conversation starter: orchestratorExists=${!!orchestratorRef.current}, isProcessing=${isProcessing}, isSending=${isSending}`,\n        );\n      }\n    }\n\n    // Skip other system messages\n    if (latestMessage.metadata?.isSystemMessage) return;\n\n    // Skip if it's not a user message\n    if (latestMessage.senderId !== \"user\") return;\n\n    // Check for direct mentions anywhere in the message\n    const mentionedAgents = new Set<Agent>();\n\n    // First check for traditional format at beginning: \"Agent X, [message]\" or \"@Agent X [message]\"\n    const beginningMentionMatch =\n      latestMessage.content.match(/^(?:@?(.+?),?\\s+)/i);\n    if (beginningMentionMatch) {\n      const mentionedName = beginningMentionMatch[1];\n      const agent = agents.find(\n        (agent) =>\n          agent.name.toLowerCase() === mentionedName.toLowerCase() ||\n          agent.name.toLowerCase().startsWith(mentionedName.toLowerCase()),\n      );\n      if (agent) mentionedAgents.add(agent);\n    }\n\n    // Then check for mentions anywhere in the message\n    const allMentionsRegex = /\\b@?([A-Za-z0-9]+(?:\\s+[A-Za-z0-9]+)*)\\b/g;\n    const allMatches = [...latestMessage.content.matchAll(allMentionsRegex)];\n\n    for (const match of allMatches) {\n      const potentialName = match[1];\n      // Check if this potential name matches any agent\n      for (const agent of agents) {\n        if (\n          agent.name.toLowerCase() === potentialName.toLowerCase() ||\n          agent.name.toLowerCase().startsWith(potentialName.toLowerCase())\n        ) {\n          mentionedAgents.add(agent);\n          break;\n        }\n      }\n    }\n\n    // Queue responses for all mentioned agents that are in the conversation\n    for (const mentionedAgent of mentionedAgents) {\n      if (conversation.participants.includes(mentionedAgent.id)) {\n        queueAgentResponse(mentionedAgent.id, {\n          messageToRespondTo: latestMessage,\n          responseDelay: 300, // Quick response for direct mentions\n          force: true, // Force response regardless of dynamics\n        });\n      }\n    }\n\n    // Mark this message as processed\n    processedMessageRef.current = latestMessageId;\n  }, [conversation, agents, isSending, isProcessing, queueAgentResponse]); // Simplified dependencies\n\n  // Return the hook's API\n  return {\n    queueAgentResponse,\n    processNewMessage,\n    cancelAllResponses,\n    processingAgents,\n    queuedAgents,\n    typingAgents,\n    processingMessageIds,\n    isProcessing: processingAgents.length > 0 || queuedAgents.length > 0,\n    error,\n  };\n}\n"],"names":["useConversationOrchestrator","conversation","agents","options","onSendMessage","client","llmClient","useLLM","isSendingContext","useIsSending","isSending","processingAgents","setProcessingAgents","useState","queuedAgents","setQueuedAgents","typingAgents","setTypingAgents","error","setError","processingMessageIds","setProcessingMessageIds","isProcessing","setIsProcessing","orchestratorRef","useRef","conversationRef","agentsRef","onSendMessageRef","optionsRef","processedMessageRef","handleMessageGenerated","useCallback","message","console","log","content","trim","senderId","current","warn","handleOrchestratorError","setTimeout","createOrchestratorOnDemand","knowledgeRetriever","KnowledgeRetriever","ConversationOrchestrator","onMessageGenerated","onError","useEffect","updateConversation","updateAgents","cleanup","intervalId","setInterval","getProcessingAgents","getQueuedAgents","getProcessingMessageIds","length","clearInterval","queueAgentResponse","agentId","responseOptions","hasMessageToRespondTo","messageToRespondTo","force","streamResponse","hasOnChunk","onChunk","messages","id","sender","substring","type","metadata","prev","text","isComplete","messageId","safeOnChunk","textLength","prevState","updated","currentText","newText","err","Error","String","processNewMessage","some","m","conversationId","participantCount","participants","respondingAgents","filter","agent","includes","map","a","name","cancelAllResponses","cleanupTimer","changed","Object","entries","forEach","state","latestMessage","latestMessageId","orchestratorExists","index","responseDelay","isSystemMessage","mentionedAgents","Set","beginningMentionMatch","match","mentionedName","find","toLowerCase","startsWith","add","allMentionsRegex","allMatches","matchAll","potentialName","mentionedAgent"],"mappings":"AAAA;;;;;+BAagBA;;;eAAAA;;;uBAXyC;0CAMlD;oCAC4B;4BACZ;kCACM;AAEtB,SAASA,4BACdC,YAAiC,EACjCC,MAAe,EACfC,UAA+B,CAAC,CAAC,EACjCC,aAA2D;IAE3D,MAAM,EAAEC,QAAQC,SAAS,EAAE,GAAGC,IAAAA,kBAAM;IAEpC,oCAAoC;IACpC,MAAMC,mBAAmBC,IAAAA,8BAAY;IACrC,MAAMC,YACJ,OAAOF,kBAAkBE,cAAc,YACnCF,iBAAiBE,SAAS,GAC1B;IAEN,MAAM,CAACC,kBAAkBC,oBAAoB,GAAGC,IAAAA,eAAQ,EAAW,EAAE;IACrE,MAAM,CAACC,cAAcC,gBAAgB,GAAGF,IAAAA,eAAQ,EAAW,EAAE;IAC7D,MAAM,CAACG,cAAcC,gBAAgB,GAAGJ,IAAAA,eAAQ,EAE9C,CAAC;IACH,MAAM,CAACK,OAAOC,SAAS,GAAGN,IAAAA,eAAQ,EAAgB;IAClD,MAAM,CAACO,sBAAsBC,wBAAwB,GAAGR,IAAAA,eAAQ,EAC9D,EAAE;IAEJ,MAAM,CAACS,cAAcC,gBAAgB,GAAGV,IAAAA,eAAQ,EAAC;IAEjD,gCAAgC;IAChC,MAAMW,kBAAkBC,IAAAA,aAAM,EAAkC;IAChE,MAAMC,kBAAkBD,IAAAA,aAAM,EAACxB;IAC/B,MAAM0B,YAAYF,IAAAA,aAAM,EAACvB;IACzB,MAAM0B,mBAAmBH,IAAAA,aAAM,EAACrB;IAChC,MAAMyB,aAAaJ,IAAAA,aAAM,EAACtB;IAC1B,MAAM2B,sBAAsBL,IAAAA,aAAM,EAAgB,OAAO,kCAAkC;IAE3F,oCAAoC;IACpC,MAAMM,yBAAyBC,IAAAA,kBAAW,EAAC,CAACC;QAC1CC,QAAQC,GAAG,CAAC,sBAAsBF;QAElC,0DAA0D;QAC1D,IAAI,CAACA,QAAQG,OAAO,CAACC,IAAI,IAAI;YAC3BH,QAAQC,GAAG,CAAC,CAAC,4BAA4B,EAAEF,QAAQK,QAAQ,CAAC,CAAC;YAC7D;QACF;QAEA,yEAAyE;QACzE,IAAI,OAAOV,iBAAiBW,OAAO,KAAK,YAAY;YAClDX,iBAAiBW,OAAO,CAACN,QAAQG,OAAO,EAAEH,QAAQK,QAAQ;QAC5D,OAAO;YACLJ,QAAQM,IAAI,CACV,mCACA,OAAOZ,iBAAiBW,OAAO;QAEnC;IACF,GAAG,EAAE;IAEL,MAAME,0BAA0BT,IAAAA,kBAAW,EAAC,CAACd;QAC3CgB,QAAQhB,KAAK,CAAC,uBAAuBA;QACrCC,SAAS,CAAC,OAAO,EAAED,MAAMe,OAAO,CAAC,CAAC;QAElC,8BAA8B;QAC9BS,WAAW;YACTvB,SAAS;QACX,GAAG;IACL,GAAG,EAAE;IAEL,gEAAgE;IAChE,MAAMwB,6BAA6B;QACjC,IAAI,CAACnB,gBAAgBe,OAAO,IAAIb,gBAAgBa,OAAO,IAAIjC,WAAW;YACpE4B,QAAQC,GAAG,CACT;YAEF,MAAMS,qBAAqB,IAAIC,sCAAkB;YACjDrB,gBAAgBe,OAAO,GAAG,IAAIO,kDAAwB,CACpDpB,gBAAgBa,OAAO,EACvBZ,UAAUY,OAAO,EACjBjC,WACAsC,oBACA;gBACE,GAAGf,WAAWU,OAAO;gBACrBQ,oBAAoBhB;gBACpBiB,SAASP;YACX;YAEF,OAAO;QACT;QACA,OAAO;IACT;IAEA,gCAAgC;IAChCQ,IAAAA,gBAAS,EAAC;QACRvB,gBAAgBa,OAAO,GAAGtC;QAC1B0B,UAAUY,OAAO,GAAGrC;QACpB0B,iBAAiBW,OAAO,GAAGnC;QAC3ByB,WAAWU,OAAO,GAAGpC;QAErB,mCAAmC;QACnC,IAAIqB,gBAAgBe,OAAO,IAAItC,cAAc;YAC3CuB,gBAAgBe,OAAO,CAACW,kBAAkB,CAACjD;YAC3CuB,gBAAgBe,OAAO,CAACY,YAAY,CAACjD;QACvC;IACF,GAAG;QAACD;QAAcC;QAAQE;QAAeD;KAAQ;IAEjD,0BAA0B;IAC1B8C,IAAAA,gBAAS,EAAC;QACR,8DAA8D;QAC9D,IAAIhD,gBAAgBK,WAAW;YAC7B,uCAAuC;YACvC,MAAMsC,qBAAqB,IAAIC,sCAAkB;YAEjD,+CAA+C;YAC/C,IAAI,CAACrB,gBAAgBe,OAAO,EAAE;gBAC5BL,QAAQC,GAAG,CAAC;gBACZX,gBAAgBe,OAAO,GAAG,IAAIO,kDAAwB,CACpD7C,cACAC,QACAI,WACAsC,oBACA;oBACE,GAAGzC,OAAO;oBACV4C,oBAAoBhB;oBACpBiB,SAASP;gBACX;YAEJ,OAAO;gBACL,oCAAoC;gBACpCP,QAAQC,GAAG,CAAC;gBACZX,gBAAgBe,OAAO,CAACW,kBAAkB,CAACjD;gBAC3CuB,gBAAgBe,OAAO,CAACY,YAAY,CAACjD;YACvC;QACF,OAAO,IAAIsB,gBAAgBe,OAAO,EAAE;YAClC,wCAAwC;YACxCL,QAAQC,GAAG,CAAC;YACZX,gBAAgBe,OAAO,CAACa,OAAO;YAC/B5B,gBAAgBe,OAAO,GAAG;QAC5B;QAEA,4CAA4C;QAC5C,MAAMc,aAAaC,YAAY;YAC7B,IAAI9B,gBAAgBe,OAAO,EAAE;gBAC3B3B,oBAAoBY,gBAAgBe,OAAO,CAACgB,mBAAmB;gBAC/DxC,gBAAgBS,gBAAgBe,OAAO,CAACiB,eAAe;gBACvDnC,wBACEG,gBAAgBe,OAAO,CAACkB,uBAAuB;gBAEjDlC,gBACEC,gBAAgBe,OAAO,CAACgB,mBAAmB,GAAGG,MAAM,GAAG,KACrDlC,gBAAgBe,OAAO,CAACiB,eAAe,GAAGE,MAAM,GAAG;YAEzD;QACF,GAAG;QAEH,OAAO;YACLC,cAAcN;QAChB;IACF,GAAG;QACDpD;QACAC;QACAC;QACAG;QACAyB;QACAU;KACD;IAED,sCAAsC;IACtC,MAAMmB,qBAAqB5B,IAAAA,kBAAW,EACpC,CAAC6B,SAAiBC,kBAAmC,CAAC,CAAC;QACrD5B,QAAQC,GAAG,CAAC,CAAC,2CAA2C,EAAE0B,QAAQ,CAAC,EAAE;YACnEE,uBAAuB,CAAC,CAACD,gBAAgBE,kBAAkB;YAC3DC,OAAOH,gBAAgBG,KAAK;YAC5BC,gBAAgBJ,gBAAgBI,cAAc;YAC9CC,YAAY,CAAC,CAACL,gBAAgBM,OAAO;QACvC;QAEA,4DAA4D;QAC5DzB;QAEA,IAAI,CAACnB,gBAAgBe,OAAO,EAAE;YAC5BL,QAAQhB,KAAK,CACX;YAEFC,SACE;YAEF;QACF;QAEA,kDAAkD;QAClD,IACE,CAACO,gBAAgBa,OAAO,IACxBb,gBAAgBa,OAAO,CAAC8B,QAAQ,CAACX,MAAM,KAAK,GAC5C;YACAxB,QAAQhB,KAAK,CACX;YAEFC,SAAS;YACT;QACF;QAEA,IAAI;YACF,gCAAgC;YAChC,MAAM6C,qBACJF,gBAAgBE,kBAAkB,IAClCtC,gBAAgBa,OAAO,CAAC8B,QAAQ,CAC9B3C,gBAAgBa,OAAO,CAAC8B,QAAQ,CAACX,MAAM,GAAG,EAC3C;YAEHxB,QAAQC,GAAG,CAAC,iCAAiC;gBAC3CmC,IAAIN,mBAAmBM,EAAE;gBACzBC,QAAQP,mBAAmB1B,QAAQ;gBACnCF,SAAS4B,mBAAmB5B,OAAO,CAACoC,SAAS,CAAC,GAAG,MAAM;gBACvDC,MAAMT,mBAAmBU,QAAQ,EAAED;YACrC;YAEA,wCAAwC;YACxCxD,gBAAgB,CAAC0D,OAAU,CAAA;oBACzB,GAAGA,IAAI;oBACP,CAACd,QAAQ,EAAE;wBACTe,MAAM;wBACNC,YAAY;wBACZC,WAAWd,mBAAmBM,EAAE;oBAClC;gBACF,CAAA;YAEApC,QAAQC,GAAG,CAAC,CAAC,0CAA0C,EAAE0B,QAAQ,CAAC;YAElE,yDAAyD;YACzD,MAAMkB,cAAc,CAACH,MAAcC;gBACjC3C,QAAQC,GAAG,CAAC,CAAC,gCAAgC,EAAE0B,QAAQ,CAAC,CAAC,EAAE;oBACzDmB,YAAYJ,MAAMlB,UAAU;oBAC5BmB;gBACF;gBAEA,IAAI;oBACF5D,gBAAgB,CAACgE;wBACf,gEAAgE;wBAChE,IAAI,CAACA,SAAS,CAACpB,QAAQ,EAAE;4BACvB3B,QAAQC,GAAG,CACT,CAAC,aAAa,EAAE0B,QAAQ,8CAA8C,CAAC;4BAEzE,yCAAyC;4BACzC,OAAO;gCACL,GAAGoB,SAAS;gCACZ,CAACpB,QAAQ,EAAE;oCACTe,MAAMA,QAAQ;oCACdC,YAAYA;oCACZC,WAAWd,mBAAmBM,EAAE;gCAClC;4BACF;wBACF;wBAEA,MAAMY,UAAU;4BAAE,GAAGD,SAAS;wBAAC;wBAE/B,IAAIJ,YAAY;4BACd,2EAA2E;4BAC3EK,OAAO,CAACrB,QAAQ,GAAG;gCAAE,GAAGqB,OAAO,CAACrB,QAAQ;gCAAEgB,YAAY;4BAAK;wBAC7D,OAAO;4BACL,qBAAqB;4BACrB,MAAMM,cAAcD,OAAO,CAACrB,QAAQ,EAAEe,QAAQ;4BAC9C,MAAMQ,UAAUR,QAAQ;4BACxBM,OAAO,CAACrB,QAAQ,GAAG;gCACjBe,MAAMO,cAAcC;gCACpBP,YAAY;gCACZC,WAAWd,mBAAmBM,EAAE;4BAClC;wBACF;wBAEA,OAAOY;oBACT;gBACF,EAAE,OAAOhE,OAAO;oBACdgB,QAAQhB,KAAK,CACX,CAAC,kDAAkD,EAAE2C,QAAQ,CAAC,CAAC,EAC/D3C;gBAEJ;YACF;YAEA,gDAAgD;YAChD,MAAMf,UAA2B;gBAC/B,GAAG2D,eAAe;gBAClBI,gBAAgB;gBAChBF;gBACAI,SAASW;gBACThC,oBAAoBhB;YACtB;YAEAG,QAAQC,GAAG,CACT,CAAC,oEAAoE,EAAE0B,QAAQ,CAAC;YAGlF,qBAAqB;YACrBrC,gBAAgBe,OAAO,CAACqB,kBAAkB,CAACC,SAAS1D;YAEpD+B,QAAQC,GAAG,CAAC,CAAC,8CAA8C,EAAE0B,QAAQ,CAAC;YACtE1C,SAAS,OAAO,4BAA4B;QAC9C,EAAE,OAAOkE,KAAK;YACZnD,QAAQhB,KAAK,CAAC,yCAAyCmE;YACvDlE,SACE,CAAC,6BAA6B,EAAE0C,QAAQ,EAAE,EAAEwB,eAAeC,QAAQD,IAAIpD,OAAO,GAAGsD,OAAOF,KAAK,CAAC;QAElG;IACF,GACA;QAACtD;KAAuB;IAG1B,oCAAoC;IACpC,MAAMyD,oBAAoBxD,IAAAA,kBAAW,EACnC,CAACC;QACC,4DAA4D;QAC5DU;QAEA,IAAI,CAACnB,gBAAgBe,OAAO,EAAE;YAC5BL,QAAQhB,KAAK,CACX;YAEFC,SAAS;YACT;QACF;QAEA,IAAI;YACF,6DAA6D;YAC7D,IACEO,gBAAgBa,OAAO,IACvB,CAACb,gBAAgBa,OAAO,CAAC8B,QAAQ,CAACoB,IAAI,CAAC,CAACC,IAAMA,EAAEpB,EAAE,KAAKrC,QAAQqC,EAAE,GACjE;gBACApC,QAAQC,GAAG,CAAC,CAAC,eAAe,EAAEF,QAAQqC,EAAE,CAAC,0BAA0B,CAAC;gBACpE5C,gBAAgBa,OAAO,GAAG;oBACxB,GAAGb,gBAAgBa,OAAO;oBAC1B8B,UAAU;2BAAI3C,gBAAgBa,OAAO,CAAC8B,QAAQ;wBAAEpC;qBAAQ;gBAC1D;YACF;YAEA,4EAA4E;YAC5E,IAAIA,QAAQyC,QAAQ,EAAED,SAAS,wBAAwB;gBACrDvC,QAAQC,GAAG,CAAC,4CAA4C;oBACtD2C,WAAW7C,QAAQqC,EAAE;oBACrBhC,UAAUL,QAAQK,QAAQ;oBAC1BF,SAASH,QAAQG,OAAO;oBACxBsC,UAAUzC,QAAQyC,QAAQ;oBAC1BiB,gBAAgBjE,gBAAgBa,OAAO,EAAE+B;oBACzCsB,kBAAkBlE,gBAAgBa,OAAO,EAAEsD,aAAanC;gBAC1D;gBAEA,oDAAoD;gBACpD,IAAIhC,gBAAgBa,OAAO,EAAE;oBAC3B,MAAMuD,mBAAmBnE,UAAUY,OAAO,CAACwD,MAAM,CAC/C,CAACC,QACCtE,gBAAgBa,OAAO,EAAEsD,aAAaI,SAASD,MAAM1B,EAAE,KACvD0B,MAAM1B,EAAE,KAAKrC,QAAQK,QAAQ;oBAGjCJ,QAAQC,GAAG,CACT,CAAC,MAAM,EAAE2D,iBAAiBpC,MAAM,CAAC,2CAA2C,CAAC,EAC7EoC,iBAAiBI,GAAG,CAAC,CAACC,IAAMA,EAAEC,IAAI;oBAGpC,IAAIN,iBAAiBpC,MAAM,KAAK,GAAG;wBACjCxB,QAAQhB,KAAK,CACX;oBAEJ;gBACF;YACF;YAEA,2BAA2B;YAC3BgB,QAAQC,GAAG,CAAC,CAAC,0CAA0C,EAAEF,QAAQqC,EAAE,CAAC,CAAC;YACrE9C,gBAAgBe,OAAO,CAACiD,iBAAiB,CAACvD;YAC1Cd,SAAS,OAAO,4BAA4B;QAC9C,EAAE,OAAOkE,KAAK;YACZnD,QAAQhB,KAAK,CAAC,6BAA6BmE;YAC3ClE,SACE,CAAC,2BAA2B,EAAEkE,eAAeC,QAAQD,IAAIpD,OAAO,GAAGsD,OAAOF,KAAK,CAAC;QAEpF;IACF,GACA;QAACtD;QAAwBU;KAAwB;IAGnD,mCAAmC;IACnC,MAAM4D,qBAAqBrE,IAAAA,kBAAW,EAAC;QACrC,IAAIR,gBAAgBe,OAAO,EAAE;YAC3Bf,gBAAgBe,OAAO,CAAC8D,kBAAkB;QAC5C;QACA,0BAA0B;QAC1BpF,gBAAgB,CAAC;QACjBE,SAAS,OAAO,4BAA4B;IAC9C,GAAG,EAAE;IAEL,uCAAuC;IACvC8B,IAAAA,gBAAS,EAAC;QACR,MAAMqD,eAAehD,YAAY;YAC/BrC,gBAAgB,CAAC0D;gBACf,MAAMO,UAAU;oBAAE,GAAGP,IAAI;gBAAC;gBAC1B,IAAI4B,UAAU;gBAEd,mEAAmE;gBACnEC,OAAOC,OAAO,CAACvB,SAASwB,OAAO,CAAC,CAAC,CAAC7C,SAAS8C,MAAM;oBAC/C,2DAA2D;oBAC3D,IACEA,MAAM9B,UAAU,IACf8B,MAAM/B,IAAI,IAAI+B,MAAM/B,IAAI,CAACqB,QAAQ,CAAC,oBAClC,CAACtF,iBAAiBsF,QAAQ,CAACpC,YAC1B,CAAC/C,aAAamF,QAAQ,CAACpC,UACzB;wBACA,OAAOqB,OAAO,CAACrB,QAAQ;wBACvB0C,UAAU;oBACZ;gBACF;gBAEA,OAAOA,UAAUrB,UAAUP;YAC7B;QACF,GAAG,MAAM,wBAAwB;QAEjC,OAAO,IAAMhB,cAAc2C;IAC7B,GAAG;QAAC3F;QAAkBG;KAAa;IAEnC,mFAAmF;IACnFmC,IAAAA,gBAAS,EAAC;QACR,IACE,CAAChD,gBACD,CAACA,aAAaoE,QAAQ,IACtBpE,aAAaoE,QAAQ,CAACX,MAAM,KAAK,GAEjC;QAEF,MAAMkD,gBACJ3G,aAAaoE,QAAQ,CAACpE,aAAaoE,QAAQ,CAACX,MAAM,GAAG,EAAE;QACzD,IAAI,CAACkD,eAAe;QAEpB,+EAA+E;QAC/E,MAAMC,kBAAkBD,cAActC,EAAE;QAExC,gDAAgD;QAChD,IAAIxC,oBAAoBS,OAAO,KAAKsE,iBAAiB;YACnD,QAAQ,uCAAuC;QACjD;QAEA,qDAAqD;QACrD,IAAID,cAAclC,QAAQ,EAAED,SAAS,wBAAwB;YAC3DvC,QAAQC,GAAG,CACT,qEACA;gBACE2C,WAAW8B,cAActC,EAAE;gBAC3BlC,SAASwE,cAAcxE,OAAO;gBAC9BE,UAAUsE,cAActE,QAAQ;gBAChCoC,UAAUkC,cAAclC,QAAQ;gBAChCiB,gBAAgB1F,cAAcqE;gBAC9BsB,kBAAkB3F,cAAc4F,aAAanC;gBAC7CoD,oBAAoB,CAAC,CAACtF,gBAAgBe,OAAO;gBAC7CjB,cAAcA;gBACdZ,WAAWA;YACb;YAGF,qDAAqD;YACrD,IAAI,CAACY,gBAAgB,CAACZ,aAAac,gBAAgBe,OAAO,EAAE;gBAC1DL,QAAQC,GAAG,CACT;gBAGF,uDAAuD;gBACvD,MAAM2D,mBAAmB5F,OAAO6F,MAAM,CACpC,CAACC,QACC/F,aAAa4F,YAAY,CAACI,QAAQ,CAACD,MAAM1B,EAAE,KAC3C0B,MAAM1B,EAAE,KAAKsC,cAActE,QAAQ;gBAGvCJ,QAAQC,GAAG,CACT,CAAC,iCAAiC,EAAE2D,iBAAiBpC,MAAM,CAAC,2CAA2C,CAAC,EACxGoC,iBAAiBI,GAAG,CAAC,CAACC,IAAMA,EAAEC,IAAI;gBAGpC,IAAIN,iBAAiBpC,MAAM,KAAK,GAAG;oBACjCxB,QAAQhB,KAAK,CACX;gBAEJ,OAAO;oBACL,qDAAqD;oBACrD4E,iBAAiBY,OAAO,CAAC,CAACV,OAAOe;wBAC/B7E,QAAQC,GAAG,CACT,CAAC,kDAAkD,EAAE6D,MAAMI,IAAI,CAAC,wBAAwB,CAAC;wBAE3F,IAAI;4BACF,oEAAoE;4BACpExC,mBAAmBoC,MAAM1B,EAAE,EAAE;gCAC3BN,oBAAoB4C;gCACpBI,eAAe,OAAOD,QAAQ;gCAC9B9C,OAAO;4BACT;wBACF,EAAE,OAAO/C,OAAO;4BACdgB,QAAQhB,KAAK,CACX,CAAC,uDAAuD,EAAE8E,MAAMI,IAAI,CAAC,CAAC,CAAC,EACvElF;wBAEJ;oBACF;gBACF;gBAEA,iCAAiC;gBACjCY,oBAAoBS,OAAO,GAAGsE;YAChC,OAAO;gBACL3E,QAAQC,GAAG,CACT,CAAC,gGAAgG,EAAE,CAAC,CAACX,gBAAgBe,OAAO,CAAC,eAAe,EAAEjB,aAAa,YAAY,EAAEZ,UAAU,CAAC;YAExL;QACF;QAEA,6BAA6B;QAC7B,IAAIkG,cAAclC,QAAQ,EAAEuC,iBAAiB;QAE7C,kCAAkC;QAClC,IAAIL,cAActE,QAAQ,KAAK,QAAQ;QAEvC,oDAAoD;QACpD,MAAM4E,kBAAkB,IAAIC;QAE5B,gGAAgG;QAChG,MAAMC,wBACJR,cAAcxE,OAAO,CAACiF,KAAK,CAAC;QAC9B,IAAID,uBAAuB;YACzB,MAAME,gBAAgBF,qBAAqB,CAAC,EAAE;YAC9C,MAAMpB,QAAQ9F,OAAOqH,IAAI,CACvB,CAACvB,QACCA,MAAMI,IAAI,CAACoB,WAAW,OAAOF,cAAcE,WAAW,MACtDxB,MAAMI,IAAI,CAACoB,WAAW,GAAGC,UAAU,CAACH,cAAcE,WAAW;YAEjE,IAAIxB,OAAOkB,gBAAgBQ,GAAG,CAAC1B;QACjC;QAEA,kDAAkD;QAClD,MAAM2B,mBAAmB;QACzB,MAAMC,aAAa;eAAIhB,cAAcxE,OAAO,CAACyF,QAAQ,CAACF;SAAkB;QAExE,KAAK,MAAMN,SAASO,WAAY;YAC9B,MAAME,gBAAgBT,KAAK,CAAC,EAAE;YAC9B,iDAAiD;YACjD,KAAK,MAAMrB,SAAS9F,OAAQ;gBAC1B,IACE8F,MAAMI,IAAI,CAACoB,WAAW,OAAOM,cAAcN,WAAW,MACtDxB,MAAMI,IAAI,CAACoB,WAAW,GAAGC,UAAU,CAACK,cAAcN,WAAW,KAC7D;oBACAN,gBAAgBQ,GAAG,CAAC1B;oBACpB;gBACF;YACF;QACF;QAEA,wEAAwE;QACxE,KAAK,MAAM+B,kBAAkBb,gBAAiB;YAC5C,IAAIjH,aAAa4F,YAAY,CAACI,QAAQ,CAAC8B,eAAezD,EAAE,GAAG;gBACzDV,mBAAmBmE,eAAezD,EAAE,EAAE;oBACpCN,oBAAoB4C;oBACpBI,eAAe;oBACf/C,OAAO;gBACT;YACF;QACF;QAEA,iCAAiC;QACjCnC,oBAAoBS,OAAO,GAAGsE;IAChC,GAAG;QAAC5G;QAAcC;QAAQQ;QAAWY;QAAcsC;KAAmB,GAAG,0BAA0B;IAEnG,wBAAwB;IACxB,OAAO;QACLA;QACA4B;QACAa;QACA1F;QACAG;QACAE;QACAI;QACAE,cAAcX,iBAAiB+C,MAAM,GAAG,KAAK5C,aAAa4C,MAAM,GAAG;QACnExC;IACF;AACF"}