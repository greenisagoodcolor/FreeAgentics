c03db9cf347fea63dc04722c6197bb97
/**
 * LLM Client Focused Coverage Tests
 * Target: Test actual LLM client functionality to boost coverage
 */ // Mock fetch globally
"use strict";
// Mock dynamic imports
jest.mock("@/lib/encryption", ()=>({
        encrypt: jest.fn((text)=>`encrypted_${text}`),
        decrypt: jest.fn((text)=>text.replace("encrypted_", ""))
    }));
jest.mock("@/lib/llm-errors", ()=>({
        RateLimitError: class extends Error {
            constructor(message){
                super(message);
                this.name = "RateLimitError";
            }
        },
        AuthenticationError: class extends Error {
            constructor(message){
                super(message);
                this.name = "AuthenticationError";
            }
        }
    }));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
global.fetch = jest.fn();
describe("LLM Client Coverage Boost", ()=>{
    beforeEach(()=>{
        global.fetch.mockClear();
    });
    it("imports LLMClient class successfully", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        expect(LLMClient).toBeDefined();
    });
    it("creates LLM client with valid config", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        expect(client.provider).toBe("openai");
    });
    it("validates provider on creation", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        expect(()=>{
            new LLMClient({
                provider: "invalid",
                apiKey: "test-key"
            });
        }).toThrow("Invalid provider");
    });
    it("handles secure storage option", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key",
            useSecureStorage: true
        });
        expect(client.provider).toBe("openai");
    });
    it("handles chat method with successful response", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: ()=>Promise.resolve({
                    choices: [
                        {
                            message: {
                                content: "test response"
                            }
                        }
                    ]
                })
        });
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        const response = await client.chat([
            {
                role: "user",
                content: "test"
            }
        ]);
        expect(response).toBeDefined();
        expect(global.fetch).toHaveBeenCalledWith("/api/llm/openai/chat/completions", expect.objectContaining({
            method: "POST",
            headers: expect.objectContaining({
                Authorization: "Bearer test-key"
            })
        }));
    });
    it("handles rate limit errors", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        global.fetch.mockResolvedValueOnce({
            ok: false,
            status: 429
        });
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        await expect(client.chat([
            {
                role: "user",
                content: "test"
            }
        ])).rejects.toThrow("Rate limit exceeded");
    });
    it("handles authentication errors", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        global.fetch.mockResolvedValueOnce({
            ok: false,
            status: 401
        });
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        await expect(client.chat([
            {
                role: "user",
                content: "test"
            }
        ])).rejects.toThrow("Invalid API key");
    });
    it("handles general request failures", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        global.fetch.mockResolvedValueOnce({
            ok: false,
            status: 500
        });
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        await expect(client.chat([
            {
                role: "user",
                content: "test"
            }
        ])).rejects.toThrow("Request failed");
    });
    it("handles chat streaming", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const mockBody = new ReadableStream();
        global.fetch.mockResolvedValueOnce({
            ok: true,
            body: mockBody
        });
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        const stream = await client.chatStream([
            {
                role: "user",
                content: "test"
            }
        ]);
        expect(stream).toBe(mockBody);
    });
    it("handles streaming with no response body", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        global.fetch.mockResolvedValueOnce({
            ok: true,
            body: null
        });
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        await expect(client.chatStream([
            {
                role: "user",
                content: "test"
            }
        ])).rejects.toThrow("No response body");
    });
    it("gets providers by priority", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const providers = [
            {
                provider: "openai",
                priority: 1
            },
            {
                provider: "anthropic",
                priority: 2
            }
        ];
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key",
            providers
        });
        expect(client.getProvidersByPriority()).toEqual(providers);
    });
    it("sets provider", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        await client.setProvider("anthropic");
        expect(client.provider).toBe("anthropic");
    });
    it("counts tokens", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        const count = client.countTokens("hello world test");
        expect(count).toBeGreaterThan(0);
        expect(typeof count).toBe("number");
    });
    it("clears cache", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        // Should not throw
        client.clearCache();
    });
    it("adds request interceptor", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        const interceptor = jest.fn();
        client.addRequestInterceptor(interceptor);
    });
    it("adds response interceptor", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        const interceptor = jest.fn();
        client.addResponseInterceptor(interceptor);
    });
    it("creates embeddings", async ()=>{
        const { LLMClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/llm-client")));
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: ()=>Promise.resolve({
                    data: [
                        {
                            embedding: [
                                0.1,
                                0.2,
                                0.3
                            ]
                        }
                    ]
                })
        });
        const client = new LLMClient({
            provider: "openai",
            apiKey: "test-key"
        });
        const embedding = await client.createEmbedding("test text");
        expect(Array.isArray(embedding)).toBe(true);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2xsbS1jbGllbnQtZm9jdXNlZC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTExNIENsaWVudCBGb2N1c2VkIENvdmVyYWdlIFRlc3RzXG4gKiBUYXJnZXQ6IFRlc3QgYWN0dWFsIExMTSBjbGllbnQgZnVuY3Rpb25hbGl0eSB0byBib29zdCBjb3ZlcmFnZVxuICovXG5cbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcbmdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKTtcblxuLy8gTW9jayBkeW5hbWljIGltcG9ydHNcbmplc3QubW9jayhcIkAvbGliL2VuY3J5cHRpb25cIiwgKCkgPT4gKHtcbiAgZW5jcnlwdDogamVzdC5mbigodGV4dCkgPT4gYGVuY3J5cHRlZF8ke3RleHR9YCksXG4gIGRlY3J5cHQ6IGplc3QuZm4oKHRleHQpID0+IHRleHQucmVwbGFjZShcImVuY3J5cHRlZF9cIiwgXCJcIikpLFxufSkpO1xuXG5qZXN0Lm1vY2soXCJAL2xpYi9sbG0tZXJyb3JzXCIsICgpID0+ICh7XG4gIFJhdGVMaW1pdEVycm9yOiBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5uYW1lID0gXCJSYXRlTGltaXRFcnJvclwiO1xuICAgIH1cbiAgfSxcbiAgQXV0aGVudGljYXRpb25FcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIHRoaXMubmFtZSA9IFwiQXV0aGVudGljYXRpb25FcnJvclwiO1xuICAgIH1cbiAgfSxcbn0pKTtcblxuZGVzY3JpYmUoXCJMTE0gQ2xpZW50IENvdmVyYWdlIEJvb3N0XCIsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBpdChcImltcG9ydHMgTExNQ2xpZW50IGNsYXNzIHN1Y2Nlc3NmdWxseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBMTE1DbGllbnQgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL2xsbS1jbGllbnRcIik7XG4gICAgZXhwZWN0KExMTUNsaWVudCkudG9CZURlZmluZWQoKTtcbiAgfSk7XG5cbiAgaXQoXCJjcmVhdGVzIExMTSBjbGllbnQgd2l0aCB2YWxpZCBjb25maWdcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgTExNQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9sbG0tY2xpZW50XCIpO1xuXG4gICAgY29uc3QgY2xpZW50ID0gbmV3IExMTUNsaWVudCh7XG4gICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgIGFwaUtleTogXCJ0ZXN0LWtleVwiLFxuICAgIH0pO1xuXG4gICAgZXhwZWN0KGNsaWVudC5wcm92aWRlcikudG9CZShcIm9wZW5haVwiKTtcbiAgfSk7XG5cbiAgaXQoXCJ2YWxpZGF0ZXMgcHJvdmlkZXIgb24gY3JlYXRpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgTExNQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9sbG0tY2xpZW50XCIpO1xuXG4gICAgZXhwZWN0KCgpID0+IHtcbiAgICAgIG5ldyBMTE1DbGllbnQoe1xuICAgICAgICBwcm92aWRlcjogXCJpbnZhbGlkXCIgYXMgYW55LFxuICAgICAgICBhcGlLZXk6IFwidGVzdC1rZXlcIixcbiAgICAgIH0pO1xuICAgIH0pLnRvVGhyb3coXCJJbnZhbGlkIHByb3ZpZGVyXCIpO1xuICB9KTtcblxuICBpdChcImhhbmRsZXMgc2VjdXJlIHN0b3JhZ2Ugb3B0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IExMTUNsaWVudCB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvbGxtLWNsaWVudFwiKTtcblxuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBMTE1DbGllbnQoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICBhcGlLZXk6IFwidGVzdC1rZXlcIixcbiAgICAgIHVzZVNlY3VyZVN0b3JhZ2U6IHRydWUsXG4gICAgfSk7XG5cbiAgICBleHBlY3QoY2xpZW50LnByb3ZpZGVyKS50b0JlKFwib3BlbmFpXCIpO1xuICB9KTtcblxuICBpdChcImhhbmRsZXMgY2hhdCBtZXRob2Qgd2l0aCBzdWNjZXNzZnVsIHJlc3BvbnNlXCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IExMTUNsaWVudCB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvbGxtLWNsaWVudFwiKTtcblxuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBqc29uOiAoKSA9PlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIGNob2ljZXM6IFt7IG1lc3NhZ2U6IHsgY29udGVudDogXCJ0ZXN0IHJlc3BvbnNlXCIgfSB9XSxcbiAgICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBjbGllbnQgPSBuZXcgTExNQ2xpZW50KHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haVwiLFxuICAgICAgYXBpS2V5OiBcInRlc3Qta2V5XCIsXG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5jaGF0KFt7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBcInRlc3RcIiB9XSk7XG4gICAgZXhwZWN0KHJlc3BvbnNlKS50b0JlRGVmaW5lZCgpO1xuICAgIGV4cGVjdChnbG9iYWwuZmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgXCIvYXBpL2xsbS9vcGVuYWkvY2hhdC9jb21wbGV0aW9uc1wiLFxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogXCJCZWFyZXIgdGVzdC1rZXlcIixcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICApO1xuICB9KTtcblxuICBpdChcImhhbmRsZXMgcmF0ZSBsaW1pdCBlcnJvcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgTExNQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9sbG0tY2xpZW50XCIpO1xuXG4gICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICBvazogZmFsc2UsXG4gICAgICBzdGF0dXM6IDQyOSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBMTE1DbGllbnQoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICBhcGlLZXk6IFwidGVzdC1rZXlcIixcbiAgICB9KTtcblxuICAgIGF3YWl0IGV4cGVjdChcbiAgICAgIGNsaWVudC5jaGF0KFt7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBcInRlc3RcIiB9XSksXG4gICAgKS5yZWplY3RzLnRvVGhyb3coXCJSYXRlIGxpbWl0IGV4Y2VlZGVkXCIpO1xuICB9KTtcblxuICBpdChcImhhbmRsZXMgYXV0aGVudGljYXRpb24gZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IExMTUNsaWVudCB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvbGxtLWNsaWVudFwiKTtcblxuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IGZhbHNlLFxuICAgICAgc3RhdHVzOiA0MDEsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjbGllbnQgPSBuZXcgTExNQ2xpZW50KHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haVwiLFxuICAgICAgYXBpS2V5OiBcInRlc3Qta2V5XCIsXG4gICAgfSk7XG5cbiAgICBhd2FpdCBleHBlY3QoXG4gICAgICBjbGllbnQuY2hhdChbeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogXCJ0ZXN0XCIgfV0pLFxuICAgICkucmVqZWN0cy50b1Rocm93KFwiSW52YWxpZCBBUEkga2V5XCIpO1xuICB9KTtcblxuICBpdChcImhhbmRsZXMgZ2VuZXJhbCByZXF1ZXN0IGZhaWx1cmVzXCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IExMTUNsaWVudCB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvbGxtLWNsaWVudFwiKTtcblxuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IGZhbHNlLFxuICAgICAgc3RhdHVzOiA1MDAsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjbGllbnQgPSBuZXcgTExNQ2xpZW50KHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haVwiLFxuICAgICAgYXBpS2V5OiBcInRlc3Qta2V5XCIsXG4gICAgfSk7XG5cbiAgICBhd2FpdCBleHBlY3QoXG4gICAgICBjbGllbnQuY2hhdChbeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogXCJ0ZXN0XCIgfV0pLFxuICAgICkucmVqZWN0cy50b1Rocm93KFwiUmVxdWVzdCBmYWlsZWRcIik7XG4gIH0pO1xuXG4gIGl0KFwiaGFuZGxlcyBjaGF0IHN0cmVhbWluZ1wiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBMTE1DbGllbnQgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL2xsbS1jbGllbnRcIik7XG5cbiAgICBjb25zdCBtb2NrQm9keSA9IG5ldyBSZWFkYWJsZVN0cmVhbSgpO1xuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBib2R5OiBtb2NrQm9keSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBMTE1DbGllbnQoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICBhcGlLZXk6IFwidGVzdC1rZXlcIixcbiAgICB9KTtcblxuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGNsaWVudC5jaGF0U3RyZWFtKFt7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBcInRlc3RcIiB9XSk7XG4gICAgZXhwZWN0KHN0cmVhbSkudG9CZShtb2NrQm9keSk7XG4gIH0pO1xuXG4gIGl0KFwiaGFuZGxlcyBzdHJlYW1pbmcgd2l0aCBubyByZXNwb25zZSBib2R5XCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IExMTUNsaWVudCB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvbGxtLWNsaWVudFwiKTtcblxuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBib2R5OiBudWxsLFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2xpZW50ID0gbmV3IExMTUNsaWVudCh7XG4gICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgIGFwaUtleTogXCJ0ZXN0LWtleVwiLFxuICAgIH0pO1xuXG4gICAgYXdhaXQgZXhwZWN0KFxuICAgICAgY2xpZW50LmNoYXRTdHJlYW0oW3sgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IFwidGVzdFwiIH1dKSxcbiAgICApLnJlamVjdHMudG9UaHJvdyhcIk5vIHJlc3BvbnNlIGJvZHlcIik7XG4gIH0pO1xuXG4gIGl0KFwiZ2V0cyBwcm92aWRlcnMgYnkgcHJpb3JpdHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgTExNQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9sbG0tY2xpZW50XCIpO1xuXG4gICAgY29uc3QgcHJvdmlkZXJzID0gW1xuICAgICAgeyBwcm92aWRlcjogXCJvcGVuYWlcIiwgcHJpb3JpdHk6IDEgfSxcbiAgICAgIHsgcHJvdmlkZXI6IFwiYW50aHJvcGljXCIsIHByaW9yaXR5OiAyIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBMTE1DbGllbnQoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICBhcGlLZXk6IFwidGVzdC1rZXlcIixcbiAgICAgIHByb3ZpZGVycyxcbiAgICB9KTtcblxuICAgIGV4cGVjdChjbGllbnQuZ2V0UHJvdmlkZXJzQnlQcmlvcml0eSgpKS50b0VxdWFsKHByb3ZpZGVycyk7XG4gIH0pO1xuXG4gIGl0KFwic2V0cyBwcm92aWRlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBMTE1DbGllbnQgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL2xsbS1jbGllbnRcIik7XG5cbiAgICBjb25zdCBjbGllbnQgPSBuZXcgTExNQ2xpZW50KHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haVwiLFxuICAgICAgYXBpS2V5OiBcInRlc3Qta2V5XCIsXG4gICAgfSk7XG5cbiAgICBhd2FpdCBjbGllbnQuc2V0UHJvdmlkZXIoXCJhbnRocm9waWNcIik7XG4gICAgZXhwZWN0KGNsaWVudC5wcm92aWRlcikudG9CZShcImFudGhyb3BpY1wiKTtcbiAgfSk7XG5cbiAgaXQoXCJjb3VudHMgdG9rZW5zXCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IExMTUNsaWVudCB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvbGxtLWNsaWVudFwiKTtcblxuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBMTE1DbGllbnQoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICBhcGlLZXk6IFwidGVzdC1rZXlcIixcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvdW50ID0gY2xpZW50LmNvdW50VG9rZW5zKFwiaGVsbG8gd29ybGQgdGVzdFwiKTtcbiAgICBleHBlY3QoY291bnQpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICBleHBlY3QodHlwZW9mIGNvdW50KS50b0JlKFwibnVtYmVyXCIpO1xuICB9KTtcblxuICBpdChcImNsZWFycyBjYWNoZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBMTE1DbGllbnQgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL2xsbS1jbGllbnRcIik7XG5cbiAgICBjb25zdCBjbGllbnQgPSBuZXcgTExNQ2xpZW50KHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haVwiLFxuICAgICAgYXBpS2V5OiBcInRlc3Qta2V5XCIsXG4gICAgfSk7XG5cbiAgICAvLyBTaG91bGQgbm90IHRocm93XG4gICAgY2xpZW50LmNsZWFyQ2FjaGUoKTtcbiAgfSk7XG5cbiAgaXQoXCJhZGRzIHJlcXVlc3QgaW50ZXJjZXB0b3JcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgTExNQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9sbG0tY2xpZW50XCIpO1xuXG4gICAgY29uc3QgY2xpZW50ID0gbmV3IExMTUNsaWVudCh7XG4gICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgIGFwaUtleTogXCJ0ZXN0LWtleVwiLFxuICAgIH0pO1xuXG4gICAgY29uc3QgaW50ZXJjZXB0b3IgPSBqZXN0LmZuKCk7XG4gICAgY2xpZW50LmFkZFJlcXVlc3RJbnRlcmNlcHRvcihpbnRlcmNlcHRvcik7XG4gIH0pO1xuXG4gIGl0KFwiYWRkcyByZXNwb25zZSBpbnRlcmNlcHRvclwiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBMTE1DbGllbnQgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL2xsbS1jbGllbnRcIik7XG5cbiAgICBjb25zdCBjbGllbnQgPSBuZXcgTExNQ2xpZW50KHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haVwiLFxuICAgICAgYXBpS2V5OiBcInRlc3Qta2V5XCIsXG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnRlcmNlcHRvciA9IGplc3QuZm4oKTtcbiAgICBjbGllbnQuYWRkUmVzcG9uc2VJbnRlcmNlcHRvcihpbnRlcmNlcHRvcik7XG4gIH0pO1xuXG4gIGl0KFwiY3JlYXRlcyBlbWJlZGRpbmdzXCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IExMTUNsaWVudCB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvbGxtLWNsaWVudFwiKTtcblxuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBbeyBlbWJlZGRpbmc6IFswLjEsIDAuMiwgMC4zXSB9XSB9KSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBMTE1DbGllbnQoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICBhcGlLZXk6IFwidGVzdC1rZXlcIixcbiAgICB9KTtcblxuICAgIGNvbnN0IGVtYmVkZGluZyA9IGF3YWl0IGNsaWVudC5jcmVhdGVFbWJlZGRpbmcoXCJ0ZXN0IHRleHRcIik7XG4gICAgZXhwZWN0KEFycmF5LmlzQXJyYXkoZW1iZWRkaW5nKSkudG9CZSh0cnVlKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImVuY3J5cHQiLCJmbiIsInRleHQiLCJkZWNyeXB0IiwicmVwbGFjZSIsIlJhdGVMaW1pdEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiQXV0aGVudGljYXRpb25FcnJvciIsImdsb2JhbCIsImZldGNoIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwibW9ja0NsZWFyIiwiaXQiLCJMTE1DbGllbnQiLCJleHBlY3QiLCJ0b0JlRGVmaW5lZCIsImNsaWVudCIsInByb3ZpZGVyIiwiYXBpS2V5IiwidG9CZSIsInRvVGhyb3ciLCJ1c2VTZWN1cmVTdG9yYWdlIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJqc29uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjaG9pY2VzIiwiY29udGVudCIsInJlc3BvbnNlIiwiY2hhdCIsInJvbGUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm9iamVjdENvbnRhaW5pbmciLCJtZXRob2QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInN0YXR1cyIsInJlamVjdHMiLCJtb2NrQm9keSIsIlJlYWRhYmxlU3RyZWFtIiwiYm9keSIsInN0cmVhbSIsImNoYXRTdHJlYW0iLCJwcm92aWRlcnMiLCJwcmlvcml0eSIsImdldFByb3ZpZGVyc0J5UHJpb3JpdHkiLCJ0b0VxdWFsIiwic2V0UHJvdmlkZXIiLCJjb3VudCIsImNvdW50VG9rZW5zIiwidG9CZUdyZWF0ZXJUaGFuIiwiY2xlYXJDYWNoZSIsImludGVyY2VwdG9yIiwiYWRkUmVxdWVzdEludGVyY2VwdG9yIiwiYWRkUmVzcG9uc2VJbnRlcmNlcHRvciIsImRhdGEiLCJlbWJlZGRpbmciLCJjcmVhdGVFbWJlZGRpbmciLCJBcnJheSIsImlzQXJyYXkiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQyxHQUVELHNCQUFzQjs7QUFHdEIsdUJBQXVCO0FBQ3ZCQSxLQUFLQyxJQUFJLENBQUMsb0JBQW9CLElBQU8sQ0FBQTtRQUNuQ0MsU0FBU0YsS0FBS0csRUFBRSxDQUFDLENBQUNDLE9BQVMsQ0FBQyxVQUFVLEVBQUVBLEtBQUssQ0FBQztRQUM5Q0MsU0FBU0wsS0FBS0csRUFBRSxDQUFDLENBQUNDLE9BQVNBLEtBQUtFLE9BQU8sQ0FBQyxjQUFjO0lBQ3hELENBQUE7QUFFQU4sS0FBS0MsSUFBSSxDQUFDLG9CQUFvQixJQUFPLENBQUE7UUFDbkNNLGdCQUFnQixjQUFjQztZQUM1QkMsWUFBWUMsT0FBZSxDQUFFO2dCQUMzQixLQUFLLENBQUNBO2dCQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1lBQ2Q7UUFDRjtRQUNBQyxxQkFBcUIsY0FBY0o7WUFD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