{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/knowledge-import.ts"],"sourcesContent":["import JSZip from \"jszip\";\nimport type { Agent, Conversation, KnowledgeEntry } from \"./types\";\nimport type { LLMSettings } from \"./llm-settings\";\nimport { createLogger } from \"./debug-logger\";\nimport { extractTagsFromMarkdown } from \"./utils\"; // Import the tag extraction utility\n\n// Create a module-specific logger\nconst logger = createLogger(\"knowledge-import\");\n\ninterface ImportOptions {\n  mode: \"replace\" | \"new\" | \"merge\" | \"settings-only\";\n  importSettings: boolean;\n  importApiKeys: boolean;\n  importConversations: boolean;\n}\n\ninterface ImportResult {\n  agents?: Agent[];\n  settings?: LLMSettings;\n  conversations?: Conversation[];\n}\n\n/**\n * Parse markdown content into a knowledge entry\n * @param content Markdown content\n * @param fileName File name for metadata extraction\n * @returns KnowledgeEntry object\n */\nexport function parseMarkdownToKnowledge(\n  content: string,\n  fileName: string,\n): KnowledgeEntry {\n  // Extract metadata from the markdown content\n  const metadataRegex = /^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n/;\n  const metadataMatch = content.match(metadataRegex);\n\n  let id = `knowledge-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;\n  let title = fileName.replace(/\\.md$/, \"\").replace(/-/g, \" \");\n  let tags: string[] = [];\n  let timestamp = new Date();\n\n  // Extract the content without the metadata section\n  let knowledgeContent = content;\n\n  if (metadataMatch) {\n    const metadataStr = metadataMatch[1];\n    const metadataLines = metadataStr.split(\"\\n\");\n\n    // Parse metadata\n    metadataLines.forEach((line) => {\n      const [key, value] = line.split(\":\").map((part) => part.trim());\n      if (!key || !value) return;\n\n      switch (key.toLowerCase()) {\n        case \"id\":\n          id = value;\n          break;\n        case \"title\":\n          title = value;\n          break;\n        case \"tags\":\n          tags = value.split(\",\").map((tag) => tag.trim());\n          break;\n        case \"timestamp\":\n        case \"created_at\":\n          try {\n            // Ensure we create a valid date\n            const parsedDate = new Date(value);\n            if (!isNaN(parsedDate.getTime())) {\n              timestamp = parsedDate;\n            } else {\n              logger.warn(\n                `Invalid date format in metadata: ${value}, using current date instead`,\n              );\n            }\n          } catch (e) {\n            logger.warn(\n              `Error parsing date in metadata: ${value}, using current date instead`,\n              e,\n            );\n          }\n          break;\n      }\n    });\n\n    // Remove metadata section from content\n    knowledgeContent = content.replace(metadataRegex, \"\").trim();\n  }\n\n  // Check for a title in the first heading of the markdown content\n  const titleMatch = knowledgeContent.match(/^# (.+)$/m);\n  if (titleMatch) {\n    // Use the heading as the title\n    title = titleMatch[1].trim();\n\n    // Remove the heading from the content to avoid duplication\n    knowledgeContent = knowledgeContent.replace(/^# .+$/m, \"\").trim();\n  }\n\n  // Extract tags from the content using the [[tag]] syntax\n  const extractedTags = extractTagsFromMarkdown(knowledgeContent);\n  if (extractedTags.length > 0) {\n    // Merge with any tags from metadata, removing duplicates\n    const allTags = [...new Set([...tags, ...extractedTags])];\n    tags = allTags;\n  }\n\n  logger.debug(`Parsed knowledge entry: ${title}`, {\n    id,\n    tagsCount: tags.length,\n    tags: tags.join(\", \"),\n    timestamp: timestamp.toISOString(),\n  });\n\n  return {\n    id,\n    title,\n    content: knowledgeContent,\n    timestamp,\n    tags,\n  };\n}\n\n/**\n * Import agents, settings, and conversations from a ZIP file\n * @param file ZIP file to import\n * @param options Import options\n * @returns Imported agents, settings, and conversations\n */\nexport async function importAgentsAndSettingsFromZip(\n  file: File,\n  options: ImportOptions,\n): Promise<ImportResult> {\n  try {\n    logger.info(\"Starting import from ZIP file\", {\n      fileName: file.name,\n      options,\n    });\n\n    // Load the ZIP file\n    const zip = new JSZip();\n    const zipContent = await zip.loadAsync(file);\n\n    // Initialize the result\n    const result: ImportResult = {};\n\n    // Import settings if requested\n    if (options.importSettings) {\n      const settingsFile = zipContent.files[\"settings.json\"];\n      if (settingsFile) {\n        const settingsJson = await settingsFile.async(\"string\");\n        const settings = JSON.parse(settingsJson) as LLMSettings;\n\n        // Handle API key if present and requested\n        if (options.importApiKeys && settings.apiKey) {\n          try {\n            logger.info(\"Storing imported API key securely\", {\n              provider: settings.provider,\n            });\n\n            // Use the API endpoint instead of calling storeApiKey directly\n            const response = await fetch(\"/api/api-key/store\", {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({\n                provider: settings.provider,\n                apiKey: settings.apiKey,\n              }),\n            });\n\n            if (!response.ok) {\n              logger.error(\n                `Error storing imported API key: HTTP ${response.status}`,\n              );\n              throw new Error(\n                `Failed to store API key: HTTP ${response.status}`,\n              );\n            }\n\n            const data = await response.json();\n\n            if (!data.success) {\n              logger.error(\"Failed to store imported API key:\", data.message);\n              throw new Error(`Failed to store API key: ${data.message}`);\n            }\n\n            // Get the session ID from the response\n            const sessionId = data.sessionId;\n\n            if (sessionId) {\n              // Store the session ID in localStorage (just like manual process)\n              localStorage.setItem(\n                `api_session_${settings.provider}`,\n                sessionId,\n              );\n              logger.info(\n                `Stored session ID in localStorage with key: api_session_${settings.provider}`,\n              );\n\n              // Update the settings with the session ID\n              settings.apiKeySessionId = sessionId;\n\n              // Remove the raw API key from the settings\n              delete settings.apiKey;\n\n              logger.info(\"Successfully stored imported API key\", {\n                provider: settings.provider,\n                sessionId,\n              });\n            } else {\n              logger.error(\n                \"Failed to store imported API key - no session ID returned\",\n              );\n            }\n          } catch (error) {\n            logger.error(\"Error storing imported API key\", error);\n            // Continue with import even if API key storage fails\n          }\n        } else if (settings.apiKey) {\n          // If not importing API keys, remove them from the settings\n          logger.info(\n            \"Removing API key from imported settings (not requested)\",\n          );\n          delete settings.apiKey;\n        }\n\n        result.settings = settings;\n        logger.info(\"Imported settings\", {\n          provider: settings.provider,\n          model: settings.model,\n        });\n      } else {\n        logger.warn(\"No settings.json found in the ZIP file\");\n      }\n    }\n\n    // Skip agent import if in settings-only mode\n    if (options.mode === \"settings-only\") {\n      logger.info(\"Settings-only mode, skipping agent import\");\n      return result;\n    }\n\n    // Import agents\n    const agentFiles = Object.keys(zipContent.files).filter(\n      (path) =>\n        path.startsWith(\"agents/\") &&\n        path !== \"agents/\" &&\n        path.endsWith(\".json\"),\n    );\n\n    if (agentFiles.length === 0) {\n      logger.warn(\"No agent files found in the ZIP file\");\n      return result;\n    }\n\n    // Process each agent file\n    const agents: Agent[] = [];\n    for (const agentFile of agentFiles) {\n      const agentJson = await zipContent.files[agentFile].async(\"string\");\n      const agent = JSON.parse(agentJson) as Agent;\n\n      // Look for knowledge entries for this agent\n      const knowledgeFolder = `knowledge/${agent.id}/`;\n      const knowledgeFiles = Object.keys(zipContent.files).filter(\n        (path) =>\n          path.startsWith(knowledgeFolder) &&\n          path !== knowledgeFolder &&\n          path.endsWith(\".md\"),\n      );\n\n      // Process each knowledge file\n      const knowledge: KnowledgeEntry[] = [];\n      for (const knowledgeFile of knowledgeFiles) {\n        try {\n          const markdownContent =\n            await zipContent.files[knowledgeFile].async(\"string\");\n          const fileName = knowledgeFile.split(\"/\").pop() || \"\";\n          const fileId = fileName.replace(\".md\", \"\");\n\n          // Use the parseMarkdownToKnowledge function which now extracts titles from headings\n          const parsedEntry = parseMarkdownToKnowledge(\n            markdownContent,\n            fileName,\n          );\n\n          // Preserve the file ID if no ID was found in the metadata or use the parsed ID\n          const entryId = parsedEntry.id.startsWith(\"knowledge-\")\n            ? fileId\n            : parsedEntry.id;\n\n          // Create the knowledge entry with all metadata including tags\n          knowledge.push({\n            ...parsedEntry,\n            id: entryId,\n          });\n\n          logger.debug(`Imported knowledge entry: ${parsedEntry.title}`, {\n            id: entryId,\n            tagsCount: parsedEntry.tags.length,\n            tags: parsedEntry.tags.join(\", \"),\n          });\n        } catch (error) {\n          logger.error(`Error parsing knowledge file ${knowledgeFile}:`, error);\n          // Continue with other knowledge files even if one fails\n        }\n      }\n\n      // Add the knowledge entries to the agent\n      agent.knowledge = knowledge;\n      agents.push(agent);\n    }\n\n    result.agents = agents;\n    logger.info(`Imported ${agents.length} agents`);\n\n    // Import conversations if requested\n    if (options.importConversations) {\n      const conversationFiles = Object.keys(zipContent.files).filter(\n        (path) =>\n          path.startsWith(\"conversations/\") &&\n          path !== \"conversations/\" &&\n          path.endsWith(\".json\"),\n      );\n\n      if (conversationFiles.length > 0) {\n        const conversations: Conversation[] = [];\n\n        for (const conversationFile of conversationFiles) {\n          try {\n            const conversationJson =\n              await zipContent.files[conversationFile].async(\"string\");\n            const conversation = JSON.parse(conversationJson) as Conversation;\n\n            // Ensure dates are properly parsed\n            conversation.startTime = new Date(conversation.startTime);\n            if (conversation.endTime) {\n              conversation.endTime = new Date(conversation.endTime);\n            }\n\n            // Ensure message timestamps are properly parsed\n            conversation.messages = conversation.messages.map((message) => ({\n              ...message,\n              timestamp: new Date(message.timestamp),\n            }));\n\n            conversations.push(conversation);\n          } catch (error) {\n            logger.error(\n              `Error parsing conversation file ${conversationFile}:`,\n              error,\n            );\n            // Continue with other conversations even if one fails\n          }\n        }\n\n        result.conversations = conversations;\n        logger.info(`Imported ${conversations.length} conversations`);\n      } else {\n        logger.warn(\"No conversation files found in the ZIP file\");\n      }\n    }\n\n    return result;\n  } catch (error) {\n    logger.error(\"Error importing from ZIP:\", error);\n    throw new Error(\n      `Failed to import from ZIP: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n\n/**\n * Merge imported agents with existing agents based on the selected mode\n * @param importedAgents Imported agents\n * @param existingAgents Existing agents\n * @param options Import options\n * @returns Merged agents\n */\nexport function mergeImportedAgents(\n  importedAgents: Agent[],\n  existingAgents: Agent[],\n  options: { mode: \"replace\" | \"new\" | \"merge\" },\n): Agent[] {\n  // Create a map of existing agents by ID for quick lookup\n  const existingAgentsMap = new Map<string, Agent>();\n  existingAgents.forEach((agent) => existingAgentsMap.set(agent.id, agent));\n\n  // Process imported agents based on the selected mode\n  switch (options.mode) {\n    case \"replace\":\n      // Replace existing agents with the same ID, keep others\n      return existingAgents\n        .map((agent) => {\n          const importedAgent = importedAgents.find((a) => a.id === agent.id);\n          return importedAgent || agent;\n        })\n        .concat(\n          // Add imported agents that don't exist yet\n          importedAgents.filter((agent) => !existingAgentsMap.has(agent.id)),\n        );\n\n    case \"new\":\n      // Add imported agents with new IDs to avoid conflicts\n      const maxId = Math.max(\n        ...existingAgents.map((a) => Number.parseInt(a.id) || 0),\n        0,\n      );\n      return [\n        ...existingAgents,\n        ...importedAgents.map((agent, index) => ({\n          ...agent,\n          id: `${maxId + index + 1}`,\n          inConversation: false,\n        })),\n      ];\n\n    case \"merge\":\n      // Merge knowledge from imported agents into existing agents with the same ID\n      return existingAgents\n        .map((agent) => {\n          const importedAgent = importedAgents.find((a) => a.id === agent.id);\n          if (!importedAgent) return agent;\n\n          // Create a set of existing knowledge entry IDs for quick lookup\n          const existingKnowledgeIds = new Set(\n            agent.knowledge.map((k) => k.id),\n          );\n\n          // Merge knowledge entries, avoiding duplicates\n          const mergedKnowledge = [\n            ...agent.knowledge,\n            ...importedAgent.knowledge.filter(\n              (k) => !existingKnowledgeIds.has(k.id),\n            ),\n          ];\n\n          return {\n            ...agent,\n            knowledge: mergedKnowledge,\n          };\n        })\n        .concat(\n          // Add imported agents that don't exist yet\n          importedAgents.filter((agent) => !existingAgentsMap.has(agent.id)),\n        );\n\n    default:\n      return existingAgents;\n  }\n}\n"],"names":["importAgentsAndSettingsFromZip","mergeImportedAgents","parseMarkdownToKnowledge","logger","createLogger","content","fileName","metadataRegex","metadataMatch","match","id","Date","now","Math","random","toString","substring","title","replace","tags","timestamp","knowledgeContent","metadataStr","metadataLines","split","forEach","line","key","value","map","part","trim","toLowerCase","tag","parsedDate","isNaN","getTime","warn","e","titleMatch","extractedTags","extractTagsFromMarkdown","length","allTags","Set","debug","tagsCount","join","toISOString","file","options","info","name","zip","JSZip","zipContent","loadAsync","result","importSettings","settingsFile","files","settingsJson","async","settings","JSON","parse","importApiKeys","apiKey","provider","response","fetch","method","headers","body","stringify","ok","error","status","Error","data","json","success","message","sessionId","localStorage","setItem","apiKeySessionId","model","mode","agentFiles","Object","keys","filter","path","startsWith","endsWith","agents","agentFile","agentJson","agent","knowledgeFolder","knowledgeFiles","knowledge","knowledgeFile","markdownContent","pop","fileId","parsedEntry","entryId","push","importConversations","conversationFiles","conversations","conversationFile","conversationJson","conversation","startTime","endTime","messages","String","importedAgents","existingAgents","existingAgentsMap","Map","set","importedAgent","find","a","concat","has","maxId","max","Number","parseInt","index","inConversation","existingKnowledgeIds","k","mergedKnowledge"],"mappings":"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"}