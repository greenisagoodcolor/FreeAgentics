c6f5d00ecfc3c307473c16e6bc0b590d
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    importAgentsAndSettingsFromZip: function() {
        return importAgentsAndSettingsFromZip;
    },
    mergeImportedAgents: function() {
        return mergeImportedAgents;
    },
    parseMarkdownToKnowledge: function() {
        return parseMarkdownToKnowledge;
    }
});
const _jszip = /*#__PURE__*/ _interop_require_default(require("jszip"));
const _debuglogger = require("./debug-logger");
const _utils = require("./utils");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Create a module-specific logger
const logger = (0, _debuglogger.createLogger)("knowledge-import");
function parseMarkdownToKnowledge(content, fileName) {
    // Extract metadata from the markdown content
    const metadataRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
    const metadataMatch = content.match(metadataRegex);
    let id = `knowledge-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    let title = fileName.replace(/\.md$/, "").replace(/-/g, " ");
    let tags = [];
    let timestamp = new Date();
    // Extract the content without the metadata section
    let knowledgeContent = content;
    if (metadataMatch) {
        const metadataStr = metadataMatch[1];
        const metadataLines = metadataStr.split("\n");
        // Parse metadata
        metadataLines.forEach((line)=>{
            const [key, value] = line.split(":").map((part)=>part.trim());
            if (!key || !value) return;
            switch(key.toLowerCase()){
                case "id":
                    id = value;
                    break;
                case "title":
                    title = value;
                    break;
                case "tags":
                    tags = value.split(",").map((tag)=>tag.trim());
                    break;
                case "timestamp":
                case "created_at":
                    try {
                        // Ensure we create a valid date
                        const parsedDate = new Date(value);
                        if (!isNaN(parsedDate.getTime())) {
                            timestamp = parsedDate;
                        } else {
                            logger.warn(`Invalid date format in metadata: ${value}, using current date instead`);
                        }
                    } catch (e) {
                        logger.warn(`Error parsing date in metadata: ${value}, using current date instead`, e);
                    }
                    break;
            }
        });
        // Remove metadata section from content
        knowledgeContent = content.replace(metadataRegex, "").trim();
    }
    // Check for a title in the first heading of the markdown content
    const titleMatch = knowledgeContent.match(/^# (.+)$/m);
    if (titleMatch) {
        // Use the heading as the title
        title = titleMatch[1].trim();
        // Remove the heading from the content to avoid duplication
        knowledgeContent = knowledgeContent.replace(/^# .+$/m, "").trim();
    }
    // Extract tags from the content using the [[tag]] syntax
    const extractedTags = (0, _utils.extractTagsFromMarkdown)(knowledgeContent);
    if (extractedTags.length > 0) {
        // Merge with any tags from metadata, removing duplicates
        const allTags = [
            ...new Set([
                ...tags,
                ...extractedTags
            ])
        ];
        tags = allTags;
    }
    logger.debug(`Parsed knowledge entry: ${title}`, {
        id,
        tagsCount: tags.length,
        tags: tags.join(", "),
        timestamp: timestamp.toISOString()
    });
    return {
        id,
        title,
        content: knowledgeContent,
        timestamp,
        tags
    };
}
async function importAgentsAndSettingsFromZip(file, options) {
    try {
        logger.info("Starting import from ZIP file", {
            fileName: file.name,
            options
        });
        // Load the ZIP file
        const zip = new _jszip.default();
        const zipContent = await zip.loadAsync(file);
        // Initialize the result
        const result = {};
        // Import settings if requested
        if (options.importSettings) {
            const settingsFile = zipContent.files["settings.json"];
            if (settingsFile) {
                const settingsJson = await settingsFile.async("string");
                const settings = JSON.parse(settingsJson);
                // Handle API key if present and requested
                if (options.importApiKeys && settings.apiKey) {
                    try {
                        logger.info("Storing imported API key securely", {
                            provider: settings.provider
                        });
                        // Use the API endpoint instead of calling storeApiKey directly
                        const response = await fetch("/api/api-key/store", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({
                                provider: settings.provider,
                                apiKey: settings.apiKey
                            })
                        });
                        if (!response.ok) {
                            logger.error(`Error storing imported API key: HTTP ${response.status}`);
                            throw new Error(`Failed to store API key: HTTP ${response.status}`);
                        }
                        const data = await response.json();
                        if (!data.success) {
                            logger.error("Failed to store imported API key:", data.message);
                            throw new Error(`Failed to store API key: ${data.message}`);
                        }
                        // Get the session ID from the response
                        const sessionId = data.sessionId;
                        if (sessionId) {
                            // Store the session ID in localStorage (just like manual process)
                            localStorage.setItem(`api_session_${settings.provider}`, sessionId);
                            logger.info(`Stored session ID in localStorage with key: api_session_${settings.provider}`);
                            // Update the settings with the session ID
                            settings.apiKeySessionId = sessionId;
                            // Remove the raw API key from the settings
                            delete settings.apiKey;
                            logger.info("Successfully stored imported API key", {
                                provider: settings.provider,
                                sessionId
                            });
                        } else {
                            logger.error("Failed to store imported API key - no session ID returned");
                        }
                    } catch (error) {
                        logger.error("Error storing imported API key", error);
                    // Continue with import even if API key storage fails
                    }
                } else if (settings.apiKey) {
                    // If not importing API keys, remove them from the settings
                    logger.info("Removing API key from imported settings (not requested)");
                    delete settings.apiKey;
                }
                result.settings = settings;
                logger.info("Imported settings", {
                    provider: settings.provider,
                    model: settings.model
                });
            } else {
                logger.warn("No settings.json found in the ZIP file");
            }
        }
        // Skip agent import if in settings-only mode
        if (options.mode === "settings-only") {
            logger.info("Settings-only mode, skipping agent import");
            return result;
        }
        // Import agents
        const agentFiles = Object.keys(zipContent.files).filter((path)=>path.startsWith("agents/") && path !== "agents/" && path.endsWith(".json"));
        if (agentFiles.length === 0) {
            logger.warn("No agent files found in the ZIP file");
            return result;
        }
        // Process each agent file
        const agents = [];
        for (const agentFile of agentFiles){
            const agentJson = await zipContent.files[agentFile].async("string");
            const agent = JSON.parse(agentJson);
            // Look for knowledge entries for this agent
            const knowledgeFolder = `knowledge/${agent.id}/`;
            const knowledgeFiles = Object.keys(zipContent.files).filter((path)=>path.startsWith(knowledgeFolder) && path !== knowledgeFolder && path.endsWith(".md"));
            // Process each knowledge file
            const knowledge = [];
            for (const knowledgeFile of knowledgeFiles){
                try {
                    const markdownContent = await zipContent.files[knowledgeFile].async("string");
                    const fileName = knowledgeFile.split("/").pop() || "";
                    const fileId = fileName.replace(".md", "");
                    // Use the parseMarkdownToKnowledge function which now extracts titles from headings
                    const parsedEntry = parseMarkdownToKnowledge(markdownContent, fileName);
                    // Preserve the file ID if no ID was found in the metadata or use the parsed ID
                    const entryId = parsedEntry.id.startsWith("knowledge-") ? fileId : parsedEntry.id;
                    // Create the knowledge entry with all metadata including tags
                    knowledge.push({
                        ...parsedEntry,
                        id: entryId
                    });
                    logger.debug(`Imported knowledge entry: ${parsedEntry.title}`, {
                        id: entryId,
                        tagsCount: parsedEntry.tags.length,
                        tags: parsedEntry.tags.join(", ")
                    });
                } catch (error) {
                    logger.error(`Error parsing knowledge file ${knowledgeFile}:`, error);
                // Continue with other knowledge files even if one fails
                }
            }
            // Add the knowledge entries to the agent
            agent.knowledge = knowledge;
            agents.push(agent);
        }
        result.agents = agents;
        logger.info(`Imported ${agents.length} agents`);
        // Import conversations if requested
        if (options.importConversations) {
            const conversationFiles = Object.keys(zipContent.files).filter((path)=>path.startsWith("conversations/") && path !== "conversations/" && path.endsWith(".json"));
            if (conversationFiles.length > 0) {
                const conversations = [];
                for (const conversationFile of conversationFiles){
                    try {
                        const conversationJson = await zipContent.files[conversationFile].async("string");
                        const conversation = JSON.parse(conversationJson);
                        // Ensure dates are properly parsed
                        conversation.startTime = new Date(conversation.startTime);
                        if (conversation.endTime) {
                            conversation.endTime = new Date(conversation.endTime);
                        }
                        // Ensure message timestamps are properly parsed
                        conversation.messages = conversation.messages.map((message)=>({
                                ...message,
                                timestamp: new Date(message.timestamp)
                            }));
                        conversations.push(conversation);
                    } catch (error) {
                        logger.error(`Error parsing conversation file ${conversationFile}:`, error);
                    // Continue with other conversations even if one fails
                    }
                }
                result.conversations = conversations;
                logger.info(`Imported ${conversations.length} conversations`);
            } else {
                logger.warn("No conversation files found in the ZIP file");
            }
        }
        return result;
    } catch (error) {
        logger.error("Error importing from ZIP:", error);
        throw new Error(`Failed to import from ZIP: ${error instanceof Error ? error.message : String(error)}`);
    }
}
function mergeImportedAgents(importedAgents, existingAgents, options) {
    // Create a map of existing agents by ID for quick lookup
    const existingAgentsMap = new Map();
    existingAgents.forEach((agent)=>existingAgentsMap.set(agent.id, agent));
    // Process imported agents based on the selected mode
    switch(options.mode){
        case "replace":
            // Replace existing agents with the same ID, keep others
            return existingAgents.map((agent)=>{
                const importedAgent = importedAgents.find((a)=>a.id === agent.id);
                return importedAgent || agent;
            }).concat(// Add imported agents that don't exist yet
            importedAgents.filter((agent)=>!existingAgentsMap.has(agent.id)));
        case "new":
            // Add imported agents with new IDs to avoid conflicts
            const maxId = Math.max(...existingAgents.map((a)=>Number.parseInt(a.id) || 0), 0);
            return [
                ...existingAgents,
                ...importedAgents.map((agent, index)=>({
                        ...agent,
                        id: `${maxId + index + 1}`,
                        inConversation: false
                    }))
            ];
        case "merge":
            // Merge knowledge from imported agents into existing agents with the same ID
            return existingAgents.map((agent)=>{
                const importedAgent = importedAgents.find((a)=>a.id === agent.id);
                if (!importedAgent) return agent;
                // Create a set of existing knowledge entry IDs for quick lookup
                const existingKnowledgeIds = new Set(agent.knowledge.map((k)=>k.id));
                // Merge knowledge entries, avoiding duplicates
                const mergedKnowledge = [
                    ...agent.knowledge,
                    ...importedAgent.knowledge.filter((k)=>!existingKnowledgeIds.has(k.id))
                ];
                return {
                    ...agent,
                    knowledge: mergedKnowledge
                };
            }).concat(// Add imported agents that don't exist yet
            importedAgents.filter((agent)=>!existingAgentsMap.has(agent.id)));
        default:
            return existingAgents;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIva25vd2xlZGdlLWltcG9ydC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSlNaaXAgZnJvbSBcImpzemlwXCI7XG5pbXBvcnQgdHlwZSB7IEFnZW50LCBDb252ZXJzYXRpb24sIEtub3dsZWRnZUVudHJ5IH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB0eXBlIHsgTExNU2V0dGluZ3MgfSBmcm9tIFwiLi9sbG0tc2V0dGluZ3NcIjtcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciB9IGZyb20gXCIuL2RlYnVnLWxvZ2dlclwiO1xuaW1wb3J0IHsgZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24gfSBmcm9tIFwiLi91dGlsc1wiOyAvLyBJbXBvcnQgdGhlIHRhZyBleHRyYWN0aW9uIHV0aWxpdHlcblxuLy8gQ3JlYXRlIGEgbW9kdWxlLXNwZWNpZmljIGxvZ2dlclxuY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKFwia25vd2xlZGdlLWltcG9ydFwiKTtcblxuaW50ZXJmYWNlIEltcG9ydE9wdGlvbnMge1xuICBtb2RlOiBcInJlcGxhY2VcIiB8IFwibmV3XCIgfCBcIm1lcmdlXCIgfCBcInNldHRpbmdzLW9ubHlcIjtcbiAgaW1wb3J0U2V0dGluZ3M6IGJvb2xlYW47XG4gIGltcG9ydEFwaUtleXM6IGJvb2xlYW47XG4gIGltcG9ydENvbnZlcnNhdGlvbnM6IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBJbXBvcnRSZXN1bHQge1xuICBhZ2VudHM/OiBBZ2VudFtdO1xuICBzZXR0aW5ncz86IExMTVNldHRpbmdzO1xuICBjb252ZXJzYXRpb25zPzogQ29udmVyc2F0aW9uW107XG59XG5cbi8qKlxuICogUGFyc2UgbWFya2Rvd24gY29udGVudCBpbnRvIGEga25vd2xlZGdlIGVudHJ5XG4gKiBAcGFyYW0gY29udGVudCBNYXJrZG93biBjb250ZW50XG4gKiBAcGFyYW0gZmlsZU5hbWUgRmlsZSBuYW1lIGZvciBtZXRhZGF0YSBleHRyYWN0aW9uXG4gKiBAcmV0dXJucyBLbm93bGVkZ2VFbnRyeSBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWFya2Rvd25Ub0tub3dsZWRnZShcbiAgY29udGVudDogc3RyaW5nLFxuICBmaWxlTmFtZTogc3RyaW5nLFxuKTogS25vd2xlZGdlRW50cnkge1xuICAvLyBFeHRyYWN0IG1ldGFkYXRhIGZyb20gdGhlIG1hcmtkb3duIGNvbnRlbnRcbiAgY29uc3QgbWV0YWRhdGFSZWdleCA9IC9eLS0tXFxzKlxcbihbXFxzXFxTXSo/KVxcbi0tLVxccypcXG4vO1xuICBjb25zdCBtZXRhZGF0YU1hdGNoID0gY29udGVudC5tYXRjaChtZXRhZGF0YVJlZ2V4KTtcblxuICBsZXQgaWQgPSBga25vd2xlZGdlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNyl9YDtcbiAgbGV0IHRpdGxlID0gZmlsZU5hbWUucmVwbGFjZSgvXFwubWQkLywgXCJcIikucmVwbGFjZSgvLS9nLCBcIiBcIik7XG4gIGxldCB0YWdzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblxuICAvLyBFeHRyYWN0IHRoZSBjb250ZW50IHdpdGhvdXQgdGhlIG1ldGFkYXRhIHNlY3Rpb25cbiAgbGV0IGtub3dsZWRnZUNvbnRlbnQgPSBjb250ZW50O1xuXG4gIGlmIChtZXRhZGF0YU1hdGNoKSB7XG4gICAgY29uc3QgbWV0YWRhdGFTdHIgPSBtZXRhZGF0YU1hdGNoWzFdO1xuICAgIGNvbnN0IG1ldGFkYXRhTGluZXMgPSBtZXRhZGF0YVN0ci5zcGxpdChcIlxcblwiKTtcblxuICAgIC8vIFBhcnNlIG1ldGFkYXRhXG4gICAgbWV0YWRhdGFMaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBsaW5lLnNwbGl0KFwiOlwiKS5tYXAoKHBhcnQpID0+IHBhcnQudHJpbSgpKTtcbiAgICAgIGlmICgha2V5IHx8ICF2YWx1ZSkgcmV0dXJuO1xuXG4gICAgICBzd2l0Y2ggKGtleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGlkID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgIHRpdGxlID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0YWdzXCI6XG4gICAgICAgICAgdGFncyA9IHZhbHVlLnNwbGl0KFwiLFwiKS5tYXAoKHRhZykgPT4gdGFnLnRyaW0oKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0aW1lc3RhbXBcIjpcbiAgICAgICAgY2FzZSBcImNyZWF0ZWRfYXRcIjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGNyZWF0ZSBhIHZhbGlkIGRhdGVcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZERhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBwYXJzZWREYXRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgYEludmFsaWQgZGF0ZSBmb3JtYXQgaW4gbWV0YWRhdGE6ICR7dmFsdWV9LCB1c2luZyBjdXJyZW50IGRhdGUgaW5zdGVhZGAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgIGBFcnJvciBwYXJzaW5nIGRhdGUgaW4gbWV0YWRhdGE6ICR7dmFsdWV9LCB1c2luZyBjdXJyZW50IGRhdGUgaW5zdGVhZGAsXG4gICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSBtZXRhZGF0YSBzZWN0aW9uIGZyb20gY29udGVudFxuICAgIGtub3dsZWRnZUNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UobWV0YWRhdGFSZWdleCwgXCJcIikudHJpbSgpO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGEgdGl0bGUgaW4gdGhlIGZpcnN0IGhlYWRpbmcgb2YgdGhlIG1hcmtkb3duIGNvbnRlbnRcbiAgY29uc3QgdGl0bGVNYXRjaCA9IGtub3dsZWRnZUNvbnRlbnQubWF0Y2goL14jICguKykkL20pO1xuICBpZiAodGl0bGVNYXRjaCkge1xuICAgIC8vIFVzZSB0aGUgaGVhZGluZyBhcyB0aGUgdGl0bGVcbiAgICB0aXRsZSA9IHRpdGxlTWF0Y2hbMV0udHJpbSgpO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBoZWFkaW5nIGZyb20gdGhlIGNvbnRlbnQgdG8gYXZvaWQgZHVwbGljYXRpb25cbiAgICBrbm93bGVkZ2VDb250ZW50ID0ga25vd2xlZGdlQ29udGVudC5yZXBsYWNlKC9eIyAuKyQvbSwgXCJcIikudHJpbSgpO1xuICB9XG5cbiAgLy8gRXh0cmFjdCB0YWdzIGZyb20gdGhlIGNvbnRlbnQgdXNpbmcgdGhlIFtbdGFnXV0gc3ludGF4XG4gIGNvbnN0IGV4dHJhY3RlZFRhZ3MgPSBleHRyYWN0VGFnc0Zyb21NYXJrZG93bihrbm93bGVkZ2VDb250ZW50KTtcbiAgaWYgKGV4dHJhY3RlZFRhZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIE1lcmdlIHdpdGggYW55IHRhZ3MgZnJvbSBtZXRhZGF0YSwgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICAgIGNvbnN0IGFsbFRhZ3MgPSBbLi4ubmV3IFNldChbLi4udGFncywgLi4uZXh0cmFjdGVkVGFnc10pXTtcbiAgICB0YWdzID0gYWxsVGFncztcbiAgfVxuXG4gIGxvZ2dlci5kZWJ1ZyhgUGFyc2VkIGtub3dsZWRnZSBlbnRyeTogJHt0aXRsZX1gLCB7XG4gICAgaWQsXG4gICAgdGFnc0NvdW50OiB0YWdzLmxlbmd0aCxcbiAgICB0YWdzOiB0YWdzLmpvaW4oXCIsIFwiKSxcbiAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHRpdGxlLFxuICAgIGNvbnRlbnQ6IGtub3dsZWRnZUNvbnRlbnQsXG4gICAgdGltZXN0YW1wLFxuICAgIHRhZ3MsXG4gIH07XG59XG5cbi8qKlxuICogSW1wb3J0IGFnZW50cywgc2V0dGluZ3MsIGFuZCBjb252ZXJzYXRpb25zIGZyb20gYSBaSVAgZmlsZVxuICogQHBhcmFtIGZpbGUgWklQIGZpbGUgdG8gaW1wb3J0XG4gKiBAcGFyYW0gb3B0aW9ucyBJbXBvcnQgb3B0aW9uc1xuICogQHJldHVybnMgSW1wb3J0ZWQgYWdlbnRzLCBzZXR0aW5ncywgYW5kIGNvbnZlcnNhdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcG9ydEFnZW50c0FuZFNldHRpbmdzRnJvbVppcChcbiAgZmlsZTogRmlsZSxcbiAgb3B0aW9uczogSW1wb3J0T3B0aW9ucyxcbik6IFByb21pc2U8SW1wb3J0UmVzdWx0PiB7XG4gIHRyeSB7XG4gICAgbG9nZ2VyLmluZm8oXCJTdGFydGluZyBpbXBvcnQgZnJvbSBaSVAgZmlsZVwiLCB7XG4gICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgb3B0aW9ucyxcbiAgICB9KTtcblxuICAgIC8vIExvYWQgdGhlIFpJUCBmaWxlXG4gICAgY29uc3QgemlwID0gbmV3IEpTWmlwKCk7XG4gICAgY29uc3QgemlwQ29udGVudCA9IGF3YWl0IHppcC5sb2FkQXN5bmMoZmlsZSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSByZXN1bHRcbiAgICBjb25zdCByZXN1bHQ6IEltcG9ydFJlc3VsdCA9IHt9O1xuXG4gICAgLy8gSW1wb3J0IHNldHRpbmdzIGlmIHJlcXVlc3RlZFxuICAgIGlmIChvcHRpb25zLmltcG9ydFNldHRpbmdzKSB7XG4gICAgICBjb25zdCBzZXR0aW5nc0ZpbGUgPSB6aXBDb250ZW50LmZpbGVzW1wic2V0dGluZ3MuanNvblwiXTtcbiAgICAgIGlmIChzZXR0aW5nc0ZpbGUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3NKc29uID0gYXdhaXQgc2V0dGluZ3NGaWxlLmFzeW5jKFwic3RyaW5nXCIpO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2V0dGluZ3NKc29uKSBhcyBMTE1TZXR0aW5ncztcblxuICAgICAgICAvLyBIYW5kbGUgQVBJIGtleSBpZiBwcmVzZW50IGFuZCByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKG9wdGlvbnMuaW1wb3J0QXBpS2V5cyAmJiBzZXR0aW5ncy5hcGlLZXkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJTdG9yaW5nIGltcG9ydGVkIEFQSSBrZXkgc2VjdXJlbHlcIiwge1xuICAgICAgICAgICAgICBwcm92aWRlcjogc2V0dGluZ3MucHJvdmlkZXIsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBBUEkgZW5kcG9pbnQgaW5zdGVhZCBvZiBjYWxsaW5nIHN0b3JlQXBpS2V5IGRpcmVjdGx5XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS9hcGkta2V5L3N0b3JlXCIsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHNldHRpbmdzLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIGFwaUtleTogc2V0dGluZ3MuYXBpS2V5LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICBgRXJyb3Igc3RvcmluZyBpbXBvcnRlZCBBUEkga2V5OiBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIHN0b3JlIEFQSSBrZXk6IEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHN0b3JlIGltcG9ydGVkIEFQSSBrZXk6XCIsIGRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN0b3JlIEFQSSBrZXk6ICR7ZGF0YS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHNlc3Npb24gSUQgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IGRhdGEuc2Vzc2lvbklkO1xuXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBzZXNzaW9uIElEIGluIGxvY2FsU3RvcmFnZSAoanVzdCBsaWtlIG1hbnVhbCBwcm9jZXNzKVxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICAgICBgYXBpX3Nlc3Npb25fJHtzZXR0aW5ncy5wcm92aWRlcn1gLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgYFN0b3JlZCBzZXNzaW9uIElEIGluIGxvY2FsU3RvcmFnZSB3aXRoIGtleTogYXBpX3Nlc3Npb25fJHtzZXR0aW5ncy5wcm92aWRlcn1gLFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2V0dGluZ3Mgd2l0aCB0aGUgc2Vzc2lvbiBJRFxuICAgICAgICAgICAgICBzZXR0aW5ncy5hcGlLZXlTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG5cbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByYXcgQVBJIGtleSBmcm9tIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAgICBkZWxldGUgc2V0dGluZ3MuYXBpS2V5O1xuXG4gICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiU3VjY2Vzc2Z1bGx5IHN0b3JlZCBpbXBvcnRlZCBBUEkga2V5XCIsIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogc2V0dGluZ3MucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkZhaWxlZCB0byBzdG9yZSBpbXBvcnRlZCBBUEkga2V5IC0gbm8gc2Vzc2lvbiBJRCByZXR1cm5lZFwiLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBzdG9yaW5nIGltcG9ydGVkIEFQSSBrZXlcIiwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCBpbXBvcnQgZXZlbiBpZiBBUEkga2V5IHN0b3JhZ2UgZmFpbHNcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYXBpS2V5KSB7XG4gICAgICAgICAgLy8gSWYgbm90IGltcG9ydGluZyBBUEkga2V5cywgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2V0dGluZ3NcbiAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIFwiUmVtb3ZpbmcgQVBJIGtleSBmcm9tIGltcG9ydGVkIHNldHRpbmdzIChub3QgcmVxdWVzdGVkKVwiLFxuICAgICAgICAgICk7XG4gICAgICAgICAgZGVsZXRlIHNldHRpbmdzLmFwaUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIkltcG9ydGVkIHNldHRpbmdzXCIsIHtcbiAgICAgICAgICBwcm92aWRlcjogc2V0dGluZ3MucHJvdmlkZXIsXG4gICAgICAgICAgbW9kZWw6IHNldHRpbmdzLm1vZGVsLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiTm8gc2V0dGluZ3MuanNvbiBmb3VuZCBpbiB0aGUgWklQIGZpbGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2tpcCBhZ2VudCBpbXBvcnQgaWYgaW4gc2V0dGluZ3Mtb25seSBtb2RlXG4gICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gXCJzZXR0aW5ncy1vbmx5XCIpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiU2V0dGluZ3Mtb25seSBtb2RlLCBza2lwcGluZyBhZ2VudCBpbXBvcnRcIik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEltcG9ydCBhZ2VudHNcbiAgICBjb25zdCBhZ2VudEZpbGVzID0gT2JqZWN0LmtleXMoemlwQ29udGVudC5maWxlcykuZmlsdGVyKFxuICAgICAgKHBhdGgpID0+XG4gICAgICAgIHBhdGguc3RhcnRzV2l0aChcImFnZW50cy9cIikgJiZcbiAgICAgICAgcGF0aCAhPT0gXCJhZ2VudHMvXCIgJiZcbiAgICAgICAgcGF0aC5lbmRzV2l0aChcIi5qc29uXCIpLFxuICAgICk7XG5cbiAgICBpZiAoYWdlbnRGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKFwiTm8gYWdlbnQgZmlsZXMgZm91bmQgaW4gdGhlIFpJUCBmaWxlXCIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGVhY2ggYWdlbnQgZmlsZVxuICAgIGNvbnN0IGFnZW50czogQWdlbnRbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgYWdlbnRGaWxlIG9mIGFnZW50RmlsZXMpIHtcbiAgICAgIGNvbnN0IGFnZW50SnNvbiA9IGF3YWl0IHppcENvbnRlbnQuZmlsZXNbYWdlbnRGaWxlXS5hc3luYyhcInN0cmluZ1wiKTtcbiAgICAgIGNvbnN0IGFnZW50ID0gSlNPTi5wYXJzZShhZ2VudEpzb24pIGFzIEFnZW50O1xuXG4gICAgICAvLyBMb29rIGZvciBrbm93bGVkZ2UgZW50cmllcyBmb3IgdGhpcyBhZ2VudFxuICAgICAgY29uc3Qga25vd2xlZGdlRm9sZGVyID0gYGtub3dsZWRnZS8ke2FnZW50LmlkfS9gO1xuICAgICAgY29uc3Qga25vd2xlZGdlRmlsZXMgPSBPYmplY3Qua2V5cyh6aXBDb250ZW50LmZpbGVzKS5maWx0ZXIoXG4gICAgICAgIChwYXRoKSA9PlxuICAgICAgICAgIHBhdGguc3RhcnRzV2l0aChrbm93bGVkZ2VGb2xkZXIpICYmXG4gICAgICAgICAgcGF0aCAhPT0ga25vd2xlZGdlRm9sZGVyICYmXG4gICAgICAgICAgcGF0aC5lbmRzV2l0aChcIi5tZFwiKSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBrbm93bGVkZ2UgZmlsZVxuICAgICAgY29uc3Qga25vd2xlZGdlOiBLbm93bGVkZ2VFbnRyeVtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtub3dsZWRnZUZpbGUgb2Yga25vd2xlZGdlRmlsZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBtYXJrZG93bkNvbnRlbnQgPVxuICAgICAgICAgICAgYXdhaXQgemlwQ29udGVudC5maWxlc1trbm93bGVkZ2VGaWxlXS5hc3luYyhcInN0cmluZ1wiKTtcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGtub3dsZWRnZUZpbGUuc3BsaXQoXCIvXCIpLnBvcCgpIHx8IFwiXCI7XG4gICAgICAgICAgY29uc3QgZmlsZUlkID0gZmlsZU5hbWUucmVwbGFjZShcIi5tZFwiLCBcIlwiKTtcblxuICAgICAgICAgIC8vIFVzZSB0aGUgcGFyc2VNYXJrZG93blRvS25vd2xlZGdlIGZ1bmN0aW9uIHdoaWNoIG5vdyBleHRyYWN0cyB0aXRsZXMgZnJvbSBoZWFkaW5nc1xuICAgICAgICAgIGNvbnN0IHBhcnNlZEVudHJ5ID0gcGFyc2VNYXJrZG93blRvS25vd2xlZGdlKFxuICAgICAgICAgICAgbWFya2Rvd25Db250ZW50LFxuICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBmaWxlIElEIGlmIG5vIElEIHdhcyBmb3VuZCBpbiB0aGUgbWV0YWRhdGEgb3IgdXNlIHRoZSBwYXJzZWQgSURcbiAgICAgICAgICBjb25zdCBlbnRyeUlkID0gcGFyc2VkRW50cnkuaWQuc3RhcnRzV2l0aChcImtub3dsZWRnZS1cIilcbiAgICAgICAgICAgID8gZmlsZUlkXG4gICAgICAgICAgICA6IHBhcnNlZEVudHJ5LmlkO1xuXG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBrbm93bGVkZ2UgZW50cnkgd2l0aCBhbGwgbWV0YWRhdGEgaW5jbHVkaW5nIHRhZ3NcbiAgICAgICAgICBrbm93bGVkZ2UucHVzaCh7XG4gICAgICAgICAgICAuLi5wYXJzZWRFbnRyeSxcbiAgICAgICAgICAgIGlkOiBlbnRyeUlkLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKGBJbXBvcnRlZCBrbm93bGVkZ2UgZW50cnk6ICR7cGFyc2VkRW50cnkudGl0bGV9YCwge1xuICAgICAgICAgICAgaWQ6IGVudHJ5SWQsXG4gICAgICAgICAgICB0YWdzQ291bnQ6IHBhcnNlZEVudHJ5LnRhZ3MubGVuZ3RoLFxuICAgICAgICAgICAgdGFnczogcGFyc2VkRW50cnkudGFncy5qb2luKFwiLCBcIiksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciBwYXJzaW5nIGtub3dsZWRnZSBmaWxlICR7a25vd2xlZGdlRmlsZX06YCwgZXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIga25vd2xlZGdlIGZpbGVzIGV2ZW4gaWYgb25lIGZhaWxzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSBrbm93bGVkZ2UgZW50cmllcyB0byB0aGUgYWdlbnRcbiAgICAgIGFnZW50Lmtub3dsZWRnZSA9IGtub3dsZWRnZTtcbiAgICAgIGFnZW50cy5wdXNoKGFnZW50KTtcbiAgICB9XG5cbiAgICByZXN1bHQuYWdlbnRzID0gYWdlbnRzO1xuICAgIGxvZ2dlci5pbmZvKGBJbXBvcnRlZCAke2FnZW50cy5sZW5ndGh9IGFnZW50c2ApO1xuXG4gICAgLy8gSW1wb3J0IGNvbnZlcnNhdGlvbnMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKG9wdGlvbnMuaW1wb3J0Q29udmVyc2F0aW9ucykge1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uRmlsZXMgPSBPYmplY3Qua2V5cyh6aXBDb250ZW50LmZpbGVzKS5maWx0ZXIoXG4gICAgICAgIChwYXRoKSA9PlxuICAgICAgICAgIHBhdGguc3RhcnRzV2l0aChcImNvbnZlcnNhdGlvbnMvXCIpICYmXG4gICAgICAgICAgcGF0aCAhPT0gXCJjb252ZXJzYXRpb25zL1wiICYmXG4gICAgICAgICAgcGF0aC5lbmRzV2l0aChcIi5qc29uXCIpLFxuICAgICAgKTtcblxuICAgICAgaWYgKGNvbnZlcnNhdGlvbkZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uczogQ29udmVyc2F0aW9uW10gPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGNvbnZlcnNhdGlvbkZpbGUgb2YgY29udmVyc2F0aW9uRmlsZXMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9uSnNvbiA9XG4gICAgICAgICAgICAgIGF3YWl0IHppcENvbnRlbnQuZmlsZXNbY29udmVyc2F0aW9uRmlsZV0uYXN5bmMoXCJzdHJpbmdcIik7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb24gPSBKU09OLnBhcnNlKGNvbnZlcnNhdGlvbkpzb24pIGFzIENvbnZlcnNhdGlvbjtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIGRhdGVzIGFyZSBwcm9wZXJseSBwYXJzZWRcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5zdGFydFRpbWUgPSBuZXcgRGF0ZShjb252ZXJzYXRpb24uc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIGlmIChjb252ZXJzYXRpb24uZW5kVGltZSkge1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb24uZW5kVGltZSA9IG5ldyBEYXRlKGNvbnZlcnNhdGlvbi5lbmRUaW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5zdXJlIG1lc3NhZ2UgdGltZXN0YW1wcyBhcmUgcHJvcGVybHkgcGFyc2VkXG4gICAgICAgICAgICBjb252ZXJzYXRpb24ubWVzc2FnZXMgPSBjb252ZXJzYXRpb24ubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKG1lc3NhZ2UudGltZXN0YW1wKSxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY29udmVyc2F0aW9ucy5wdXNoKGNvbnZlcnNhdGlvbik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgYEVycm9yIHBhcnNpbmcgY29udmVyc2F0aW9uIGZpbGUgJHtjb252ZXJzYXRpb25GaWxlfTpgLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIG90aGVyIGNvbnZlcnNhdGlvbnMgZXZlbiBpZiBvbmUgZmFpbHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY29udmVyc2F0aW9ucyA9IGNvbnZlcnNhdGlvbnM7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBJbXBvcnRlZCAke2NvbnZlcnNhdGlvbnMubGVuZ3RofSBjb252ZXJzYXRpb25zYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybihcIk5vIGNvbnZlcnNhdGlvbiBmaWxlcyBmb3VuZCBpbiB0aGUgWklQIGZpbGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBpbXBvcnRpbmcgZnJvbSBaSVA6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRmFpbGVkIHRvIGltcG9ydCBmcm9tIFpJUDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgaW1wb3J0ZWQgYWdlbnRzIHdpdGggZXhpc3RpbmcgYWdlbnRzIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBtb2RlXG4gKiBAcGFyYW0gaW1wb3J0ZWRBZ2VudHMgSW1wb3J0ZWQgYWdlbnRzXG4gKiBAcGFyYW0gZXhpc3RpbmdBZ2VudHMgRXhpc3RpbmcgYWdlbnRzXG4gKiBAcGFyYW0gb3B0aW9ucyBJbXBvcnQgb3B0aW9uc1xuICogQHJldHVybnMgTWVyZ2VkIGFnZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJbXBvcnRlZEFnZW50cyhcbiAgaW1wb3J0ZWRBZ2VudHM6IEFnZW50W10sXG4gIGV4aXN0aW5nQWdlbnRzOiBBZ2VudFtdLFxuICBvcHRpb25zOiB7IG1vZGU6IFwicmVwbGFjZVwiIHwgXCJuZXdcIiB8IFwibWVyZ2VcIiB9LFxuKTogQWdlbnRbXSB7XG4gIC8vIENyZWF0ZSBhIG1hcCBvZiBleGlzdGluZyBhZ2VudHMgYnkgSUQgZm9yIHF1aWNrIGxvb2t1cFxuICBjb25zdCBleGlzdGluZ0FnZW50c01hcCA9IG5ldyBNYXA8c3RyaW5nLCBBZ2VudD4oKTtcbiAgZXhpc3RpbmdBZ2VudHMuZm9yRWFjaCgoYWdlbnQpID0+IGV4aXN0aW5nQWdlbnRzTWFwLnNldChhZ2VudC5pZCwgYWdlbnQpKTtcblxuICAvLyBQcm9jZXNzIGltcG9ydGVkIGFnZW50cyBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgbW9kZVxuICBzd2l0Y2ggKG9wdGlvbnMubW9kZSkge1xuICAgIGNhc2UgXCJyZXBsYWNlXCI6XG4gICAgICAvLyBSZXBsYWNlIGV4aXN0aW5nIGFnZW50cyB3aXRoIHRoZSBzYW1lIElELCBrZWVwIG90aGVyc1xuICAgICAgcmV0dXJuIGV4aXN0aW5nQWdlbnRzXG4gICAgICAgIC5tYXAoKGFnZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgaW1wb3J0ZWRBZ2VudCA9IGltcG9ydGVkQWdlbnRzLmZpbmQoKGEpID0+IGEuaWQgPT09IGFnZW50LmlkKTtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0ZWRBZ2VudCB8fCBhZ2VudDtcbiAgICAgICAgfSlcbiAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAvLyBBZGQgaW1wb3J0ZWQgYWdlbnRzIHRoYXQgZG9uJ3QgZXhpc3QgeWV0XG4gICAgICAgICAgaW1wb3J0ZWRBZ2VudHMuZmlsdGVyKChhZ2VudCkgPT4gIWV4aXN0aW5nQWdlbnRzTWFwLmhhcyhhZ2VudC5pZCkpLFxuICAgICAgICApO1xuXG4gICAgY2FzZSBcIm5ld1wiOlxuICAgICAgLy8gQWRkIGltcG9ydGVkIGFnZW50cyB3aXRoIG5ldyBJRHMgdG8gYXZvaWQgY29uZmxpY3RzXG4gICAgICBjb25zdCBtYXhJZCA9IE1hdGgubWF4KFxuICAgICAgICAuLi5leGlzdGluZ0FnZW50cy5tYXAoKGEpID0+IE51bWJlci5wYXJzZUludChhLmlkKSB8fCAwKSxcbiAgICAgICAgMCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5leGlzdGluZ0FnZW50cyxcbiAgICAgICAgLi4uaW1wb3J0ZWRBZ2VudHMubWFwKChhZ2VudCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgLi4uYWdlbnQsXG4gICAgICAgICAgaWQ6IGAke21heElkICsgaW5kZXggKyAxfWAsXG4gICAgICAgICAgaW5Db252ZXJzYXRpb246IGZhbHNlLFxuICAgICAgICB9KSksXG4gICAgICBdO1xuXG4gICAgY2FzZSBcIm1lcmdlXCI6XG4gICAgICAvLyBNZXJnZSBrbm93bGVkZ2UgZnJvbSBpbXBvcnRlZCBhZ2VudHMgaW50byBleGlzdGluZyBhZ2VudHMgd2l0aCB0aGUgc2FtZSBJRFxuICAgICAgcmV0dXJuIGV4aXN0aW5nQWdlbnRzXG4gICAgICAgIC5tYXAoKGFnZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgaW1wb3J0ZWRBZ2VudCA9IGltcG9ydGVkQWdlbnRzLmZpbmQoKGEpID0+IGEuaWQgPT09IGFnZW50LmlkKTtcbiAgICAgICAgICBpZiAoIWltcG9ydGVkQWdlbnQpIHJldHVybiBhZ2VudDtcblxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBleGlzdGluZyBrbm93bGVkZ2UgZW50cnkgSURzIGZvciBxdWljayBsb29rdXBcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0tub3dsZWRnZUlkcyA9IG5ldyBTZXQoXG4gICAgICAgICAgICBhZ2VudC5rbm93bGVkZ2UubWFwKChrKSA9PiBrLmlkKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gTWVyZ2Uga25vd2xlZGdlIGVudHJpZXMsIGF2b2lkaW5nIGR1cGxpY2F0ZXNcbiAgICAgICAgICBjb25zdCBtZXJnZWRLbm93bGVkZ2UgPSBbXG4gICAgICAgICAgICAuLi5hZ2VudC5rbm93bGVkZ2UsXG4gICAgICAgICAgICAuLi5pbXBvcnRlZEFnZW50Lmtub3dsZWRnZS5maWx0ZXIoXG4gICAgICAgICAgICAgIChrKSA9PiAhZXhpc3RpbmdLbm93bGVkZ2VJZHMuaGFzKGsuaWQpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFnZW50LFxuICAgICAgICAgICAga25vd2xlZGdlOiBtZXJnZWRLbm93bGVkZ2UsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAvLyBBZGQgaW1wb3J0ZWQgYWdlbnRzIHRoYXQgZG9uJ3QgZXhpc3QgeWV0XG4gICAgICAgICAgaW1wb3J0ZWRBZ2VudHMuZmlsdGVyKChhZ2VudCkgPT4gIWV4aXN0aW5nQWdlbnRzTWFwLmhhcyhhZ2VudC5pZCkpLFxuICAgICAgICApO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBleGlzdGluZ0FnZW50cztcbiAgfVxufVxuIl0sIm5hbWVzIjpbImltcG9ydEFnZW50c0FuZFNldHRpbmdzRnJvbVppcCIsIm1lcmdlSW1wb3J0ZWRBZ2VudHMiLCJwYXJzZU1hcmtkb3duVG9Lbm93bGVkZ2UiLCJsb2dnZXIiLCJjcmVhdGVMb2dnZXIiLCJjb250ZW50IiwiZmlsZU5hbWUiLCJtZXRhZGF0YVJlZ2V4IiwibWV0YWRhdGFNYXRjaCIsIm1hdGNoIiwiaWQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwidGl0bGUiLCJyZXBsYWNlIiwidGFncyIsInRpbWVzdGFtcCIsImtub3dsZWRnZUNvbnRlbnQiLCJtZXRhZGF0YVN0ciIsIm1ldGFkYXRhTGluZXMiLCJzcGxpdCIsImZvckVhY2giLCJsaW5lIiwia2V5IiwidmFsdWUiLCJtYXAiLCJwYXJ0IiwidHJpbSIsInRvTG93ZXJDYXNlIiwidGFnIiwicGFyc2VkRGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsIndhcm4iLCJlIiwidGl0bGVNYXRjaCIsImV4dHJhY3RlZFRhZ3MiLCJleHRyYWN0VGFnc0Zyb21NYXJrZG93biIsImxlbmd0aCIsImFsbFRhZ3MiLCJTZXQiLCJkZWJ1ZyIsInRhZ3NDb3VudCIsImpvaW4iLCJ0b0lTT1N0cmluZyIsImZpbGUiLCJvcHRpb25zIiwiaW5mbyIsIm5hbWUiLCJ6aXAiLCJKU1ppcCIsInppcENvbnRlbnQiLCJsb2FkQXN5bmMiLCJyZXN1bHQiLCJpbXBvcnRTZXR0aW5ncyIsInNldHRpbmdzRmlsZSIsImZpbGVzIiwic2V0dGluZ3NKc29uIiwiYXN5bmMiLCJzZXR0aW5ncyIsIkpTT04iLCJwYXJzZSIsImltcG9ydEFwaUtleXMiLCJhcGlLZXkiLCJwcm92aWRlciIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInN0cmluZ2lmeSIsIm9rIiwiZXJyb3IiLCJzdGF0dXMiLCJFcnJvciIsImRhdGEiLCJqc29uIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJzZXNzaW9uSWQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiYXBpS2V5U2Vzc2lvbklkIiwibW9kZWwiLCJtb2RlIiwiYWdlbnRGaWxlcyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJwYXRoIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiYWdlbnRzIiwiYWdlbnRGaWxlIiwiYWdlbnRKc29uIiwiYWdlbnQiLCJrbm93bGVkZ2VGb2xkZXIiLCJrbm93bGVkZ2VGaWxlcyIsImtub3dsZWRnZSIsImtub3dsZWRnZUZpbGUiLCJtYXJrZG93bkNvbnRlbnQiLCJwb3AiLCJmaWxlSWQiLCJwYXJzZWRFbnRyeSIsImVudHJ5SWQiLCJwdXNoIiwiaW1wb3J0Q29udmVyc2F0aW9ucyIsImNvbnZlcnNhdGlvbkZpbGVzIiwiY29udmVyc2F0aW9ucyIsImNvbnZlcnNhdGlvbkZpbGUiLCJjb252ZXJzYXRpb25Kc29uIiwiY29udmVyc2F0aW9uIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsIm1lc3NhZ2VzIiwiU3RyaW5nIiwiaW1wb3J0ZWRBZ2VudHMiLCJleGlzdGluZ0FnZW50cyIsImV4aXN0aW5nQWdlbnRzTWFwIiwiTWFwIiwic2V0IiwiaW1wb3J0ZWRBZ2VudCIsImZpbmQiLCJhIiwiY29uY2F0IiwiaGFzIiwibWF4SWQiLCJtYXgiLCJOdW1iZXIiLCJwYXJzZUludCIsImluZGV4IiwiaW5Db252ZXJzYXRpb24iLCJleGlzdGluZ0tub3dsZWRnZUlkcyIsImsiLCJtZXJnZWRLbm93bGVkZ2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBaUlzQkEsOEJBQThCO2VBQTlCQTs7SUF5UE5DLG1CQUFtQjtlQUFuQkE7O0lBOVZBQyx3QkFBd0I7ZUFBeEJBOzs7OERBNUJFOzZCQUdXO3VCQUNXOzs7Ozs7QUFFeEMsa0NBQWtDO0FBQ2xDLE1BQU1DLFNBQVNDLElBQUFBLHlCQUFZLEVBQUM7QUFxQnJCLFNBQVNGLHlCQUNkRyxPQUFlLEVBQ2ZDLFFBQWdCO0lBRWhCLDZDQUE2QztJQUM3QyxNQUFNQyxnQkFBZ0I7SUFDdEIsTUFBTUMsZ0JBQWdCSCxRQUFRSSxLQUFLLENBQUNGO0lBRXBDLElBQUlHLEtBQUssQ0FBQyxVQUFVLEVBQUVDLEtBQUtDLEdBQUcsR0FBRyxDQUFDLEVBQUVDLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNoRixJQUFJQyxRQUFRWCxTQUFTWSxPQUFPLENBQUMsU0FBUyxJQUFJQSxPQUFPLENBQUMsTUFBTTtJQUN4RCxJQUFJQyxPQUFpQixFQUFFO0lBQ3ZCLElBQUlDLFlBQVks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