46d529b179fc9ba96508ef2de948c15a
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useLLMProviders: function() {
        return useLLMProviders;
    },
    useProviderCredentials: function() {
        return useProviderCredentials;
    }
});
const _react = require("react");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function useLLMProviders(options = {}) {
    const { autoRefresh = false, refreshInterval = 300000 } = options; // 5 minutes default
    const [providers, setProviders] = (0, _react.useState)([]);
    const [failoverRules, setFailoverRules] = (0, _react.useState)([]);
    const [loading, setLoading] = (0, _react.useState)(true);
    const [error, setError] = (0, _react.useState)(null);
    // Fetch providers from API
    const fetchProviders = (0, _react.useCallback)(async ()=>{
        try {
            const response = await fetch("/api/llm/providers");
            if (!response.ok) {
                throw new Error(`Failed to fetch providers: ${response.statusText}`);
            }
            const data = await response.json();
            if (data.success) {
                setProviders(data.providers || []);
                setError(null);
            } else {
                throw new Error(data.error || "Failed to fetch providers");
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Unknown error";
            setError(errorMessage);
            console.error("[USE-PROVIDERS] Fetch error:", err);
        }
    }, []);
    // Fetch failover rules
    const fetchFailoverRules = (0, _react.useCallback)(async ()=>{
        try {
            const response = await fetch("/api/llm/failover-rules");
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    setFailoverRules(data.rules || []);
                }
            }
        } catch (err) {
            console.warn("[USE-PROVIDERS] Failed to fetch failover rules:", err);
        }
    }, []);
    // Initial load
    (0, _react.useEffect)(()=>{
        const loadData = async ()=>{
            setLoading(true);
            await Promise.all([
                fetchProviders(),
                fetchFailoverRules()
            ]);
            setLoading(false);
        };
        loadData();
    }, [
        fetchProviders,
        fetchFailoverRules
    ]);
    // Auto-refresh functionality
    (0, _react.useEffect)(()=>{
        if (!autoRefresh) return;
        const interval = setInterval(()=>{
            fetchProviders();
        }, refreshInterval);
        return ()=>clearInterval(interval);
    }, [
        autoRefresh,
        refreshInterval,
        fetchProviders
    ]);
    // Create new provider
    const createProvider = (0, _react.useCallback)(async (providerData)=>{
        try {
            const response = await fetch("/api/llm/providers", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(providerData)
            });
            if (!response.ok) {
                throw new Error(`Failed to create provider: ${response.statusText}`);
            }
            const data = await response.json();
            if (data.success) {
                const newProvider = data.provider;
                setProviders((prev)=>[
                        ...prev,
                        newProvider
                    ]);
                return newProvider;
            } else {
                throw new Error(data.error || "Failed to create provider");
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Unknown error";
            setError(errorMessage);
            console.error("[USE-PROVIDERS] Create error:", err);
            return null;
        }
    }, []);
    // Update provider
    const updateProvider = (0, _react.useCallback)(async (providerId, updates)=>{
        try {
            const response = await fetch("/api/llm/providers", {
                method: "PUT",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    action: "update",
                    providerId,
                    updates
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to update provider: ${response.statusText}`);
            }
            const data = await response.json();
            if (data.success) {
                setProviders((prev)=>prev.map((p)=>p.id === providerId ? {
                            ...p,
                            ...updates
                        } : p));
                return true;
            } else {
                throw new Error(data.error || "Failed to update provider");
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Unknown error";
            setError(errorMessage);
            console.error("[USE-PROVIDERS] Update error:", err);
            return false;
        }
    }, []);
    // Delete provider
    const deleteProvider = (0, _react.useCallback)(async (providerId)=>{
        try {
            const response = await fetch(`/api/llm/providers?id=${providerId}`, {
                method: "DELETE"
            });
            if (!response.ok) {
                throw new Error(`Failed to delete provider: ${response.statusText}`);
            }
            const data = await response.json();
            if (data.success) {
                setProviders((prev)=>prev.filter((p)=>p.id !== providerId));
                return true;
            } else {
                throw new Error(data.error || "Failed to delete provider");
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Unknown error";
            setError(errorMessage);
            console.error("[USE-PROVIDERS] Delete error:", err);
            return false;
        }
    }, []);
    // Reorder providers
    const reorderProviders = (0, _react.useCallback)(async (reorderedProviders)=>{
        try {
            const response = await fetch("/api/llm/providers", {
                method: "PUT",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    action: "reorder",
                    providers: reorderedProviders
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to reorder providers: ${response.statusText}`);
            }
            const data = await response.json();
            if (data.success) {
                setProviders(data.providers);
                return true;
            } else {
                throw new Error(data.error || "Failed to reorder providers");
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Unknown error";
            setError(errorMessage);
            console.error("[USE-PROVIDERS] Reorder error:", err);
            return false;
        }
    }, []);
    // Toggle provider enabled state
    const toggleProvider = (0, _react.useCallback)(async (providerId)=>{
        const provider = providers.find((p)=>p.id === providerId);
        if (!provider) return false;
        return await updateProvider(providerId, {
            enabled: !provider.enabled
        });
    }, [
        providers,
        updateProvider
    ]);
    // Refresh providers
    const refreshProviders = (0, _react.useCallback)(async ()=>{
        await fetchProviders();
    }, [
        fetchProviders
    ]);
    // Get healthy providers
    const getHealthyProviders = (0, _react.useCallback)(()=>{
        return providers.filter((p)=>p.enabled && p.status.isHealthy);
    }, [
        providers
    ]);
    // Get primary provider (lowest priority number)
    const getPrimaryProvider = (0, _react.useCallback)(()=>{
        const enabledProviders = providers.filter((p)=>p.enabled);
        if (enabledProviders.length === 0) return null;
        return enabledProviders.reduce((primary, current)=>current.priority < primary.priority ? current : primary);
    }, [
        providers
    ]);
    // Get provider by ID
    const getProviderById = (0, _react.useCallback)((id)=>{
        return providers.find((p)=>p.id === id) || null;
    }, [
        providers
    ]);
    // Perform health checks
    const performHealthChecks = (0, _react.useCallback)(async ()=>{
        // This would call the health check API for all providers
        try {
            const response = await fetch("/api/llm/health-check", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    providerIds: providers.map((p)=>p.id)
                })
            });
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.results) {
                    // Update provider statuses
                    setProviders((prev)=>prev.map((provider)=>{
                            const healthResult = data.results[provider.id];
                            if (healthResult) {
                                return {
                                    ...provider,
                                    status: {
                                        ...provider.status,
                                        isHealthy: healthResult.isHealthy,
                                        lastHealthCheck: new Date(),
                                        responseTimeMs: healthResult.responseTimeMs,
                                        errorCount: healthResult.isHealthy ? 0 : provider.status.errorCount + 1
                                    }
                                };
                            }
                            return provider;
                        }));
                }
            }
        } catch (err) {
            console.error("[USE-PROVIDERS] Health check error:", err);
        }
    }, [
        providers
    ]);
    // Get provider statistics
    const getProviderStats = (0, _react.useCallback)(()=>{
        const total = providers.length;
        const healthy = providers.filter((p)=>p.status.isHealthy).length;
        const enabled = providers.filter((p)=>p.enabled).length;
        const totalRequests = providers.reduce((sum, p)=>sum + p.usage.totalRequests, 0);
        const totalCost = providers.reduce((sum, p)=>sum + p.usage.totalCost, 0);
        return {
            total,
            healthy,
            enabled,
            totalRequests,
            totalCost
        };
    }, [
        providers
    ]);
    return {
        providers,
        failoverRules,
        loading,
        error,
        createProvider,
        updateProvider,
        deleteProvider,
        reorderProviders,
        toggleProvider,
        refreshProviders,
        getHealthyProviders,
        getPrimaryProvider,
        getProviderById,
        performHealthChecks,
        getProviderStats
    };
}
function useProviderCredentials() {
    const [encryptionStatus, setEncryptionStatus] = (0, _react.useState)({
        isInitialized: false,
        hasKey: false
    });
    const encryptCredentials = (0, _react.useCallback)(async (credentials)=>{
        try {
            // Import and use the CredentialCrypto class
            const { CredentialCrypto } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../crypto-client")));
            const encryptedResult = await CredentialCrypto.encryptCredentials(credentials);
            // Convert single result to record format expected by components
            const encryptedRecord = {};
            Object.keys(credentials).forEach((key)=>{
                if (credentials[key]) {
                    encryptedRecord[key] = {
                        encryptedData: encryptedResult.encryptedData,
                        keyId: encryptedResult.keyId,
                        algorithm: encryptedResult.algorithm,
                        timestamp: encryptedResult.timestamp
                    };
                }
            });
            return encryptedRecord;
        } catch (error) {
            console.error("[USE-CREDENTIALS] Encryption error:", error);
            return null;
        }
    }, []);
    const initializeEncryption = (0, _react.useCallback)(async ()=>{
        try {
            const { CredentialCrypto } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../crypto-client")));
            await CredentialCrypto.initializeSecureSession();
            setEncryptionStatus({
                isInitialized: true,
                hasKey: true
            });
            return true;
        } catch (error) {
            console.error("[USE-CREDENTIALS] Initialization error:", error);
            return false;
        }
    }, []);
    return {
        encryptionStatus,
        encryptCredentials,
        initializeEncryption
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvaG9va3MvdXNlLWxsbS1wcm92aWRlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBMTE1Qcm92aWRlcixcbiAgRmFpbG92ZXJSdWxlLFxufSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL2xsbS1wcm92aWRlci1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBDcmVkZW50aWFsRm9ybURhdGEgfSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL3NlY3VyZS1jcmVkZW50aWFsLWlucHV0XCI7XG5pbXBvcnQgeyBFbmNyeXB0aW9uUmVzdWx0IH0gZnJvbSBcIkAvbGliL2NyeXB0by1jbGllbnRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VQcm92aWRlcnNPcHRpb25zIHtcbiAgYXV0b1JlZnJlc2g/OiBib29sZWFuO1xuICByZWZyZXNoSW50ZXJ2YWw/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUHJvdmlkZXJzUmV0dXJuIHtcbiAgcHJvdmlkZXJzOiBMTE1Qcm92aWRlcltdO1xuICBmYWlsb3ZlclJ1bGVzOiBGYWlsb3ZlclJ1bGVbXTtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIC8vIFByb3ZpZGVyIG1hbmFnZW1lbnRcbiAgY3JlYXRlUHJvdmlkZXI6IChcbiAgICBwcm92aWRlcjogUGFydGlhbDxMTE1Qcm92aWRlcj4sXG4gICkgPT4gUHJvbWlzZTxMTE1Qcm92aWRlciB8IG51bGw+O1xuICB1cGRhdGVQcm92aWRlcjogKFxuICAgIHByb3ZpZGVySWQ6IHN0cmluZyxcbiAgICB1cGRhdGVzOiBQYXJ0aWFsPExMTVByb3ZpZGVyPixcbiAgKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBkZWxldGVQcm92aWRlcjogKHByb3ZpZGVySWQ6IHN0cmluZykgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgcmVvcmRlclByb3ZpZGVyczogKHByb3ZpZGVyczogTExNUHJvdmlkZXJbXSkgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgdG9nZ2xlUHJvdmlkZXI6IChwcm92aWRlcklkOiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gIHJlZnJlc2hQcm92aWRlcnM6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGdldEhlYWx0aHlQcm92aWRlcnM6ICgpID0+IExMTVByb3ZpZGVyW107XG4gIGdldFByaW1hcnlQcm92aWRlcjogKCkgPT4gTExNUHJvdmlkZXIgfCBudWxsO1xuICBnZXRQcm92aWRlckJ5SWQ6IChpZDogc3RyaW5nKSA9PiBMTE1Qcm92aWRlciB8IG51bGw7XG4gIC8vIEhlYWx0aCBhbmQgbW9uaXRvcmluZ1xuICBwZXJmb3JtSGVhbHRoQ2hlY2tzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBnZXRQcm92aWRlclN0YXRzOiAoKSA9PiB7XG4gICAgdG90YWw6IG51bWJlcjtcbiAgICBoZWFsdGh5OiBudW1iZXI7XG4gICAgZW5hYmxlZDogbnVtYmVyO1xuICAgIHRvdGFsUmVxdWVzdHM6IG51bWJlcjtcbiAgICB0b3RhbENvc3Q6IG51bWJlcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBtYW5hZ2luZyBMTE0gcHJvdmlkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMTE1Qcm92aWRlcnMoXG4gIG9wdGlvbnM6IFVzZVByb3ZpZGVyc09wdGlvbnMgPSB7fSxcbik6IFVzZVByb3ZpZGVyc1JldHVybiB7XG4gIGNvbnN0IHsgYXV0b1JlZnJlc2ggPSBmYWxzZSwgcmVmcmVzaEludGVydmFsID0gMzAwMDAwIH0gPSBvcHRpb25zOyAvLyA1IG1pbnV0ZXMgZGVmYXVsdFxuXG4gIGNvbnN0IFtwcm92aWRlcnMsIHNldFByb3ZpZGVyc10gPSB1c2VTdGF0ZTxMTE1Qcm92aWRlcltdPihbXSk7XG4gIGNvbnN0IFtmYWlsb3ZlclJ1bGVzLCBzZXRGYWlsb3ZlclJ1bGVzXSA9IHVzZVN0YXRlPEZhaWxvdmVyUnVsZVtdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEZldGNoIHByb3ZpZGVycyBmcm9tIEFQSVxuICBjb25zdCBmZXRjaFByb3ZpZGVycyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvbGxtL3Byb3ZpZGVyc1wiKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggcHJvdmlkZXJzOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIHNldFByb3ZpZGVycyhkYXRhLnByb3ZpZGVycyB8fCBbXSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggcHJvdmlkZXJzXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVVNFLVBST1ZJREVSU10gRmV0Y2ggZXJyb3I6XCIsIGVycik7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gRmV0Y2ggZmFpbG92ZXIgcnVsZXNcbiAgY29uc3QgZmV0Y2hGYWlsb3ZlclJ1bGVzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS9sbG0vZmFpbG92ZXItcnVsZXNcIik7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHNldEZhaWxvdmVyUnVsZXMoZGF0YS5ydWxlcyB8fCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltVU0UtUFJPVklERVJTXSBGYWlsZWQgdG8gZmV0Y2ggZmFpbG92ZXIgcnVsZXM6XCIsIGVycik7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gSW5pdGlhbCBsb2FkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW2ZldGNoUHJvdmlkZXJzKCksIGZldGNoRmFpbG92ZXJSdWxlcygpXSk7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9O1xuXG4gICAgbG9hZERhdGEoKTtcbiAgfSwgW2ZldGNoUHJvdmlkZXJzLCBmZXRjaEZhaWxvdmVyUnVsZXNdKTtcblxuICAvLyBBdXRvLXJlZnJlc2ggZnVuY3Rpb25hbGl0eVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghYXV0b1JlZnJlc2gpIHJldHVybjtcblxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgZmV0Y2hQcm92aWRlcnMoKTtcbiAgICB9LCByZWZyZXNoSW50ZXJ2YWwpO1xuXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9LCBbYXV0b1JlZnJlc2gsIHJlZnJlc2hJbnRlcnZhbCwgZmV0Y2hQcm92aWRlcnNdKTtcblxuICAvLyBDcmVhdGUgbmV3IHByb3ZpZGVyXG4gIGNvbnN0IGNyZWF0ZVByb3ZpZGVyID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHByb3ZpZGVyRGF0YTogUGFydGlhbDxMTE1Qcm92aWRlcj4pOiBQcm9taXNlPExMTVByb3ZpZGVyIHwgbnVsbD4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvbGxtL3Byb3ZpZGVyc1wiLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb3ZpZGVyRGF0YSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcHJvdmlkZXI6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBjb25zdCBuZXdQcm92aWRlciA9IGRhdGEucHJvdmlkZXI7XG4gICAgICAgICAgc2V0UHJvdmlkZXJzKChwcmV2KSA9PiBbLi4ucHJldiwgbmV3UHJvdmlkZXJdKTtcbiAgICAgICAgICByZXR1cm4gbmV3UHJvdmlkZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgXCJGYWlsZWQgdG8gY3JlYXRlIHByb3ZpZGVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCI7XG4gICAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVVNFLVBST1ZJREVSU10gQ3JlYXRlIGVycm9yOlwiLCBlcnIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtdLFxuICApO1xuXG4gIC8vIFVwZGF0ZSBwcm92aWRlclxuICBjb25zdCB1cGRhdGVQcm92aWRlciA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChcbiAgICAgIHByb3ZpZGVySWQ6IHN0cmluZyxcbiAgICAgIHVwZGF0ZXM6IFBhcnRpYWw8TExNUHJvdmlkZXI+LFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvbGxtL3Byb3ZpZGVyc1wiLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcInVwZGF0ZVwiLFxuICAgICAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgICAgIHVwZGF0ZXMsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgcHJvdmlkZXI6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRQcm92aWRlcnMoKHByZXYpID0+XG4gICAgICAgICAgICBwcmV2Lm1hcCgocCkgPT4gKHAuaWQgPT09IHByb3ZpZGVySWQgPyB7IC4uLnAsIC4uLnVwZGF0ZXMgfSA6IHApKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm92aWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW1VTRS1QUk9WSURFUlNdIFVwZGF0ZSBlcnJvcjpcIiwgZXJyKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgW10sXG4gICk7XG5cbiAgLy8gRGVsZXRlIHByb3ZpZGVyXG4gIGNvbnN0IGRlbGV0ZVByb3ZpZGVyID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHByb3ZpZGVySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9sbG0vcHJvdmlkZXJzP2lkPSR7cHJvdmlkZXJJZH1gLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIHByb3ZpZGVyOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0UHJvdmlkZXJzKChwcmV2KSA9PiBwcmV2LmZpbHRlcigocCkgPT4gcC5pZCAhPT0gcHJvdmlkZXJJZCkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIGRlbGV0ZSBwcm92aWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW1VTRS1QUk9WSURFUlNdIERlbGV0ZSBlcnJvcjpcIiwgZXJyKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgW10sXG4gICk7XG5cbiAgLy8gUmVvcmRlciBwcm92aWRlcnNcbiAgY29uc3QgcmVvcmRlclByb3ZpZGVycyA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChyZW9yZGVyZWRQcm92aWRlcnM6IExMTVByb3ZpZGVyW10pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCIvYXBpL2xsbS9wcm92aWRlcnNcIiwge1xuICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZW9yZGVyXCIsXG4gICAgICAgICAgICBwcm92aWRlcnM6IHJlb3JkZXJlZFByb3ZpZGVycyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gcmVvcmRlciBwcm92aWRlcnM6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0UHJvdmlkZXJzKGRhdGEucHJvdmlkZXJzKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCBcIkZhaWxlZCB0byByZW9yZGVyIHByb3ZpZGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW1VTRS1QUk9WSURFUlNdIFJlb3JkZXIgZXJyb3I6XCIsIGVycik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtdLFxuICApO1xuXG4gIC8vIFRvZ2dsZSBwcm92aWRlciBlbmFibGVkIHN0YXRlXG4gIGNvbnN0IHRvZ2dsZVByb3ZpZGVyID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHByb3ZpZGVySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlcnMuZmluZCgocCkgPT4gcC5pZCA9PT0gcHJvdmlkZXJJZCk7XG4gICAgICBpZiAoIXByb3ZpZGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBhd2FpdCB1cGRhdGVQcm92aWRlcihwcm92aWRlcklkLCB7IGVuYWJsZWQ6ICFwcm92aWRlci5lbmFibGVkIH0pO1xuICAgIH0sXG4gICAgW3Byb3ZpZGVycywgdXBkYXRlUHJvdmlkZXJdLFxuICApO1xuXG4gIC8vIFJlZnJlc2ggcHJvdmlkZXJzXG4gIGNvbnN0IHJlZnJlc2hQcm92aWRlcnMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmV0Y2hQcm92aWRlcnMoKTtcbiAgfSwgW2ZldGNoUHJvdmlkZXJzXSk7XG5cbiAgLy8gR2V0IGhlYWx0aHkgcHJvdmlkZXJzXG4gIGNvbnN0IGdldEhlYWx0aHlQcm92aWRlcnMgPSB1c2VDYWxsYmFjaygoKTogTExNUHJvdmlkZXJbXSA9PiB7XG4gICAgcmV0dXJuIHByb3ZpZGVycy5maWx0ZXIoKHApID0+IHAuZW5hYmxlZCAmJiBwLnN0YXR1cy5pc0hlYWx0aHkpO1xuICB9LCBbcHJvdmlkZXJzXSk7XG5cbiAgLy8gR2V0IHByaW1hcnkgcHJvdmlkZXIgKGxvd2VzdCBwcmlvcml0eSBudW1iZXIpXG4gIGNvbnN0IGdldFByaW1hcnlQcm92aWRlciA9IHVzZUNhbGxiYWNrKCgpOiBMTE1Qcm92aWRlciB8IG51bGwgPT4ge1xuICAgIGNvbnN0IGVuYWJsZWRQcm92aWRlcnMgPSBwcm92aWRlcnMuZmlsdGVyKChwKSA9PiBwLmVuYWJsZWQpO1xuICAgIGlmIChlbmFibGVkUHJvdmlkZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gZW5hYmxlZFByb3ZpZGVycy5yZWR1Y2UoKHByaW1hcnksIGN1cnJlbnQpID0+XG4gICAgICBjdXJyZW50LnByaW9yaXR5IDwgcHJpbWFyeS5wcmlvcml0eSA/IGN1cnJlbnQgOiBwcmltYXJ5LFxuICAgICk7XG4gIH0sIFtwcm92aWRlcnNdKTtcblxuICAvLyBHZXQgcHJvdmlkZXIgYnkgSURcbiAgY29uc3QgZ2V0UHJvdmlkZXJCeUlkID0gdXNlQ2FsbGJhY2soXG4gICAgKGlkOiBzdHJpbmcpOiBMTE1Qcm92aWRlciB8IG51bGwgPT4ge1xuICAgICAgcmV0dXJuIHByb3ZpZGVycy5maW5kKChwKSA9PiBwLmlkID09PSBpZCkgfHwgbnVsbDtcbiAgICB9LFxuICAgIFtwcm92aWRlcnNdLFxuICApO1xuXG4gIC8vIFBlcmZvcm0gaGVhbHRoIGNoZWNrc1xuICBjb25zdCBwZXJmb3JtSGVhbHRoQ2hlY2tzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIC8vIFRoaXMgd291bGQgY2FsbCB0aGUgaGVhbHRoIGNoZWNrIEFQSSBmb3IgYWxsIHByb3ZpZGVyc1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS9sbG0vaGVhbHRoLWNoZWNrXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcHJvdmlkZXJJZHM6IHByb3ZpZGVycy5tYXAoKHApID0+IHAuaWQpLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnJlc3VsdHMpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgcHJvdmlkZXIgc3RhdHVzZXNcbiAgICAgICAgICBzZXRQcm92aWRlcnMoKHByZXYpID0+XG4gICAgICAgICAgICBwcmV2Lm1hcCgocHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaGVhbHRoUmVzdWx0ID0gZGF0YS5yZXN1bHRzW3Byb3ZpZGVyLmlkXTtcbiAgICAgICAgICAgICAgaWYgKGhlYWx0aFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAuLi5wcm92aWRlci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGlzSGVhbHRoeTogaGVhbHRoUmVzdWx0LmlzSGVhbHRoeSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEhlYWx0aENoZWNrOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRpbWVNczogaGVhbHRoUmVzdWx0LnJlc3BvbnNlVGltZU1zLFxuICAgICAgICAgICAgICAgICAgICBlcnJvckNvdW50OiBoZWFsdGhSZXN1bHQuaXNIZWFsdGh5XG4gICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlci5zdGF0dXMuZXJyb3JDb3VudCArIDEsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltVU0UtUFJPVklERVJTXSBIZWFsdGggY2hlY2sgZXJyb3I6XCIsIGVycik7XG4gICAgfVxuICB9LCBbcHJvdmlkZXJzXSk7XG5cbiAgLy8gR2V0IHByb3ZpZGVyIHN0YXRpc3RpY3NcbiAgY29uc3QgZ2V0UHJvdmlkZXJTdGF0cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCB0b3RhbCA9IHByb3ZpZGVycy5sZW5ndGg7XG4gICAgY29uc3QgaGVhbHRoeSA9IHByb3ZpZGVycy5maWx0ZXIoKHApID0+IHAuc3RhdHVzLmlzSGVhbHRoeSkubGVuZ3RoO1xuICAgIGNvbnN0IGVuYWJsZWQgPSBwcm92aWRlcnMuZmlsdGVyKChwKSA9PiBwLmVuYWJsZWQpLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbFJlcXVlc3RzID0gcHJvdmlkZXJzLnJlZHVjZShcbiAgICAgIChzdW0sIHApID0+IHN1bSArIHAudXNhZ2UudG90YWxSZXF1ZXN0cyxcbiAgICAgIDAsXG4gICAgKTtcbiAgICBjb25zdCB0b3RhbENvc3QgPSBwcm92aWRlcnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAudXNhZ2UudG90YWxDb3N0LCAwKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbCxcbiAgICAgIGhlYWx0aHksXG4gICAgICBlbmFibGVkLFxuICAgICAgdG90YWxSZXF1ZXN0cyxcbiAgICAgIHRvdGFsQ29zdCxcbiAgICB9O1xuICB9LCBbcHJvdmlkZXJzXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm92aWRlcnMsXG4gICAgZmFpbG92ZXJSdWxlcyxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIGNyZWF0ZVByb3ZpZGVyLFxuICAgIHVwZGF0ZVByb3ZpZGVyLFxuICAgIGRlbGV0ZVByb3ZpZGVyLFxuICAgIHJlb3JkZXJQcm92aWRlcnMsXG4gICAgdG9nZ2xlUHJvdmlkZXIsXG4gICAgcmVmcmVzaFByb3ZpZGVycyxcbiAgICBnZXRIZWFsdGh5UHJvdmlkZXJzLFxuICAgIGdldFByaW1hcnlQcm92aWRlcixcbiAgICBnZXRQcm92aWRlckJ5SWQsXG4gICAgcGVyZm9ybUhlYWx0aENoZWNrcyxcbiAgICBnZXRQcm92aWRlclN0YXRzLFxuICB9O1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIG1hbmFnaW5nIHByb3ZpZGVyIGNyZWRlbnRpYWxzIHNlY3VyZWx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcm92aWRlckNyZWRlbnRpYWxzKCkge1xuICBjb25zdCBbZW5jcnlwdGlvblN0YXR1cywgc2V0RW5jcnlwdGlvblN0YXR1c10gPSB1c2VTdGF0ZSh7XG4gICAgaXNJbml0aWFsaXplZDogZmFsc2UsXG4gICAgaGFzS2V5OiBmYWxzZSxcbiAgfSk7XG5cbiAgY29uc3QgZW5jcnlwdENyZWRlbnRpYWxzID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKFxuICAgICAgY3JlZGVudGlhbHM6IENyZWRlbnRpYWxGb3JtRGF0YSxcbiAgICApOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIEVuY3J5cHRpb25SZXN1bHQ+IHwgbnVsbD4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW1wb3J0IGFuZCB1c2UgdGhlIENyZWRlbnRpYWxDcnlwdG8gY2xhc3NcbiAgICAgICAgY29uc3QgeyBDcmVkZW50aWFsQ3J5cHRvIH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9jcnlwdG8tY2xpZW50XCIpO1xuXG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZFJlc3VsdCA9XG4gICAgICAgICAgYXdhaXQgQ3JlZGVudGlhbENyeXB0by5lbmNyeXB0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgc2luZ2xlIHJlc3VsdCB0byByZWNvcmQgZm9ybWF0IGV4cGVjdGVkIGJ5IGNvbXBvbmVudHNcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkUmVjb3JkOiBSZWNvcmQ8c3RyaW5nLCBFbmNyeXB0aW9uUmVzdWx0PiA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGNyZWRlbnRpYWxzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBpZiAoY3JlZGVudGlhbHNba2V5XSkge1xuICAgICAgICAgICAgZW5jcnlwdGVkUmVjb3JkW2tleV0gPSB7XG4gICAgICAgICAgICAgIGVuY3J5cHRlZERhdGE6IGVuY3J5cHRlZFJlc3VsdC5lbmNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgICBrZXlJZDogZW5jcnlwdGVkUmVzdWx0LmtleUlkLFxuICAgICAgICAgICAgICBhbGdvcml0aG06IGVuY3J5cHRlZFJlc3VsdC5hbGdvcml0aG0sXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogZW5jcnlwdGVkUmVzdWx0LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZW5jcnlwdGVkUmVjb3JkO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIltVU0UtQ1JFREVOVElBTFNdIEVuY3J5cHRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXSxcbiAgKTtcblxuICBjb25zdCBpbml0aWFsaXplRW5jcnlwdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBDcmVkZW50aWFsQ3J5cHRvIH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9jcnlwdG8tY2xpZW50XCIpO1xuICAgICAgYXdhaXQgQ3JlZGVudGlhbENyeXB0by5pbml0aWFsaXplU2VjdXJlU2Vzc2lvbigpO1xuXG4gICAgICBzZXRFbmNyeXB0aW9uU3RhdHVzKHtcbiAgICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgaGFzS2V5OiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1VTRS1DUkVERU5USUFMU10gSW5pdGlhbGl6YXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIGVuY3J5cHRpb25TdGF0dXMsXG4gICAgZW5jcnlwdENyZWRlbnRpYWxzLFxuICAgIGluaXRpYWxpemVFbmNyeXB0aW9uLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUxMTVByb3ZpZGVycyIsInVzZVByb3ZpZGVyQ3JlZGVudGlhbHMiLCJvcHRpb25zIiwiYXV0b1JlZnJlc2giLCJyZWZyZXNoSW50ZXJ2YWwiLCJwcm92aWRlcnMiLCJzZXRQcm92aWRlcnMiLCJ1c2VTdGF0ZSIsImZhaWxvdmVyUnVsZXMiLCJzZXRGYWlsb3ZlclJ1bGVzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiZmV0Y2hQcm92aWRlcnMiLCJ1c2VDYWxsYmFjayIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImRhdGEiLCJqc29uIiwic3VjY2VzcyIsImVyciIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiZmV0Y2hGYWlsb3ZlclJ1bGVzIiwicnVsZXMiLCJ3YXJuIiwidXNlRWZmZWN0IiwibG9hZERhdGEiLCJQcm9taXNlIiwiYWxsIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjcmVhdGVQcm92aWRlciIsInByb3ZpZGVyRGF0YSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm5ld1Byb3ZpZGVyIiwicHJvdmlkZXIiLCJwcmV2IiwidXBkYXRlUHJvdmlkZXIiLCJwcm92aWRlcklkIiwidXBkYXRlcyIsImFjdGlvbiIsIm1hcCIsInAiLCJpZCIsImRlbGV0ZVByb3ZpZGVyIiwiZmlsdGVyIiwicmVvcmRlclByb3ZpZGVycyIsInJlb3JkZXJlZFByb3ZpZGVycyIsInRvZ2dsZVByb3ZpZGVyIiwiZmluZCIsImVuYWJsZWQiLCJyZWZyZXNoUHJvdmlkZXJzIiwiZ2V0SGVhbHRoeVByb3ZpZGVycyIsInN0YXR1cyIsImlzSGVhbHRoeSIsImdldFByaW1hcnlQcm92aWRlciIsImVuYWJsZWRQcm92aWRlcnMiLCJsZW5ndGgiLCJyZWR1Y2UiLCJwcmltYXJ5IiwiY3VycmVudCIsInByaW9yaXR5IiwiZ2V0UHJvdmlkZXJCeUlkIiwicGVyZm9ybUhlYWx0aENoZWNrcyIsInByb3ZpZGVySWRzIiwicmVzdWx0cyIsImhlYWx0aFJlc3VsdCIsImxhc3RIZWFsdGhDaGVjayIsIkRhdGUiLCJyZXNwb25zZVRpbWVNcyIsImVycm9yQ291bnQiLCJnZXRQcm92aWRlclN0YXRzIiwidG90YWwiLCJoZWFsdGh5IiwidG90YWxSZXF1ZXN0cyIsInN1bSIsInVzYWdlIiwidG90YWxDb3N0IiwiZW5jcnlwdGlvblN0YXR1cyIsInNldEVuY3J5cHRpb25TdGF0dXMiLCJpc0luaXRpYWxpemVkIiwiaGFzS2V5IiwiZW5jcnlwdENyZWRlbnRpYWxzIiwiY3JlZGVudGlhbHMiLCJDcmVkZW50aWFsQ3J5cHRvIiwiZW5jcnlwdGVkUmVzdWx0IiwiZW5jcnlwdGVkUmVjb3JkIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJlbmNyeXB0ZWREYXRhIiwia2V5SWQiLCJhbGdvcml0aG0iLCJ0aW1lc3RhbXAiLCJpbml0aWFsaXplRW5jcnlwdGlvbiIsImluaXRpYWxpemVTZWN1cmVTZXNzaW9uIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0lBa0RnQkEsZUFBZTtlQUFmQTs7SUFzVkFDLHNCQUFzQjtlQUF0QkE7Ozt1QkF0WWlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnRDFDLFNBQVNELGdCQUNkRSxVQUErQixDQUFDLENBQUM7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