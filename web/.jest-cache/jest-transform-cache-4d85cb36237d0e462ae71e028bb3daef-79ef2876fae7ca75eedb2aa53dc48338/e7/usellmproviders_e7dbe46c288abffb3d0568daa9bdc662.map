{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/hooks/use-llm-providers.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport {\n  LLMProvider,\n  FailoverRule,\n} from \"@/components/ui/llm-provider-manager\";\nimport { CredentialFormData } from \"@/components/ui/secure-credential-input\";\nimport { EncryptionResult } from \"@/lib/crypto-client\";\n\nexport interface UseProvidersOptions {\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n}\n\nexport interface UseProvidersReturn {\n  providers: LLMProvider[];\n  failoverRules: FailoverRule[];\n  loading: boolean;\n  error: string | null;\n  // Provider management\n  createProvider: (\n    provider: Partial<LLMProvider>,\n  ) => Promise<LLMProvider | null>;\n  updateProvider: (\n    providerId: string,\n    updates: Partial<LLMProvider>,\n  ) => Promise<boolean>;\n  deleteProvider: (providerId: string) => Promise<boolean>;\n  reorderProviders: (providers: LLMProvider[]) => Promise<boolean>;\n  toggleProvider: (providerId: string) => Promise<boolean>;\n  // Utility functions\n  refreshProviders: () => Promise<void>;\n  getHealthyProviders: () => LLMProvider[];\n  getPrimaryProvider: () => LLMProvider | null;\n  getProviderById: (id: string) => LLMProvider | null;\n  // Health and monitoring\n  performHealthChecks: () => Promise<void>;\n  getProviderStats: () => {\n    total: number;\n    healthy: number;\n    enabled: number;\n    totalRequests: number;\n    totalCost: number;\n  };\n}\n\n/**\n * Hook for managing LLM providers\n */\nexport function useLLMProviders(\n  options: UseProvidersOptions = {},\n): UseProvidersReturn {\n  const { autoRefresh = false, refreshInterval = 300000 } = options; // 5 minutes default\n\n  const [providers, setProviders] = useState<LLMProvider[]>([]);\n  const [failoverRules, setFailoverRules] = useState<FailoverRule[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Fetch providers from API\n  const fetchProviders = useCallback(async () => {\n    try {\n      const response = await fetch(\"/api/llm/providers\");\n      if (!response.ok) {\n        throw new Error(`Failed to fetch providers: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      if (data.success) {\n        setProviders(data.providers || []);\n        setError(null);\n      } else {\n        throw new Error(data.error || \"Failed to fetch providers\");\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : \"Unknown error\";\n      setError(errorMessage);\n      console.error(\"[USE-PROVIDERS] Fetch error:\", err);\n    }\n  }, []);\n\n  // Fetch failover rules\n  const fetchFailoverRules = useCallback(async () => {\n    try {\n      const response = await fetch(\"/api/llm/failover-rules\");\n      if (response.ok) {\n        const data = await response.json();\n        if (data.success) {\n          setFailoverRules(data.rules || []);\n        }\n      }\n    } catch (err) {\n      console.warn(\"[USE-PROVIDERS] Failed to fetch failover rules:\", err);\n    }\n  }, []);\n\n  // Initial load\n  useEffect(() => {\n    const loadData = async () => {\n      setLoading(true);\n      await Promise.all([fetchProviders(), fetchFailoverRules()]);\n      setLoading(false);\n    };\n\n    loadData();\n  }, [fetchProviders, fetchFailoverRules]);\n\n  // Auto-refresh functionality\n  useEffect(() => {\n    if (!autoRefresh) return;\n\n    const interval = setInterval(() => {\n      fetchProviders();\n    }, refreshInterval);\n\n    return () => clearInterval(interval);\n  }, [autoRefresh, refreshInterval, fetchProviders]);\n\n  // Create new provider\n  const createProvider = useCallback(\n    async (providerData: Partial<LLMProvider>): Promise<LLMProvider | null> => {\n      try {\n        const response = await fetch(\"/api/llm/providers\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(providerData),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to create provider: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        if (data.success) {\n          const newProvider = data.provider;\n          setProviders((prev) => [...prev, newProvider]);\n          return newProvider;\n        } else {\n          throw new Error(data.error || \"Failed to create provider\");\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        setError(errorMessage);\n        console.error(\"[USE-PROVIDERS] Create error:\", err);\n        return null;\n      }\n    },\n    [],\n  );\n\n  // Update provider\n  const updateProvider = useCallback(\n    async (\n      providerId: string,\n      updates: Partial<LLMProvider>,\n    ): Promise<boolean> => {\n      try {\n        const response = await fetch(\"/api/llm/providers\", {\n          method: \"PUT\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            action: \"update\",\n            providerId,\n            updates,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to update provider: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        if (data.success) {\n          setProviders((prev) =>\n            prev.map((p) => (p.id === providerId ? { ...p, ...updates } : p)),\n          );\n          return true;\n        } else {\n          throw new Error(data.error || \"Failed to update provider\");\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        setError(errorMessage);\n        console.error(\"[USE-PROVIDERS] Update error:\", err);\n        return false;\n      }\n    },\n    [],\n  );\n\n  // Delete provider\n  const deleteProvider = useCallback(\n    async (providerId: string): Promise<boolean> => {\n      try {\n        const response = await fetch(`/api/llm/providers?id=${providerId}`, {\n          method: \"DELETE\",\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to delete provider: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        if (data.success) {\n          setProviders((prev) => prev.filter((p) => p.id !== providerId));\n          return true;\n        } else {\n          throw new Error(data.error || \"Failed to delete provider\");\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        setError(errorMessage);\n        console.error(\"[USE-PROVIDERS] Delete error:\", err);\n        return false;\n      }\n    },\n    [],\n  );\n\n  // Reorder providers\n  const reorderProviders = useCallback(\n    async (reorderedProviders: LLMProvider[]): Promise<boolean> => {\n      try {\n        const response = await fetch(\"/api/llm/providers\", {\n          method: \"PUT\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            action: \"reorder\",\n            providers: reorderedProviders,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(\n            `Failed to reorder providers: ${response.statusText}`,\n          );\n        }\n\n        const data = await response.json();\n        if (data.success) {\n          setProviders(data.providers);\n          return true;\n        } else {\n          throw new Error(data.error || \"Failed to reorder providers\");\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        setError(errorMessage);\n        console.error(\"[USE-PROVIDERS] Reorder error:\", err);\n        return false;\n      }\n    },\n    [],\n  );\n\n  // Toggle provider enabled state\n  const toggleProvider = useCallback(\n    async (providerId: string): Promise<boolean> => {\n      const provider = providers.find((p) => p.id === providerId);\n      if (!provider) return false;\n\n      return await updateProvider(providerId, { enabled: !provider.enabled });\n    },\n    [providers, updateProvider],\n  );\n\n  // Refresh providers\n  const refreshProviders = useCallback(async () => {\n    await fetchProviders();\n  }, [fetchProviders]);\n\n  // Get healthy providers\n  const getHealthyProviders = useCallback((): LLMProvider[] => {\n    return providers.filter((p) => p.enabled && p.status.isHealthy);\n  }, [providers]);\n\n  // Get primary provider (lowest priority number)\n  const getPrimaryProvider = useCallback((): LLMProvider | null => {\n    const enabledProviders = providers.filter((p) => p.enabled);\n    if (enabledProviders.length === 0) return null;\n\n    return enabledProviders.reduce((primary, current) =>\n      current.priority < primary.priority ? current : primary,\n    );\n  }, [providers]);\n\n  // Get provider by ID\n  const getProviderById = useCallback(\n    (id: string): LLMProvider | null => {\n      return providers.find((p) => p.id === id) || null;\n    },\n    [providers],\n  );\n\n  // Perform health checks\n  const performHealthChecks = useCallback(async () => {\n    // This would call the health check API for all providers\n    try {\n      const response = await fetch(\"/api/llm/health-check\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          providerIds: providers.map((p) => p.id),\n        }),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        if (data.success && data.results) {\n          // Update provider statuses\n          setProviders((prev) =>\n            prev.map((provider) => {\n              const healthResult = data.results[provider.id];\n              if (healthResult) {\n                return {\n                  ...provider,\n                  status: {\n                    ...provider.status,\n                    isHealthy: healthResult.isHealthy,\n                    lastHealthCheck: new Date(),\n                    responseTimeMs: healthResult.responseTimeMs,\n                    errorCount: healthResult.isHealthy\n                      ? 0\n                      : provider.status.errorCount + 1,\n                  },\n                };\n              }\n              return provider;\n            }),\n          );\n        }\n      }\n    } catch (err) {\n      console.error(\"[USE-PROVIDERS] Health check error:\", err);\n    }\n  }, [providers]);\n\n  // Get provider statistics\n  const getProviderStats = useCallback(() => {\n    const total = providers.length;\n    const healthy = providers.filter((p) => p.status.isHealthy).length;\n    const enabled = providers.filter((p) => p.enabled).length;\n    const totalRequests = providers.reduce(\n      (sum, p) => sum + p.usage.totalRequests,\n      0,\n    );\n    const totalCost = providers.reduce((sum, p) => sum + p.usage.totalCost, 0);\n\n    return {\n      total,\n      healthy,\n      enabled,\n      totalRequests,\n      totalCost,\n    };\n  }, [providers]);\n\n  return {\n    providers,\n    failoverRules,\n    loading,\n    error,\n    createProvider,\n    updateProvider,\n    deleteProvider,\n    reorderProviders,\n    toggleProvider,\n    refreshProviders,\n    getHealthyProviders,\n    getPrimaryProvider,\n    getProviderById,\n    performHealthChecks,\n    getProviderStats,\n  };\n}\n\n/**\n * Hook for managing provider credentials securely\n */\nexport function useProviderCredentials() {\n  const [encryptionStatus, setEncryptionStatus] = useState({\n    isInitialized: false,\n    hasKey: false,\n  });\n\n  const encryptCredentials = useCallback(\n    async (\n      credentials: CredentialFormData,\n    ): Promise<Record<string, EncryptionResult> | null> => {\n      try {\n        // Import and use the CredentialCrypto class\n        const { CredentialCrypto } = await import(\"@/lib/crypto-client\");\n\n        const encryptedResult =\n          await CredentialCrypto.encryptCredentials(credentials);\n\n        // Convert single result to record format expected by components\n        const encryptedRecord: Record<string, EncryptionResult> = {};\n\n        Object.keys(credentials).forEach((key) => {\n          if (credentials[key]) {\n            encryptedRecord[key] = {\n              encryptedData: encryptedResult.encryptedData,\n              keyId: encryptedResult.keyId,\n              algorithm: encryptedResult.algorithm,\n              timestamp: encryptedResult.timestamp,\n            };\n          }\n        });\n\n        return encryptedRecord;\n      } catch (error) {\n        console.error(\"[USE-CREDENTIALS] Encryption error:\", error);\n        return null;\n      }\n    },\n    [],\n  );\n\n  const initializeEncryption = useCallback(async (): Promise<boolean> => {\n    try {\n      const { CredentialCrypto } = await import(\"@/lib/crypto-client\");\n      await CredentialCrypto.initializeSecureSession();\n\n      setEncryptionStatus({\n        isInitialized: true,\n        hasKey: true,\n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"[USE-CREDENTIALS] Initialization error:\", error);\n      return false;\n    }\n  }, []);\n\n  return {\n    encryptionStatus,\n    encryptCredentials,\n    initializeEncryption,\n  };\n}\n"],"names":["useLLMProviders","useProviderCredentials","options","autoRefresh","refreshInterval","providers","setProviders","useState","failoverRules","setFailoverRules","loading","setLoading","error","setError","fetchProviders","useCallback","response","fetch","ok","Error","statusText","data","json","success","err","errorMessage","message","console","fetchFailoverRules","rules","warn","useEffect","loadData","Promise","all","interval","setInterval","clearInterval","createProvider","providerData","method","headers","body","JSON","stringify","newProvider","provider","prev","updateProvider","providerId","updates","action","map","p","id","deleteProvider","filter","reorderProviders","reorderedProviders","toggleProvider","find","enabled","refreshProviders","getHealthyProviders","status","isHealthy","getPrimaryProvider","enabledProviders","length","reduce","primary","current","priority","getProviderById","performHealthChecks","providerIds","results","healthResult","lastHealthCheck","Date","responseTimeMs","errorCount","getProviderStats","total","healthy","totalRequests","sum","usage","totalCost","encryptionStatus","setEncryptionStatus","isInitialized","hasKey","encryptCredentials","credentials","CredentialCrypto","encryptedResult","encryptedRecord","Object","keys","forEach","key","encryptedData","keyId","algorithm","timestamp","initializeEncryption","initializeSecureSession"],"mappings":"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"}