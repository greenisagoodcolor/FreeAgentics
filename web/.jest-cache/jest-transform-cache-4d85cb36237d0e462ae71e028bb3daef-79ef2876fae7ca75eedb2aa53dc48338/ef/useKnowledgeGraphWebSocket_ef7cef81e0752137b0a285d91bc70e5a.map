{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/hooks/useKnowledgeGraphWebSocket.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from \"react\";\nimport { KnowledgeGraphUpdate } from \"@/lib/types\";\n\n// WebSocket Hook for Knowledge Graph Real-time Updates\n// Implements ADR-008 WebSocket Communication patterns\n\nexport interface UseKnowledgeGraphWebSocketOptions {\n  graphId?: string;\n  autoConnect?: boolean;\n  reconnectAttempts?: number;\n  reconnectDelay?: number;\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n  onError?: (error: Event) => void;\n  onUpdate?: (update: KnowledgeGraphUpdate) => void;\n}\n\nexport interface WebSocketState {\n  isConnected: boolean;\n  isConnecting: boolean;\n  error: string | null;\n  lastUpdate: KnowledgeGraphUpdate | null;\n  connectionAttempts: number;\n}\n\nexport interface UseKnowledgeGraphWebSocketReturn {\n  state: WebSocketState;\n  connect: () => Promise<boolean>;\n  disconnect: () => void;\n  sendMessage: (message: any) => boolean;\n  subscribe: (\n    eventType: string,\n    callback: (update: KnowledgeGraphUpdate) => void,\n  ) => () => void;\n}\n\nexport function useKnowledgeGraphWebSocket(\n  options: UseKnowledgeGraphWebSocketOptions = {},\n): UseKnowledgeGraphWebSocketReturn {\n  const {\n    graphId,\n    autoConnect = true,\n    reconnectAttempts = 3,\n    reconnectDelay = 1000,\n    onConnect,\n    onDisconnect,\n    onError,\n    onUpdate,\n  } = options;\n\n  // WebSocket connection state\n  const [state, setState] = useState<WebSocketState>({\n    isConnected: false,\n    isConnecting: false,\n    error: null,\n    lastUpdate: null,\n    connectionAttempts: 0,\n  });\n\n  // Refs for WebSocket and event listeners\n  const wsRef = useRef<WebSocket | null>(null);\n  const eventListenersRef = useRef<\n    Map<string, Set<(update: KnowledgeGraphUpdate) => void>>\n  >(new Map());\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const heartbeatIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Generate WebSocket URL\n  const getWebSocketUrl = useCallback((graphId?: string): string => {\n    const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    const host = window.location.host;\n    const path = graphId ? `/ws/knowledge/${graphId}` : \"/ws/knowledge\";\n    return `${protocol}//${host}${path}`;\n  }, []);\n\n  // Handle incoming WebSocket messages\n  const handleMessage = useCallback(\n    (event: MessageEvent) => {\n      try {\n        const update: KnowledgeGraphUpdate = JSON.parse(event.data);\n\n        // Update state with latest update\n        setState((prev) => ({\n          ...prev,\n          lastUpdate: update,\n          error: null,\n        }));\n\n        // Call general update handler\n        onUpdate?.(update);\n\n        // Emit to specific event type listeners\n        const listeners = eventListenersRef.current.get(update.type);\n        if (listeners) {\n          listeners.forEach((callback) => {\n            try {\n              callback(update);\n            } catch (error) {\n              console.error(\"Error in WebSocket update callback:\", error);\n            }\n          });\n        }\n\n        // Emit to general update listeners\n        const generalListeners = eventListenersRef.current.get(\"update\");\n        if (generalListeners) {\n          generalListeners.forEach((callback) => {\n            try {\n              callback(update);\n            } catch (error) {\n              console.error(\n                \"Error in general WebSocket update callback:\",\n                error,\n              );\n            }\n          });\n        }\n      } catch (error) {\n        console.error(\"Failed to parse WebSocket message:\", error);\n        setState((prev) => ({\n          ...prev,\n          error: \"Failed to parse message\",\n        }));\n      }\n    },\n    [onUpdate],\n  );\n\n  // Handle WebSocket connection open\n  const handleOpen = useCallback(() => {\n    console.log(\"Knowledge graph WebSocket connected\");\n\n    setState((prev) => ({\n      ...prev,\n      isConnected: true,\n      isConnecting: false,\n      error: null,\n      connectionAttempts: 0,\n    }));\n\n    // Start heartbeat\n    heartbeatIntervalRef.current = setInterval(() => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({ type: \"ping\" }));\n      }\n    }, 30000); // 30 seconds\n\n    onConnect?.();\n  }, [onConnect]);\n\n  // Handle WebSocket connection close\n  const handleClose = useCallback(\n    (event: CloseEvent) => {\n      console.log(\n        \"Knowledge graph WebSocket disconnected:\",\n        event.code,\n        event.reason,\n      );\n\n      setState((prev) => ({\n        ...prev,\n        isConnected: false,\n        isConnecting: false,\n      }));\n\n      // Clear heartbeat\n      if (heartbeatIntervalRef.current) {\n        clearInterval(heartbeatIntervalRef.current);\n        heartbeatIntervalRef.current = null;\n      }\n\n      onDisconnect?.();\n\n      // Attempt reconnection if not manually closed\n      if (event.code !== 1000 && state.connectionAttempts < reconnectAttempts) {\n        setState((prev) => ({\n          ...prev,\n          connectionAttempts: prev.connectionAttempts + 1,\n        }));\n\n        reconnectTimeoutRef.current = setTimeout(\n          () => {\n            connect();\n          },\n          reconnectDelay * Math.pow(2, state.connectionAttempts),\n        ); // Exponential backoff\n      }\n    },\n    [onDisconnect, state.connectionAttempts, reconnectAttempts, reconnectDelay],\n  );\n\n  // Handle WebSocket errors\n  const handleError = useCallback(\n    (event: Event) => {\n      console.error(\"Knowledge graph WebSocket error:\", event);\n\n      setState((prev) => ({\n        ...prev,\n        error: \"WebSocket connection error\",\n        isConnecting: false,\n      }));\n\n      onError?.(event);\n    },\n    [onError],\n  );\n\n  // Connect to WebSocket\n  const connect = useCallback(async (): Promise<boolean> => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return true; // Already connected\n    }\n\n    if (state.isConnecting) {\n      return false; // Already connecting\n    }\n\n    setState((prev) => ({\n      ...prev,\n      isConnecting: true,\n      error: null,\n    }));\n\n    try {\n      const url = getWebSocketUrl(graphId);\n      const ws = new WebSocket(url);\n\n      ws.onopen = handleOpen;\n      ws.onmessage = handleMessage;\n      ws.onclose = handleClose;\n      ws.onerror = handleError;\n\n      wsRef.current = ws;\n\n      return new Promise((resolve) => {\n        const checkConnection = () => {\n          if (ws.readyState === WebSocket.OPEN) {\n            resolve(true);\n          } else if (\n            ws.readyState === WebSocket.CLOSED ||\n            ws.readyState === WebSocket.CLOSING\n          ) {\n            resolve(false);\n          } else {\n            setTimeout(checkConnection, 100);\n          }\n        };\n        checkConnection();\n      });\n    } catch (error) {\n      console.error(\"Failed to create WebSocket connection:\", error);\n      setState((prev) => ({\n        ...prev,\n        isConnecting: false,\n        error: \"Failed to create connection\",\n      }));\n      return false;\n    }\n  }, [\n    graphId,\n    state.isConnecting,\n    getWebSocketUrl,\n    handleOpen,\n    handleMessage,\n    handleClose,\n    handleError,\n  ]);\n\n  // Disconnect from WebSocket\n  const disconnect = useCallback(() => {\n    // Clear reconnection timeout\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n\n    // Clear heartbeat\n    if (heartbeatIntervalRef.current) {\n      clearInterval(heartbeatIntervalRef.current);\n      heartbeatIntervalRef.current = null;\n    }\n\n    // Close WebSocket connection\n    if (wsRef.current) {\n      wsRef.current.close(1000, \"Manual disconnect\");\n      wsRef.current = null;\n    }\n\n    setState((prev) => ({\n      ...prev,\n      isConnected: false,\n      isConnecting: false,\n      connectionAttempts: 0,\n    }));\n  }, []);\n\n  // Send message via WebSocket\n  const sendMessage = useCallback((message: any): boolean => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      try {\n        wsRef.current.send(JSON.stringify(message));\n        return true;\n      } catch (error) {\n        console.error(\"Failed to send WebSocket message:\", error);\n        setState((prev) => ({\n          ...prev,\n          error: \"Failed to send message\",\n        }));\n        return false;\n      }\n    }\n    return false;\n  }, []);\n\n  // Subscribe to specific event types\n  const subscribe = useCallback(\n    (\n      eventType: string,\n      callback: (update: KnowledgeGraphUpdate) => void,\n    ): (() => void) => {\n      if (!eventListenersRef.current.has(eventType)) {\n        eventListenersRef.current.set(eventType, new Set());\n      }\n\n      const listeners = eventListenersRef.current.get(eventType)!;\n      listeners.add(callback);\n\n      // Return unsubscribe function\n      return () => {\n        listeners.delete(callback);\n        if (listeners.size === 0) {\n          eventListenersRef.current.delete(eventType);\n        }\n      };\n    },\n    [],\n  );\n\n  // Auto-connect on mount if enabled\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n\n    // Cleanup on unmount\n    return () => {\n      disconnect();\n    };\n  }, [autoConnect, connect, disconnect]);\n\n  // Reconnect when graphId changes\n  useEffect(() => {\n    if (state.isConnected && graphId) {\n      disconnect();\n      setTimeout(() => connect(), 100);\n    }\n  }, [graphId]);\n\n  // Handle page visibility changes to reconnect when page becomes visible\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (\n        document.visibilityState === \"visible\" &&\n        !state.isConnected &&\n        !state.isConnecting\n      ) {\n        connect();\n      }\n    };\n\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    return () => {\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n    };\n  }, [state.isConnected, state.isConnecting, connect]);\n\n  return {\n    state,\n    connect,\n    disconnect,\n    sendMessage,\n    subscribe,\n  };\n}\n"],"names":["useKnowledgeGraphWebSocket","options","graphId","autoConnect","reconnectAttempts","reconnectDelay","onConnect","onDisconnect","onError","onUpdate","state","setState","useState","isConnected","isConnecting","error","lastUpdate","connectionAttempts","wsRef","useRef","eventListenersRef","Map","reconnectTimeoutRef","heartbeatIntervalRef","getWebSocketUrl","useCallback","protocol","window","location","host","path","handleMessage","event","update","JSON","parse","data","prev","listeners","current","get","type","forEach","callback","console","generalListeners","handleOpen","log","setInterval","readyState","WebSocket","OPEN","send","stringify","handleClose","code","reason","clearInterval","setTimeout","connect","Math","pow","handleError","url","ws","onopen","onmessage","onclose","onerror","Promise","resolve","checkConnection","CLOSED","CLOSING","disconnect","clearTimeout","close","sendMessage","message","subscribe","eventType","has","set","Set","add","delete","size","useEffect","handleVisibilityChange","document","visibilityState","addEventListener","removeEventListener"],"mappings":"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"}