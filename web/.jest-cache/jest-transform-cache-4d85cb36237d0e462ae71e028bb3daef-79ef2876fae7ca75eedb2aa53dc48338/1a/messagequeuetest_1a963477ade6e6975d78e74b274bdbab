9f32811a9ae49045dbb0d1993d5fb9dd
/**
 * Message Queue Tests
 *
 * Tests for real-time message queue handling, processing, and optimization
 * following ADR-007 comprehensive testing requirements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _messagequeue = require("../../lib/message-queue");
describe("Message Queue Management", ()=>{
    let queue;
    let config;
    beforeEach(()=>{
        config = {
            maxSize: 1000,
            batchSize: 10,
            processingInterval: 100,
            priorityLevels: [
                "critical",
                "high",
                "normal",
                "low"
            ],
            enableBatching: true,
            enableDeduplication: true,
            retryAttempts: 3,
            retryDelay: 1000
        };
        queue = (0, _messagequeue.createMessageQueue)(config);
    });
    describe("Queue Creation and Configuration", ()=>{
        it("creates queue with valid configuration", ()=>{
            expect(queue).toBeDefined();
            expect(queue.getConfig()).toMatchObject(config);
        });
        it("initializes with empty state", ()=>{
            const metrics = queue.getMetrics();
            expect(metrics.totalMessages).toBe(0);
            expect(metrics.pendingMessages).toBe(0);
            expect(metrics.processedMessages).toBe(0);
        });
        it("validates configuration constraints", ()=>{
            expect(()=>{
                (0, _messagequeue.createMessageQueue)({
                    ...config,
                    maxSize: -1
                });
            }).toThrow("Invalid configuration");
        });
    });
    describe("Message Enqueueing", ()=>{
        it("adds messages to queue", async ()=>{
            const message = {
                id: "msg-1",
                type: "agent_response",
                priority: "normal",
                content: "Test message",
                timestamp: Date.now(),
                agentId: "agent-1"
            };
            await queue.enqueue(message);
            const metrics = queue.getMetrics();
            expect(metrics.totalMessages).toBe(1);
            expect(metrics.pendingMessages).toBe(1);
        });
        it("respects priority ordering", async ()=>{
            const messages = [
                {
                    id: "low",
                    priority: "low",
                    content: "Low priority"
                },
                {
                    id: "critical",
                    priority: "critical",
                    content: "Critical priority"
                },
                {
                    id: "normal",
                    priority: "normal",
                    content: "Normal priority"
                },
                {
                    id: "high",
                    priority: "high",
                    content: "High priority"
                }
            ];
            for (const msg of messages){
                await queue.enqueue({
                    ...msg,
                    type: "test",
                    timestamp: Date.now(),
                    agentId: "agent-1"
                });
            }
            const nextMessage = await queue.dequeue();
            expect(nextMessage?.id).toBe("critical");
        });
        it("rejects messages when queue is full", async ()=>{
            const smallQueue = (0, _messagequeue.createMessageQueue)({
                ...config,
                maxSize: 2
            });
            await smallQueue.enqueue({
                id: "1",
                type: "test",
                priority: "normal",
                content: "Msg 1",
                timestamp: Date.now(),
                agentId: "agent-1"
            });
            await smallQueue.enqueue({
                id: "2",
                type: "test",
                priority: "normal",
                content: "Msg 2",
                timestamp: Date.now(),
                agentId: "agent-1"
            });
            await expect(smallQueue.enqueue({
                id: "3",
                type: "test",
                priority: "normal",
                content: "Msg 3",
                timestamp: Date.now(),
                agentId: "agent-1"
            })).rejects.toThrow("Queue full");
        });
        it("handles duplicate message detection", async ()=>{
            const message = {
                id: "duplicate",
                type: "test",
                priority: "normal",
                content: "Duplicate content",
                timestamp: Date.now(),
                agentId: "agent-1"
            };
            await queue.enqueue(message);
            await queue.enqueue({
                ...message,
                timestamp: Date.now() + 100
            });
            const metrics = queue.getMetrics();
            expect(metrics.totalMessages).toBe(1); // Should deduplicate
        });
    });
    describe("Message Processing", ()=>{
        it("processes single messages", async ()=>{
            const processor = jest.fn(async (message)=>({
                    success: true,
                    result: `Processed: ${message.content}`
                }));
            queue.setProcessor(processor);
            await queue.enqueue({
                id: "test-msg",
                type: "agent_response",
                priority: "normal",
                content: "Test content",
                timestamp: Date.now(),
                agentId: "agent-1"
            });
            await queue.processNext();
            expect(processor).toHaveBeenCalledTimes(1);
            expect(queue.getMetrics().processedMessages).toBe(1);
        });
        it("handles processing errors with retry", async ()=>{
            let attemptCount = 0;
            const failingProcessor = jest.fn(async (message)=>{
                attemptCount++;
                if (attemptCount < 3) {
                    throw new Error("Processing failed");
                }
                return {
                    success: true,
                    result: "Finally succeeded"
                };
            });
            queue.setProcessor(failingProcessor);
            await queue.enqueue({
                id: "failing-msg",
                type: "test",
                priority: "normal",
                content: "Will fail initially",
                timestamp: Date.now(),
                agentId: "agent-1"
            });
            await queue.processNext(); // First attempt (fail)
            await queue.processNext(); // Second attempt (fail)
            await queue.processNext(); // Third attempt (succeed)
            expect(failingProcessor).toHaveBeenCalledTimes(3);
            expect(queue.getMetrics().processedMessages).toBe(1);
        });
        it("moves to dead letter queue after max retries", async ()=>{
            const alwaysFailProcessor = jest.fn(async (message)=>{
                throw new Error("Always fails");
            });
            queue.setProcessor(alwaysFailProcessor);
            await queue.enqueue({
                id: "dead-letter-msg",
                type: "test",
                priority: "normal",
                content: "Will always fail",
                timestamp: Date.now(),
                agentId: "agent-1"
            });
            // Process with retries
            for(let i = 0; i < config.retryAttempts + 1; i++){
                await queue.processNext();
            }
            const deadLetterQueue = queue.getDeadLetterQueue();
            expect(deadLetterQueue.length).toBe(1);
            expect(deadLetterQueue[0].id).toBe("dead-letter-msg");
        });
    });
    describe("Batch Processing", ()=>{
        it("processes messages in batches", async ()=>{
            const batchProcessor = jest.fn(async (messages)=>messages.map((msg)=>({
                        success: true,
                        result: `Batch processed: ${msg.content}`
                    })));
            queue.setBatchProcessor(batchProcessor);
            // Add multiple messages
            for(let i = 0; i < 15; i++){
                await queue.enqueue({
                    id: `batch-msg-${i}`,
                    type: "test",
                    priority: "normal",
                    content: `Batch message ${i}`,
                    timestamp: Date.now(),
                    agentId: "agent-1"
                });
            }
            await queue.processBatch();
            expect(batchProcessor).toHaveBeenCalledWith(expect.arrayContaining([
                expect.objectContaining({
                    id: "batch-msg-0"
                }),
                expect.objectContaining({
                    id: "batch-msg-9"
                })
            ]));
        });
        it("optimizes batch sizes based on performance", async ()=>{
            const batchProcessor = jest.fn(async (messages)=>messages.map((msg)=>({
                        success: true,
                        result: `Processed: ${msg.content}`
                    })));
            queue.setBatchProcessor(batchProcessor);
            // Simulate successful batch processing
            for(let batch = 0; batch < 5; batch++){
                for(let i = 0; i < 20; i++){
                    await queue.enqueue({
                        id: `opt-${batch}-${i}`,
                        type: "test",
                        priority: "normal",
                        content: `Optimization test ${i}`,
                        timestamp: Date.now(),
                        agentId: "agent-1"
                    });
                }
                await queue.processBatch();
            }
            await queue.optimizeBatchSize();
            const newMetrics = queue.getMetrics();
            expect(newMetrics.averageBatchSize).toBeDefined();
        });
    });
    describe("Queue Optimization", ()=>{
        it("removes expired messages", async ()=>{
            const expiredMessage = {
                id: "expired",
                type: "test",
                priority: "normal",
                content: "Expired message",
                timestamp: Date.now() - 86400000,
                agentId: "agent-1",
                expiresAt: Date.now() - 3600000
            };
            const validMessage = {
                id: "valid",
                type: "test",
                priority: "normal",
                content: "Valid message",
                timestamp: Date.now(),
                agentId: "agent-1"
            };
            await queue.enqueue(expiredMessage);
            await queue.enqueue(validMessage);
            await queue.removeExpiredMessages();
            const metrics = queue.getMetrics();
            expect(metrics.pendingMessages).toBe(1);
        });
        it("compacts queue to remove gaps", async ()=>{
            const processor = jest.fn(async (message)=>({
                    success: true
                }));
            queue.setProcessor(processor);
            // Add messages
            for(let i = 0; i < 10; i++){
                await queue.enqueue({
                    id: `compact-${i}`,
                    type: "test",
                    priority: "normal",
                    content: `Message ${i}`,
                    timestamp: Date.now(),
                    agentId: "agent-1"
                });
            }
            // Process some messages to create gaps
            await queue.processNext();
            await queue.processNext();
            await queue.processNext();
            const beforeCompaction = queue.getMetrics();
            await queue.compact();
            const afterCompaction = queue.getMetrics();
            expect(afterCompaction.queueSize).toBeLessThanOrEqual(beforeCompaction.queueSize);
        });
    });
    describe("Message Filtering and Search", ()=>{
        beforeEach(async ()=>{
            // Add test messages
            const testMessages = [
                {
                    id: "agent1-msg1",
                    agentId: "agent-1",
                    type: "response",
                    content: "Hello from agent 1"
                },
                {
                    id: "agent2-msg1",
                    agentId: "agent-2",
                    type: "request",
                    content: "Request from agent 2"
                },
                {
                    id: "agent1-msg2",
                    agentId: "agent-1",
                    type: "response",
                    content: "Another response"
                }
            ];
            for (const msg of testMessages){
                await queue.enqueue({
                    ...msg,
                    priority: "normal",
                    timestamp: Date.now()
                });
            }
        });
        it("filters messages by agent ID", ()=>{
            const agent1Messages = queue.findMessages({
                agentId: "agent-1"
            });
            expect(agent1Messages).toHaveLength(2);
            expect(agent1Messages.every((m)=>m.agentId === "agent-1")).toBe(true);
        });
        it("filters messages by type", ()=>{
            const responseMessages = queue.findMessages({
                type: "response"
            });
            expect(responseMessages).toHaveLength(2);
            expect(responseMessages.every((m)=>m.type === "response")).toBe(true);
        });
        it("searches messages by content", ()=>{
            const helloMessages = queue.searchMessages("Hello");
            expect(helloMessages).toHaveLength(1);
            expect(helloMessages[0].content).toContain("Hello");
        });
    });
    describe("Real-time Processing", ()=>{
        it("starts and stops automatic processing", async ()=>{
            const processor = jest.fn(async (message)=>({
                    success: true
                }));
            queue.setProcessor(processor);
            await queue.enqueue({
                id: "auto-process",
                type: "test",
                priority: "normal",
                content: "Auto process test",
                timestamp: Date.now(),
                agentId: "agent-1"
            });
            queue.startAutoProcessing(50); // Process every 50ms
            await new Promise((resolve)=>setTimeout(resolve, 150));
            queue.stopAutoProcessing();
            expect(processor).toHaveBeenCalled();
        });
        it("handles concurrent processing safely", async ()=>{
            const processingTimes = [];
            const processor = jest.fn(async (message)=>{
                const start = Date.now();
                await new Promise((resolve)=>setTimeout(resolve, 10));
                processingTimes.push(Date.now() - start);
                return {
                    success: true
                };
            });
            queue.setProcessor(processor);
            // Add multiple messages
            const promises = [];
            for(let i = 0; i < 5; i++){
                promises.push(queue.enqueue({
                    id: `concurrent-${i}`,
                    type: "test",
                    priority: "normal",
                    content: `Concurrent message ${i}`,
                    timestamp: Date.now(),
                    agentId: "agent-1"
                }));
            }
            await Promise.all(promises);
            // Process concurrently
            const processPromises = [];
            for(let i = 0; i < 5; i++){
                processPromises.push(queue.processNext());
            }
            await Promise.all(processPromises);
            expect(processor).toHaveBeenCalledTimes(5);
            expect(queue.getMetrics().processedMessages).toBe(5);
        });
    });
    describe("Performance Monitoring", ()=>{
        it("tracks processing metrics", async ()=>{
            const fastProcessor = jest.fn(async (message)=>{
                await new Promise((resolve)=>setTimeout(resolve, 10));
                return {
                    success: true
                };
            });
            queue.setProcessor(fastProcessor);
            for(let i = 0; i < 5; i++){
                await queue.enqueue({
                    id: `perf-${i}`,
                    type: "test",
                    priority: "normal",
                    content: `Performance test ${i}`,
                    timestamp: Date.now(),
                    agentId: "agent-1"
                });
            }
            // Process all messages
            for(let i = 0; i < 5; i++){
                await queue.processNext();
            }
            const metrics = queue.getMetrics();
            expect(metrics.averageProcessingTime).toBeGreaterThan(0);
            expect(metrics.throughput).toBeGreaterThan(0);
            expect(metrics.errorRate).toBe(0);
        });
        it("detects performance degradation", async ()=>{
            let processingTime = 10;
            const degradingProcessor = jest.fn(async (message)=>{
                await new Promise((resolve)=>setTimeout(resolve, processingTime));
                processingTime += 5; // Gradually slow down
                return {
                    success: true
                };
            });
            queue.setProcessor(degradingProcessor);
            for(let i = 0; i < 10; i++){
                await queue.enqueue({
                    id: `degrade-${i}`,
                    type: "test",
                    priority: "normal",
                    content: `Degradation test ${i}`,
                    timestamp: Date.now(),
                    agentId: "agent-1"
                });
                await queue.processNext();
            }
            const performanceReport = queue.getPerformanceReport();
            expect(performanceReport.degradationDetected).toBe(true);
            expect(performanceReport.recommendations).toContain("Consider scaling processing capacity");
        });
    });
    describe("Error Handling and Recovery", ()=>{
        it("handles processor failures gracefully", async ()=>{
            const faultyProcessor = jest.fn(async (message)=>{
                if (message.id.includes("error")) {
                    throw new Error("Simulated processing error");
                }
                return {
                    success: true
                };
            });
            queue.setProcessor(faultyProcessor);
            await queue.enqueue({
                id: "normal-msg",
                type: "test",
                priority: "normal",
                content: "Normal message",
                timestamp: Date.now(),
                agentId: "agent-1"
            });
            await queue.enqueue({
                id: "error-msg",
                type: "test",
                priority: "normal",
                content: "Error message",
                timestamp: Date.now(),
                agentId: "agent-1"
            });
            await queue.processNext(); // Should succeed
            await queue.processNext(); // Should fail but not crash
            const metrics = queue.getMetrics();
            expect(metrics.processedMessages).toBe(1);
            expect(metrics.errorCount).toBe(1);
        });
        it("recovers from queue corruption", async ()=>{
            // Simulate queue corruption
            queue.simulateCorruption(); // Mock method for testing
            const isHealthy = await queue.performHealthCheck();
            expect(isHealthy).toBe(false);
            await queue.recover();
            const isHealthyAfterRecovery = await queue.performHealthCheck();
            expect(isHealthyAfterRecovery).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL21lc3NhZ2UtcXVldWUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1lc3NhZ2UgUXVldWUgVGVzdHNcbiAqXG4gKiBUZXN0cyBmb3IgcmVhbC10aW1lIG1lc3NhZ2UgcXVldWUgaGFuZGxpbmcsIHByb2Nlc3NpbmcsIGFuZCBvcHRpbWl6YXRpb25cbiAqIGZvbGxvd2luZyBBRFItMDA3IGNvbXByZWhlbnNpdmUgdGVzdGluZyByZXF1aXJlbWVudHMuXG4gKi9cblxuaW1wb3J0IHtcbiAgTWVzc2FnZVF1ZXVlLFxuICBjcmVhdGVNZXNzYWdlUXVldWUsXG4gIE1lc3NhZ2UsXG4gIE1lc3NhZ2VQcmlvcml0eSxcbiAgUXVldWVNZXRyaWNzLFxuICBwcm9jZXNzTWVzc2FnZSxcbiAgYmF0Y2hQcm9jZXNzTWVzc2FnZXMsXG4gIG9wdGltaXplUXVldWUsXG4gIE1lc3NhZ2VQcm9jZXNzb3IsXG4gIFF1ZXVlQ29uZmlnLFxufSBmcm9tIFwiQC9saWIvbWVzc2FnZS1xdWV1ZVwiO1xuXG5kZXNjcmliZShcIk1lc3NhZ2UgUXVldWUgTWFuYWdlbWVudFwiLCAoKSA9PiB7XG4gIGxldCBxdWV1ZTogTWVzc2FnZVF1ZXVlO1xuICBsZXQgY29uZmlnOiBRdWV1ZUNvbmZpZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBjb25maWcgPSB7XG4gICAgICBtYXhTaXplOiAxMDAwLFxuICAgICAgYmF0Y2hTaXplOiAxMCxcbiAgICAgIHByb2Nlc3NpbmdJbnRlcnZhbDogMTAwLFxuICAgICAgcHJpb3JpdHlMZXZlbHM6IFtcImNyaXRpY2FsXCIsIFwiaGlnaFwiLCBcIm5vcm1hbFwiLCBcImxvd1wiXSxcbiAgICAgIGVuYWJsZUJhdGNoaW5nOiB0cnVlLFxuICAgICAgZW5hYmxlRGVkdXBsaWNhdGlvbjogdHJ1ZSxcbiAgICAgIHJldHJ5QXR0ZW1wdHM6IDMsXG4gICAgICByZXRyeURlbGF5OiAxMDAwLFxuICAgIH07XG5cbiAgICBxdWV1ZSA9IGNyZWF0ZU1lc3NhZ2VRdWV1ZShjb25maWcpO1xuICB9KTtcblxuICBkZXNjcmliZShcIlF1ZXVlIENyZWF0aW9uIGFuZCBDb25maWd1cmF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcImNyZWF0ZXMgcXVldWUgd2l0aCB2YWxpZCBjb25maWd1cmF0aW9uXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChxdWV1ZSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChxdWV1ZS5nZXRDb25maWcoKSkudG9NYXRjaE9iamVjdChjb25maWcpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJpbml0aWFsaXplcyB3aXRoIGVtcHR5IHN0YXRlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBxdWV1ZS5nZXRNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbE1lc3NhZ2VzKS50b0JlKDApO1xuICAgICAgZXhwZWN0KG1ldHJpY3MucGVuZGluZ01lc3NhZ2VzKS50b0JlKDApO1xuICAgICAgZXhwZWN0KG1ldHJpY3MucHJvY2Vzc2VkTWVzc2FnZXMpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdChcInZhbGlkYXRlcyBjb25maWd1cmF0aW9uIGNvbnN0cmFpbnRzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGNyZWF0ZU1lc3NhZ2VRdWV1ZSh7XG4gICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgIG1heFNpemU6IC0xLFxuICAgICAgICB9KTtcbiAgICAgIH0pLnRvVGhyb3coXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb25cIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiTWVzc2FnZSBFbnF1ZXVlaW5nXCIsICgpID0+IHtcbiAgICBpdChcImFkZHMgbWVzc2FnZXMgdG8gcXVldWVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgaWQ6IFwibXNnLTFcIixcbiAgICAgICAgdHlwZTogXCJhZ2VudF9yZXNwb25zZVwiLFxuICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIixcbiAgICAgICAgY29udGVudDogXCJUZXN0IG1lc3NhZ2VcIixcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUobWVzc2FnZSk7XG5cbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBxdWV1ZS5nZXRNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbE1lc3NhZ2VzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MucGVuZGluZ01lc3NhZ2VzKS50b0JlKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJyZXNwZWN0cyBwcmlvcml0eSBvcmRlcmluZ1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxvd1wiLFxuICAgICAgICAgIHByaW9yaXR5OiBcImxvd1wiIGFzIE1lc3NhZ2VQcmlvcml0eSxcbiAgICAgICAgICBjb250ZW50OiBcIkxvdyBwcmlvcml0eVwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwiY3JpdGljYWxcIixcbiAgICAgICAgICBwcmlvcml0eTogXCJjcml0aWNhbFwiIGFzIE1lc3NhZ2VQcmlvcml0eSxcbiAgICAgICAgICBjb250ZW50OiBcIkNyaXRpY2FsIHByaW9yaXR5XCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJub3JtYWxcIixcbiAgICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIiBhcyBNZXNzYWdlUHJpb3JpdHksXG4gICAgICAgICAgY29udGVudDogXCJOb3JtYWwgcHJpb3JpdHlcIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImhpZ2hcIixcbiAgICAgICAgICBwcmlvcml0eTogXCJoaWdoXCIgYXMgTWVzc2FnZVByaW9yaXR5LFxuICAgICAgICAgIGNvbnRlbnQ6IFwiSGlnaCBwcmlvcml0eVwiLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBtc2cgb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgYXdhaXQgcXVldWUuZW5xdWV1ZSh7XG4gICAgICAgICAgLi4ubXNnLFxuICAgICAgICAgIHR5cGU6IFwidGVzdFwiLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5leHRNZXNzYWdlID0gYXdhaXQgcXVldWUuZGVxdWV1ZSgpO1xuICAgICAgZXhwZWN0KG5leHRNZXNzYWdlPy5pZCkudG9CZShcImNyaXRpY2FsXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJyZWplY3RzIG1lc3NhZ2VzIHdoZW4gcXVldWUgaXMgZnVsbFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzbWFsbFF1ZXVlID0gY3JlYXRlTWVzc2FnZVF1ZXVlKHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBtYXhTaXplOiAyLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHNtYWxsUXVldWUuZW5xdWV1ZSh7XG4gICAgICAgIGlkOiBcIjFcIixcbiAgICAgICAgdHlwZTogXCJ0ZXN0XCIsXG4gICAgICAgIHByaW9yaXR5OiBcIm5vcm1hbFwiLFxuICAgICAgICBjb250ZW50OiBcIk1zZyAxXCIsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHNtYWxsUXVldWUuZW5xdWV1ZSh7XG4gICAgICAgIGlkOiBcIjJcIixcbiAgICAgICAgdHlwZTogXCJ0ZXN0XCIsXG4gICAgICAgIHByaW9yaXR5OiBcIm5vcm1hbFwiLFxuICAgICAgICBjb250ZW50OiBcIk1zZyAyXCIsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzbWFsbFF1ZXVlLmVucXVldWUoe1xuICAgICAgICAgIGlkOiBcIjNcIixcbiAgICAgICAgICB0eXBlOiBcInRlc3RcIixcbiAgICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIixcbiAgICAgICAgICBjb250ZW50OiBcIk1zZyAzXCIsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICB9KSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KFwiUXVldWUgZnVsbFwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwiaGFuZGxlcyBkdXBsaWNhdGUgbWVzc2FnZSBkZXRlY3Rpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgaWQ6IFwiZHVwbGljYXRlXCIsXG4gICAgICAgIHR5cGU6IFwidGVzdFwiIGFzIGNvbnN0LFxuICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIiBhcyBNZXNzYWdlUHJpb3JpdHksXG4gICAgICAgIGNvbnRlbnQ6IFwiRHVwbGljYXRlIGNvbnRlbnRcIixcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUobWVzc2FnZSk7XG4gICAgICBhd2FpdCBxdWV1ZS5lbnF1ZXVlKHsgLi4ubWVzc2FnZSwgdGltZXN0YW1wOiBEYXRlLm5vdygpICsgMTAwIH0pO1xuXG4gICAgICBjb25zdCBtZXRyaWNzID0gcXVldWUuZ2V0TWV0cmljcygpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MudG90YWxNZXNzYWdlcykudG9CZSgxKTsgLy8gU2hvdWxkIGRlZHVwbGljYXRlXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiTWVzc2FnZSBQcm9jZXNzaW5nXCIsICgpID0+IHtcbiAgICBpdChcInByb2Nlc3NlcyBzaW5nbGUgbWVzc2FnZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc29yOiBNZXNzYWdlUHJvY2Vzc29yID0gamVzdC5mbihhc3luYyAobWVzc2FnZSkgPT4gKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcmVzdWx0OiBgUHJvY2Vzc2VkOiAke21lc3NhZ2UuY29udGVudH1gLFxuICAgICAgfSkpO1xuXG4gICAgICBxdWV1ZS5zZXRQcm9jZXNzb3IocHJvY2Vzc29yKTtcblxuICAgICAgYXdhaXQgcXVldWUuZW5xdWV1ZSh7XG4gICAgICAgIGlkOiBcInRlc3QtbXNnXCIsXG4gICAgICAgIHR5cGU6IFwiYWdlbnRfcmVzcG9uc2VcIixcbiAgICAgICAgcHJpb3JpdHk6IFwibm9ybWFsXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiVGVzdCBjb250ZW50XCIsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgcXVldWUucHJvY2Vzc05leHQoKTtcblxuICAgICAgZXhwZWN0KHByb2Nlc3NvcikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KHF1ZXVlLmdldE1ldHJpY3MoKS5wcm9jZXNzZWRNZXNzYWdlcykudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KFwiaGFuZGxlcyBwcm9jZXNzaW5nIGVycm9ycyB3aXRoIHJldHJ5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhdHRlbXB0Q291bnQgPSAwO1xuICAgICAgY29uc3QgZmFpbGluZ1Byb2Nlc3NvcjogTWVzc2FnZVByb2Nlc3NvciA9IGplc3QuZm4oYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgYXR0ZW1wdENvdW50Kys7XG4gICAgICAgIGlmIChhdHRlbXB0Q291bnQgPCAzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvY2Vzc2luZyBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcmVzdWx0OiBcIkZpbmFsbHkgc3VjY2VlZGVkXCIgfTtcbiAgICAgIH0pO1xuXG4gICAgICBxdWV1ZS5zZXRQcm9jZXNzb3IoZmFpbGluZ1Byb2Nlc3Nvcik7XG5cbiAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUoe1xuICAgICAgICBpZDogXCJmYWlsaW5nLW1zZ1wiLFxuICAgICAgICB0eXBlOiBcInRlc3RcIixcbiAgICAgICAgcHJpb3JpdHk6IFwibm9ybWFsXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiV2lsbCBmYWlsIGluaXRpYWxseVwiLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHF1ZXVlLnByb2Nlc3NOZXh0KCk7IC8vIEZpcnN0IGF0dGVtcHQgKGZhaWwpXG4gICAgICBhd2FpdCBxdWV1ZS5wcm9jZXNzTmV4dCgpOyAvLyBTZWNvbmQgYXR0ZW1wdCAoZmFpbClcbiAgICAgIGF3YWl0IHF1ZXVlLnByb2Nlc3NOZXh0KCk7IC8vIFRoaXJkIGF0dGVtcHQgKHN1Y2NlZWQpXG5cbiAgICAgIGV4cGVjdChmYWlsaW5nUHJvY2Vzc29yKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICBleHBlY3QocXVldWUuZ2V0TWV0cmljcygpLnByb2Nlc3NlZE1lc3NhZ2VzKS50b0JlKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJtb3ZlcyB0byBkZWFkIGxldHRlciBxdWV1ZSBhZnRlciBtYXggcmV0cmllc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhbHdheXNGYWlsUHJvY2Vzc29yOiBNZXNzYWdlUHJvY2Vzc29yID0gamVzdC5mbihhc3luYyAobWVzc2FnZSkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHdheXMgZmFpbHNcIik7XG4gICAgICB9KTtcblxuICAgICAgcXVldWUuc2V0UHJvY2Vzc29yKGFsd2F5c0ZhaWxQcm9jZXNzb3IpO1xuXG4gICAgICBhd2FpdCBxdWV1ZS5lbnF1ZXVlKHtcbiAgICAgICAgaWQ6IFwiZGVhZC1sZXR0ZXItbXNnXCIsXG4gICAgICAgIHR5cGU6IFwidGVzdFwiLFxuICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIixcbiAgICAgICAgY29udGVudDogXCJXaWxsIGFsd2F5cyBmYWlsXCIsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvY2VzcyB3aXRoIHJldHJpZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlnLnJldHJ5QXR0ZW1wdHMgKyAxOyBpKyspIHtcbiAgICAgICAgYXdhaXQgcXVldWUucHJvY2Vzc05leHQoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVhZExldHRlclF1ZXVlID0gcXVldWUuZ2V0RGVhZExldHRlclF1ZXVlKCk7XG4gICAgICBleHBlY3QoZGVhZExldHRlclF1ZXVlLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChkZWFkTGV0dGVyUXVldWVbMF0uaWQpLnRvQmUoXCJkZWFkLWxldHRlci1tc2dcIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiQmF0Y2ggUHJvY2Vzc2luZ1wiLCAoKSA9PiB7XG4gICAgaXQoXCJwcm9jZXNzZXMgbWVzc2FnZXMgaW4gYmF0Y2hlc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBiYXRjaFByb2Nlc3NvciA9IGplc3QuZm4oYXN5bmMgKG1lc3NhZ2VzKSA9PlxuICAgICAgICBtZXNzYWdlcy5tYXAoKG1zZykgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHJlc3VsdDogYEJhdGNoIHByb2Nlc3NlZDogJHttc2cuY29udGVudH1gLFxuICAgICAgICB9KSksXG4gICAgICApO1xuXG4gICAgICBxdWV1ZS5zZXRCYXRjaFByb2Nlc3NvcihiYXRjaFByb2Nlc3Nvcik7XG5cbiAgICAgIC8vIEFkZCBtdWx0aXBsZSBtZXNzYWdlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUoe1xuICAgICAgICAgIGlkOiBgYmF0Y2gtbXNnLSR7aX1gLFxuICAgICAgICAgIHR5cGU6IFwidGVzdFwiLFxuICAgICAgICAgIHByaW9yaXR5OiBcIm5vcm1hbFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBCYXRjaCBtZXNzYWdlICR7aX1gLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHF1ZXVlLnByb2Nlc3NCYXRjaCgpO1xuXG4gICAgICBleHBlY3QoYmF0Y2hQcm9jZXNzb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3QuYXJyYXlDb250YWluaW5nKFtcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IGlkOiBcImJhdGNoLW1zZy0wXCIgfSksXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoeyBpZDogXCJiYXRjaC1tc2ctOVwiIH0pLFxuICAgICAgICBdKSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcIm9wdGltaXplcyBiYXRjaCBzaXplcyBiYXNlZCBvbiBwZXJmb3JtYW5jZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBiYXRjaFByb2Nlc3NvciA9IGplc3QuZm4oYXN5bmMgKG1lc3NhZ2VzKSA9PlxuICAgICAgICBtZXNzYWdlcy5tYXAoKG1zZykgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHJlc3VsdDogYFByb2Nlc3NlZDogJHttc2cuY29udGVudH1gLFxuICAgICAgICB9KSksXG4gICAgICApO1xuICAgICAgcXVldWUuc2V0QmF0Y2hQcm9jZXNzb3IoYmF0Y2hQcm9jZXNzb3IpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBzdWNjZXNzZnVsIGJhdGNoIHByb2Nlc3NpbmdcbiAgICAgIGZvciAobGV0IGJhdGNoID0gMDsgYmF0Y2ggPCA1OyBiYXRjaCsrKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUoe1xuICAgICAgICAgICAgaWQ6IGBvcHQtJHtiYXRjaH0tJHtpfWAsXG4gICAgICAgICAgICB0eXBlOiBcInRlc3RcIixcbiAgICAgICAgICAgIHByaW9yaXR5OiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgY29udGVudDogYE9wdGltaXphdGlvbiB0ZXN0ICR7aX1gLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcXVldWUucHJvY2Vzc0JhdGNoKCk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHF1ZXVlLm9wdGltaXplQmF0Y2hTaXplKCk7XG5cbiAgICAgIGNvbnN0IG5ld01ldHJpY3MgPSBxdWV1ZS5nZXRNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobmV3TWV0cmljcy5hdmVyYWdlQmF0Y2hTaXplKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlF1ZXVlIE9wdGltaXphdGlvblwiLCAoKSA9PiB7XG4gICAgaXQoXCJyZW1vdmVzIGV4cGlyZWQgbWVzc2FnZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwaXJlZE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBcImV4cGlyZWRcIixcbiAgICAgICAgdHlwZTogXCJ0ZXN0XCIgYXMgY29uc3QsXG4gICAgICAgIHByaW9yaXR5OiBcIm5vcm1hbFwiIGFzIE1lc3NhZ2VQcmlvcml0eSxcbiAgICAgICAgY29udGVudDogXCJFeHBpcmVkIG1lc3NhZ2VcIixcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpIC0gODY0MDAwMDAsIC8vIDI0IGhvdXJzIGFnb1xuICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpIC0gMzYwMDAwMCwgLy8gMSBob3VyIGFnb1xuICAgICAgfTtcblxuICAgICAgY29uc3QgdmFsaWRNZXNzYWdlID0ge1xuICAgICAgICBpZDogXCJ2YWxpZFwiLFxuICAgICAgICB0eXBlOiBcInRlc3RcIiBhcyBjb25zdCxcbiAgICAgICAgcHJpb3JpdHk6IFwibm9ybWFsXCIgYXMgTWVzc2FnZVByaW9yaXR5LFxuICAgICAgICBjb250ZW50OiBcIlZhbGlkIG1lc3NhZ2VcIixcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUoZXhwaXJlZE1lc3NhZ2UpO1xuICAgICAgYXdhaXQgcXVldWUuZW5xdWV1ZSh2YWxpZE1lc3NhZ2UpO1xuXG4gICAgICBhd2FpdCBxdWV1ZS5yZW1vdmVFeHBpcmVkTWVzc2FnZXMoKTtcblxuICAgICAgY29uc3QgbWV0cmljcyA9IHF1ZXVlLmdldE1ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLnBlbmRpbmdNZXNzYWdlcykudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KFwiY29tcGFjdHMgcXVldWUgdG8gcmVtb3ZlIGdhcHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc29yID0gamVzdC5mbihhc3luYyAobWVzc2FnZSkgPT4gKHsgc3VjY2VzczogdHJ1ZSB9KSk7XG4gICAgICBxdWV1ZS5zZXRQcm9jZXNzb3IocHJvY2Vzc29yKTtcblxuICAgICAgLy8gQWRkIG1lc3NhZ2VzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgYXdhaXQgcXVldWUuZW5xdWV1ZSh7XG4gICAgICAgICAgaWQ6IGBjb21wYWN0LSR7aX1gLFxuICAgICAgICAgIHR5cGU6IFwidGVzdFwiLFxuICAgICAgICAgIHByaW9yaXR5OiBcIm5vcm1hbFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBNZXNzYWdlICR7aX1gLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByb2Nlc3Mgc29tZSBtZXNzYWdlcyB0byBjcmVhdGUgZ2Fwc1xuICAgICAgYXdhaXQgcXVldWUucHJvY2Vzc05leHQoKTtcbiAgICAgIGF3YWl0IHF1ZXVlLnByb2Nlc3NOZXh0KCk7XG4gICAgICBhd2FpdCBxdWV1ZS5wcm9jZXNzTmV4dCgpO1xuXG4gICAgICBjb25zdCBiZWZvcmVDb21wYWN0aW9uID0gcXVldWUuZ2V0TWV0cmljcygpO1xuICAgICAgYXdhaXQgcXVldWUuY29tcGFjdCgpO1xuICAgICAgY29uc3QgYWZ0ZXJDb21wYWN0aW9uID0gcXVldWUuZ2V0TWV0cmljcygpO1xuXG4gICAgICBleHBlY3QoYWZ0ZXJDb21wYWN0aW9uLnF1ZXVlU2l6ZSkudG9CZUxlc3NUaGFuT3JFcXVhbChcbiAgICAgICAgYmVmb3JlQ29tcGFjdGlvbi5xdWV1ZVNpemUsXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIk1lc3NhZ2UgRmlsdGVyaW5nIGFuZCBTZWFyY2hcIiwgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWRkIHRlc3QgbWVzc2FnZXNcbiAgICAgIGNvbnN0IHRlc3RNZXNzYWdlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImFnZW50MS1tc2cxXCIsXG4gICAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgICAgdHlwZTogXCJyZXNwb25zZVwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiSGVsbG8gZnJvbSBhZ2VudCAxXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJhZ2VudDItbXNnMVwiLFxuICAgICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMlwiLFxuICAgICAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiUmVxdWVzdCBmcm9tIGFnZW50IDJcIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImFnZW50MS1tc2cyXCIsXG4gICAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgICAgdHlwZTogXCJyZXNwb25zZVwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiQW5vdGhlciByZXNwb25zZVwiLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBtc2cgb2YgdGVzdE1lc3NhZ2VzKSB7XG4gICAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUoe1xuICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIiBhcyBNZXNzYWdlUHJpb3JpdHksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiZmlsdGVycyBtZXNzYWdlcyBieSBhZ2VudCBJRFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBhZ2VudDFNZXNzYWdlcyA9IHF1ZXVlLmZpbmRNZXNzYWdlcyh7IGFnZW50SWQ6IFwiYWdlbnQtMVwiIH0pO1xuICAgICAgZXhwZWN0KGFnZW50MU1lc3NhZ2VzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QoYWdlbnQxTWVzc2FnZXMuZXZlcnkoKG0pID0+IG0uYWdlbnRJZCA9PT0gXCJhZ2VudC0xXCIpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJmaWx0ZXJzIG1lc3NhZ2VzIGJ5IHR5cGVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IHF1ZXVlLmZpbmRNZXNzYWdlcyh7IHR5cGU6IFwicmVzcG9uc2VcIiB9KTtcbiAgICAgIGV4cGVjdChyZXNwb25zZU1lc3NhZ2VzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QocmVzcG9uc2VNZXNzYWdlcy5ldmVyeSgobSkgPT4gbS50eXBlID09PSBcInJlc3BvbnNlXCIpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzZWFyY2hlcyBtZXNzYWdlcyBieSBjb250ZW50XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGhlbGxvTWVzc2FnZXMgPSBxdWV1ZS5zZWFyY2hNZXNzYWdlcyhcIkhlbGxvXCIpO1xuICAgICAgZXhwZWN0KGhlbGxvTWVzc2FnZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChoZWxsb01lc3NhZ2VzWzBdLmNvbnRlbnQpLnRvQ29udGFpbihcIkhlbGxvXCIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlJlYWwtdGltZSBQcm9jZXNzaW5nXCIsICgpID0+IHtcbiAgICBpdChcInN0YXJ0cyBhbmQgc3RvcHMgYXV0b21hdGljIHByb2Nlc3NpbmdcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc29yID0gamVzdC5mbihhc3luYyAobWVzc2FnZSkgPT4gKHsgc3VjY2VzczogdHJ1ZSB9KSk7XG4gICAgICBxdWV1ZS5zZXRQcm9jZXNzb3IocHJvY2Vzc29yKTtcblxuICAgICAgYXdhaXQgcXVldWUuZW5xdWV1ZSh7XG4gICAgICAgIGlkOiBcImF1dG8tcHJvY2Vzc1wiLFxuICAgICAgICB0eXBlOiBcInRlc3RcIixcbiAgICAgICAgcHJpb3JpdHk6IFwibm9ybWFsXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiQXV0byBwcm9jZXNzIHRlc3RcIixcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgIH0pO1xuXG4gICAgICBxdWV1ZS5zdGFydEF1dG9Qcm9jZXNzaW5nKDUwKTsgLy8gUHJvY2VzcyBldmVyeSA1MG1zXG5cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MCkpO1xuXG4gICAgICBxdWV1ZS5zdG9wQXV0b1Byb2Nlc3NpbmcoKTtcblxuICAgICAgZXhwZWN0KHByb2Nlc3NvcikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJoYW5kbGVzIGNvbmN1cnJlbnQgcHJvY2Vzc2luZyBzYWZlbHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc2luZ1RpbWVzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgY29uc3QgcHJvY2Vzc29yID0gamVzdC5mbihhc3luYyAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgIHByb2Nlc3NpbmdUaW1lcy5wdXNoKERhdGUubm93KCkgLSBzdGFydCk7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICBxdWV1ZS5zZXRQcm9jZXNzb3IocHJvY2Vzc29yKTtcblxuICAgICAgLy8gQWRkIG11bHRpcGxlIG1lc3NhZ2VzXG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICBxdWV1ZS5lbnF1ZXVlKHtcbiAgICAgICAgICAgIGlkOiBgY29uY3VycmVudC0ke2l9YCxcbiAgICAgICAgICAgIHR5cGU6IFwidGVzdFwiLFxuICAgICAgICAgICAgcHJpb3JpdHk6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBjb250ZW50OiBgQ29uY3VycmVudCBtZXNzYWdlICR7aX1gLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgLy8gUHJvY2VzcyBjb25jdXJyZW50bHlcbiAgICAgIGNvbnN0IHByb2Nlc3NQcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgcHJvY2Vzc1Byb21pc2VzLnB1c2gocXVldWUucHJvY2Vzc05leHQoKSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb2Nlc3NQcm9taXNlcyk7XG5cbiAgICAgIGV4cGVjdChwcm9jZXNzb3IpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg1KTtcbiAgICAgIGV4cGVjdChxdWV1ZS5nZXRNZXRyaWNzKCkucHJvY2Vzc2VkTWVzc2FnZXMpLnRvQmUoNSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiUGVyZm9ybWFuY2UgTW9uaXRvcmluZ1wiLCAoKSA9PiB7XG4gICAgaXQoXCJ0cmFja3MgcHJvY2Vzc2luZyBtZXRyaWNzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZhc3RQcm9jZXNzb3IgPSBqZXN0LmZuKGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICBxdWV1ZS5zZXRQcm9jZXNzb3IoZmFzdFByb2Nlc3Nvcik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUoe1xuICAgICAgICAgIGlkOiBgcGVyZi0ke2l9YCxcbiAgICAgICAgICB0eXBlOiBcInRlc3RcIixcbiAgICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIixcbiAgICAgICAgICBjb250ZW50OiBgUGVyZm9ybWFuY2UgdGVzdCAke2l9YCxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQcm9jZXNzIGFsbCBtZXNzYWdlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgYXdhaXQgcXVldWUucHJvY2Vzc05leHQoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWV0cmljcyA9IHF1ZXVlLmdldE1ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmF2ZXJhZ2VQcm9jZXNzaW5nVGltZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KG1ldHJpY3MudGhyb3VnaHB1dCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JSYXRlKS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgaXQoXCJkZXRlY3RzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBwcm9jZXNzaW5nVGltZSA9IDEwO1xuICAgICAgY29uc3QgZGVncmFkaW5nUHJvY2Vzc29yID0gamVzdC5mbihhc3luYyAobWVzc2FnZSkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBwcm9jZXNzaW5nVGltZSkpO1xuICAgICAgICBwcm9jZXNzaW5nVGltZSArPSA1OyAvLyBHcmFkdWFsbHkgc2xvdyBkb3duXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICBxdWV1ZS5zZXRQcm9jZXNzb3IoZGVncmFkaW5nUHJvY2Vzc29yKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHF1ZXVlLmVucXVldWUoe1xuICAgICAgICAgIGlkOiBgZGVncmFkZS0ke2l9YCxcbiAgICAgICAgICB0eXBlOiBcInRlc3RcIixcbiAgICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIixcbiAgICAgICAgICBjb250ZW50OiBgRGVncmFkYXRpb24gdGVzdCAke2l9YCxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBxdWV1ZS5wcm9jZXNzTmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwZXJmb3JtYW5jZVJlcG9ydCA9IHF1ZXVlLmdldFBlcmZvcm1hbmNlUmVwb3J0KCk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2VSZXBvcnQuZGVncmFkYXRpb25EZXRlY3RlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChwZXJmb3JtYW5jZVJlcG9ydC5yZWNvbW1lbmRhdGlvbnMpLnRvQ29udGFpbihcbiAgICAgICAgXCJDb25zaWRlciBzY2FsaW5nIHByb2Nlc3NpbmcgY2FwYWNpdHlcIixcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRXJyb3IgSGFuZGxpbmcgYW5kIFJlY292ZXJ5XCIsICgpID0+IHtcbiAgICBpdChcImhhbmRsZXMgcHJvY2Vzc29yIGZhaWx1cmVzIGdyYWNlZnVsbHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmF1bHR5UHJvY2Vzc29yID0gamVzdC5mbihhc3luYyAobWVzc2FnZSkgPT4ge1xuICAgICAgICBpZiAobWVzc2FnZS5pZC5pbmNsdWRlcyhcImVycm9yXCIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2ltdWxhdGVkIHByb2Nlc3NpbmcgZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHF1ZXVlLnNldFByb2Nlc3NvcihmYXVsdHlQcm9jZXNzb3IpO1xuXG4gICAgICBhd2FpdCBxdWV1ZS5lbnF1ZXVlKHtcbiAgICAgICAgaWQ6IFwibm9ybWFsLW1zZ1wiLFxuICAgICAgICB0eXBlOiBcInRlc3RcIixcbiAgICAgICAgcHJpb3JpdHk6IFwibm9ybWFsXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiTm9ybWFsIG1lc3NhZ2VcIixcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBxdWV1ZS5lbnF1ZXVlKHtcbiAgICAgICAgaWQ6IFwiZXJyb3ItbXNnXCIsXG4gICAgICAgIHR5cGU6IFwidGVzdFwiLFxuICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIixcbiAgICAgICAgY29udGVudDogXCJFcnJvciBtZXNzYWdlXCIsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgcXVldWUucHJvY2Vzc05leHQoKTsgLy8gU2hvdWxkIHN1Y2NlZWRcbiAgICAgIGF3YWl0IHF1ZXVlLnByb2Nlc3NOZXh0KCk7IC8vIFNob3VsZCBmYWlsIGJ1dCBub3QgY3Jhc2hcblxuICAgICAgY29uc3QgbWV0cmljcyA9IHF1ZXVlLmdldE1ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLnByb2Nlc3NlZE1lc3NhZ2VzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JDb3VudCkudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KFwicmVjb3ZlcnMgZnJvbSBxdWV1ZSBjb3JydXB0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNpbXVsYXRlIHF1ZXVlIGNvcnJ1cHRpb25cbiAgICAgIHF1ZXVlLnNpbXVsYXRlQ29ycnVwdGlvbigpOyAvLyBNb2NrIG1ldGhvZCBmb3IgdGVzdGluZ1xuXG4gICAgICBjb25zdCBpc0hlYWx0aHkgPSBhd2FpdCBxdWV1ZS5wZXJmb3JtSGVhbHRoQ2hlY2soKTtcbiAgICAgIGV4cGVjdChpc0hlYWx0aHkpLnRvQmUoZmFsc2UpO1xuXG4gICAgICBhd2FpdCBxdWV1ZS5yZWNvdmVyKCk7XG5cbiAgICAgIGNvbnN0IGlzSGVhbHRoeUFmdGVyUmVjb3ZlcnkgPSBhd2FpdCBxdWV1ZS5wZXJmb3JtSGVhbHRoQ2hlY2soKTtcbiAgICAgIGV4cGVjdChpc0hlYWx0aHlBZnRlclJlY292ZXJ5KS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwicXVldWUiLCJjb25maWciLCJiZWZvcmVFYWNoIiwibWF4U2l6ZSIsImJhdGNoU2l6ZSIsInByb2Nlc3NpbmdJbnRlcnZhbCIsInByaW9yaXR5TGV2ZWxzIiwiZW5hYmxlQmF0Y2hpbmciLCJlbmFibGVEZWR1cGxpY2F0aW9uIiwicmV0cnlBdHRlbXB0cyIsInJldHJ5RGVsYXkiLCJjcmVhdGVNZXNzYWdlUXVldWUiLCJpdCIsImV4cGVjdCIsInRvQmVEZWZpbmVkIiwiZ2V0Q29uZmlnIiwidG9NYXRjaE9iamVjdCIsIm1ldHJpY3MiLCJnZXRNZXRyaWNzIiwidG90YWxNZXNzYWdlcyIsInRvQmUiLCJwZW5kaW5nTWVzc2FnZXMiLCJwcm9jZXNzZWRNZXNzYWdlcyIsInRvVGhyb3ciLCJtZXNzYWdlIiwiaWQiLCJ0eXBlIiwicHJpb3JpdHkiLCJjb250ZW50IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImFnZW50SWQiLCJlbnF1ZXVlIiwibWVzc2FnZXMiLCJtc2ciLCJuZXh0TWVzc2FnZSIsImRlcXVldWUiLCJzbWFsbFF1ZXVlIiwicmVqZWN0cyIsInByb2Nlc3NvciIsImplc3QiLCJmbiIsInN1Y2Nlc3MiLCJyZXN1bHQiLCJzZXRQcm9jZXNzb3IiLCJwcm9jZXNzTmV4dCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsImF0dGVtcHRDb3VudCIsImZhaWxpbmdQcm9jZXNzb3IiLCJFcnJvciIsImFsd2F5c0ZhaWxQcm9jZXNzb3IiLCJpIiwiZGVhZExldHRlclF1ZXVlIiwiZ2V0RGVhZExldHRlclF1ZXVlIiwibGVuZ3RoIiwiYmF0Y2hQcm9jZXNzb3IiLCJtYXAiLCJzZXRCYXRjaFByb2Nlc3NvciIsInByb2Nlc3NCYXRjaCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiYXJyYXlDb250YWluaW5nIiwib2JqZWN0Q29udGFpbmluZyIsImJhdGNoIiwib3B0aW1pemVCYXRjaFNpemUiLCJuZXdNZXRyaWNzIiwiYXZlcmFnZUJhdGNoU2l6ZSIsImV4cGlyZWRNZXNzYWdlIiwiZXhwaXJlc0F0IiwidmFsaWRNZXNzYWdlIiwicmVtb3ZlRXhwaXJlZE1lc3NhZ2VzIiwiYmVmb3JlQ29tcGFjdGlvbiIsImNvbXBhY3QiLCJhZnRlckNvbXBhY3Rpb24iLCJxdWV1ZVNpemUiLCJ0b0JlTGVzc1RoYW5PckVxdWFsIiwidGVzdE1lc3NhZ2VzIiwiYWdlbnQxTWVzc2FnZXMiLCJmaW5kTWVzc2FnZXMiLCJ0b0hhdmVMZW5ndGgiLCJldmVyeSIsIm0iLCJyZXNwb25zZU1lc3NhZ2VzIiwiaGVsbG9NZXNzYWdlcyIsInNlYXJjaE1lc3NhZ2VzIiwidG9Db250YWluIiwic3RhcnRBdXRvUHJvY2Vzc2luZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInN0b3BBdXRvUHJvY2Vzc2luZyIsInRvSGF2ZUJlZW5DYWxsZWQiLCJwcm9jZXNzaW5nVGltZXMiLCJzdGFydCIsInB1c2giLCJwcm9taXNlcyIsImFsbCIsInByb2Nlc3NQcm9taXNlcyIsImZhc3RQcm9jZXNzb3IiLCJhdmVyYWdlUHJvY2Vzc2luZ1RpbWUiLCJ0b0JlR3JlYXRlclRoYW4iLCJ0aHJvdWdocHV0IiwiZXJyb3JSYXRlIiwicHJvY2Vzc2luZ1RpbWUiLCJkZWdyYWRpbmdQcm9jZXNzb3IiLCJwZXJmb3JtYW5jZVJlcG9ydCIsImdldFBlcmZvcm1hbmNlUmVwb3J0IiwiZGVncmFkYXRpb25EZXRlY3RlZCIsInJlY29tbWVuZGF0aW9ucyIsImZhdWx0eVByb2Nlc3NvciIsImluY2x1ZGVzIiwiZXJyb3JDb3VudCIsInNpbXVsYXRlQ29ycnVwdGlvbiIsImlzSGVhbHRoeSIsInBlcmZvcm1IZWFsdGhDaGVjayIsInJlY292ZXIiLCJpc0hlYWx0aHlBZnRlclJlY292ZXJ5Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozs4QkFhTTtBQUVQQSxTQUFTLDRCQUE0QjtJQUNuQyxJQUFJQztJQUNKLElBQUlDO0lBRUpDLFdBQVc7UUFDVEQsU0FBUztZQUNQRSxTQUFTO1lBQ1RDLFdBQVc7WUFDWEMsb0JBQW9CO1lBQ3BCQyxnQkFBZ0I7Z0JBQUM7Z0JBQVk7Z0JBQVE7Z0JBQVU7YUFBTTtZQUNyREMsZ0JBQWdCO1lBQ2hCQyxxQkFBcUI7WUFDckJDLGVBQWU7WUFDZkMsWUFBWTtRQUNkO1FBRUFWLFFBQVFXLElBQUFBLGdDQUFrQixFQUFDVjtJQUM3QjtJQUVBRixTQUFTLG9DQUFvQztRQUMzQ2EsR0FBRywwQ0FBMEM7WUFDM0NDLE9BQU9iLE9BQU9jLFdBQVc7WUFDekJELE9BQU9iLE1BQU1lLFNBQVMsSUFB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