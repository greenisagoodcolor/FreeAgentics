{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/knowledge-retriever.ts"],"sourcesContent":["import type { KnowledgeEntry } from \"@/lib/types\";\n\nexport interface RetrievalResult {\n  entries: KnowledgeEntry[];\n  relevanceScores: number[];\n}\n\nexport interface RetrievalOptions {\n  maxResults?: number;\n  minRelevanceScore?: number;\n  includeTags?: string[];\n  excludeTags?: string[];\n  recencyBoost?: boolean;\n}\n\nexport class KnowledgeRetriever {\n  /**\n   * Retrieves relevant knowledge entries based on a query\n   */\n  retrieveRelevant(\n    query: string,\n    knowledgeBase: KnowledgeEntry[],\n    options: RetrievalOptions = {},\n  ): RetrievalResult {\n    const {\n      maxResults = 5,\n      minRelevanceScore = 0.1,\n      includeTags = [],\n      excludeTags = [],\n      recencyBoost = true,\n    } = options;\n\n    // Normalize query for matching\n    const normalizedQuery = query.toLowerCase();\n    const queryTerms = this.extractTerms(normalizedQuery);\n\n    // Calculate relevance for each entry\n    const entriesWithScores = knowledgeBase.map((entry) => {\n      // Skip entries with excluded tags\n      if (\n        excludeTags.length > 0 &&\n        entry.tags.some((tag) => excludeTags.includes(tag))\n      ) {\n        return { entry, score: 0 };\n      }\n\n      // Boost entries with included tags\n      let tagBoost = 0;\n      if (includeTags.length > 0) {\n        tagBoost =\n          entry.tags.filter((tag) => includeTags.includes(tag)).length * 0.2;\n      }\n\n      // Calculate base relevance score\n      let score = this.calculateRelevance(queryTerms, entry);\n\n      // Apply tag boost\n      score += tagBoost;\n\n      // Apply recency boost if enabled\n      if (recencyBoost) {\n        // Calculate days since entry was created\n        const daysSinceCreation =\n          (Date.now() - entry.timestamp.getTime()) / (1000 * 60 * 60 * 24);\n        // Boost recent entries (max 0.2 boost for entries created today, decreasing over 30 days)\n        const recencyBoostValue = Math.max(\n          0,\n          0.2 * (1 - daysSinceCreation / 30),\n        );\n        score += recencyBoostValue;\n      }\n\n      return { entry, score };\n    });\n\n    // Filter by minimum relevance score and sort by relevance\n    const filteredEntries = entriesWithScores\n      .filter((item) => item.score >= minRelevanceScore)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, maxResults);\n\n    // Return formatted result\n    return {\n      entries: filteredEntries.map((item) => item.entry),\n      relevanceScores: filteredEntries.map((item) => item.score),\n    };\n  }\n\n  /**\n   * Extracts terms from text for matching\n   */\n  private extractTerms(text: string): string[] {\n    // Remove punctuation and split by whitespace\n    return text\n      .replace(/[.,/#!$%^&*;:{}=\\-_`~()]/g, \"\")\n      .split(/\\s+/)\n      .filter((term) => term.length > 2); // Filter out very short terms\n  }\n\n  /**\n   * Calculates relevance score between query terms and a knowledge entry\n   */\n  private calculateRelevance(\n    queryTerms: string[],\n    entry: KnowledgeEntry,\n  ): number {\n    // Extract terms from entry title and content\n    const titleTerms = this.extractTerms(entry.title.toLowerCase());\n    const contentTerms = this.extractTerms(entry.content.toLowerCase());\n\n    // Count matching terms in title (with higher weight) and content\n    const titleMatches = queryTerms.filter((term) =>\n      titleTerms.some(\n        (titleTerm) => titleTerm.includes(term) || term.includes(titleTerm),\n      ),\n    ).length;\n\n    const contentMatches = queryTerms.filter((term) =>\n      contentTerms.some(\n        (contentTerm) =>\n          contentTerm.includes(term) || term.includes(contentTerm),\n      ),\n    ).length;\n\n    // Calculate weighted score\n    // Title matches are weighted 3x more than content matches\n    const weightedMatches = titleMatches * 3 + contentMatches;\n\n    // Normalize by query length with a slight boost for multiple matches\n    const queryLength = queryTerms.length || 1; // Avoid division by zero\n    const score =\n      (weightedMatches / queryLength) *\n      (1 + Math.min(weightedMatches, 5) * 0.05);\n\n    return Math.min(1, score); // Cap at 1.0\n  }\n\n  /**\n   * Retrieves knowledge entries by tag\n   */\n  retrieveByTag(\n    tag: string,\n    knowledgeBase: KnowledgeEntry[],\n    maxResults = 10,\n  ): KnowledgeEntry[] {\n    return knowledgeBase\n      .filter((entry) => entry.tags.includes(tag))\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\n      .slice(0, maxResults);\n  }\n\n  /**\n   * Retrieves knowledge entries by title similarity\n   */\n  retrieveByTitle(\n    title: string,\n    knowledgeBase: KnowledgeEntry[],\n    maxResults = 5,\n  ): KnowledgeEntry[] {\n    const normalizedTitle = title.toLowerCase();\n\n    return knowledgeBase\n      .map((entry) => ({\n        entry,\n        similarity: this.calculateTitleSimilarity(\n          normalizedTitle,\n          entry.title.toLowerCase(),\n        ),\n      }))\n      .filter((item) => item.similarity > 0.3) // Minimum similarity threshold\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, maxResults)\n      .map((item) => item.entry);\n  }\n\n  /**\n   * Calculates simple similarity between two titles\n   */\n  private calculateTitleSimilarity(title1: string, title2: string): number {\n    // Simple implementation - can be enhanced with more sophisticated algorithms\n    if (title1 === title2) return 1;\n    if (title1.includes(title2) || title2.includes(title1)) return 0.8;\n\n    const terms1 = this.extractTerms(title1);\n    const terms2 = this.extractTerms(title2);\n\n    const commonTerms = terms1.filter((term) =>\n      terms2.some((t2) => t2.includes(term) || term.includes(t2)),\n    ).length;\n\n    return commonTerms / Math.max(terms1.length, terms2.length, 1);\n  }\n}\n"],"names":["KnowledgeRetriever","retrieveRelevant","query","knowledgeBase","options","maxResults","minRelevanceScore","includeTags","excludeTags","recencyBoost","normalizedQuery","toLowerCase","queryTerms","extractTerms","entriesWithScores","map","entry","length","tags","some","tag","includes","score","tagBoost","filter","calculateRelevance","daysSinceCreation","Date","now","timestamp","getTime","recencyBoostValue","Math","max","filteredEntries","item","sort","a","b","slice","entries","relevanceScores","text","replace","split","term","titleTerms","title","contentTerms","content","titleMatches","titleTerm","contentMatches","contentTerm","weightedMatches","queryLength","min","retrieveByTag","retrieveByTitle","normalizedTitle","similarity","calculateTitleSimilarity","title1","title2","terms1","terms2","commonTerms","t2"],"mappings":"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"}