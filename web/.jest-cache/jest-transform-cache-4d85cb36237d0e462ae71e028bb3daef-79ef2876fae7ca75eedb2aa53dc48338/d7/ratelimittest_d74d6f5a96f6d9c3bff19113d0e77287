64af64d2826d56f7173aa66e0c03bf4f
/**
 * Phase 1: lib/rate-limit.ts Comprehensive Test Suite
 * Target: Complete rate limiting functionality
 * Goal: Maximum statement coverage for rate limiting utilities
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _ratelimit = require("../../lib/rate-limit");
describe("lib/rate-limit.ts - Complete Coverage", ()=>{
    // Mock timers for testing
    beforeEach(()=>{
        jest.useFakeTimers();
    });
    afterEach(()=>{
        jest.clearAllTimers();
        jest.useRealTimers();
    });
    describe("RateLimiter class", ()=>{
        test("creates rate limiter with correct options", ()=>{
            const options = {
                interval: 60000,
                uniqueTokenPerInterval: 10
            };
            const limiter = (0, _ratelimit.rateLimit)(options);
            expect(limiter).toBeDefined();
            expect(limiter).toHaveProperty("check");
            expect(limiter).toHaveProperty("getRemainingTokens");
            expect(limiter).toHaveProperty("getResetTime");
            expect(limiter).toHaveProperty("cleanup");
        });
        describe("check method", ()=>{
            test("allows first request within limit", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 10
                });
                await expect(limiter.check(1, "user1")).resolves.toBeUndefined();
            });
            test("allows multiple requests within limit", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 10
                });
                await limiter.check(3, "user1");
                await limiter.check(3, "user1");
                await limiter.check(3, "user1");
                // Total: 9 tokens, should succeed
                await expect(limiter.check(1, "user1")).resolves.toBeUndefined();
            });
            test("rejects request when limit exceeded", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                await limiter.check(3, "user1");
                await limiter.check(2, "user1");
                // Total would be 6, exceeds limit of 5
                await expect(limiter.check(1, "user1")).rejects.toThrow("Rate limit exceeded. Try again in 60 seconds.");
            });
            test("tracks different identifiers separately", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                await limiter.check(5, "user1");
                await limiter.check(5, "user2");
                // user1 is at limit, user2 is at limit, but they're separate
                await expect(limiter.check(1, "user1")).rejects.toThrow();
                await expect(limiter.check(1, "user2")).rejects.toThrow();
            });
            test("resets after interval expires", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                await limiter.check(5, "user1");
                // Should be at limit
                await expect(limiter.check(1, "user1")).rejects.toThrow();
                // Advance time past the interval
                jest.advanceTimersByTime(60001);
                // Should be reset now
                await expect(limiter.check(5, "user1")).resolves.toBeUndefined();
            });
            test("handles exact boundary of reset time", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(5, "user1");
                // Advance to exact reset time
                jest.setSystemTime(startTime + 60000);
                // Should still be limited at exact boundary
                await expect(limiter.check(1, "user1")).rejects.toThrow();
                // One millisecond past reset time
                jest.setSystemTime(startTime + 60001);
                // Should be reset now
                await expect(limiter.check(1, "user1")).resolves.toBeUndefined();
            });
            test("calculates correct wait time in error message", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(5, "user1");
                // Advance part way through interval
                jest.setSystemTime(startTime + 20000);
                try {
                    await limiter.check(1, "user1");
                    fail("Should have thrown");
                } catch (error) {
                    expect(error.message).toBe("Rate limit exceeded. Try again in 40 seconds.");
                }
            });
            test("handles zero tokens request", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                await expect(limiter.check(0, "user1")).resolves.toBeUndefined();
                expect(limiter.getRemainingTokens("user1")).toBe(5);
            });
            test("handles negative tokens request", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                await limiter.check(-5, "user1");
                // Negative tokens should still be counted
                expect(limiter.getRemainingTokens("user1")).toBe(10);
            });
            test("handles very large token requests", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                // First request creates a record even if over limit
                await expect(limiter.check(100, "user1")).resolves.toBeUndefined();
                // But now the user has consumed 100 tokens
                expect(limiter.getRemainingTokens("user1")).toBe(0);
                // Any subsequent request should fail
                await expect(limiter.check(1, "user1")).rejects.toThrow("Rate limit exceeded. Try again in 60 seconds.");
            });
            test("handles empty identifier", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                await expect(limiter.check(1, "")).resolves.toBeUndefined();
                expect(limiter.getRemainingTokens("")).toBe(4);
            });
            test("handles special character identifiers", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const specialIds = [
                    "user@example.com",
                    "user-123",
                    "user_456",
                    "user.789",
                    "user:abc",
                    "user/path",
                    "user\\path",
                    "user[bracket]",
                    "user{brace}",
                    "user with spaces",
                    "user	tab",
                    "user\nnewline",
                    "user\uD83D\uDE80emoji",
                    "中文用户"
                ];
                for (const id of specialIds){
                    await expect(limiter.check(1, id)).resolves.toBeUndefined();
                    expect(limiter.getRemainingTokens(id)).toBe(4);
                }
            });
        });
        describe("getRemainingTokens method", ()=>{
            test("returns full limit for new identifier", ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 10
                });
                expect(limiter.getRemainingTokens("new-user")).toBe(10);
            });
            test("returns correct remaining tokens after usage", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 10
                });
                await limiter.check(3, "user1");
                expect(limiter.getRemainingTokens("user1")).toBe(7);
                await limiter.check(2, "user1");
                expect(limiter.getRemainingTokens("user1")).toBe(5);
            });
            test("returns zero when at limit", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                await limiter.check(5, "user1");
                expect(limiter.getRemainingTokens("user1")).toBe(0);
            });
            test("returns zero when over limit", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                // First request uses 6 tokens (over limit of 5)
                await limiter.check(6, "user1");
                // User is now over limit
                expect(limiter.getRemainingTokens("user1")).toBe(0);
            });
            test("returns full limit after reset", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                await limiter.check(5, "user1");
                expect(limiter.getRemainingTokens("user1")).toBe(0);
                jest.advanceTimersByTime(60001);
                expect(limiter.getRemainingTokens("user1")).toBe(5);
            });
            test("handles multiple identifiers correctly", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 10
                });
                await limiter.check(3, "user1");
                await limiter.check(5, "user2");
                await limiter.check(7, "user3");
                expect(limiter.getRemainingTokens("user1")).toBe(7);
                expect(limiter.getRemainingTokens("user2")).toBe(5);
                expect(limiter.getRemainingTokens("user3")).toBe(3);
            });
        });
        describe("getResetTime method", ()=>{
            test("returns correct reset time for active record", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(1, "user1");
                const resetTime = limiter.getResetTime("user1");
                expect(resetTime).toBe(startTime + 60000);
            });
            test("returns future reset time for new identifier", ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const now = Date.now();
                jest.setSystemTime(now);
                const resetTime = limiter.getResetTime("new-user");
                expect(resetTime).toBe(now + 60000);
            });
            test("maintains reset time through multiple checks", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 10
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(1, "user1");
                const resetTime1 = limiter.getResetTime("user1");
                jest.advanceTimersByTime(10000);
                await limiter.check(1, "user1");
                const resetTime2 = limiter.getResetTime("user1");
                // Reset time should not change
                expect(resetTime2).toBe(resetTime1);
                expect(resetTime2).toBe(startTime + 60000);
            });
            test("returns new reset time after interval expires", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(1, "user1");
                const resetTime1 = limiter.getResetTime("user1");
                jest.setSystemTime(startTime + 60001);
                await limiter.check(1, "user1");
                const resetTime2 = limiter.getResetTime("user1");
                expect(resetTime2).not.toBe(resetTime1);
                expect(resetTime2).toBe(startTime + 60001 + 60000);
            });
        });
        describe("cleanup method", ()=>{
            test("removes expired entries", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                // Create entries at different times
                await limiter.check(1, "user1");
                jest.setSystemTime(startTime + 30000);
                await limiter.check(1, "user2");
                jest.setSystemTime(startTime + 60001);
                await limiter.check(1, "user3");
                // user1 should be expired, user2 and user3 should remain
                limiter.cleanup();
                // user1 should have full tokens (new record)
                expect(limiter.getRemainingTokens("user1")).toBe(5);
                // user2 should still have its record
                expect(limiter.getRemainingTokens("user2")).toBe(4);
                // user3 should have its record
                expect(limiter.getRemainingTokens("user3")).toBe(4);
            });
            test("handles empty store", ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                // Should not throw
                expect(()=>limiter.cleanup()).not.toThrow();
            });
            test("handles all expired entries", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(1, "user1");
                await limiter.check(1, "user2");
                await limiter.check(1, "user3");
                jest.setSystemTime(startTime + 60001);
                limiter.cleanup();
                // All should have full tokens (new records)
                expect(limiter.getRemainingTokens("user1")).toBe(5);
                expect(limiter.getRemainingTokens("user2")).toBe(5);
                expect(limiter.getRemainingTokens("user3")).toBe(5);
            });
            test("preserves non-expired entries", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(3, "user1");
                jest.setSystemTime(startTime + 30000);
                limiter.cleanup();
                // Should still have the record
                expect(limiter.getRemainingTokens("user1")).toBe(2);
            });
        });
        describe("factory function and intervals", ()=>{
            test("sets up automatic cleanup interval", ()=>{
                const setIntervalSpy = jest.spyOn(global, "setInterval");
                (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 5
                });
                expect(setIntervalSpy).toHaveBeenCalledWith(expect.any(Function), 60000);
            });
            test("cleanup interval runs periodically", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 5000,
                    uniqueTokenPerInterval: 5
                });
                const cleanupSpy = jest.spyOn(limiter, "cleanup");
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(1, "user1");
                // Fast-forward to trigger cleanup
                jest.advanceTimersByTime(60000);
                expect(cleanupSpy).toHaveBeenCalledTimes(1);
                // Fast-forward again
                jest.advanceTimersByTime(60000);
                expect(cleanupSpy).toHaveBeenCalledTimes(2);
            });
        });
        describe("edge cases and stress testing", ()=>{
            test("handles many identifiers", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 10
                });
                // Create 1000 different users
                for(let i = 0; i < 1000; i++){
                    await limiter.check(1, `user${i}`);
                }
                // Check a few random ones
                expect(limiter.getRemainingTokens("user0")).toBe(9);
                expect(limiter.getRemainingTokens("user500")).toBe(9);
                expect(limiter.getRemainingTokens("user999")).toBe(9);
            });
            test("handles rapid requests", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 100
                });
                const promises = [];
                for(let i = 0; i < 50; i++){
                    promises.push(limiter.check(1, "user1"));
                }
                await Promise.all(promises);
                expect(limiter.getRemainingTokens("user1")).toBe(50);
            });
            test("handles very short intervals", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 100,
                    uniqueTokenPerInterval: 5
                });
                await limiter.check(5, "user1");
                await expect(limiter.check(1, "user1")).rejects.toThrow();
                jest.advanceTimersByTime(101);
                await expect(limiter.check(5, "user1")).resolves.toBeUndefined();
            });
            test("handles very long intervals", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 86400000,
                    uniqueTokenPerInterval: 1000
                });
                await limiter.check(999, "user1");
                expect(limiter.getRemainingTokens("user1")).toBe(1);
                // Should still be limited after 23 hours
                jest.advanceTimersByTime(82800000);
                expect(limiter.getRemainingTokens("user1")).toBe(1);
                // Should reset after 24 hours
                jest.advanceTimersByTime(3600001);
                expect(limiter.getRemainingTokens("user1")).toBe(1000);
            });
            test("handles fractional wait times correctly", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 1500,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(5, "user1");
                // Advance to 0.7 seconds before reset
                jest.setSystemTime(startTime + 800);
                try {
                    await limiter.check(1, "user1");
                    fail("Should have thrown");
                } catch (error) {
                    // Should round up to 1 second
                    expect(error.message).toBe("Rate limit exceeded. Try again in 1 seconds.");
                }
            });
            test("handles concurrent operations on same identifier", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 10
                });
                // Simulate concurrent requests
                const promises = [
                    limiter.check(2, "user1"),
                    limiter.check(2, "user1"),
                    limiter.check(2, "user1"),
                    limiter.check(2, "user1"),
                    limiter.check(2, "user1")
                ];
                await Promise.all(promises);
                expect(limiter.getRemainingTokens("user1")).toBe(0);
                // Next request should fail
                await expect(limiter.check(1, "user1")).rejects.toThrow();
            });
            test("maintains consistency during cleanup", async ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 5000,
                    uniqueTokenPerInterval: 5
                });
                const startTime = Date.now();
                jest.setSystemTime(startTime);
                await limiter.check(3, "user1");
                // Expire the entry
                jest.setSystemTime(startTime + 5001);
                // Check before cleanup
                expect(limiter.getRemainingTokens("user1")).toBe(5);
                // Run cleanup
                limiter.cleanup();
                // Should still return correct value
                expect(limiter.getRemainingTokens("user1")).toBe(5);
            });
            test("handles limit of zero", ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: 0
                });
                expect(limiter.getRemainingTokens("user1")).toBe(0);
            });
            test("handles negative limit", ()=>{
                const limiter = (0, _ratelimit.rateLimit)({
                    interval: 60000,
                    uniqueTokenPerInterval: -5
                });
                expect(limiter.getRemainingTokens("user1")).toBe(-5);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL3JhdGUtbGltaXQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBoYXNlIDE6IGxpYi9yYXRlLWxpbWl0LnRzIENvbXByZWhlbnNpdmUgVGVzdCBTdWl0ZVxuICogVGFyZ2V0OiBDb21wbGV0ZSByYXRlIGxpbWl0aW5nIGZ1bmN0aW9uYWxpdHlcbiAqIEdvYWw6IE1heGltdW0gc3RhdGVtZW50IGNvdmVyYWdlIGZvciByYXRlIGxpbWl0aW5nIHV0aWxpdGllc1xuICovXG5cbmltcG9ydCB7XG4gIHJhdGVMaW1pdCxcbiAgdHlwZSBSYXRlTGltaXRlcixcbiAgdHlwZSBSYXRlTGltaXRPcHRpb25zLFxufSBmcm9tIFwiLi4vLi4vbGliL3JhdGUtbGltaXRcIjtcblxuZGVzY3JpYmUoXCJsaWIvcmF0ZS1saW1pdC50cyAtIENvbXBsZXRlIENvdmVyYWdlXCIsICgpID0+IHtcbiAgLy8gTW9jayB0aW1lcnMgZm9yIHRlc3RpbmdcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbFRpbWVycygpO1xuICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xuICB9KTtcblxuICBkZXNjcmliZShcIlJhdGVMaW1pdGVyIGNsYXNzXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiY3JlYXRlcyByYXRlIGxpbWl0ZXIgd2l0aCBjb3JyZWN0IG9wdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogUmF0ZUxpbWl0T3B0aW9ucyA9IHtcbiAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLCAvLyAxIG1pbnV0ZVxuICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiAxMCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQob3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChsaW1pdGVyKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGxpbWl0ZXIpLnRvSGF2ZVByb3BlcnR5KFwiY2hlY2tcIik7XG4gICAgICBleHBlY3QobGltaXRlcikudG9IYXZlUHJvcGVydHkoXCJnZXRSZW1haW5pbmdUb2tlbnNcIik7XG4gICAgICBleHBlY3QobGltaXRlcikudG9IYXZlUHJvcGVydHkoXCJnZXRSZXNldFRpbWVcIik7XG4gICAgICBleHBlY3QobGltaXRlcikudG9IYXZlUHJvcGVydHkoXCJjbGVhbnVwXCIpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJjaGVjayBtZXRob2RcIiwgKCkgPT4ge1xuICAgICAgdGVzdChcImFsbG93cyBmaXJzdCByZXF1ZXN0IHdpdGhpbiBsaW1pdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiAxMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyMVwiKSkucmVzb2x2ZXMudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJhbGxvd3MgbXVsdGlwbGUgcmVxdWVzdHMgd2l0aGluIGxpbWl0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDEwLFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDMsIFwidXNlcjFcIik7XG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMywgXCJ1c2VyMVwiKTtcbiAgICAgICAgYXdhaXQgbGltaXRlci5jaGVjaygzLCBcInVzZXIxXCIpO1xuXG4gICAgICAgIC8vIFRvdGFsOiA5IHRva2Vucywgc2hvdWxkIHN1Y2NlZWRcbiAgICAgICAgYXdhaXQgZXhwZWN0KGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyMVwiKSkucmVzb2x2ZXMudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJyZWplY3RzIHJlcXVlc3Qgd2hlbiBsaW1pdCBleGNlZWRlZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDMsIFwidXNlcjFcIik7XG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMiwgXCJ1c2VyMVwiKTtcblxuICAgICAgICAvLyBUb3RhbCB3b3VsZCBiZSA2LCBleGNlZWRzIGxpbWl0IG9mIDVcbiAgICAgICAgYXdhaXQgZXhwZWN0KGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyMVwiKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAgIFwiUmF0ZSBsaW1pdCBleGNlZWRlZC4gVHJ5IGFnYWluIGluIDYwIHNlY29uZHMuXCIsXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInRyYWNrcyBkaWZmZXJlbnQgaWRlbnRpZmllcnMgc2VwYXJhdGVseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDUsIFwidXNlcjFcIik7XG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soNSwgXCJ1c2VyMlwiKTtcblxuICAgICAgICAvLyB1c2VyMSBpcyBhdCBsaW1pdCwgdXNlcjIgaXMgYXQgbGltaXQsIGJ1dCB0aGV5J3JlIHNlcGFyYXRlXG4gICAgICAgIGF3YWl0IGV4cGVjdChsaW1pdGVyLmNoZWNrKDEsIFwidXNlcjFcIikpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgICBhd2FpdCBleHBlY3QobGltaXRlci5jaGVjaygxLCBcInVzZXIyXCIpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwicmVzZXRzIGFmdGVyIGludGVydmFsIGV4cGlyZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNjAwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogNSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbGltaXRlci5jaGVjayg1LCBcInVzZXIxXCIpO1xuXG4gICAgICAgIC8vIFNob3VsZCBiZSBhdCBsaW1pdFxuICAgICAgICBhd2FpdCBleHBlY3QobGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpKS5yZWplY3RzLnRvVGhyb3coKTtcblxuICAgICAgICAvLyBBZHZhbmNlIHRpbWUgcGFzdCB0aGUgaW50ZXJ2YWxcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDYwMDAxKTtcblxuICAgICAgICAvLyBTaG91bGQgYmUgcmVzZXQgbm93XG4gICAgICAgIGF3YWl0IGV4cGVjdChsaW1pdGVyLmNoZWNrKDUsIFwidXNlcjFcIikpLnJlc29sdmVzLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwiaGFuZGxlcyBleGFjdCBib3VuZGFyeSBvZiByZXNldCB0aW1lXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGplc3Quc2V0U3lzdGVtVGltZShzdGFydFRpbWUpO1xuXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soNSwgXCJ1c2VyMVwiKTtcblxuICAgICAgICAvLyBBZHZhbmNlIHRvIGV4YWN0IHJlc2V0IHRpbWVcbiAgICAgICAgamVzdC5zZXRTeXN0ZW1UaW1lKHN0YXJ0VGltZSArIDYwMDAwKTtcblxuICAgICAgICAvLyBTaG91bGQgc3RpbGwgYmUgbGltaXRlZCBhdCBleGFjdCBib3VuZGFyeVxuICAgICAgICBhd2FpdCBleHBlY3QobGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpKS5yZWplY3RzLnRvVGhyb3coKTtcblxuICAgICAgICAvLyBPbmUgbWlsbGlzZWNvbmQgcGFzdCByZXNldCB0aW1lXG4gICAgICAgIGplc3Quc2V0U3lzdGVtVGltZShzdGFydFRpbWUgKyA2MDAwMSk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIHJlc2V0IG5vd1xuICAgICAgICBhd2FpdCBleHBlY3QobGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcImNhbGN1bGF0ZXMgY29ycmVjdCB3YWl0IHRpbWUgaW4gZXJyb3IgbWVzc2FnZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBqZXN0LnNldFN5c3RlbVRpbWUoc3RhcnRUaW1lKTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDUsIFwidXNlcjFcIik7XG5cbiAgICAgICAgLy8gQWR2YW5jZSBwYXJ0IHdheSB0aHJvdWdoIGludGVydmFsXG4gICAgICAgIGplc3Quc2V0U3lzdGVtVGltZShzdGFydFRpbWUgKyAyMDAwMCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDEsIFwidXNlcjFcIik7XG4gICAgICAgICAgZmFpbChcIlNob3VsZCBoYXZlIHRocm93blwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS50b0JlKFxuICAgICAgICAgICAgXCJSYXRlIGxpbWl0IGV4Y2VlZGVkLiBUcnkgYWdhaW4gaW4gNDAgc2Vjb25kcy5cIixcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcImhhbmRsZXMgemVybyB0b2tlbnMgcmVxdWVzdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBleHBlY3QobGltaXRlci5jaGVjaygwLCBcInVzZXIxXCIpKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcInVzZXIxXCIpKS50b0JlKDUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJoYW5kbGVzIG5lZ2F0aXZlIHRva2VucyByZXF1ZXN0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soLTUsIFwidXNlcjFcIik7XG4gICAgICAgIC8vIE5lZ2F0aXZlIHRva2VucyBzaG91bGQgc3RpbGwgYmUgY291bnRlZFxuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMVwiKSkudG9CZSgxMCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcImhhbmRsZXMgdmVyeSBsYXJnZSB0b2tlbiByZXF1ZXN0c1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaXJzdCByZXF1ZXN0IGNyZWF0ZXMgYSByZWNvcmQgZXZlbiBpZiBvdmVyIGxpbWl0XG4gICAgICAgIGF3YWl0IGV4cGVjdChsaW1pdGVyLmNoZWNrKDEwMCwgXCJ1c2VyMVwiKSkucmVzb2x2ZXMudG9CZVVuZGVmaW5lZCgpO1xuXG4gICAgICAgIC8vIEJ1dCBub3cgdGhlIHVzZXIgaGFzIGNvbnN1bWVkIDEwMCB0b2tlbnNcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoMCk7XG5cbiAgICAgICAgLy8gQW55IHN1YnNlcXVlbnQgcmVxdWVzdCBzaG91bGQgZmFpbFxuICAgICAgICBhd2FpdCBleHBlY3QobGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICAgXCJSYXRlIGxpbWl0IGV4Y2VlZGVkLiBUcnkgYWdhaW4gaW4gNjAgc2Vjb25kcy5cIixcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwiaGFuZGxlcyBlbXB0eSBpZGVudGlmaWVyXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChsaW1pdGVyLmNoZWNrKDEsIFwiXCIpKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcIlwiKSkudG9CZSg0KTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwiaGFuZGxlcyBzcGVjaWFsIGNoYXJhY3RlciBpZGVudGlmaWVyc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBzcGVjaWFsSWRzID0gW1xuICAgICAgICAgIFwidXNlckBleGFtcGxlLmNvbVwiLFxuICAgICAgICAgIFwidXNlci0xMjNcIixcbiAgICAgICAgICBcInVzZXJfNDU2XCIsXG4gICAgICAgICAgXCJ1c2VyLjc4OVwiLFxuICAgICAgICAgIFwidXNlcjphYmNcIixcbiAgICAgICAgICBcInVzZXIvcGF0aFwiLFxuICAgICAgICAgIFwidXNlclxcXFxwYXRoXCIsXG4gICAgICAgICAgXCJ1c2VyW2JyYWNrZXRdXCIsXG4gICAgICAgICAgXCJ1c2Vye2JyYWNlfVwiLFxuICAgICAgICAgIFwidXNlciB3aXRoIHNwYWNlc1wiLFxuICAgICAgICAgIFwidXNlclxcdHRhYlwiLFxuICAgICAgICAgIFwidXNlclxcbm5ld2xpbmVcIixcbiAgICAgICAgICBcInVzZXLwn5qAZW1vamlcIixcbiAgICAgICAgICBcIuS4reaWh+eUqOaIt1wiLFxuICAgICAgICBdO1xuXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2Ygc3BlY2lhbElkcykge1xuICAgICAgICAgIGF3YWl0IGV4cGVjdChsaW1pdGVyLmNoZWNrKDEsIGlkKSkucmVzb2x2ZXMudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhpZCkpLnRvQmUoNCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJnZXRSZW1haW5pbmdUb2tlbnMgbWV0aG9kXCIsICgpID0+IHtcbiAgICAgIHRlc3QoXCJyZXR1cm5zIGZ1bGwgbGltaXQgZm9yIG5ldyBpZGVudGlmaWVyXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDEwLFxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJuZXctdXNlclwiKSkudG9CZSgxMCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInJldHVybnMgY29ycmVjdCByZW1haW5pbmcgdG9rZW5zIGFmdGVyIHVzYWdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDEwLFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDMsIFwidXNlcjFcIik7XG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcInVzZXIxXCIpKS50b0JlKDcpO1xuXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMiwgXCJ1c2VyMVwiKTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoNSk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInJldHVybnMgemVybyB3aGVuIGF0IGxpbWl0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soNSwgXCJ1c2VyMVwiKTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoMCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInJldHVybnMgemVybyB3aGVuIG92ZXIgbGltaXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNjAwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogNSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmlyc3QgcmVxdWVzdCB1c2VzIDYgdG9rZW5zIChvdmVyIGxpbWl0IG9mIDUpXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soNiwgXCJ1c2VyMVwiKTtcbiAgICAgICAgLy8gVXNlciBpcyBub3cgb3ZlciBsaW1pdFxuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMVwiKSkudG9CZSgwKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwicmV0dXJucyBmdWxsIGxpbWl0IGFmdGVyIHJlc2V0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soNSwgXCJ1c2VyMVwiKTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoMCk7XG5cbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDYwMDAxKTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoNSk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcImhhbmRsZXMgbXVsdGlwbGUgaWRlbnRpZmllcnMgY29ycmVjdGx5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDEwLFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDMsIFwidXNlcjFcIik7XG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soNSwgXCJ1c2VyMlwiKTtcbiAgICAgICAgYXdhaXQgbGltaXRlci5jaGVjayg3LCBcInVzZXIzXCIpO1xuXG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcInVzZXIxXCIpKS50b0JlKDcpO1xuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMlwiKSkudG9CZSg1KTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjNcIikpLnRvQmUoMyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwiZ2V0UmVzZXRUaW1lIG1ldGhvZFwiLCAoKSA9PiB7XG4gICAgICB0ZXN0KFwicmV0dXJucyBjb3JyZWN0IHJlc2V0IHRpbWUgZm9yIGFjdGl2ZSByZWNvcmRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNjAwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogNSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgamVzdC5zZXRTeXN0ZW1UaW1lKHN0YXJ0VGltZSk7XG5cbiAgICAgICAgYXdhaXQgbGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpO1xuXG4gICAgICAgIGNvbnN0IHJlc2V0VGltZSA9IGxpbWl0ZXIuZ2V0UmVzZXRUaW1lKFwidXNlcjFcIik7XG4gICAgICAgIGV4cGVjdChyZXNldFRpbWUpLnRvQmUoc3RhcnRUaW1lICsgNjAwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJyZXR1cm5zIGZ1dHVyZSByZXNldCB0aW1lIGZvciBuZXcgaWRlbnRpZmllclwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBqZXN0LnNldFN5c3RlbVRpbWUobm93KTtcblxuICAgICAgICBjb25zdCByZXNldFRpbWUgPSBsaW1pdGVyLmdldFJlc2V0VGltZShcIm5ldy11c2VyXCIpO1xuICAgICAgICBleHBlY3QocmVzZXRUaW1lKS50b0JlKG5vdyArIDYwMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwibWFpbnRhaW5zIHJlc2V0IHRpbWUgdGhyb3VnaCBtdWx0aXBsZSBjaGVja3NcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNjAwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogMTAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGplc3Quc2V0U3lzdGVtVGltZShzdGFydFRpbWUpO1xuXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyMVwiKTtcbiAgICAgICAgY29uc3QgcmVzZXRUaW1lMSA9IGxpbWl0ZXIuZ2V0UmVzZXRUaW1lKFwidXNlcjFcIik7XG5cbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDAwKTtcbiAgICAgICAgYXdhaXQgbGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpO1xuICAgICAgICBjb25zdCByZXNldFRpbWUyID0gbGltaXRlci5nZXRSZXNldFRpbWUoXCJ1c2VyMVwiKTtcblxuICAgICAgICAvLyBSZXNldCB0aW1lIHNob3VsZCBub3QgY2hhbmdlXG4gICAgICAgIGV4cGVjdChyZXNldFRpbWUyKS50b0JlKHJlc2V0VGltZTEpO1xuICAgICAgICBleHBlY3QocmVzZXRUaW1lMikudG9CZShzdGFydFRpbWUgKyA2MDAwMCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInJldHVybnMgbmV3IHJlc2V0IHRpbWUgYWZ0ZXIgaW50ZXJ2YWwgZXhwaXJlc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBqZXN0LnNldFN5c3RlbVRpbWUoc3RhcnRUaW1lKTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDEsIFwidXNlcjFcIik7XG4gICAgICAgIGNvbnN0IHJlc2V0VGltZTEgPSBsaW1pdGVyLmdldFJlc2V0VGltZShcInVzZXIxXCIpO1xuXG4gICAgICAgIGplc3Quc2V0U3lzdGVtVGltZShzdGFydFRpbWUgKyA2MDAwMSk7XG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyMVwiKTtcbiAgICAgICAgY29uc3QgcmVzZXRUaW1lMiA9IGxpbWl0ZXIuZ2V0UmVzZXRUaW1lKFwidXNlcjFcIik7XG5cbiAgICAgICAgZXhwZWN0KHJlc2V0VGltZTIpLm5vdC50b0JlKHJlc2V0VGltZTEpO1xuICAgICAgICBleHBlY3QocmVzZXRUaW1lMikudG9CZShzdGFydFRpbWUgKyA2MDAwMSArIDYwMDAwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJjbGVhbnVwIG1ldGhvZFwiLCAoKSA9PiB7XG4gICAgICB0ZXN0KFwicmVtb3ZlcyBleHBpcmVkIGVudHJpZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNjAwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogNSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgamVzdC5zZXRTeXN0ZW1UaW1lKHN0YXJ0VGltZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGVudHJpZXMgYXQgZGlmZmVyZW50IHRpbWVzXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyMVwiKTtcblxuICAgICAgICBqZXN0LnNldFN5c3RlbVRpbWUoc3RhcnRUaW1lICsgMzAwMDApO1xuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDEsIFwidXNlcjJcIik7XG5cbiAgICAgICAgamVzdC5zZXRTeXN0ZW1UaW1lKHN0YXJ0VGltZSArIDYwMDAxKTtcbiAgICAgICAgYXdhaXQgbGltaXRlci5jaGVjaygxLCBcInVzZXIzXCIpO1xuXG4gICAgICAgIC8vIHVzZXIxIHNob3VsZCBiZSBleHBpcmVkLCB1c2VyMiBhbmQgdXNlcjMgc2hvdWxkIHJlbWFpblxuICAgICAgICBsaW1pdGVyLmNsZWFudXAoKTtcblxuICAgICAgICAvLyB1c2VyMSBzaG91bGQgaGF2ZSBmdWxsIHRva2VucyAobmV3IHJlY29yZClcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoNSk7XG5cbiAgICAgICAgLy8gdXNlcjIgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIHJlY29yZFxuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMlwiKSkudG9CZSg0KTtcblxuICAgICAgICAvLyB1c2VyMyBzaG91bGQgaGF2ZSBpdHMgcmVjb3JkXG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcInVzZXIzXCIpKS50b0JlKDQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJoYW5kbGVzIGVtcHR5IHN0b3JlXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNob3VsZCBub3QgdGhyb3dcbiAgICAgICAgZXhwZWN0KCgpID0+IGxpbWl0ZXIuY2xlYW51cCgpKS5ub3QudG9UaHJvdygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJoYW5kbGVzIGFsbCBleHBpcmVkIGVudHJpZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNjAwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogNSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgamVzdC5zZXRTeXN0ZW1UaW1lKHN0YXJ0VGltZSk7XG5cbiAgICAgICAgYXdhaXQgbGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpO1xuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDEsIFwidXNlcjJcIik7XG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyM1wiKTtcblxuICAgICAgICBqZXN0LnNldFN5c3RlbVRpbWUoc3RhcnRUaW1lICsgNjAwMDEpO1xuICAgICAgICBsaW1pdGVyLmNsZWFudXAoKTtcblxuICAgICAgICAvLyBBbGwgc2hvdWxkIGhhdmUgZnVsbCB0b2tlbnMgKG5ldyByZWNvcmRzKVxuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMVwiKSkudG9CZSg1KTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjJcIikpLnRvQmUoNSk7XG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcInVzZXIzXCIpKS50b0JlKDUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJwcmVzZXJ2ZXMgbm9uLWV4cGlyZWQgZW50cmllc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBqZXN0LnNldFN5c3RlbVRpbWUoc3RhcnRUaW1lKTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDMsIFwidXNlcjFcIik7XG5cbiAgICAgICAgamVzdC5zZXRTeXN0ZW1UaW1lKHN0YXJ0VGltZSArIDMwMDAwKTtcbiAgICAgICAgbGltaXRlci5jbGVhbnVwKCk7XG5cbiAgICAgICAgLy8gU2hvdWxkIHN0aWxsIGhhdmUgdGhlIHJlY29yZFxuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMVwiKSkudG9CZSgyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJmYWN0b3J5IGZ1bmN0aW9uIGFuZCBpbnRlcnZhbHNcIiwgKCkgPT4ge1xuICAgICAgdGVzdChcInNldHMgdXAgYXV0b21hdGljIGNsZWFudXAgaW50ZXJ2YWxcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBzZXRJbnRlcnZhbFNweSA9IGplc3Quc3B5T24oZ2xvYmFsLCBcInNldEludGVydmFsXCIpO1xuXG4gICAgICAgIHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChzZXRJbnRlcnZhbFNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0LmFueShGdW5jdGlvbiksXG4gICAgICAgICAgNjAwMDAsXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcImNsZWFudXAgaW50ZXJ2YWwgcnVucyBwZXJpb2RpY2FsbHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNTAwMCwgLy8gNSBzZWNvbmRzXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogNSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY2xlYW51cFNweSA9IGplc3Quc3B5T24obGltaXRlciwgXCJjbGVhbnVwXCIpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGplc3Quc2V0U3lzdGVtVGltZShzdGFydFRpbWUpO1xuXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyMVwiKTtcblxuICAgICAgICAvLyBGYXN0LWZvcndhcmQgdG8gdHJpZ2dlciBjbGVhbnVwXG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSg2MDAwMCk7XG5cbiAgICAgICAgZXhwZWN0KGNsZWFudXBTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcblxuICAgICAgICAvLyBGYXN0LWZvcndhcmQgYWdhaW5cbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDYwMDAwKTtcblxuICAgICAgICBleHBlY3QoY2xlYW51cFNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcImVkZ2UgY2FzZXMgYW5kIHN0cmVzcyB0ZXN0aW5nXCIsICgpID0+IHtcbiAgICAgIHRlc3QoXCJoYW5kbGVzIG1hbnkgaWRlbnRpZmllcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNjAwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogMTAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSAxMDAwIGRpZmZlcmVudCB1c2Vyc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMSwgYHVzZXIke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBhIGZldyByYW5kb20gb25lc1xuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMFwiKSkudG9CZSg5KTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjUwMFwiKSkudG9CZSg5KTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjk5OVwiKSkudG9CZSg5KTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwiaGFuZGxlcyByYXBpZCByZXF1ZXN0c1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA2MDAwMCxcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiAxMDAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICAgIHByb21pc2VzLnB1c2gobGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoNTApO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJoYW5kbGVzIHZlcnkgc2hvcnQgaW50ZXJ2YWxzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDEwMCwgLy8gMTAwbXNcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDUsIFwidXNlcjFcIik7XG4gICAgICAgIGF3YWl0IGV4cGVjdChsaW1pdGVyLmNoZWNrKDEsIFwidXNlcjFcIikpLnJlamVjdHMudG9UaHJvdygpO1xuXG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDEpO1xuICAgICAgICBhd2FpdCBleHBlY3QobGltaXRlci5jaGVjayg1LCBcInVzZXIxXCIpKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcImhhbmRsZXMgdmVyeSBsb25nIGludGVydmFsc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiA4NjQwMDAwMCwgLy8gMjQgaG91cnNcbiAgICAgICAgICB1bmlxdWVUb2tlblBlckludGVydmFsOiAxMDAwLFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBsaW1pdGVyLmNoZWNrKDk5OSwgXCJ1c2VyMVwiKTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoMSk7XG5cbiAgICAgICAgLy8gU2hvdWxkIHN0aWxsIGJlIGxpbWl0ZWQgYWZ0ZXIgMjMgaG91cnNcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDgyODAwMDAwKTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoMSk7XG5cbiAgICAgICAgLy8gU2hvdWxkIHJlc2V0IGFmdGVyIDI0IGhvdXJzXG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgzNjAwMDAxKTtcbiAgICAgICAgZXhwZWN0KGxpbWl0ZXIuZ2V0UmVtYWluaW5nVG9rZW5zKFwidXNlcjFcIikpLnRvQmUoMTAwMCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcImhhbmRsZXMgZnJhY3Rpb25hbCB3YWl0IHRpbWVzIGNvcnJlY3RseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICAgICAgICAgIGludGVydmFsOiAxNTAwLCAvLyAxLjUgc2Vjb25kc1xuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGplc3Quc2V0U3lzdGVtVGltZShzdGFydFRpbWUpO1xuXG4gICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soNSwgXCJ1c2VyMVwiKTtcblxuICAgICAgICAvLyBBZHZhbmNlIHRvIDAuNyBzZWNvbmRzIGJlZm9yZSByZXNldFxuICAgICAgICBqZXN0LnNldFN5c3RlbVRpbWUoc3RhcnRUaW1lICsgODAwKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGxpbWl0ZXIuY2hlY2soMSwgXCJ1c2VyMVwiKTtcbiAgICAgICAgICBmYWlsKFwiU2hvdWxkIGhhdmUgdGhyb3duXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgLy8gU2hvdWxkIHJvdW5kIHVwIHRvIDEgc2Vjb25kXG4gICAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQmUoXG4gICAgICAgICAgICBcIlJhdGUgbGltaXQgZXhjZWVkZWQuIFRyeSBhZ2FpbiBpbiAxIHNlY29uZHMuXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJoYW5kbGVzIGNvbmN1cnJlbnQgb3BlcmF0aW9ucyBvbiBzYW1lIGlkZW50aWZpZXJcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsaW1pdGVyID0gcmF0ZUxpbWl0KHtcbiAgICAgICAgICBpbnRlcnZhbDogNjAwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogMTAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIGNvbmN1cnJlbnQgcmVxdWVzdHNcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXG4gICAgICAgICAgbGltaXRlci5jaGVjaygyLCBcInVzZXIxXCIpLFxuICAgICAgICAgIGxpbWl0ZXIuY2hlY2soMiwgXCJ1c2VyMVwiKSxcbiAgICAgICAgICBsaW1pdGVyLmNoZWNrKDIsIFwidXNlcjFcIiksXG4gICAgICAgICAgbGltaXRlci5jaGVjaygyLCBcInVzZXIxXCIpLFxuICAgICAgICAgIGxpbWl0ZXIuY2hlY2soMiwgXCJ1c2VyMVwiKSxcbiAgICAgICAgXTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcInVzZXIxXCIpKS50b0JlKDApO1xuXG4gICAgICAgIC8vIE5leHQgcmVxdWVzdCBzaG91bGQgZmFpbFxuICAgICAgICBhd2FpdCBleHBlY3QobGltaXRlci5jaGVjaygxLCBcInVzZXIxXCIpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwibWFpbnRhaW5zIGNvbnNpc3RlbmN5IGR1cmluZyBjbGVhbnVwXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDUwMDAsXG4gICAgICAgICAgdW5pcXVlVG9rZW5QZXJJbnRlcnZhbDogNSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgamVzdC5zZXRTeXN0ZW1UaW1lKHN0YXJ0VGltZSk7XG5cbiAgICAgICAgYXdhaXQgbGltaXRlci5jaGVjaygzLCBcInVzZXIxXCIpO1xuXG4gICAgICAgIC8vIEV4cGlyZSB0aGUgZW50cnlcbiAgICAgICAgamVzdC5zZXRTeXN0ZW1UaW1lKHN0YXJ0VGltZSArIDUwMDEpO1xuXG4gICAgICAgIC8vIENoZWNrIGJlZm9yZSBjbGVhbnVwXG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcInVzZXIxXCIpKS50b0JlKDUpO1xuXG4gICAgICAgIC8vIFJ1biBjbGVhbnVwXG4gICAgICAgIGxpbWl0ZXIuY2xlYW51cCgpO1xuXG4gICAgICAgIC8vIFNob3VsZCBzdGlsbCByZXR1cm4gY29ycmVjdCB2YWx1ZVxuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMVwiKSkudG9CZSg1KTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwiaGFuZGxlcyBsaW1pdCBvZiB6ZXJvXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IDAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChsaW1pdGVyLmdldFJlbWFpbmluZ1Rva2VucyhcInVzZXIxXCIpKS50b0JlKDApO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJoYW5kbGVzIG5lZ2F0aXZlIGxpbWl0XCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXRlciA9IHJhdGVMaW1pdCh7XG4gICAgICAgICAgaW50ZXJ2YWw6IDYwMDAwLFxuICAgICAgICAgIHVuaXF1ZVRva2VuUGVySW50ZXJ2YWw6IC01LFxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobGltaXRlci5nZXRSZW1haW5pbmdUb2tlbnMoXCJ1c2VyMVwiKSkudG9CZSgtNSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJqZXN0IiwidXNlRmFrZVRpbWVycyIsImFmdGVyRWFjaCIsImNsZWFyQWxsVGltZXJzIiwidXNlUmVhbFRpbWVycyIsInRlc3QiLCJvcHRpb25zIiwiaW50ZXJ2YWwiLCJ1bmlxdWVUb2tlblBlckludGVydmFsIiwibGltaXRlciIsInJhdGVMaW1pdCIsImV4cGVjdCIsInRvQmVEZWZpbmVkIiwidG9IYXZlUHJvcGVydHkiLCJjaGVjayIsInJlc29sdmVzIiwidG9CZVVuZGVmaW5lZCIsInJlamVjdHMiLCJ0b1Rocm93IiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJzZXRTeXN0ZW1UaW1lIiwiZmFpbCIsImVycm9yIiwibWVzc2FnZSIsInRvQmUiLCJnZXRSZW1haW5pbmdUb2tlbnMiLCJzcGVjaWFsSWRzIiwiaWQiLCJyZXNldFRpbWUiLCJnZXRSZXNldFRpbWUiLCJyZXNldFRpbWUxIiwicmVzZXRUaW1lMiIsIm5vdCIsImNsZWFudXAiLCJzZXRJbnRlcnZhbFNweSIsInNweU9uIiwiZ2xvYmFsIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJhbnkiLCJGdW5jdGlvbiIsImNsZWFudXBTcHkiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJpIiwicHJvbWlzZXMiLCJwdXNoIiwiUHJvbWlzZSIsImFsbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQzs7OzsyQkFNTTtBQUVQQSxTQUFTLHlDQUF5QztJQUNoRCwwQkFBMEI7SUFDMUJDLFdBQVc7UUFDVEMsS0FBS0MsYUFBYTtJQUNwQjtJQUVBQyxVQUFVO1FBQ1JGLEtBQUtHLGNBQWM7UUFDbkJILEtBQUtJLGFBQWE7SUFDcEI7SUFFQU4sU0FBUyxxQkFBcUI7UUFDNUJPLEtBQUssNkNBQTZDO1lBQ2hELE1BQU1DLFVBQTRCO2dCQUNoQ0MsVUFBVTtnQkFDVkMsd0JBQXdCO1lBQzFCO1lBRUEsTUFBTUMsVUFBVUMsSUFBQUEsb0JBQVMsRUFBQ0o7WUFFMUJLLE9BQU9GLFNBQVNHLFdBQVc7WUFDM0JELE9BQU9GLFNBQVNJLGNBQWMsQ0FBQztZQUMvQkYsT0FBT0YsU0FBU0ksY0FBYyxDQUFDO1lBQy9CRixPQUFPRixTQUFTSSxjQUFjLENBQUM7WUFDL0JGLE9BQU9GLFNBQVNJLGNBQWMsQ0FBQztRQUNqQztRQUVBZixTQUFTLGdCQUFnQjtZQUN2Qk8sS0FBSyxxQ0FBcUM7Z0JBQ3hDLE1BQU1JLFVBQVVDLElBQUFBLG9CQUFTLEVBQUM7b0JBQ3hCSCxVQUFVO29CQUNWQyx3QkFBd0I7Z0JBQzFCO2dCQUVBLE1BQU1HLE9BQU9GLFFBQVFLLEtBQUssQ0FBQyxHQUFHLFVBQVVDLFFBQVEsQ0FBQ0MsYUFBYTtZQUNoRTtZ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