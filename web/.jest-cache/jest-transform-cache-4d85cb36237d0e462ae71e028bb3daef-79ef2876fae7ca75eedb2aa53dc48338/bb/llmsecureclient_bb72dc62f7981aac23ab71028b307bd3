0f2bce07bc763e92e02031af940d14e3
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    LLMSecureClient: function() {
        return LLMSecureClient;
    },
    llmSecureClient: function() {
        return llmSecureClient;
    }
});
const _llmservice = require("./llm-service");
const _llmsettings = require("./llm-settings");
const _sessionmanagement = require("./session-management");
const _featureflags = require("./feature-flags");
const _debuglogger = require("./debug-logger");
const _browsercheck = require("./browser-check");
const logger = (0, _debuglogger.createLogger)("LLM-SECURE-CLIENT");
class LLMSecureClient {
    constructor(initialSettings = {}){
        logger.log("LLMSecureClient constructor called with:", {
            initialSettingsType: typeof initialSettings,
            isObject: initialSettings && typeof initialSettings === "object",
            hasServerRef: initialSettings && typeof initialSettings === "object" && "__server_ref" in initialSettings,
            keys: initialSettings && typeof initialSettings === "object" ? Object.keys(initialSettings) : []
        });
        // Create a fresh settings object with default values from client-side defaults
        this.settings = {
            ..._llmsettings.clientDefaultSettings
        };
        // Try to load settings from localStorage first
        try {
            if (_browsercheck.isBrowser) {
                const savedSettings = localStorage.getItem("llm-settings");
                if (savedSettings) {
                    const parsedSettings = JSON.parse(savedSettings);
                    logger.log("Loaded settings from localStorage:", {
                        provider: parsedSettings.provider,
                        model: parsedSettings.model,
                        hasApiKey: !!parsedSettings.apiKey,
                        apiKeyLength: parsedSettings.apiKey ? parsedSettings.apiKey.length : 0,
                        hasApiKeySessionId: !!parsedSettings.apiKeySessionId
                    });
                    // Apply saved settings
                    if (parsedSettings.provider) this.settings.provider = parsedSettings.provider;
                    if (parsedSettings.model) this.settings.model = parsedSettings.model;
                    if (typeof parsedSettings.temperature === "number") this.settings.temperature = parsedSettings.temperature;
                    if (typeof parsedSettings.maxTokens === "number") this.settings.maxTokens = parsedSettings.maxTokens;
                    if (typeof parsedSettings.topP === "number") this.settings.topP = parsedSettings.topP;
                    if (typeof parsedSettings.frequencyPenalty === "number") this.settings.frequencyPenalty = parsedSettings.frequencyPenalty;
                    if (typeof parsedSettings.presencePenalty === "number") this.settings.presencePenalty = parsedSettings.presencePenalty;
                    if (typeof parsedSettings.systemFingerprint === "boolean") this.settings.systemFingerprint = parsedSettings.systemFingerprint;
                    // Handle API key or session ID
                    if (parsedSettings.apiKeySessionId) {
                        this.settings.apiKeySessionId = parsedSettings.apiKeySessionId;
                    } else if (parsedSettings.apiKey) {
                        // If we have an API key but no session ID, we'll need to migrate it
                        // This will be handled in the migration utility
                        this.settings.apiKey = parsedSettings.apiKey;
                    }
                }
            }
        } catch (e) {
            logger.warn("Could not load settings from localStorage:", e);
        }
        // Only copy properties from initialSettings if it's a valid object without server refs
        // and if they weren't already loaded from localStorage
        if (initialSettings && typeof initialSettings === "object" && !("__server_ref" in initialSettings)) {
            logger.log("Copying properties from initialSettings to this.settings");
            if (initialSettings.provider) this.settings.provider = initialSettings.provider;
            if (initialSettings.model) this.settings.model = initialSettings.model;
            if (typeof initialSettings.temperature === "number") this.settings.temperature = initialSettings.temperature;
            if (typeof initialSettings.maxTokens === "number") this.settings.maxTokens = initialSettings.maxTokens;
            if (typeof initialSettings.topP === "number") this.settings.topP = initialSettings.topP;
            if (typeof initialSettings.frequencyPenalty === "number") this.settings.frequencyPenalty = initialSettings.frequencyPenalty;
            if (typeof initialSettings.presencePenalty === "number") this.settings.presencePenalty = initialSettings.presencePenalty;
            if (typeof initialSettings.systemFingerprint === "boolean") this.settings.systemFingerprint = initialSettings.systemFingerprint;
            // Handle API key or session ID
            if (initialSettings.apiKeySessionId) {
                this.settings.apiKeySessionId = initialSettings.apiKeySessionId;
            } else if (initialSettings.apiKey) {
                this.settings.apiKey = initialSettings.apiKey;
            }
        } else {
            logger.log("Not copying properties from initialSettings due to server ref or invalid object");
        }
        logger.log("LLMSecureClient initialized with settings:", {
            ...this.settings,
            apiKey: this.settings.apiKey ? `[Length: ${this.settings.apiKey.length}]` : undefined,
            apiKeySessionId: this.settings.apiKeySessionId ? "[PRESENT]" : undefined,
            provider: this.settings.provider
        });
        // Check if we need to migrate an API key to the secure storage
        this.migrateApiKeyIfNeeded();
    }
    // Migrate API key to secure storage if needed
    async migrateApiKeyIfNeeded() {
        // Only migrate if secure storage is enabled
        if (!(0, _featureflags.isFeatureEnabled)("useSecureApiStorage")) {
            return;
        }
        // Check if we have an API key but no session ID
        if (this.settings.apiKey && !this.settings.apiKeySessionId) {
            logger.log("Migrating API key to secure storage");
            try {
                // Store the API key securely
                const response = await fetch("/api/api-key/store", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        provider: this.settings.provider,
                        apiKey: this.settings.apiKey
                    })
                });
                const data = await response.json();
                if (data.success && data.sessionId) {
                    logger.log("API key migrated successfully");
                    // Store the session ID
                    this.settings.apiKeySessionId = data.sessionId;
                    // Remove the API key from settings
                    delete this.settings.apiKey;
                    // Save the updated settings
                    this.saveSettingsToLocalStorage();
                } else {
                    logger.error("Failed to migrate API key:", data.message);
                }
            } catch (error) {
                logger.error("Error migrating API key:", error);
            }
        }
    }
    // Save settings to localStorage
    saveSettingsToLocalStorage() {
        try {
            localStorage.setItem("llm-settings", JSON.stringify(this.settings));
            logger.log("Settings saved to localStorage");
        } catch (e) {
            logger.warn("Could not save settings to localStorage:", e);
        }
    }
    // Update settings
    updateSettings(newSettings) {
        logger.log("LLMSecureClient.updateSettings called with:", {
            newSettingsType: typeof newSettings,
            isObject: newSettings && typeof newSettings === "object",
            hasServerRef: newSettings && typeof newSettings === "object" && "__server_ref" in newSettings,
            keys: newSettings && typeof newSettings === "object" ? Object.keys(newSettings) : [],
            apiKeyPresent: newSettings && typeof newSettings === "object" ? "apiKey" in newSettings : false,
            apiKeyValue: newSettings && typeof newSettings === "object" && "apiKey" in newSettings ? typeof newSettings.apiKey === "string" ? `[Length: ${newSettings.apiKey.length}]` : String(newSettings.apiKey) : "undefined",
            apiKeySessionIdPresent: newSettings && typeof newSettings === "object" ? "apiKeySessionId" in newSettings : false
        });
        // Handle server references or undefined values
        if (!newSettings || typeof newSettings !== "object" || "__server_ref" in newSettings) {
            logger.warn("Invalid settings update or server reference detected, ignoring");
            return;
        }
        // CRITICAL FIX: Ensure provider is correctly updated
        // Log the provider change explicitly
        if (newSettings.provider) {
            logger.log(`Updating provider from ${this.settings.provider} to ${newSettings.provider}`);
            this.settings.provider = newSettings.provider;
        }
        // Update only the properties that are provided
        logger.log("Updating settings properties");
        if (newSettings.model) this.settings.model = newSettings.model;
        if (typeof newSettings.temperature === "number") this.settings.temperature = newSettings.temperature;
        if (typeof newSettings.maxTokens === "number") this.settings.maxTokens = newSettings.maxTokens;
        if (typeof newSettings.topP === "number") this.settings.topP = newSettings.topP;
        if (typeof newSettings.frequencyPenalty === "number") this.settings.frequencyPenalty = newSettings.frequencyPenalty;
        if (typeof newSettings.presencePenalty === "number") this.settings.presencePenalty = newSettings.presencePenalty;
        if (typeof newSettings.systemFingerprint === "boolean") this.settings.systemFingerprint = newSettings.systemFingerprint;
        // Handle API key updates
        if ((0, _featureflags.isFeatureEnabled)("useSecureApiStorage")) {
            // Secure storage is enabled, handle API key securely
            if ("apiKey" in newSettings && typeof newSettings.apiKey === "string" && newSettings.apiKey.trim() !== "") {
                // Store the API key securely
                this.storeApiKeySecurely(newSettings.apiKey);
            } else if (newSettings.apiKeySessionId) {
                // Use the provided session ID
                this.settings.apiKeySessionId = newSettings.apiKeySessionId;
                // Remove any existing API key
                delete this.settings.apiKey;
            } else if (newSettings.apiKey === undefined || newSettings.apiKey === null) {
                // Clear both API key and session ID
                delete this.settings.apiKey;
                delete this.settings.apiKeySessionId;
            }
        } else {
            // Secure storage is disabled, handle API key directly
            if ("apiKey" in newSettings) {
                if (typeof newSettings.apiKey === "string" && newSettings.apiKey.trim() !== "") {
                    this.settings.apiKey = newSettings.apiKey;
                } else if (newSettings.apiKey === undefined || newSettings.apiKey === null) {
                    delete this.settings.apiKey;
                }
            }
        }
        // Save settings to localStorage
        this.saveSettingsToLocalStorage();
        logger.log("Settings updated to:", {
            ...this.settings,
            apiKey: this.settings.apiKey ? `[Length: ${this.settings.apiKey.length}]` : undefined,
            apiKeySessionId: this.settings.apiKeySessionId ? "[PRESENT]" : undefined,
            provider: this.settings.provider
        });
    }
    // Store API key securely
    async storeApiKeySecurely(apiKey) {
        try {
            logger.log("Storing API key securely");
            const response = await fetch("/api/api-key/store", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    provider: this.settings.provider,
                    apiKey: apiKey
                })
            });
            const data = await response.json();
            if (data.success && data.sessionId) {
                logger.log("API key stored securely");
                // Store the session ID
                this.settings.apiKeySessionId = data.sessionId;
                // Remove the API key from settings
                delete this.settings.apiKey;
            } else {
                logger.error("Failed to store API key securely:", data.message);
                // Fall back to storing the API key directly
                this.settings.apiKey = apiKey;
            }
        } catch (error) {
            logger.error("Error storing API key securely:", error);
            // Fall back to storing the API key directly
            this.settings.apiKey = apiKey;
        }
    }
    // Get current settings
    getSettings() {
        logger.log("LLMSecureClient.getSettings called");
        try {
            // Return a copy to avoid reference issues
            const settingsCopy = {
                ...this.settings
            };
            logger.log("LLMSecureClient.getSettings returning:", {
                ...settingsCopy,
                apiKey: settingsCopy.apiKey ? `[Length: ${settingsCopy.apiKey.length}]` : undefined,
                apiKeySessionId: settingsCopy.apiKeySessionId ? "[PRESENT]" : undefined,
                provider: settingsCopy.provider
            });
            return settingsCopy;
        } catch (error) {
            logger.error("Error in LLMSecureClient.getSettings:", error);
            // Return a safe default if there's an error
            return {
                provider: "openai",
                model: "gpt-4o",
                temperature: 0.7,
                maxTokens: 1024,
                topP: 0.9,
                frequencyPenalty: 0,
                presencePenalty: 0,
                systemFingerprint: false,
                maxAutonomousMessages: 4,
                conversationCooldown: 5000
            };
        }
    }
    // Get API key (either from settings or from secure storage)
    async getApiKey() {
        if ((0, _featureflags.isFeatureEnabled)("useSecureApiStorage") && this.settings.apiKeySessionId) {
            // Get API key from secure storage
            return await (0, _sessionmanagement.getApiKeyFromSession)(this.settings.provider);
        } else if (this.settings.apiKey) {
            // Get API key from settings
            return this.settings.apiKey;
        }
        return null;
    }
    // Generate a response using a system prompt
    async generateResponse(systemPrompt, userPrompt) {
        try {
            logger.log("[LLM SECURE CLIENT] generateResponse called with:", {
                systemPromptLength: systemPrompt?.length,
                userPromptLength: userPrompt?.length,
                provider: this.settings.provider,
                model: this.settings.model,
                apiKeyAvailable: !!(this.settings.apiKey || this.settings.apiKeySessionId),
                apiKeyLength: this.settings.apiKey ? this.settings.apiKey.length : 0,
                hasApiKeySessionId: !!this.settings.apiKeySessionId
            });
            // Create a copy of settings to ensure we're not passing a reference
            const settingsCopy = {
                ...this.settings
            };
            // Get the API key
            const apiKey = await this.getApiKey();
            if (!apiKey) {
                logger.warn("[LLM SECURE CLIENT] No API key available");
                return "Error: No API key available. Please set an API key in the settings.";
            }
            // Add the API key to the settings copy
            settingsCopy.apiKey = apiKey;
            // Call the server-side function with the copy
            const response = await (0, _llmservice.generateResponse)(systemPrompt, userPrompt, settingsCopy);
            logger.log("[LLM SECURE CLIENT] Response received from server:", {
                responseLength: response?.length
            });
            return response;
        } catch (error) {
            logger.error("[LLM SECURE CLIENT] Error in generateResponse:", error);
            return `Error: ${error instanceof Error ? error.message : "Unknown error"}`;
        }
    }
    // Extract beliefs from conversation
    async extractBeliefs(conversationText, agentName, extractionPriorities) {
        try {
            logger.log("LLMSecureClient.extractBeliefs called");
            // Create a copy of settings to ensure we're not passing a reference
            const settingsCopy = {
                ...this.settings
            };
            // Get the API key
            const apiKey = await this.getApiKey();
            if (!apiKey) {
                throw new Error(`API key is required for ${settingsCopy.provider} provider during belief extraction`);
            }
            // Add the API key to the settings copy
            settingsCopy.apiKey = apiKey;
            return await (0, _llmservice.extractBeliefs)(conversationText, agentName, extractionPriorities, settingsCopy);
        } catch (error) {
            logger.error("Error in client extractBeliefs:", error);
            return `Error: ${error instanceof Error ? error.message : "Unknown error"}`;
        }
    }
    // Generate knowledge entries from beliefs
    async generateKnowledgeEntries(beliefs) {
        try {
            logger.log("LLMSecureClient.generateKnowledgeEntries called");
            // Create a copy of settings to ensure we're not passing a reference
            const settingsCopy = {
                ...this.settings
            };
            // Get the API key
            const apiKey = await this.getApiKey();
            if (!apiKey) {
                throw new Error(`API key is required for ${settingsCopy.provider} provider during knowledge generation`);
            }
            // Add the API key to the settings copy
            settingsCopy.apiKey = apiKey;
            return await (0, _llmservice.generateKnowledgeEntries)(beliefs, settingsCopy);
        } catch (error) {
            logger.error("Error in client generateKnowledgeEntries:", error);
            return [
                {
                    id: `error-${Date.now()}`,
                    title: "Error",
                    content: error instanceof Error ? error.message : "Unknown error",
                    timestamp: new Date(),
                    tags: [
                        "error"
                    ]
                }
            ];
        }
    }
    // Stream response
    async streamResponse(systemPrompt, userPrompt, onChunk) {
        logger.log("[LLM SECURE CLIENT] streamResponse called with:", {
            systemPromptLength: systemPrompt?.length,
            userPromptLength: userPrompt?.length,
            hasOnChunkCallback: typeof onChunk === "function",
            onChunkType: typeof onChunk
        });
        try {
            // Create a truly safe callback that won't throw if onChunk is not a function
            const safeCallback = (text, isComplete)=>{
                try {
                    logger.log("[LLM SECURE CLIENT] safeCallback called with:", {
                        textLength: text?.length,
                        isComplete
                    });
                    if (typeof onChunk === "function") {
                        logger.log("[LLM SECURE CLIENT] Calling onChunk function");
                        onChunk(text, isComplete);
                    } else {
                        logger.log("[LLM SECURE CLIENT] Warning: onChunk is not a function", {
                            onChunkType: typeof onChunk,
                            text: text?.substring(0, 20) + "...",
                            isComplete
                        });
                    }
                } catch (callbackError) {
                    logger.error("[LLM SECURE CLIENT] Error executing onChunk callback:", callbackError);
                }
            };
            // Use non-streaming as fallback if streaming fails
            let fullResponse = "";
            let streamingFailed = false;
            try {
                // First attempt with streaming
                logger.log("[LLM SECURE CLIENT] Attempting to use streaming response");
                // Create a copy of settings to ensure we're not passing a reference
                const settingsCopy = {
                    ...this.settings
                };
                // Get the API key
                const apiKey = await this.getApiKey();
                if (!apiKey) {
                    logger.warn("[LLM SECURE CLIENT] No API key available");
                    safeCallback("Error: No API key available. Please set an API key in the settings.", false);
                    safeCallback("", true);
                    return "Error: No API key available. Please set an API key in the settings.";
                }
                // Add the API key to the settings copy
                settingsCopy.apiKey = apiKey;
                // Call the server-side function
                logger.log("[LLM SECURE CLIENT] Calling generateResponse");
                const response = await (0, _llmservice.generateResponse)(systemPrompt, userPrompt, settingsCopy);
                logger.log("[LLM SECURE CLIENT] Response received from generateResponse:", {
                    responseLength: response?.length
                });
                // Since we can't actually stream from the server to client with callbacks,
                // we'll simulate streaming by chunking the response
                const chunkSize = 10; // Characters per chunk
                for(let i = 0; i < response.length; i += chunkSize){
                    const chunk = response.substring(i, i + chunkSize);
                    fullResponse += chunk;
                    // Use the safe callback - NEVER directly call onChunk
                    logger.log(`[LLM SECURE CLIENT] Processing chunk ${i / chunkSize + 1}/${Math.ceil(response.length / chunkSize)}`);
                    safeCallback(chunk, false);
                    // Add a small delay to simulate streaming
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                }
                // Signal completion
                logger.log("[LLM SECURE CLIENT] Signaling completion");
                safeCallback("", true);
            } catch (streamError) {
                logger.error("[LLM SECURE CLIENT] Error in streaming response:", streamError);
                streamingFailed = true;
            }
            // If streaming failed, fall back to non-streaming
            if (streamingFailed) {
                logger.log("[LLM SECURE CLIENT] Streaming failed, falling back to non-streaming");
                fullResponse = await this.generateResponse(systemPrompt, userPrompt);
                // Deliver the full response at once - using safe callback
                logger.log("[LLM SECURE CLIENT] Delivering full response at once");
                safeCallback(fullResponse, false);
                safeCallback("", true);
            }
            return fullResponse;
        } catch (error) {
            logger.error("[LLM SECURE CLIENT] Error in streamResponse:", error);
            // Try to notify through callback if possible - using safe callback
            const errorMessage = `Error: ${error instanceof Error ? error.message : String(error)}`;
            try {
                logger.log("[LLM SECURE CLIENT] Attempting to notify error through callback");
                if (typeof onChunk === "function") {
                    logger.log("[LLM SECURE CLIENT] Calling onChunk with error message");
                    onChunk(errorMessage, false);
                    onChunk("", true);
                } else {
                    logger.log("[LLM SECURE CLIENT] Cannot notify error: onChunk is not a function");
                }
            } catch (callbackError) {
                logger.error("[LLM SECURE CLIENT] Error calling onChunk callback with error:", callbackError);
            }
            // Return error message as string
            return errorMessage;
        }
    }
    // Validate API key
    async validateApiKey(provider, apiKey) {
        try {
            logger.log("LLMSecureClient.validateApiKey called");
            return await (0, _llmservice.validateApiKey)(provider, apiKey);
        } catch (error) {
            logger.error("Error in client validateApiKey:", error);
            return {
                valid: false,
                message: error instanceof Error ? error.message : "Error validating API key"
            };
        }
    }
    // Save settings
    async saveSettings() {
        try {
            logger.log("LLMSecureClient.saveSettings called");
            // Create a copy of settings without the API key
            const settingsCopy = {
                ...this.settings
            };
            // If we're using secure storage, we don't need to send the API key
            if ((0, _featureflags.isFeatureEnabled)("useSecureApiStorage")) {
                delete settingsCopy.apiKey;
            }
            logger.log("Current settings to save:", {
                ...settingsCopy,
                apiKey: settingsCopy.apiKey ? `[Length: ${settingsCopy.apiKey.length}]` : undefined,
                apiKeySessionId: settingsCopy.apiKeySessionId ? "[PRESENT]" : undefined
            });
            return await (0, _llmservice.saveLLMSettings)(settingsCopy);
        } catch (error) {
            logger.error("Error in client saveSettings:", error);
            return false;
        }
    }
}
// Create a singleton instance
logger.log("Creating llmSecureClient singleton instance");
const llmSecureClient = new LLMSecureClient();
logger.log("llmSecureClient singleton instance created");

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvbGxtLXNlY3VyZS1jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7XG4gIGV4dHJhY3RCZWxpZWZzIGFzIHNlcnZlckV4dHJhY3RCZWxpZWZzLFxuICBnZW5lcmF0ZUtub3dsZWRnZUVudHJpZXMgYXMgc2VydmVyR2VuZXJhdGVLbm93bGVkZ2VFbnRyaWVzLFxuICBnZW5lcmF0ZVJlc3BvbnNlLFxuICB2YWxpZGF0ZUFwaUtleSxcbiAgc2F2ZUxMTVNldHRpbmdzLFxufSBmcm9tIFwiQC9saWIvbGxtLXNlcnZpY2VcIjtcbmltcG9ydCB0eXBlIHsgTExNU2V0dGluZ3MgfSBmcm9tIFwiQC9saWIvbGxtLXNldHRpbmdzXCI7XG5pbXBvcnQgdHlwZSB7IEtub3dsZWRnZUVudHJ5IH0gZnJvbSBcIkAvbGliL3R5cGVzXCI7XG5pbXBvcnQgeyBjbGllbnREZWZhdWx0U2V0dGluZ3MgfSBmcm9tIFwiQC9saWIvbGxtLXNldHRpbmdzXCI7XG5pbXBvcnQgeyBnZXRBcGlLZXlGcm9tU2Vzc2lvbiB9IGZyb20gXCJAL2xpYi9zZXNzaW9uLW1hbmFnZW1lbnRcIjtcbmltcG9ydCB7IGlzRmVhdHVyZUVuYWJsZWQgfSBmcm9tIFwiQC9saWIvZmVhdHVyZS1mbGFnc1wiO1xuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyIH0gZnJvbSBcIkAvbGliL2RlYnVnLWxvZ2dlclwiO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSBcIi4vYnJvd3Nlci1jaGVja1wiO1xuXG5jb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJMTE0tU0VDVVJFLUNMSUVOVFwiKTtcblxuLy8gU2VjdXJlIGNsaWVudC1zaWRlIHdyYXBwZXIgZm9yIHRoZSBMTE0gc2VydmljZVxuZXhwb3J0IGNsYXNzIExMTVNlY3VyZUNsaWVudCB7XG4gIHByaXZhdGUgc2V0dGluZ3M6IExMTVNldHRpbmdzO1xuXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxTZXR0aW5nczogUGFydGlhbDxMTE1TZXR0aW5ncz4gPSB7fSkge1xuICAgIGxvZ2dlci5sb2coXCJMTE1TZWN1cmVDbGllbnQgY29uc3RydWN0b3IgY2FsbGVkIHdpdGg6XCIsIHtcbiAgICAgIGluaXRpYWxTZXR0aW5nc1R5cGU6IHR5cGVvZiBpbml0aWFsU2V0dGluZ3MsXG4gICAgICBpc09iamVjdDogaW5pdGlhbFNldHRpbmdzICYmIHR5cGVvZiBpbml0aWFsU2V0dGluZ3MgPT09IFwib2JqZWN0XCIsXG4gICAgICBoYXNTZXJ2ZXJSZWY6XG4gICAgICAgIGluaXRpYWxTZXR0aW5ncyAmJlxuICAgICAgICB0eXBlb2YgaW5pdGlhbFNldHRpbmdzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIFwiX19zZXJ2ZXJfcmVmXCIgaW4gaW5pdGlhbFNldHRpbmdzLFxuICAgICAga2V5czpcbiAgICAgICAgaW5pdGlhbFNldHRpbmdzICYmIHR5cGVvZiBpbml0aWFsU2V0dGluZ3MgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICA/IE9iamVjdC5rZXlzKGluaXRpYWxTZXR0aW5ncylcbiAgICAgICAgICA6IFtdLFxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGEgZnJlc2ggc2V0dGluZ3Mgb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMgZnJvbSBjbGllbnQtc2lkZSBkZWZhdWx0c1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7IC4uLmNsaWVudERlZmF1bHRTZXR0aW5ncyB9IGFzIExMTVNldHRpbmdzO1xuXG4gICAgLy8gVHJ5IHRvIGxvYWQgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JhZ2UgZmlyc3RcbiAgICB0cnkge1xuICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICBjb25zdCBzYXZlZFNldHRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJsbG0tc2V0dGluZ3NcIik7XG4gICAgICAgIGlmIChzYXZlZFNldHRpbmdzKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkU2V0dGluZ3MgPSBKU09OLnBhcnNlKHNhdmVkU2V0dGluZ3MpO1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJMb2FkZWQgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JhZ2U6XCIsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiBwYXJzZWRTZXR0aW5ncy5wcm92aWRlcixcbiAgICAgICAgICAgIG1vZGVsOiBwYXJzZWRTZXR0aW5ncy5tb2RlbCxcbiAgICAgICAgICAgIGhhc0FwaUtleTogISFwYXJzZWRTZXR0aW5ncy5hcGlLZXksXG4gICAgICAgICAgICBhcGlLZXlMZW5ndGg6IHBhcnNlZFNldHRpbmdzLmFwaUtleVxuICAgICAgICAgICAgICA/IHBhcnNlZFNldHRpbmdzLmFwaUtleS5sZW5ndGhcbiAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgaGFzQXBpS2V5U2Vzc2lvbklkOiAhIXBhcnNlZFNldHRpbmdzLmFwaUtleVNlc3Npb25JZCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEFwcGx5IHNhdmVkIHNldHRpbmdzXG4gICAgICAgICAgaWYgKHBhcnNlZFNldHRpbmdzLnByb3ZpZGVyKVxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5wcm92aWRlciA9IHBhcnNlZFNldHRpbmdzLnByb3ZpZGVyO1xuICAgICAgICAgIGlmIChwYXJzZWRTZXR0aW5ncy5tb2RlbCkgdGhpcy5zZXR0aW5ncy5tb2RlbCA9IHBhcnNlZFNldHRpbmdzLm1vZGVsO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkU2V0dGluZ3MudGVtcGVyYXR1cmUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnRlbXBlcmF0dXJlID0gcGFyc2VkU2V0dGluZ3MudGVtcGVyYXR1cmU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRTZXR0aW5ncy5tYXhUb2tlbnMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1heFRva2VucyA9IHBhcnNlZFNldHRpbmdzLm1heFRva2VucztcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlZFNldHRpbmdzLnRvcFAgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnRvcFAgPSBwYXJzZWRTZXR0aW5ncy50b3BQO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSA9IHBhcnNlZFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSA9IHBhcnNlZFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlZFNldHRpbmdzLnN5c3RlbUZpbmdlcnByaW50ID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc3lzdGVtRmluZ2VycHJpbnQgPSBwYXJzZWRTZXR0aW5ncy5zeXN0ZW1GaW5nZXJwcmludDtcblxuICAgICAgICAgIC8vIEhhbmRsZSBBUEkga2V5IG9yIHNlc3Npb24gSURcbiAgICAgICAgICBpZiAocGFyc2VkU2V0dGluZ3MuYXBpS2V5U2Vzc2lvbklkKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmFwaUtleVNlc3Npb25JZCA9IHBhcnNlZFNldHRpbmdzLmFwaUtleVNlc3Npb25JZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZFNldHRpbmdzLmFwaUtleSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBBUEkga2V5IGJ1dCBubyBzZXNzaW9uIElELCB3ZSdsbCBuZWVkIHRvIG1pZ3JhdGUgaXRcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSBoYW5kbGVkIGluIHRoZSBtaWdyYXRpb24gdXRpbGl0eVxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5hcGlLZXkgPSBwYXJzZWRTZXR0aW5ncy5hcGlLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4oXCJDb3VsZCBub3QgbG9hZCBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZTpcIiwgZSk7XG4gICAgfVxuXG4gICAgLy8gT25seSBjb3B5IHByb3BlcnRpZXMgZnJvbSBpbml0aWFsU2V0dGluZ3MgaWYgaXQncyBhIHZhbGlkIG9iamVjdCB3aXRob3V0IHNlcnZlciByZWZzXG4gICAgLy8gYW5kIGlmIHRoZXkgd2VyZW4ndCBhbHJlYWR5IGxvYWRlZCBmcm9tIGxvY2FsU3RvcmFnZVxuICAgIGlmIChcbiAgICAgIGluaXRpYWxTZXR0aW5ncyAmJlxuICAgICAgdHlwZW9mIGluaXRpYWxTZXR0aW5ncyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgIShcIl9fc2VydmVyX3JlZlwiIGluIGluaXRpYWxTZXR0aW5ncylcbiAgICApIHtcbiAgICAgIGxvZ2dlci5sb2coXCJDb3B5aW5nIHByb3BlcnRpZXMgZnJvbSBpbml0aWFsU2V0dGluZ3MgdG8gdGhpcy5zZXR0aW5nc1wiKTtcbiAgICAgIGlmIChpbml0aWFsU2V0dGluZ3MucHJvdmlkZXIpXG4gICAgICAgIHRoaXMuc2V0dGluZ3MucHJvdmlkZXIgPSBpbml0aWFsU2V0dGluZ3MucHJvdmlkZXI7XG4gICAgICBpZiAoaW5pdGlhbFNldHRpbmdzLm1vZGVsKSB0aGlzLnNldHRpbmdzLm1vZGVsID0gaW5pdGlhbFNldHRpbmdzLm1vZGVsO1xuICAgICAgaWYgKHR5cGVvZiBpbml0aWFsU2V0dGluZ3MudGVtcGVyYXR1cmUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRoaXMuc2V0dGluZ3MudGVtcGVyYXR1cmUgPSBpbml0aWFsU2V0dGluZ3MudGVtcGVyYXR1cmU7XG4gICAgICBpZiAodHlwZW9mIGluaXRpYWxTZXR0aW5ncy5tYXhUb2tlbnMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRoaXMuc2V0dGluZ3MubWF4VG9rZW5zID0gaW5pdGlhbFNldHRpbmdzLm1heFRva2VucztcbiAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFNldHRpbmdzLnRvcFAgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRoaXMuc2V0dGluZ3MudG9wUCA9IGluaXRpYWxTZXR0aW5ncy50b3BQO1xuICAgICAgaWYgKHR5cGVvZiBpbml0aWFsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5ID0gaW5pdGlhbFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHk7XG4gICAgICBpZiAodHlwZW9mIGluaXRpYWxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRoaXMuc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5ID0gaW5pdGlhbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eTtcbiAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFNldHRpbmdzLnN5c3RlbUZpbmdlcnByaW50ID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zeXN0ZW1GaW5nZXJwcmludCA9IGluaXRpYWxTZXR0aW5ncy5zeXN0ZW1GaW5nZXJwcmludDtcblxuICAgICAgLy8gSGFuZGxlIEFQSSBrZXkgb3Igc2Vzc2lvbiBJRFxuICAgICAgaWYgKGluaXRpYWxTZXR0aW5ncy5hcGlLZXlTZXNzaW9uSWQpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hcGlLZXlTZXNzaW9uSWQgPSBpbml0aWFsU2V0dGluZ3MuYXBpS2V5U2Vzc2lvbklkO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2V0dGluZ3MuYXBpS2V5KSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuYXBpS2V5ID0gaW5pdGlhbFNldHRpbmdzLmFwaUtleTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgXCJOb3QgY29weWluZyBwcm9wZXJ0aWVzIGZyb20gaW5pdGlhbFNldHRpbmdzIGR1ZSB0byBzZXJ2ZXIgcmVmIG9yIGludmFsaWQgb2JqZWN0XCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxvZ2dlci5sb2coXCJMTE1TZWN1cmVDbGllbnQgaW5pdGlhbGl6ZWQgd2l0aCBzZXR0aW5nczpcIiwge1xuICAgICAgLi4udGhpcy5zZXR0aW5ncyxcbiAgICAgIGFwaUtleTogdGhpcy5zZXR0aW5ncy5hcGlLZXlcbiAgICAgICAgPyBgW0xlbmd0aDogJHt0aGlzLnNldHRpbmdzLmFwaUtleS5sZW5ndGh9XWBcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBhcGlLZXlTZXNzaW9uSWQ6IHRoaXMuc2V0dGluZ3MuYXBpS2V5U2Vzc2lvbklkID8gXCJbUFJFU0VOVF1cIiA6IHVuZGVmaW5lZCxcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnNldHRpbmdzLnByb3ZpZGVyLFxuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBtaWdyYXRlIGFuIEFQSSBrZXkgdG8gdGhlIHNlY3VyZSBzdG9yYWdlXG4gICAgdGhpcy5taWdyYXRlQXBpS2V5SWZOZWVkZWQoKTtcbiAgfVxuXG4gIC8vIE1pZ3JhdGUgQVBJIGtleSB0byBzZWN1cmUgc3RvcmFnZSBpZiBuZWVkZWRcbiAgcHJpdmF0ZSBhc3luYyBtaWdyYXRlQXBpS2V5SWZOZWVkZWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gT25seSBtaWdyYXRlIGlmIHNlY3VyZSBzdG9yYWdlIGlzIGVuYWJsZWRcbiAgICBpZiAoIWlzRmVhdHVyZUVuYWJsZWQoXCJ1c2VTZWN1cmVBcGlTdG9yYWdlXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbiBBUEkga2V5IGJ1dCBubyBzZXNzaW9uIElEXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuYXBpS2V5ICYmICF0aGlzLnNldHRpbmdzLmFwaUtleVNlc3Npb25JZCkge1xuICAgICAgbG9nZ2VyLmxvZyhcIk1pZ3JhdGluZyBBUEkga2V5IHRvIHNlY3VyZSBzdG9yYWdlXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIEFQSSBrZXkgc2VjdXJlbHlcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvYXBpLWtleS9zdG9yZVwiLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLnNldHRpbmdzLnByb3ZpZGVyLFxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLnNldHRpbmdzLmFwaUtleSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnNlc3Npb25JZCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJBUEkga2V5IG1pZ3JhdGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgICAvLyBTdG9yZSB0aGUgc2Vzc2lvbiBJRFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3MuYXBpS2V5U2Vzc2lvbklkID0gZGF0YS5zZXNzaW9uSWQ7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBBUEkga2V5IGZyb20gc2V0dGluZ3NcbiAgICAgICAgICBkZWxldGUgdGhpcy5zZXR0aW5ncy5hcGlLZXk7XG4gICAgICAgICAgLy8gU2F2ZSB0aGUgdXBkYXRlZCBzZXR0aW5nc1xuICAgICAgICAgIHRoaXMuc2F2ZVNldHRpbmdzVG9Mb2NhbFN0b3JhZ2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbWlncmF0ZSBBUEkga2V5OlwiLCBkYXRhLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBtaWdyYXRpbmcgQVBJIGtleTpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNhdmUgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlXG4gIHByaXZhdGUgc2F2ZVNldHRpbmdzVG9Mb2NhbFN0b3JhZ2UoKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibGxtLXNldHRpbmdzXCIsIEpTT04uc3RyaW5naWZ5KHRoaXMuc2V0dGluZ3MpKTtcbiAgICAgIGxvZ2dlci5sb2coXCJTZXR0aW5ncyBzYXZlZCB0byBsb2NhbFN0b3JhZ2VcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4oXCJDb3VsZCBub3Qgc2F2ZSBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2U6XCIsIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBzZXR0aW5nc1xuICB1cGRhdGVTZXR0aW5ncyhuZXdTZXR0aW5nczogUGFydGlhbDxMTE1TZXR0aW5ncz4pOiB2b2lkIHtcbiAgICBsb2dnZXIubG9nKFwiTExNU2VjdXJlQ2xpZW50LnVwZGF0ZVNldHRpbmdzIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICBuZXdTZXR0aW5nc1R5cGU6IHR5cGVvZiBuZXdTZXR0aW5ncyxcbiAgICAgIGlzT2JqZWN0OiBuZXdTZXR0aW5ncyAmJiB0eXBlb2YgbmV3U2V0dGluZ3MgPT09IFwib2JqZWN0XCIsXG4gICAgICBoYXNTZXJ2ZXJSZWY6XG4gICAgICAgIG5ld1NldHRpbmdzICYmXG4gICAgICAgIHR5cGVvZiBuZXdTZXR0aW5ncyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcIl9fc2VydmVyX3JlZlwiIGluIG5ld1NldHRpbmdzLFxuICAgICAga2V5czpcbiAgICAgICAgbmV3U2V0dGluZ3MgJiYgdHlwZW9mIG5ld1NldHRpbmdzID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgPyBPYmplY3Qua2V5cyhuZXdTZXR0aW5ncylcbiAgICAgICAgICA6IFtdLFxuICAgICAgYXBpS2V5UHJlc2VudDpcbiAgICAgICAgbmV3U2V0dGluZ3MgJiYgdHlwZW9mIG5ld1NldHRpbmdzID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgPyBcImFwaUtleVwiIGluIG5ld1NldHRpbmdzXG4gICAgICAgICAgOiBmYWxzZSxcbiAgICAgIGFwaUtleVZhbHVlOlxuICAgICAgICBuZXdTZXR0aW5ncyAmJlxuICAgICAgICB0eXBlb2YgbmV3U2V0dGluZ3MgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJhcGlLZXlcIiBpbiBuZXdTZXR0aW5nc1xuICAgICAgICAgID8gdHlwZW9mIG5ld1NldHRpbmdzLmFwaUtleSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBgW0xlbmd0aDogJHtuZXdTZXR0aW5ncy5hcGlLZXkubGVuZ3RofV1gXG4gICAgICAgICAgICA6IFN0cmluZyhuZXdTZXR0aW5ncy5hcGlLZXkpXG4gICAgICAgICAgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgYXBpS2V5U2Vzc2lvbklkUHJlc2VudDpcbiAgICAgICAgbmV3U2V0dGluZ3MgJiYgdHlwZW9mIG5ld1NldHRpbmdzID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgPyBcImFwaUtleVNlc3Npb25JZFwiIGluIG5ld1NldHRpbmdzXG4gICAgICAgICAgOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBzZXJ2ZXIgcmVmZXJlbmNlcyBvciB1bmRlZmluZWQgdmFsdWVzXG4gICAgaWYgKFxuICAgICAgIW5ld1NldHRpbmdzIHx8XG4gICAgICB0eXBlb2YgbmV3U2V0dGluZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgIFwiX19zZXJ2ZXJfcmVmXCIgaW4gbmV3U2V0dGluZ3NcbiAgICApIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBcIkludmFsaWQgc2V0dGluZ3MgdXBkYXRlIG9yIHNlcnZlciByZWZlcmVuY2UgZGV0ZWN0ZWQsIGlnbm9yaW5nXCIsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENSSVRJQ0FMIEZJWDogRW5zdXJlIHByb3ZpZGVyIGlzIGNvcnJlY3RseSB1cGRhdGVkXG4gICAgLy8gTG9nIHRoZSBwcm92aWRlciBjaGFuZ2UgZXhwbGljaXRseVxuICAgIGlmIChuZXdTZXR0aW5ncy5wcm92aWRlcikge1xuICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgYFVwZGF0aW5nIHByb3ZpZGVyIGZyb20gJHt0aGlzLnNldHRpbmdzLnByb3ZpZGVyfSB0byAke25ld1NldHRpbmdzLnByb3ZpZGVyfWAsXG4gICAgICApO1xuICAgICAgdGhpcy5zZXR0aW5ncy5wcm92aWRlciA9IG5ld1NldHRpbmdzLnByb3ZpZGVyO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHByb3ZpZGVkXG4gICAgbG9nZ2VyLmxvZyhcIlVwZGF0aW5nIHNldHRpbmdzIHByb3BlcnRpZXNcIik7XG4gICAgaWYgKG5ld1NldHRpbmdzLm1vZGVsKSB0aGlzLnNldHRpbmdzLm1vZGVsID0gbmV3U2V0dGluZ3MubW9kZWw7XG4gICAgaWYgKHR5cGVvZiBuZXdTZXR0aW5ncy50ZW1wZXJhdHVyZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHRoaXMuc2V0dGluZ3MudGVtcGVyYXR1cmUgPSBuZXdTZXR0aW5ncy50ZW1wZXJhdHVyZTtcbiAgICBpZiAodHlwZW9mIG5ld1NldHRpbmdzLm1heFRva2VucyA9PT0gXCJudW1iZXJcIilcbiAgICAgIHRoaXMuc2V0dGluZ3MubWF4VG9rZW5zID0gbmV3U2V0dGluZ3MubWF4VG9rZW5zO1xuICAgIGlmICh0eXBlb2YgbmV3U2V0dGluZ3MudG9wUCA9PT0gXCJudW1iZXJcIilcbiAgICAgIHRoaXMuc2V0dGluZ3MudG9wUCA9IG5ld1NldHRpbmdzLnRvcFA7XG4gICAgaWYgKHR5cGVvZiBuZXdTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5ID09PSBcIm51bWJlclwiKVxuICAgICAgdGhpcy5zZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5ID0gbmV3U2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eTtcbiAgICBpZiAodHlwZW9mIG5ld1NldHRpbmdzLnByZXNlbmNlUGVuYWx0eSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHRoaXMuc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5ID0gbmV3U2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5O1xuICAgIGlmICh0eXBlb2YgbmV3U2V0dGluZ3Muc3lzdGVtRmluZ2VycHJpbnQgPT09IFwiYm9vbGVhblwiKVxuICAgICAgdGhpcy5zZXR0aW5ncy5zeXN0ZW1GaW5nZXJwcmludCA9IG5ld1NldHRpbmdzLnN5c3RlbUZpbmdlcnByaW50O1xuXG4gICAgLy8gSGFuZGxlIEFQSSBrZXkgdXBkYXRlc1xuICAgIGlmIChpc0ZlYXR1cmVFbmFibGVkKFwidXNlU2VjdXJlQXBpU3RvcmFnZVwiKSkge1xuICAgICAgLy8gU2VjdXJlIHN0b3JhZ2UgaXMgZW5hYmxlZCwgaGFuZGxlIEFQSSBrZXkgc2VjdXJlbHlcbiAgICAgIGlmIChcbiAgICAgICAgXCJhcGlLZXlcIiBpbiBuZXdTZXR0aW5ncyAmJlxuICAgICAgICB0eXBlb2YgbmV3U2V0dGluZ3MuYXBpS2V5ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIG5ld1NldHRpbmdzLmFwaUtleS50cmltKCkgIT09IFwiXCJcbiAgICAgICkge1xuICAgICAgICAvLyBTdG9yZSB0aGUgQVBJIGtleSBzZWN1cmVseVxuICAgICAgICB0aGlzLnN0b3JlQXBpS2V5U2VjdXJlbHkobmV3U2V0dGluZ3MuYXBpS2V5KTtcbiAgICAgIH0gZWxzZSBpZiAobmV3U2V0dGluZ3MuYXBpS2V5U2Vzc2lvbklkKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgc2Vzc2lvbiBJRFxuICAgICAgICB0aGlzLnNldHRpbmdzLmFwaUtleVNlc3Npb25JZCA9IG5ld1NldHRpbmdzLmFwaUtleVNlc3Npb25JZDtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBBUEkga2V5XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNldHRpbmdzLmFwaUtleTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG5ld1NldHRpbmdzLmFwaUtleSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIG5ld1NldHRpbmdzLmFwaUtleSA9PT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIC8vIENsZWFyIGJvdGggQVBJIGtleSBhbmQgc2Vzc2lvbiBJRFxuICAgICAgICBkZWxldGUgdGhpcy5zZXR0aW5ncy5hcGlLZXk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNldHRpbmdzLmFwaUtleVNlc3Npb25JZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VjdXJlIHN0b3JhZ2UgaXMgZGlzYWJsZWQsIGhhbmRsZSBBUEkga2V5IGRpcmVjdGx5XG4gICAgICBpZiAoXCJhcGlLZXlcIiBpbiBuZXdTZXR0aW5ncykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIG5ld1NldHRpbmdzLmFwaUtleSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgIG5ld1NldHRpbmdzLmFwaUtleS50cmltKCkgIT09IFwiXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy5hcGlLZXkgPSBuZXdTZXR0aW5ncy5hcGlLZXk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgbmV3U2V0dGluZ3MuYXBpS2V5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICBuZXdTZXR0aW5ncy5hcGlLZXkgPT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2V0dGluZ3MuYXBpS2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2F2ZSBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2VcbiAgICB0aGlzLnNhdmVTZXR0aW5nc1RvTG9jYWxTdG9yYWdlKCk7XG5cbiAgICBsb2dnZXIubG9nKFwiU2V0dGluZ3MgdXBkYXRlZCB0bzpcIiwge1xuICAgICAgLi4udGhpcy5zZXR0aW5ncyxcbiAgICAgIGFwaUtleTogdGhpcy5zZXR0aW5ncy5hcGlLZXlcbiAgICAgICAgPyBgW0xlbmd0aDogJHt0aGlzLnNldHRpbmdzLmFwaUtleS5sZW5ndGh9XWBcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBhcGlLZXlTZXNzaW9uSWQ6IHRoaXMuc2V0dGluZ3MuYXBpS2V5U2Vzc2lvbklkID8gXCJbUFJFU0VOVF1cIiA6IHVuZGVmaW5lZCxcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnNldHRpbmdzLnByb3ZpZGVyLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gU3RvcmUgQVBJIGtleSBzZWN1cmVseVxuICBwcml2YXRlIGFzeW5jIHN0b3JlQXBpS2V5U2VjdXJlbHkoYXBpS2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmxvZyhcIlN0b3JpbmcgQVBJIGtleSBzZWN1cmVseVwiKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCIvYXBpL2FwaS1rZXkvc3RvcmVcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwcm92aWRlcjogdGhpcy5zZXR0aW5ncy5wcm92aWRlcixcbiAgICAgICAgICBhcGlLZXk6IGFwaUtleSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS5zZXNzaW9uSWQpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkFQSSBrZXkgc3RvcmVkIHNlY3VyZWx5XCIpO1xuICAgICAgICAvLyBTdG9yZSB0aGUgc2Vzc2lvbiBJRFxuICAgICAgICB0aGlzLnNldHRpbmdzLmFwaUtleVNlc3Npb25JZCA9IGRhdGEuc2Vzc2lvbklkO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIEFQSSBrZXkgZnJvbSBzZXR0aW5nc1xuICAgICAgICBkZWxldGUgdGhpcy5zZXR0aW5ncy5hcGlLZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gc3RvcmUgQVBJIGtleSBzZWN1cmVseTpcIiwgZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHN0b3JpbmcgdGhlIEFQSSBrZXkgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHN0b3JpbmcgQVBJIGtleSBzZWN1cmVseTpcIiwgZXJyb3IpO1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIHN0b3JpbmcgdGhlIEFQSSBrZXkgZGlyZWN0bHlcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXBpS2V5ID0gYXBpS2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBjdXJyZW50IHNldHRpbmdzXG4gIGdldFNldHRpbmdzKCk6IExMTVNldHRpbmdzIHtcbiAgICBsb2dnZXIubG9nKFwiTExNU2VjdXJlQ2xpZW50LmdldFNldHRpbmdzIGNhbGxlZFwiKTtcbiAgICB0cnkge1xuICAgICAgLy8gUmV0dXJuIGEgY29weSB0byBhdm9pZCByZWZlcmVuY2UgaXNzdWVzXG4gICAgICBjb25zdCBzZXR0aW5nc0NvcHkgPSB7IC4uLnRoaXMuc2V0dGluZ3MgfTtcbiAgICAgIGxvZ2dlci5sb2coXCJMTE1TZWN1cmVDbGllbnQuZ2V0U2V0dGluZ3MgcmV0dXJuaW5nOlwiLCB7XG4gICAgICAgIC4uLnNldHRpbmdzQ29weSxcbiAgICAgICAgYXBpS2V5OiBzZXR0aW5nc0NvcHkuYXBpS2V5XG4gICAgICAgICAgPyBgW0xlbmd0aDogJHtzZXR0aW5nc0NvcHkuYXBpS2V5Lmxlbmd0aH1dYFxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBhcGlLZXlTZXNzaW9uSWQ6IHNldHRpbmdzQ29weS5hcGlLZXlTZXNzaW9uSWQgPyBcIltQUkVTRU5UXVwiIDogdW5kZWZpbmVkLFxuICAgICAgICBwcm92aWRlcjogc2V0dGluZ3NDb3B5LnByb3ZpZGVyLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2V0dGluZ3NDb3B5O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBpbiBMTE1TZWN1cmVDbGllbnQuZ2V0U2V0dGluZ3M6XCIsIGVycm9yKTtcbiAgICAgIC8vIFJldHVybiBhIHNhZmUgZGVmYXVsdCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgICAgbW9kZWw6IFwiZ3B0LTRvXCIsXG4gICAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXG4gICAgICAgIG1heFRva2VuczogMTAyNCxcbiAgICAgICAgdG9wUDogMC45LFxuICAgICAgICBmcmVxdWVuY3lQZW5hbHR5OiAwLFxuICAgICAgICBwcmVzZW5jZVBlbmFsdHk6IDAsXG4gICAgICAgIHN5c3RlbUZpbmdlcnByaW50OiBmYWxzZSxcbiAgICAgICAgbWF4QXV0b25vbW91c01lc3NhZ2VzOiA0LFxuICAgICAgICBjb252ZXJzYXRpb25Db29sZG93bjogNTAwMCxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IEFQSSBrZXkgKGVpdGhlciBmcm9tIHNldHRpbmdzIG9yIGZyb20gc2VjdXJlIHN0b3JhZ2UpXG4gIHByaXZhdGUgYXN5bmMgZ2V0QXBpS2V5KCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGlmIChcbiAgICAgIGlzRmVhdHVyZUVuYWJsZWQoXCJ1c2VTZWN1cmVBcGlTdG9yYWdlXCIpICYmXG4gICAgICB0aGlzLnNldHRpbmdzLmFwaUtleVNlc3Npb25JZFxuICAgICkge1xuICAgICAgLy8gR2V0IEFQSSBrZXkgZnJvbSBzZWN1cmUgc3RvcmFnZVxuICAgICAgcmV0dXJuIGF3YWl0IGdldEFwaUtleUZyb21TZXNzaW9uKHRoaXMuc2V0dGluZ3MucHJvdmlkZXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5hcGlLZXkpIHtcbiAgICAgIC8vIEdldCBBUEkga2V5IGZyb20gc2V0dGluZ3NcbiAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmFwaUtleTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBhIHJlc3BvbnNlIHVzaW5nIGEgc3lzdGVtIHByb21wdFxuICBhc3luYyBnZW5lcmF0ZVJlc3BvbnNlKFxuICAgIHN5c3RlbVByb21wdDogc3RyaW5nLFxuICAgIHVzZXJQcm9tcHQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmxvZyhcIltMTE0gU0VDVVJFIENMSUVOVF0gZ2VuZXJhdGVSZXNwb25zZSBjYWxsZWQgd2l0aDpcIiwge1xuICAgICAgICBzeXN0ZW1Qcm9tcHRMZW5ndGg6IHN5c3RlbVByb21wdD8ubGVuZ3RoLFxuICAgICAgICB1c2VyUHJvbXB0TGVuZ3RoOiB1c2VyUHJvbXB0Py5sZW5ndGgsXG4gICAgICAgIHByb3ZpZGVyOiB0aGlzLnNldHRpbmdzLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogdGhpcy5zZXR0aW5ncy5tb2RlbCxcbiAgICAgICAgYXBpS2V5QXZhaWxhYmxlOiAhIShcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLmFwaUtleSB8fCB0aGlzLnNldHRpbmdzLmFwaUtleVNlc3Npb25JZFxuICAgICAgICApLFxuICAgICAgICBhcGlLZXlMZW5ndGg6IHRoaXMuc2V0dGluZ3MuYXBpS2V5ID8gdGhpcy5zZXR0aW5ncy5hcGlLZXkubGVuZ3RoIDogMCxcbiAgICAgICAgaGFzQXBpS2V5U2Vzc2lvbklkOiAhIXRoaXMuc2V0dGluZ3MuYXBpS2V5U2Vzc2lvbklkLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2Ygc2V0dGluZ3MgdG8gZW5zdXJlIHdlJ3JlIG5vdCBwYXNzaW5nIGEgcmVmZXJlbmNlXG4gICAgICBjb25zdCBzZXR0aW5nc0NvcHkgPSB7IC4uLnRoaXMuc2V0dGluZ3MgfTtcblxuICAgICAgLy8gR2V0IHRoZSBBUEkga2V5XG4gICAgICBjb25zdCBhcGlLZXkgPSBhd2FpdCB0aGlzLmdldEFwaUtleSgpO1xuICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJbTExNIFNFQ1VSRSBDTElFTlRdIE5vIEFQSSBrZXkgYXZhaWxhYmxlXCIpO1xuICAgICAgICByZXR1cm4gXCJFcnJvcjogTm8gQVBJIGtleSBhdmFpbGFibGUuIFBsZWFzZSBzZXQgYW4gQVBJIGtleSBpbiB0aGUgc2V0dGluZ3MuXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgQVBJIGtleSB0byB0aGUgc2V0dGluZ3MgY29weVxuICAgICAgc2V0dGluZ3NDb3B5LmFwaUtleSA9IGFwaUtleTtcblxuICAgICAgLy8gQ2FsbCB0aGUgc2VydmVyLXNpZGUgZnVuY3Rpb24gd2l0aCB0aGUgY29weVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZW5lcmF0ZVJlc3BvbnNlKFxuICAgICAgICBzeXN0ZW1Qcm9tcHQsXG4gICAgICAgIHVzZXJQcm9tcHQsXG4gICAgICAgIHNldHRpbmdzQ29weSxcbiAgICAgICk7XG4gICAgICBsb2dnZXIubG9nKFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBSZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjpcIiwge1xuICAgICAgICByZXNwb25zZUxlbmd0aDogcmVzcG9uc2U/Lmxlbmd0aCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJbTExNIFNFQ1VSRSBDTElFTlRdIEVycm9yIGluIGdlbmVyYXRlUmVzcG9uc2U6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBgRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV4dHJhY3QgYmVsaWVmcyBmcm9tIGNvbnZlcnNhdGlvblxuICBhc3luYyBleHRyYWN0QmVsaWVmcyhcbiAgICBjb252ZXJzYXRpb25UZXh0OiBzdHJpbmcsXG4gICAgYWdlbnROYW1lOiBzdHJpbmcsXG4gICAgZXh0cmFjdGlvblByaW9yaXRpZXM6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmxvZyhcIkxMTVNlY3VyZUNsaWVudC5leHRyYWN0QmVsaWVmcyBjYWxsZWRcIik7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2Ygc2V0dGluZ3MgdG8gZW5zdXJlIHdlJ3JlIG5vdCBwYXNzaW5nIGEgcmVmZXJlbmNlXG4gICAgICBjb25zdCBzZXR0aW5nc0NvcHkgPSB7IC4uLnRoaXMuc2V0dGluZ3MgfTtcblxuICAgICAgLy8gR2V0IHRoZSBBUEkga2V5XG4gICAgICBjb25zdCBhcGlLZXkgPSBhd2FpdCB0aGlzLmdldEFwaUtleSgpO1xuICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBBUEkga2V5IGlzIHJlcXVpcmVkIGZvciAke3NldHRpbmdzQ29weS5wcm92aWRlcn0gcHJvdmlkZXIgZHVyaW5nIGJlbGllZiBleHRyYWN0aW9uYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSBBUEkga2V5IHRvIHRoZSBzZXR0aW5ncyBjb3B5XG4gICAgICBzZXR0aW5nc0NvcHkuYXBpS2V5ID0gYXBpS2V5O1xuXG4gICAgICByZXR1cm4gYXdhaXQgc2VydmVyRXh0cmFjdEJlbGllZnMoXG4gICAgICAgIGNvbnZlcnNhdGlvblRleHQsXG4gICAgICAgIGFnZW50TmFtZSxcbiAgICAgICAgZXh0cmFjdGlvblByaW9yaXRpZXMsXG4gICAgICAgIHNldHRpbmdzQ29weSxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGluIGNsaWVudCBleHRyYWN0QmVsaWVmczpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGBFcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWA7XG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUga25vd2xlZGdlIGVudHJpZXMgZnJvbSBiZWxpZWZzXG4gIGFzeW5jIGdlbmVyYXRlS25vd2xlZGdlRW50cmllcyhiZWxpZWZzOiBzdHJpbmcpOiBQcm9taXNlPEtub3dsZWRnZUVudHJ5W10+IHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmxvZyhcIkxMTVNlY3VyZUNsaWVudC5nZW5lcmF0ZUtub3dsZWRnZUVudHJpZXMgY2FsbGVkXCIpO1xuXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHNldHRpbmdzIHRvIGVuc3VyZSB3ZSdyZSBub3QgcGFzc2luZyBhIHJlZmVyZW5jZVxuICAgICAgY29uc3Qgc2V0dGluZ3NDb3B5ID0geyAuLi50aGlzLnNldHRpbmdzIH07XG5cbiAgICAgIC8vIEdldCB0aGUgQVBJIGtleVxuICAgICAgY29uc3QgYXBpS2V5ID0gYXdhaXQgdGhpcy5nZXRBcGlLZXkoKTtcbiAgICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQVBJIGtleSBpcyByZXF1aXJlZCBmb3IgJHtzZXR0aW5nc0NvcHkucHJvdmlkZXJ9IHByb3ZpZGVyIGR1cmluZyBrbm93bGVkZ2UgZ2VuZXJhdGlvbmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgQVBJIGtleSB0byB0aGUgc2V0dGluZ3MgY29weVxuICAgICAgc2V0dGluZ3NDb3B5LmFwaUtleSA9IGFwaUtleTtcblxuICAgICAgcmV0dXJuIGF3YWl0IHNlcnZlckdlbmVyYXRlS25vd2xlZGdlRW50cmllcyhiZWxpZWZzLCBzZXR0aW5nc0NvcHkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBpbiBjbGllbnQgZ2VuZXJhdGVLbm93bGVkZ2VFbnRyaWVzOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IGBlcnJvci0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICB0aXRsZTogXCJFcnJvclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHRhZ3M6IFtcImVycm9yXCJdLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICB9XG4gIH1cblxuICAvLyBTdHJlYW0gcmVzcG9uc2VcbiAgYXN5bmMgc3RyZWFtUmVzcG9uc2UoXG4gICAgc3lzdGVtUHJvbXB0OiBzdHJpbmcsXG4gICAgdXNlclByb21wdDogc3RyaW5nLFxuICAgIG9uQ2h1bms/OiAoKHRleHQ6IHN0cmluZywgaXNDb21wbGV0ZTogYm9vbGVhbikgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkLFxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGxvZ2dlci5sb2coXCJbTExNIFNFQ1VSRSBDTElFTlRdIHN0cmVhbVJlc3BvbnNlIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICBzeXN0ZW1Qcm9tcHRMZW5ndGg6IHN5c3RlbVByb21wdD8ubGVuZ3RoLFxuICAgICAgdXNlclByb21wdExlbmd0aDogdXNlclByb21wdD8ubGVuZ3RoLFxuICAgICAgaGFzT25DaHVua0NhbGxiYWNrOiB0eXBlb2Ygb25DaHVuayA9PT0gXCJmdW5jdGlvblwiLFxuICAgICAgb25DaHVua1R5cGU6IHR5cGVvZiBvbkNodW5rLFxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSBhIHRydWx5IHNhZmUgY2FsbGJhY2sgdGhhdCB3b24ndCB0aHJvdyBpZiBvbkNodW5rIGlzIG5vdCBhIGZ1bmN0aW9uXG4gICAgICBjb25zdCBzYWZlQ2FsbGJhY2sgPSAodGV4dDogc3RyaW5nLCBpc0NvbXBsZXRlOiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIltMTE0gU0VDVVJFIENMSUVOVF0gc2FmZUNhbGxiYWNrIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICAgICAgICB0ZXh0TGVuZ3RoOiB0ZXh0Py5sZW5ndGgsXG4gICAgICAgICAgICBpc0NvbXBsZXRlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2Ygb25DaHVuayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBDYWxsaW5nIG9uQ2h1bmsgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICBvbkNodW5rKHRleHQsIGlzQ29tcGxldGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgICBcIltMTE0gU0VDVVJFIENMSUVOVF0gV2FybmluZzogb25DaHVuayBpcyBub3QgYSBmdW5jdGlvblwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb25DaHVua1R5cGU6IHR5cGVvZiBvbkNodW5rLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQ/LnN1YnN0cmluZygwLCAyMCkgKyBcIi4uLlwiLFxuICAgICAgICAgICAgICAgIGlzQ29tcGxldGUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoY2FsbGJhY2tFcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBFcnJvciBleGVjdXRpbmcgb25DaHVuayBjYWxsYmFjazpcIixcbiAgICAgICAgICAgIGNhbGxiYWNrRXJyb3IsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gVXNlIG5vbi1zdHJlYW1pbmcgYXMgZmFsbGJhY2sgaWYgc3RyZWFtaW5nIGZhaWxzXG4gICAgICBsZXQgZnVsbFJlc3BvbnNlID0gXCJcIjtcbiAgICAgIGxldCBzdHJlYW1pbmdGYWlsZWQgPSBmYWxzZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyc3QgYXR0ZW1wdCB3aXRoIHN0cmVhbWluZ1xuICAgICAgICBsb2dnZXIubG9nKFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBBdHRlbXB0aW5nIHRvIHVzZSBzdHJlYW1pbmcgcmVzcG9uc2VcIik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiBzZXR0aW5ncyB0byBlbnN1cmUgd2UncmUgbm90IHBhc3NpbmcgYSByZWZlcmVuY2VcbiAgICAgICAgY29uc3Qgc2V0dGluZ3NDb3B5ID0geyAuLi50aGlzLnNldHRpbmdzIH07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBBUEkga2V5XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGF3YWl0IHRoaXMuZ2V0QXBpS2V5KCk7XG4gICAgICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXCJbTExNIFNFQ1VSRSBDTElFTlRdIE5vIEFQSSBrZXkgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgIHNhZmVDYWxsYmFjayhcbiAgICAgICAgICAgIFwiRXJyb3I6IE5vIEFQSSBrZXkgYXZhaWxhYmxlLiBQbGVhc2Ugc2V0IGFuIEFQSSBrZXkgaW4gdGhlIHNldHRpbmdzLlwiLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzYWZlQ2FsbGJhY2soXCJcIiwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IE5vIEFQSSBrZXkgYXZhaWxhYmxlLiBQbGVhc2Ugc2V0IGFuIEFQSSBrZXkgaW4gdGhlIHNldHRpbmdzLlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSBBUEkga2V5IHRvIHRoZSBzZXR0aW5ncyBjb3B5XG4gICAgICAgIHNldHRpbmdzQ29weS5hcGlLZXkgPSBhcGlLZXk7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgc2VydmVyLXNpZGUgZnVuY3Rpb25cbiAgICAgICAgbG9nZ2VyLmxvZyhcIltMTE0gU0VDVVJFIENMSUVOVF0gQ2FsbGluZyBnZW5lcmF0ZVJlc3BvbnNlXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdlbmVyYXRlUmVzcG9uc2UoXG4gICAgICAgICAgc3lzdGVtUHJvbXB0LFxuICAgICAgICAgIHVzZXJQcm9tcHQsXG4gICAgICAgICAgc2V0dGluZ3NDb3B5LFxuICAgICAgICApO1xuICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgIFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBSZXNwb25zZSByZWNlaXZlZCBmcm9tIGdlbmVyYXRlUmVzcG9uc2U6XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzcG9uc2VMZW5ndGg6IHJlc3BvbnNlPy5sZW5ndGgsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBhY3R1YWxseSBzdHJlYW0gZnJvbSB0aGUgc2VydmVyIHRvIGNsaWVudCB3aXRoIGNhbGxiYWNrcyxcbiAgICAgICAgLy8gd2UnbGwgc2ltdWxhdGUgc3RyZWFtaW5nIGJ5IGNodW5raW5nIHRoZSByZXNwb25zZVxuICAgICAgICBjb25zdCBjaHVua1NpemUgPSAxMDsgLy8gQ2hhcmFjdGVycyBwZXIgY2h1bmtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZS5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSByZXNwb25zZS5zdWJzdHJpbmcoaSwgaSArIGNodW5rU2l6ZSk7XG4gICAgICAgICAgZnVsbFJlc3BvbnNlICs9IGNodW5rO1xuXG4gICAgICAgICAgLy8gVXNlIHRoZSBzYWZlIGNhbGxiYWNrIC0gTkVWRVIgZGlyZWN0bHkgY2FsbCBvbkNodW5rXG4gICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgIGBbTExNIFNFQ1VSRSBDTElFTlRdIFByb2Nlc3NpbmcgY2h1bmsgJHtpIC8gY2h1bmtTaXplICsgMX0vJHtNYXRoLmNlaWwocmVzcG9uc2UubGVuZ3RoIC8gY2h1bmtTaXplKX1gLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2FmZUNhbGxiYWNrKGNodW5rLCBmYWxzZSk7XG5cbiAgICAgICAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSB0byBzaW11bGF0ZSBzdHJlYW1pbmdcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2lnbmFsIGNvbXBsZXRpb25cbiAgICAgICAgbG9nZ2VyLmxvZyhcIltMTE0gU0VDVVJFIENMSUVOVF0gU2lnbmFsaW5nIGNvbXBsZXRpb25cIik7XG4gICAgICAgIHNhZmVDYWxsYmFjayhcIlwiLCB0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKHN0cmVhbUVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICBcIltMTE0gU0VDVVJFIENMSUVOVF0gRXJyb3IgaW4gc3RyZWFtaW5nIHJlc3BvbnNlOlwiLFxuICAgICAgICAgIHN0cmVhbUVycm9yLFxuICAgICAgICApO1xuICAgICAgICBzdHJlYW1pbmdGYWlsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBzdHJlYW1pbmcgZmFpbGVkLCBmYWxsIGJhY2sgdG8gbm9uLXN0cmVhbWluZ1xuICAgICAgaWYgKHN0cmVhbWluZ0ZhaWxlZCkge1xuICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgIFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBTdHJlYW1pbmcgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gbm9uLXN0cmVhbWluZ1wiLFxuICAgICAgICApO1xuICAgICAgICBmdWxsUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlUmVzcG9uc2Uoc3lzdGVtUHJvbXB0LCB1c2VyUHJvbXB0KTtcblxuICAgICAgICAvLyBEZWxpdmVyIHRoZSBmdWxsIHJlc3BvbnNlIGF0IG9uY2UgLSB1c2luZyBzYWZlIGNhbGxiYWNrXG4gICAgICAgIGxvZ2dlci5sb2coXCJbTExNIFNFQ1VSRSBDTElFTlRdIERlbGl2ZXJpbmcgZnVsbCByZXNwb25zZSBhdCBvbmNlXCIpO1xuICAgICAgICBzYWZlQ2FsbGJhY2soZnVsbFJlc3BvbnNlLCBmYWxzZSk7XG4gICAgICAgIHNhZmVDYWxsYmFjayhcIlwiLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bGxSZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBFcnJvciBpbiBzdHJlYW1SZXNwb25zZTpcIiwgZXJyb3IpO1xuXG4gICAgICAvLyBUcnkgdG8gbm90aWZ5IHRocm91Z2ggY2FsbGJhY2sgaWYgcG9zc2libGUgLSB1c2luZyBzYWZlIGNhbGxiYWNrXG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWA7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgIFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBBdHRlbXB0aW5nIHRvIG5vdGlmeSBlcnJvciB0aHJvdWdoIGNhbGxiYWNrXCIsXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25DaHVuayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIltMTE0gU0VDVVJFIENMSUVOVF0gQ2FsbGluZyBvbkNodW5rIHdpdGggZXJyb3IgbWVzc2FnZVwiKTtcbiAgICAgICAgICBvbkNodW5rKGVycm9yTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICAgIG9uQ2h1bmsoXCJcIiwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgIFwiW0xMTSBTRUNVUkUgQ0xJRU5UXSBDYW5ub3Qgbm90aWZ5IGVycm9yOiBvbkNodW5rIGlzIG5vdCBhIGZ1bmN0aW9uXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoY2FsbGJhY2tFcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgXCJbTExNIFNFQ1VSRSBDTElFTlRdIEVycm9yIGNhbGxpbmcgb25DaHVuayBjYWxsYmFjayB3aXRoIGVycm9yOlwiLFxuICAgICAgICAgIGNhbGxiYWNrRXJyb3IsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBlcnJvciBtZXNzYWdlIGFzIHN0cmluZ1xuICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBBUEkga2V5XG4gIGFzeW5jIHZhbGlkYXRlQXBpS2V5KFxuICAgIHByb3ZpZGVyOiBcIm9wZW5haVwiIHwgXCJvcGVucm91dGVyXCIsXG4gICAgYXBpS2V5OiBzdHJpbmcsXG4gICk6IFByb21pc2U8eyB2YWxpZDogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5sb2coXCJMTE1TZWN1cmVDbGllbnQudmFsaWRhdGVBcGlLZXkgY2FsbGVkXCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IHZhbGlkYXRlQXBpS2V5KHByb3ZpZGVyLCBhcGlLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBpbiBjbGllbnQgdmFsaWRhdGVBcGlLZXk6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRXJyb3IgdmFsaWRhdGluZyBBUEkga2V5XCIsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFNhdmUgc2V0dGluZ3NcbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIubG9nKFwiTExNU2VjdXJlQ2xpZW50LnNhdmVTZXR0aW5ncyBjYWxsZWRcIik7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2Ygc2V0dGluZ3Mgd2l0aG91dCB0aGUgQVBJIGtleVxuICAgICAgY29uc3Qgc2V0dGluZ3NDb3B5ID0geyAuLi50aGlzLnNldHRpbmdzIH07XG5cbiAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHNlY3VyZSBzdG9yYWdlLCB3ZSBkb24ndCBuZWVkIHRvIHNlbmQgdGhlIEFQSSBrZXlcbiAgICAgIGlmIChpc0ZlYXR1cmVFbmFibGVkKFwidXNlU2VjdXJlQXBpU3RvcmFnZVwiKSkge1xuICAgICAgICBkZWxldGUgc2V0dGluZ3NDb3B5LmFwaUtleTtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmxvZyhcIkN1cnJlbnQgc2V0dGluZ3MgdG8gc2F2ZTpcIiwge1xuICAgICAgICAuLi5zZXR0aW5nc0NvcHksXG4gICAgICAgIGFwaUtleTogc2V0dGluZ3NDb3B5LmFwaUtleVxuICAgICAgICAgID8gYFtMZW5ndGg6ICR7c2V0dGluZ3NDb3B5LmFwaUtleS5sZW5ndGh9XWBcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgYXBpS2V5U2Vzc2lvbklkOiBzZXR0aW5nc0NvcHkuYXBpS2V5U2Vzc2lvbklkID8gXCJbUFJFU0VOVF1cIiA6IHVuZGVmaW5lZCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYXdhaXQgc2F2ZUxMTVNldHRpbmdzKHNldHRpbmdzQ29weSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGluIGNsaWVudCBzYXZlU2V0dGluZ3M6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQ3JlYXRlIGEgc2luZ2xldG9uIGluc3RhbmNlXG5sb2dnZXIubG9nKFwiQ3JlYXRpbmcgbGxtU2VjdXJlQ2xpZW50IHNpbmdsZXRvbiBpbnN0YW5jZVwiKTtcbmV4cG9ydCBjb25zdCBsbG1TZWN1cmVDbGllbnQgPSBuZXcgTExNU2VjdXJlQ2xpZW50KCk7XG5sb2dnZXIubG9nKFwibGxtU2VjdXJlQ2xpZW50IHNpbmdsZXRvbiBpbnN0YW5jZSBjcmVhdGVkXCIpO1xuIl0sIm5hbWVzIjpbIkxMTVNlY3VyZUNsaWVudCIsImxsbVNlY3VyZUNsaWVudCIsImxvZ2dlciIsImNyZWF0ZUxvZ2dlciIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFNldHRpbmdzIiwibG9nIiwiaW5pdGlhbFNldHRpbmdzVHlwZSIsImlzT2JqZWN0IiwiaGFzU2VydmVyUmVmIiwia2V5cyIsIk9iamVjdCIsInNldHRpbmdzIiwiY2xpZW50RGVmYXVsdFNldHRpbmdzIiwiaXNCcm93c2VyIiwic2F2ZWRTZXR0aW5ncyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWRTZXR0aW5ncyIsIkpTT04iLCJwYXJzZSIsInByb3ZpZGVyIiwibW9kZWwiLCJoYXNBcGlLZXkiLCJhcGlLZXkiLCJhcGlLZXlMZW5ndGgiLCJsZW5ndGgiLCJoYXNBcGlLZXlTZXNzaW9uSWQiLCJhcGlLZXlTZXNzaW9uSWQiLCJ0ZW1wZXJhdHVyZSIsIm1heFRva2VucyIsInRvcFAiLCJmcmVxdWVuY3lQZW5hbHR5IiwicHJlc2VuY2VQZW5hbHR5Iiwic3lzdGVtRmluZ2VycHJpbnQiLCJlIiwid2FybiIsInVuZGVmaW5lZCIsIm1pZ3JhdGVBcGlLZXlJZk5lZWRlZCIsImlzRmVhdHVyZUVuYWJsZWQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJzdHJpbmdpZnkiLCJkYXRhIiwianNvbiIsInN1Y2Nlc3MiLCJzZXNzaW9uSWQiLCJzYXZlU2V0dGluZ3NUb0xvY2FsU3RvcmFnZSIsImVycm9yIiwibWVzc2FnZSIsInNldEl0ZW0iLCJ1cGRhdGVTZXR0aW5ncyIsIm5ld1NldHRpbmdzIiwibmV3U2V0dGluZ3NUeXBlIiwiYXBpS2V5UHJlc2VudCIsImFwaUtleVZhbHVlIiwiU3RyaW5nIiwiYXBpS2V5U2Vzc2lvbklkUHJlc2VudCIsInRyaW0iLCJzdG9yZUFwaUtleVNlY3VyZWx5IiwiZ2V0U2V0dGluZ3MiLCJzZXR0aW5nc0NvcHkiLCJtYXhBdXRvbm9tb3VzTWVzc2FnZXMiLCJjb252ZXJzYXRpb25Db29sZG93biIsImdldEFwaUtleSIsImdldEFwaUtleUZyb21TZXNzaW9uIiwiZ2VuZXJhdGVSZXNwb25zZSIsInN5c3RlbVByb21wdCIsInVzZXJQcm9tcHQiLCJzeXN0ZW1Qcm9tcHRMZW5ndGgiLCJ1c2VyUHJvbXB0TGVuZ3RoIiwiYXBpS2V5QXZhaWxhYmxlIiwicmVzcG9uc2VMZW5ndGgiLCJFcnJvciIsImV4dHJhY3RCZWxpZWZzIiwiY29udmVyc2F0aW9uVGV4dCIsImFnZW50TmFtZSIsImV4dHJhY3Rpb25Qcmlvcml0aWVzIiwic2VydmVyRXh0cmFjdEJlbGllZnMiLCJnZW5lcmF0ZUtub3dsZWRnZUVudHJpZXMiLCJiZWxpZWZzIiwic2VydmVyR2VuZXJhdGVLbm93bGVkZ2VFbnRyaWVzIiwiaWQiLCJEYXRlIiwibm93IiwidGl0bGUiLCJjb250ZW50IiwidGltZXN0YW1wIiwidGFncyIsInN0cmVhbVJlc3BvbnNlIiwib25DaHVuayIsImhhc09uQ2h1bmtDYWxsYmFjayIsIm9uQ2h1bmtUeXBlIiwic2FmZUNhbGxiYWNrIiwidGV4dCIsImlzQ29tcGxldGUiLCJ0ZXh0TGVuZ3RoIiwic3Vic3RyaW5nIiwiY2FsbGJhY2tFcnJvciIsImZ1bGxSZXNwb25zZSIsInN0cmVhbWluZ0ZhaWxlZCIsImNodW5rU2l6ZSIsImkiLCJjaHVuayIsIk1hdGgiLCJjZWlsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic3RyZWFtRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJ2YWxpZGF0ZUFwaUtleSIsInZhbGlkIiwic2F2ZVNldHRpbmdzIiwic2F2ZUxMTVNldHRpbmdzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0lBb0JhQSxlQUFlO2VBQWZBOztJQWlyQkFDLGVBQWU7ZUFBZkE7Ozs0QkE3ckJOOzZCQUcrQjttQ0FDRDs4QkFDSjs2QkFDSjs4QkFDSDtBQUUxQixNQUFNQyxTQUFTQyxJQUFBQSx5QkFBWSxFQUFDO0FBR3JCLE1BQU1IO0lBR1hJLFlBQVlDLGtCQUF3QyxDQUFDLENBQUMsQ0FBRTtRQUN0REgsT0FBT0ksR0FBRyxDQUFDLDRDQUE0QztZQUNyREMscUJBQXFCLE9BQU9GO1lBQzVCRyxVQUFVSCxtQkFBbUIs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