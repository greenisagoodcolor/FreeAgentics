{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/llm-secure-client.ts"],"sourcesContent":["\"use client\";\n\nimport {\n  extractBeliefs as serverExtractBeliefs,\n  generateKnowledgeEntries as serverGenerateKnowledgeEntries,\n  generateResponse,\n  validateApiKey,\n  saveLLMSettings,\n} from \"@/lib/llm-service\";\nimport type { LLMSettings } from \"@/lib/llm-settings\";\nimport type { KnowledgeEntry } from \"@/lib/types\";\nimport { clientDefaultSettings } from \"@/lib/llm-settings\";\nimport { getApiKeyFromSession } from \"@/lib/session-management\";\nimport { isFeatureEnabled } from \"@/lib/feature-flags\";\nimport { createLogger } from \"@/lib/debug-logger\";\nimport { isBrowser } from \"./browser-check\";\n\nconst logger = createLogger(\"LLM-SECURE-CLIENT\");\n\n// Secure client-side wrapper for the LLM service\nexport class LLMSecureClient {\n  private settings: LLMSettings;\n\n  constructor(initialSettings: Partial<LLMSettings> = {}) {\n    logger.log(\"LLMSecureClient constructor called with:\", {\n      initialSettingsType: typeof initialSettings,\n      isObject: initialSettings && typeof initialSettings === \"object\",\n      hasServerRef:\n        initialSettings &&\n        typeof initialSettings === \"object\" &&\n        \"__server_ref\" in initialSettings,\n      keys:\n        initialSettings && typeof initialSettings === \"object\"\n          ? Object.keys(initialSettings)\n          : [],\n    });\n\n    // Create a fresh settings object with default values from client-side defaults\n    this.settings = { ...clientDefaultSettings } as LLMSettings;\n\n    // Try to load settings from localStorage first\n    try {\n      if (isBrowser) {\n        const savedSettings = localStorage.getItem(\"llm-settings\");\n        if (savedSettings) {\n          const parsedSettings = JSON.parse(savedSettings);\n          logger.log(\"Loaded settings from localStorage:\", {\n            provider: parsedSettings.provider,\n            model: parsedSettings.model,\n            hasApiKey: !!parsedSettings.apiKey,\n            apiKeyLength: parsedSettings.apiKey\n              ? parsedSettings.apiKey.length\n              : 0,\n            hasApiKeySessionId: !!parsedSettings.apiKeySessionId,\n          });\n\n          // Apply saved settings\n          if (parsedSettings.provider)\n            this.settings.provider = parsedSettings.provider;\n          if (parsedSettings.model) this.settings.model = parsedSettings.model;\n          if (typeof parsedSettings.temperature === \"number\")\n            this.settings.temperature = parsedSettings.temperature;\n          if (typeof parsedSettings.maxTokens === \"number\")\n            this.settings.maxTokens = parsedSettings.maxTokens;\n          if (typeof parsedSettings.topP === \"number\")\n            this.settings.topP = parsedSettings.topP;\n          if (typeof parsedSettings.frequencyPenalty === \"number\")\n            this.settings.frequencyPenalty = parsedSettings.frequencyPenalty;\n          if (typeof parsedSettings.presencePenalty === \"number\")\n            this.settings.presencePenalty = parsedSettings.presencePenalty;\n          if (typeof parsedSettings.systemFingerprint === \"boolean\")\n            this.settings.systemFingerprint = parsedSettings.systemFingerprint;\n\n          // Handle API key or session ID\n          if (parsedSettings.apiKeySessionId) {\n            this.settings.apiKeySessionId = parsedSettings.apiKeySessionId;\n          } else if (parsedSettings.apiKey) {\n            // If we have an API key but no session ID, we'll need to migrate it\n            // This will be handled in the migration utility\n            this.settings.apiKey = parsedSettings.apiKey;\n          }\n        }\n      }\n    } catch (e) {\n      logger.warn(\"Could not load settings from localStorage:\", e);\n    }\n\n    // Only copy properties from initialSettings if it's a valid object without server refs\n    // and if they weren't already loaded from localStorage\n    if (\n      initialSettings &&\n      typeof initialSettings === \"object\" &&\n      !(\"__server_ref\" in initialSettings)\n    ) {\n      logger.log(\"Copying properties from initialSettings to this.settings\");\n      if (initialSettings.provider)\n        this.settings.provider = initialSettings.provider;\n      if (initialSettings.model) this.settings.model = initialSettings.model;\n      if (typeof initialSettings.temperature === \"number\")\n        this.settings.temperature = initialSettings.temperature;\n      if (typeof initialSettings.maxTokens === \"number\")\n        this.settings.maxTokens = initialSettings.maxTokens;\n      if (typeof initialSettings.topP === \"number\")\n        this.settings.topP = initialSettings.topP;\n      if (typeof initialSettings.frequencyPenalty === \"number\")\n        this.settings.frequencyPenalty = initialSettings.frequencyPenalty;\n      if (typeof initialSettings.presencePenalty === \"number\")\n        this.settings.presencePenalty = initialSettings.presencePenalty;\n      if (typeof initialSettings.systemFingerprint === \"boolean\")\n        this.settings.systemFingerprint = initialSettings.systemFingerprint;\n\n      // Handle API key or session ID\n      if (initialSettings.apiKeySessionId) {\n        this.settings.apiKeySessionId = initialSettings.apiKeySessionId;\n      } else if (initialSettings.apiKey) {\n        this.settings.apiKey = initialSettings.apiKey;\n      }\n    } else {\n      logger.log(\n        \"Not copying properties from initialSettings due to server ref or invalid object\",\n      );\n    }\n\n    logger.log(\"LLMSecureClient initialized with settings:\", {\n      ...this.settings,\n      apiKey: this.settings.apiKey\n        ? `[Length: ${this.settings.apiKey.length}]`\n        : undefined,\n      apiKeySessionId: this.settings.apiKeySessionId ? \"[PRESENT]\" : undefined,\n      provider: this.settings.provider,\n    });\n\n    // Check if we need to migrate an API key to the secure storage\n    this.migrateApiKeyIfNeeded();\n  }\n\n  // Migrate API key to secure storage if needed\n  private async migrateApiKeyIfNeeded(): Promise<void> {\n    // Only migrate if secure storage is enabled\n    if (!isFeatureEnabled(\"useSecureApiStorage\")) {\n      return;\n    }\n\n    // Check if we have an API key but no session ID\n    if (this.settings.apiKey && !this.settings.apiKeySessionId) {\n      logger.log(\"Migrating API key to secure storage\");\n      try {\n        // Store the API key securely\n        const response = await fetch(\"/api/api-key/store\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            provider: this.settings.provider,\n            apiKey: this.settings.apiKey,\n          }),\n        });\n\n        const data = await response.json();\n        if (data.success && data.sessionId) {\n          logger.log(\"API key migrated successfully\");\n          // Store the session ID\n          this.settings.apiKeySessionId = data.sessionId;\n          // Remove the API key from settings\n          delete this.settings.apiKey;\n          // Save the updated settings\n          this.saveSettingsToLocalStorage();\n        } else {\n          logger.error(\"Failed to migrate API key:\", data.message);\n        }\n      } catch (error) {\n        logger.error(\"Error migrating API key:\", error);\n      }\n    }\n  }\n\n  // Save settings to localStorage\n  private saveSettingsToLocalStorage(): void {\n    try {\n      localStorage.setItem(\"llm-settings\", JSON.stringify(this.settings));\n      logger.log(\"Settings saved to localStorage\");\n    } catch (e) {\n      logger.warn(\"Could not save settings to localStorage:\", e);\n    }\n  }\n\n  // Update settings\n  updateSettings(newSettings: Partial<LLMSettings>): void {\n    logger.log(\"LLMSecureClient.updateSettings called with:\", {\n      newSettingsType: typeof newSettings,\n      isObject: newSettings && typeof newSettings === \"object\",\n      hasServerRef:\n        newSettings &&\n        typeof newSettings === \"object\" &&\n        \"__server_ref\" in newSettings,\n      keys:\n        newSettings && typeof newSettings === \"object\"\n          ? Object.keys(newSettings)\n          : [],\n      apiKeyPresent:\n        newSettings && typeof newSettings === \"object\"\n          ? \"apiKey\" in newSettings\n          : false,\n      apiKeyValue:\n        newSettings &&\n        typeof newSettings === \"object\" &&\n        \"apiKey\" in newSettings\n          ? typeof newSettings.apiKey === \"string\"\n            ? `[Length: ${newSettings.apiKey.length}]`\n            : String(newSettings.apiKey)\n          : \"undefined\",\n      apiKeySessionIdPresent:\n        newSettings && typeof newSettings === \"object\"\n          ? \"apiKeySessionId\" in newSettings\n          : false,\n    });\n\n    // Handle server references or undefined values\n    if (\n      !newSettings ||\n      typeof newSettings !== \"object\" ||\n      \"__server_ref\" in newSettings\n    ) {\n      logger.warn(\n        \"Invalid settings update or server reference detected, ignoring\",\n      );\n      return;\n    }\n\n    // CRITICAL FIX: Ensure provider is correctly updated\n    // Log the provider change explicitly\n    if (newSettings.provider) {\n      logger.log(\n        `Updating provider from ${this.settings.provider} to ${newSettings.provider}`,\n      );\n      this.settings.provider = newSettings.provider;\n    }\n\n    // Update only the properties that are provided\n    logger.log(\"Updating settings properties\");\n    if (newSettings.model) this.settings.model = newSettings.model;\n    if (typeof newSettings.temperature === \"number\")\n      this.settings.temperature = newSettings.temperature;\n    if (typeof newSettings.maxTokens === \"number\")\n      this.settings.maxTokens = newSettings.maxTokens;\n    if (typeof newSettings.topP === \"number\")\n      this.settings.topP = newSettings.topP;\n    if (typeof newSettings.frequencyPenalty === \"number\")\n      this.settings.frequencyPenalty = newSettings.frequencyPenalty;\n    if (typeof newSettings.presencePenalty === \"number\")\n      this.settings.presencePenalty = newSettings.presencePenalty;\n    if (typeof newSettings.systemFingerprint === \"boolean\")\n      this.settings.systemFingerprint = newSettings.systemFingerprint;\n\n    // Handle API key updates\n    if (isFeatureEnabled(\"useSecureApiStorage\")) {\n      // Secure storage is enabled, handle API key securely\n      if (\n        \"apiKey\" in newSettings &&\n        typeof newSettings.apiKey === \"string\" &&\n        newSettings.apiKey.trim() !== \"\"\n      ) {\n        // Store the API key securely\n        this.storeApiKeySecurely(newSettings.apiKey);\n      } else if (newSettings.apiKeySessionId) {\n        // Use the provided session ID\n        this.settings.apiKeySessionId = newSettings.apiKeySessionId;\n        // Remove any existing API key\n        delete this.settings.apiKey;\n      } else if (\n        newSettings.apiKey === undefined ||\n        newSettings.apiKey === null\n      ) {\n        // Clear both API key and session ID\n        delete this.settings.apiKey;\n        delete this.settings.apiKeySessionId;\n      }\n    } else {\n      // Secure storage is disabled, handle API key directly\n      if (\"apiKey\" in newSettings) {\n        if (\n          typeof newSettings.apiKey === \"string\" &&\n          newSettings.apiKey.trim() !== \"\"\n        ) {\n          this.settings.apiKey = newSettings.apiKey;\n        } else if (\n          newSettings.apiKey === undefined ||\n          newSettings.apiKey === null\n        ) {\n          delete this.settings.apiKey;\n        }\n      }\n    }\n\n    // Save settings to localStorage\n    this.saveSettingsToLocalStorage();\n\n    logger.log(\"Settings updated to:\", {\n      ...this.settings,\n      apiKey: this.settings.apiKey\n        ? `[Length: ${this.settings.apiKey.length}]`\n        : undefined,\n      apiKeySessionId: this.settings.apiKeySessionId ? \"[PRESENT]\" : undefined,\n      provider: this.settings.provider,\n    });\n  }\n\n  // Store API key securely\n  private async storeApiKeySecurely(apiKey: string): Promise<void> {\n    try {\n      logger.log(\"Storing API key securely\");\n      const response = await fetch(\"/api/api-key/store\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          provider: this.settings.provider,\n          apiKey: apiKey,\n        }),\n      });\n\n      const data = await response.json();\n      if (data.success && data.sessionId) {\n        logger.log(\"API key stored securely\");\n        // Store the session ID\n        this.settings.apiKeySessionId = data.sessionId;\n        // Remove the API key from settings\n        delete this.settings.apiKey;\n      } else {\n        logger.error(\"Failed to store API key securely:\", data.message);\n        // Fall back to storing the API key directly\n        this.settings.apiKey = apiKey;\n      }\n    } catch (error) {\n      logger.error(\"Error storing API key securely:\", error);\n      // Fall back to storing the API key directly\n      this.settings.apiKey = apiKey;\n    }\n  }\n\n  // Get current settings\n  getSettings(): LLMSettings {\n    logger.log(\"LLMSecureClient.getSettings called\");\n    try {\n      // Return a copy to avoid reference issues\n      const settingsCopy = { ...this.settings };\n      logger.log(\"LLMSecureClient.getSettings returning:\", {\n        ...settingsCopy,\n        apiKey: settingsCopy.apiKey\n          ? `[Length: ${settingsCopy.apiKey.length}]`\n          : undefined,\n        apiKeySessionId: settingsCopy.apiKeySessionId ? \"[PRESENT]\" : undefined,\n        provider: settingsCopy.provider,\n      });\n      return settingsCopy;\n    } catch (error) {\n      logger.error(\"Error in LLMSecureClient.getSettings:\", error);\n      // Return a safe default if there's an error\n      return {\n        provider: \"openai\",\n        model: \"gpt-4o\",\n        temperature: 0.7,\n        maxTokens: 1024,\n        topP: 0.9,\n        frequencyPenalty: 0,\n        presencePenalty: 0,\n        systemFingerprint: false,\n        maxAutonomousMessages: 4,\n        conversationCooldown: 5000,\n      };\n    }\n  }\n\n  // Get API key (either from settings or from secure storage)\n  private async getApiKey(): Promise<string | null> {\n    if (\n      isFeatureEnabled(\"useSecureApiStorage\") &&\n      this.settings.apiKeySessionId\n    ) {\n      // Get API key from secure storage\n      return await getApiKeyFromSession(this.settings.provider);\n    } else if (this.settings.apiKey) {\n      // Get API key from settings\n      return this.settings.apiKey;\n    }\n    return null;\n  }\n\n  // Generate a response using a system prompt\n  async generateResponse(\n    systemPrompt: string,\n    userPrompt: string,\n  ): Promise<string> {\n    try {\n      logger.log(\"[LLM SECURE CLIENT] generateResponse called with:\", {\n        systemPromptLength: systemPrompt?.length,\n        userPromptLength: userPrompt?.length,\n        provider: this.settings.provider,\n        model: this.settings.model,\n        apiKeyAvailable: !!(\n          this.settings.apiKey || this.settings.apiKeySessionId\n        ),\n        apiKeyLength: this.settings.apiKey ? this.settings.apiKey.length : 0,\n        hasApiKeySessionId: !!this.settings.apiKeySessionId,\n      });\n\n      // Create a copy of settings to ensure we're not passing a reference\n      const settingsCopy = { ...this.settings };\n\n      // Get the API key\n      const apiKey = await this.getApiKey();\n      if (!apiKey) {\n        logger.warn(\"[LLM SECURE CLIENT] No API key available\");\n        return \"Error: No API key available. Please set an API key in the settings.\";\n      }\n\n      // Add the API key to the settings copy\n      settingsCopy.apiKey = apiKey;\n\n      // Call the server-side function with the copy\n      const response = await generateResponse(\n        systemPrompt,\n        userPrompt,\n        settingsCopy,\n      );\n      logger.log(\"[LLM SECURE CLIENT] Response received from server:\", {\n        responseLength: response?.length,\n      });\n      return response;\n    } catch (error) {\n      logger.error(\"[LLM SECURE CLIENT] Error in generateResponse:\", error);\n      return `Error: ${error instanceof Error ? error.message : \"Unknown error\"}`;\n    }\n  }\n\n  // Extract beliefs from conversation\n  async extractBeliefs(\n    conversationText: string,\n    agentName: string,\n    extractionPriorities: string,\n  ): Promise<string> {\n    try {\n      logger.log(\"LLMSecureClient.extractBeliefs called\");\n\n      // Create a copy of settings to ensure we're not passing a reference\n      const settingsCopy = { ...this.settings };\n\n      // Get the API key\n      const apiKey = await this.getApiKey();\n      if (!apiKey) {\n        throw new Error(\n          `API key is required for ${settingsCopy.provider} provider during belief extraction`,\n        );\n      }\n\n      // Add the API key to the settings copy\n      settingsCopy.apiKey = apiKey;\n\n      return await serverExtractBeliefs(\n        conversationText,\n        agentName,\n        extractionPriorities,\n        settingsCopy,\n      );\n    } catch (error) {\n      logger.error(\"Error in client extractBeliefs:\", error);\n      return `Error: ${error instanceof Error ? error.message : \"Unknown error\"}`;\n    }\n  }\n\n  // Generate knowledge entries from beliefs\n  async generateKnowledgeEntries(beliefs: string): Promise<KnowledgeEntry[]> {\n    try {\n      logger.log(\"LLMSecureClient.generateKnowledgeEntries called\");\n\n      // Create a copy of settings to ensure we're not passing a reference\n      const settingsCopy = { ...this.settings };\n\n      // Get the API key\n      const apiKey = await this.getApiKey();\n      if (!apiKey) {\n        throw new Error(\n          `API key is required for ${settingsCopy.provider} provider during knowledge generation`,\n        );\n      }\n\n      // Add the API key to the settings copy\n      settingsCopy.apiKey = apiKey;\n\n      return await serverGenerateKnowledgeEntries(beliefs, settingsCopy);\n    } catch (error) {\n      logger.error(\"Error in client generateKnowledgeEntries:\", error);\n      return [\n        {\n          id: `error-${Date.now()}`,\n          title: \"Error\",\n          content: error instanceof Error ? error.message : \"Unknown error\",\n          timestamp: new Date(),\n          tags: [\"error\"],\n        },\n      ];\n    }\n  }\n\n  // Stream response\n  async streamResponse(\n    systemPrompt: string,\n    userPrompt: string,\n    onChunk?: ((text: string, isComplete: boolean) => void) | null | undefined,\n  ): Promise<string> {\n    logger.log(\"[LLM SECURE CLIENT] streamResponse called with:\", {\n      systemPromptLength: systemPrompt?.length,\n      userPromptLength: userPrompt?.length,\n      hasOnChunkCallback: typeof onChunk === \"function\",\n      onChunkType: typeof onChunk,\n    });\n\n    try {\n      // Create a truly safe callback that won't throw if onChunk is not a function\n      const safeCallback = (text: string, isComplete: boolean): void => {\n        try {\n          logger.log(\"[LLM SECURE CLIENT] safeCallback called with:\", {\n            textLength: text?.length,\n            isComplete,\n          });\n          if (typeof onChunk === \"function\") {\n            logger.log(\"[LLM SECURE CLIENT] Calling onChunk function\");\n            onChunk(text, isComplete);\n          } else {\n            logger.log(\n              \"[LLM SECURE CLIENT] Warning: onChunk is not a function\",\n              {\n                onChunkType: typeof onChunk,\n                text: text?.substring(0, 20) + \"...\",\n                isComplete,\n              },\n            );\n          }\n        } catch (callbackError) {\n          logger.error(\n            \"[LLM SECURE CLIENT] Error executing onChunk callback:\",\n            callbackError,\n          );\n        }\n      };\n\n      // Use non-streaming as fallback if streaming fails\n      let fullResponse = \"\";\n      let streamingFailed = false;\n\n      try {\n        // First attempt with streaming\n        logger.log(\"[LLM SECURE CLIENT] Attempting to use streaming response\");\n\n        // Create a copy of settings to ensure we're not passing a reference\n        const settingsCopy = { ...this.settings };\n\n        // Get the API key\n        const apiKey = await this.getApiKey();\n        if (!apiKey) {\n          logger.warn(\"[LLM SECURE CLIENT] No API key available\");\n          safeCallback(\n            \"Error: No API key available. Please set an API key in the settings.\",\n            false,\n          );\n          safeCallback(\"\", true);\n          return \"Error: No API key available. Please set an API key in the settings.\";\n        }\n\n        // Add the API key to the settings copy\n        settingsCopy.apiKey = apiKey;\n\n        // Call the server-side function\n        logger.log(\"[LLM SECURE CLIENT] Calling generateResponse\");\n        const response = await generateResponse(\n          systemPrompt,\n          userPrompt,\n          settingsCopy,\n        );\n        logger.log(\n          \"[LLM SECURE CLIENT] Response received from generateResponse:\",\n          {\n            responseLength: response?.length,\n          },\n        );\n\n        // Since we can't actually stream from the server to client with callbacks,\n        // we'll simulate streaming by chunking the response\n        const chunkSize = 10; // Characters per chunk\n        for (let i = 0; i < response.length; i += chunkSize) {\n          const chunk = response.substring(i, i + chunkSize);\n          fullResponse += chunk;\n\n          // Use the safe callback - NEVER directly call onChunk\n          logger.log(\n            `[LLM SECURE CLIENT] Processing chunk ${i / chunkSize + 1}/${Math.ceil(response.length / chunkSize)}`,\n          );\n          safeCallback(chunk, false);\n\n          // Add a small delay to simulate streaming\n          await new Promise((resolve) => setTimeout(resolve, 10));\n        }\n\n        // Signal completion\n        logger.log(\"[LLM SECURE CLIENT] Signaling completion\");\n        safeCallback(\"\", true);\n      } catch (streamError) {\n        logger.error(\n          \"[LLM SECURE CLIENT] Error in streaming response:\",\n          streamError,\n        );\n        streamingFailed = true;\n      }\n\n      // If streaming failed, fall back to non-streaming\n      if (streamingFailed) {\n        logger.log(\n          \"[LLM SECURE CLIENT] Streaming failed, falling back to non-streaming\",\n        );\n        fullResponse = await this.generateResponse(systemPrompt, userPrompt);\n\n        // Deliver the full response at once - using safe callback\n        logger.log(\"[LLM SECURE CLIENT] Delivering full response at once\");\n        safeCallback(fullResponse, false);\n        safeCallback(\"\", true);\n      }\n\n      return fullResponse;\n    } catch (error) {\n      logger.error(\"[LLM SECURE CLIENT] Error in streamResponse:\", error);\n\n      // Try to notify through callback if possible - using safe callback\n      const errorMessage = `Error: ${error instanceof Error ? error.message : String(error)}`;\n      try {\n        logger.log(\n          \"[LLM SECURE CLIENT] Attempting to notify error through callback\",\n        );\n        if (typeof onChunk === \"function\") {\n          logger.log(\"[LLM SECURE CLIENT] Calling onChunk with error message\");\n          onChunk(errorMessage, false);\n          onChunk(\"\", true);\n        } else {\n          logger.log(\n            \"[LLM SECURE CLIENT] Cannot notify error: onChunk is not a function\",\n          );\n        }\n      } catch (callbackError) {\n        logger.error(\n          \"[LLM SECURE CLIENT] Error calling onChunk callback with error:\",\n          callbackError,\n        );\n      }\n\n      // Return error message as string\n      return errorMessage;\n    }\n  }\n\n  // Validate API key\n  async validateApiKey(\n    provider: \"openai\" | \"openrouter\",\n    apiKey: string,\n  ): Promise<{ valid: boolean; message?: string }> {\n    try {\n      logger.log(\"LLMSecureClient.validateApiKey called\");\n      return await validateApiKey(provider, apiKey);\n    } catch (error) {\n      logger.error(\"Error in client validateApiKey:\", error);\n      return {\n        valid: false,\n        message:\n          error instanceof Error ? error.message : \"Error validating API key\",\n      };\n    }\n  }\n\n  // Save settings\n  async saveSettings(): Promise<boolean> {\n    try {\n      logger.log(\"LLMSecureClient.saveSettings called\");\n\n      // Create a copy of settings without the API key\n      const settingsCopy = { ...this.settings };\n\n      // If we're using secure storage, we don't need to send the API key\n      if (isFeatureEnabled(\"useSecureApiStorage\")) {\n        delete settingsCopy.apiKey;\n      }\n\n      logger.log(\"Current settings to save:\", {\n        ...settingsCopy,\n        apiKey: settingsCopy.apiKey\n          ? `[Length: ${settingsCopy.apiKey.length}]`\n          : undefined,\n        apiKeySessionId: settingsCopy.apiKeySessionId ? \"[PRESENT]\" : undefined,\n      });\n\n      return await saveLLMSettings(settingsCopy);\n    } catch (error) {\n      logger.error(\"Error in client saveSettings:\", error);\n      return false;\n    }\n  }\n}\n\n// Create a singleton instance\nlogger.log(\"Creating llmSecureClient singleton instance\");\nexport const llmSecureClient = new LLMSecureClient();\nlogger.log(\"llmSecureClient singleton instance created\");\n"],"names":["LLMSecureClient","llmSecureClient","logger","createLogger","constructor","initialSettings","log","initialSettingsType","isObject","hasServerRef","keys","Object","settings","clientDefaultSettings","isBrowser","savedSettings","localStorage","getItem","parsedSettings","JSON","parse","provider","model","hasApiKey","apiKey","apiKeyLength","length","hasApiKeySessionId","apiKeySessionId","temperature","maxTokens","topP","frequencyPenalty","presencePenalty","systemFingerprint","e","warn","undefined","migrateApiKeyIfNeeded","isFeatureEnabled","response","fetch","method","headers","body","stringify","data","json","success","sessionId","saveSettingsToLocalStorage","error","message","setItem","updateSettings","newSettings","newSettingsType","apiKeyPresent","apiKeyValue","String","apiKeySessionIdPresent","trim","storeApiKeySecurely","getSettings","settingsCopy","maxAutonomousMessages","conversationCooldown","getApiKey","getApiKeyFromSession","generateResponse","systemPrompt","userPrompt","systemPromptLength","userPromptLength","apiKeyAvailable","responseLength","Error","extractBeliefs","conversationText","agentName","extractionPriorities","serverExtractBeliefs","generateKnowledgeEntries","beliefs","serverGenerateKnowledgeEntries","id","Date","now","title","content","timestamp","tags","streamResponse","onChunk","hasOnChunkCallback","onChunkType","safeCallback","text","isComplete","textLength","substring","callbackError","fullResponse","streamingFailed","chunkSize","i","chunk","Math","ceil","Promise","resolve","setTimeout","streamError","errorMessage","validateApiKey","valid","saveSettings","saveLLMSettings"],"mappings":"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"}