{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/utils/knowledge-graph-filters.ts"],"sourcesContent":["import {\n  KnowledgeGraph,\n  KnowledgeNode,\n  KnowledgeEdge,\n  KnowledgeGraphFilters,\n} from \"@/lib/types\";\n\n// Advanced Knowledge Graph Filtering System\n// Supports multiple filter types with real-time application\n\nexport interface FilterResult {\n  nodes: KnowledgeNode[];\n  edges: KnowledgeEdge[];\n  metadata: {\n    originalNodeCount: number;\n    originalEdgeCount: number;\n    filteredNodeCount: number;\n    filteredEdgeCount: number;\n    filterCriteria: string[];\n  };\n}\n\nexport class KnowledgeGraphFilterEngine {\n  /**\n   * Apply comprehensive filters to knowledge graph\n   */\n  applyFilters(\n    graph: KnowledgeGraph,\n    filters: KnowledgeGraphFilters,\n  ): FilterResult {\n    // Collect all nodes and edges from all layers\n    const allNodes: KnowledgeNode[] = [];\n    const allEdges: KnowledgeEdge[] = [];\n\n    graph.layers.forEach((layer) => {\n      allNodes.push(...layer.nodes);\n      allEdges.push(...layer.edges);\n    });\n\n    const originalNodeCount = allNodes.length;\n    const originalEdgeCount = allEdges.length;\n    const filterCriteria: string[] = [];\n\n    // Apply node filters\n    let filteredNodes = this.applyNodeFilters(\n      allNodes,\n      filters,\n      filterCriteria,\n    );\n\n    // Apply edge filters\n    let filteredEdges = this.applyEdgeFilters(\n      allEdges,\n      filters,\n      filterCriteria,\n    );\n\n    // Apply connectivity filters\n    const connectivityResult = this.applyConnectivityFilters(\n      filteredNodes,\n      filteredEdges,\n      filters,\n      filterCriteria,\n    );\n\n    filteredNodes = connectivityResult.nodes;\n    filteredEdges = connectivityResult.edges;\n\n    // Apply search filter\n    if (filters.searchQuery) {\n      const searchResult = this.applySearchFilter(\n        filteredNodes,\n        filteredEdges,\n        filters.searchQuery,\n        filterCriteria,\n      );\n      filteredNodes = searchResult.nodes;\n      filteredEdges = searchResult.edges;\n    }\n\n    return {\n      nodes: filteredNodes,\n      edges: filteredEdges,\n      metadata: {\n        originalNodeCount,\n        originalEdgeCount,\n        filteredNodeCount: filteredNodes.length,\n        filteredEdgeCount: filteredEdges.length,\n        filterCriteria,\n      },\n    };\n  }\n\n  /**\n   * Apply node-specific filters\n   */\n  private applyNodeFilters(\n    nodes: KnowledgeNode[],\n    filters: KnowledgeGraphFilters,\n    criteria: string[],\n  ): KnowledgeNode[] {\n    let filteredNodes = nodes;\n\n    // Filter by node types\n    if (filters.nodeTypes.length > 0) {\n      filteredNodes = filteredNodes.filter((node) =>\n        filters.nodeTypes.includes(node.type),\n      );\n      criteria.push(`Node types: ${filters.nodeTypes.join(\", \")}`);\n    }\n\n    // Filter by confidence range\n    const [minConf, maxConf] = filters.confidenceRange;\n    if (minConf > 0 || maxConf < 1) {\n      filteredNodes = filteredNodes.filter(\n        (node) => node.confidence >= minConf && node.confidence <= maxConf,\n      );\n      criteria.push(\n        `Confidence: ${(minConf * 100).toFixed(1)}% - ${(maxConf * 100).toFixed(1)}%`,\n      );\n    }\n\n    // Filter by importance range\n    const [minImp, maxImp] = filters.importanceRange;\n    if (minImp > 0 || maxImp < 1) {\n      filteredNodes = filteredNodes.filter(\n        (node) => node.importance >= minImp && node.importance <= maxImp,\n      );\n      criteria.push(\n        `Importance: ${(minImp * 100).toFixed(1)}% - ${(maxImp * 100).toFixed(1)}%`,\n      );\n    }\n\n    // Filter by time range\n    if (filters.timeRange) {\n      const [startDate, endDate] = filters.timeRange.map((d) => new Date(d));\n      filteredNodes = filteredNodes.filter((node) => {\n        const nodeDate = new Date(node.lastUpdated);\n        return nodeDate >= startDate && nodeDate <= endDate;\n      });\n      criteria.push(\n        `Time range: ${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}`,\n      );\n    }\n\n    // Filter by agent IDs\n    if (filters.agentIds.length > 0) {\n      filteredNodes = filteredNodes.filter(\n        (node) =>\n          (node.agentId && filters.agentIds.includes(node.agentId)) ||\n          (node.agentIds &&\n            node.agentIds.some((id) => filters.agentIds.includes(id))),\n      );\n      criteria.push(`Agents: ${filters.agentIds.join(\", \")}`);\n    }\n\n    // Filter by tags\n    if (filters.tags.length > 0) {\n      filteredNodes = filteredNodes.filter(\n        (node) =>\n          node.tags && node.tags.some((tag) => filters.tags.includes(tag)),\n      );\n      criteria.push(`Tags: ${filters.tags.join(\", \")}`);\n    }\n\n    return filteredNodes;\n  }\n\n  /**\n   * Apply edge-specific filters\n   */\n  private applyEdgeFilters(\n    edges: KnowledgeEdge[],\n    filters: KnowledgeGraphFilters,\n    criteria: string[],\n  ): KnowledgeEdge[] {\n    let filteredEdges = edges;\n\n    // Filter by edge types\n    if (filters.edgeTypes.length > 0) {\n      filteredEdges = filteredEdges.filter((edge) =>\n        filters.edgeTypes.includes(edge.type),\n      );\n      criteria.push(`Edge types: ${filters.edgeTypes.join(\", \")}`);\n    }\n\n    // Filter by strength range\n    const [minStr, maxStr] = filters.strengthRange;\n    if (minStr > 0 || maxStr < 1) {\n      filteredEdges = filteredEdges.filter(\n        (edge) => edge.strength >= minStr && edge.strength <= maxStr,\n      );\n      criteria.push(\n        `Strength: ${(minStr * 100).toFixed(1)}% - ${(maxStr * 100).toFixed(1)}%`,\n      );\n    }\n\n    return filteredEdges;\n  }\n\n  /**\n   * Apply connectivity-based filters\n   */\n  private applyConnectivityFilters(\n    nodes: KnowledgeNode[],\n    edges: KnowledgeEdge[],\n    filters: KnowledgeGraphFilters,\n    criteria: string[],\n  ): { nodes: KnowledgeNode[]; edges: KnowledgeEdge[] } {\n    const nodeIds = new Set(nodes.map((n) => n.id));\n\n    // Filter edges to only include those with both nodes present\n    let filteredEdges = edges.filter(\n      (edge) => nodeIds.has(edge.source) && nodeIds.has(edge.target),\n    );\n\n    // Calculate node connections\n    const nodeConnections = new Map<string, number>();\n    filteredEdges.forEach((edge) => {\n      nodeConnections.set(\n        edge.source,\n        (nodeConnections.get(edge.source) || 0) + 1,\n      );\n      nodeConnections.set(\n        edge.target,\n        (nodeConnections.get(edge.target) || 0) + 1,\n      );\n    });\n\n    let filteredNodes = nodes;\n\n    // Filter by connection requirements\n    if (filters.showOnlyConnected) {\n      filteredNodes = filteredNodes.filter((node) =>\n        nodeConnections.has(node.id),\n      );\n      criteria.push(\"Show only connected nodes\");\n    }\n\n    if (filters.hideIsolatedNodes) {\n      filteredNodes = filteredNodes.filter(\n        (node) => nodeConnections.get(node.id) || 0 > 0,\n      );\n      criteria.push(\"Hide isolated nodes\");\n    }\n\n    // Filter by maximum connections\n    if (filters.maxConnections) {\n      filteredNodes = filteredNodes.filter(\n        (node) =>\n          (nodeConnections.get(node.id) || 0) <= filters.maxConnections!,\n      );\n      criteria.push(`Max connections: ${filters.maxConnections}`);\n    }\n\n    // Re-filter edges based on final node set\n    const finalNodeIds = new Set(filteredNodes.map((n) => n.id));\n    filteredEdges = filteredEdges.filter(\n      (edge) => finalNodeIds.has(edge.source) && finalNodeIds.has(edge.target),\n    );\n\n    return { nodes: filteredNodes, edges: filteredEdges };\n  }\n\n  /**\n   * Apply text search filter\n   */\n  private applySearchFilter(\n    nodes: KnowledgeNode[],\n    edges: KnowledgeEdge[],\n    searchQuery: string,\n    criteria: string[],\n  ): { nodes: KnowledgeNode[]; edges: KnowledgeEdge[] } {\n    const query = searchQuery.toLowerCase().trim();\n    if (!query) return { nodes, edges };\n\n    // Search in nodes\n    const matchingNodes = nodes.filter((node) => {\n      // Search in title\n      if (node.title.toLowerCase().includes(query)) return true;\n\n      // Search in content\n      if (node.content?.toLowerCase().includes(query)) return true;\n\n      // Search in tags\n      if (node.tags?.some((tag) => tag.toLowerCase().includes(query)))\n        return true;\n\n      // Search in metadata\n      if (node.metadata) {\n        const metadataString = JSON.stringify(node.metadata).toLowerCase();\n        if (metadataString.includes(query)) return true;\n      }\n\n      return false;\n    });\n\n    // Search in edges and include connected nodes\n    const edgeMatchingNodeIds = new Set<string>();\n    edges.forEach((edge) => {\n      const edgeText =\n        `${edge.type} ${JSON.stringify(edge.metadata || {})}`.toLowerCase();\n      if (edgeText.includes(query)) {\n        edgeMatchingNodeIds.add(edge.source);\n        edgeMatchingNodeIds.add(edge.target);\n      }\n    });\n\n    // Combine node matches with edge-connected nodes\n    const allMatchingNodeIds = new Set([\n      ...matchingNodes.map((n) => n.id),\n      ...edgeMatchingNodeIds,\n    ]);\n\n    const filteredNodes = nodes.filter((node) =>\n      allMatchingNodeIds.has(node.id),\n    );\n\n    // Filter edges to only include those with both nodes in the result\n    const filteredEdges = edges.filter(\n      (edge) =>\n        allMatchingNodeIds.has(edge.source) &&\n        allMatchingNodeIds.has(edge.target),\n    );\n\n    criteria.push(`Search: \"${searchQuery}\"`);\n\n    return { nodes: filteredNodes, edges: filteredEdges };\n  }\n\n  /**\n   * Get filter suggestions based on current graph data\n   */\n  getFilterSuggestions(graph: KnowledgeGraph): {\n    nodeTypes: string[];\n    edgeTypes: string[];\n    tags: string[];\n    agentIds: string[];\n    confidenceRange: [number, number];\n    importanceRange: [number, number];\n    strengthRange: [number, number];\n  } {\n    const allNodes: KnowledgeNode[] = [];\n    const allEdges: KnowledgeEdge[] = [];\n\n    graph.layers.forEach((layer) => {\n      allNodes.push(...layer.nodes);\n      allEdges.push(...layer.edges);\n    });\n\n    // Extract unique values\n    const nodeTypes = [...new Set(allNodes.map((n) => n.type))];\n    const edgeTypes = [...new Set(allEdges.map((e) => e.type))];\n    const tags = [...new Set(allNodes.flatMap((n) => n.tags || []))];\n    const agentIds = [\n      ...new Set(\n        allNodes.flatMap((n) => (n.agentId ? [n.agentId] : n.agentIds || [])),\n      ),\n    ];\n\n    // Calculate ranges\n    const confidences = allNodes.map((n) => n.confidence);\n    const importances = allNodes.map((n) => n.importance);\n    const strengths = allEdges.map((e) => e.strength);\n\n    const confidenceRange: [number, number] = [\n      Math.min(...confidences),\n      Math.max(...confidences),\n    ];\n\n    const importanceRange: [number, number] = [\n      Math.min(...importances),\n      Math.max(...importances),\n    ];\n\n    const strengthRange: [number, number] = [\n      Math.min(...strengths),\n      Math.max(...strengths),\n    ];\n\n    return {\n      nodeTypes: nodeTypes.sort(),\n      edgeTypes: edgeTypes.sort(),\n      tags: tags.sort(),\n      agentIds: agentIds.sort(),\n      confidenceRange,\n      importanceRange,\n      strengthRange,\n    };\n  }\n\n  /**\n   * Create filter preset for common use cases\n   */\n  createFilterPreset(\n    presetName: string,\n    graph: KnowledgeGraph,\n  ): Partial<KnowledgeGraphFilters> {\n    const suggestions = this.getFilterSuggestions(graph);\n\n    switch (presetName) {\n      case \"high_confidence\":\n        return {\n          confidenceRange: [0.8, 1.0],\n          nodeTypes: suggestions.nodeTypes,\n          edgeTypes: suggestions.edgeTypes,\n          strengthRange: [0.7, 1.0],\n          showOnlyConnected: true,\n          hideIsolatedNodes: true,\n        };\n\n      case \"recent_updates\":\n        const weekAgo = new Date();\n        weekAgo.setDate(weekAgo.getDate() - 7);\n        return {\n          timeRange: [weekAgo, new Date()],\n          nodeTypes: suggestions.nodeTypes,\n          edgeTypes: suggestions.edgeTypes,\n          showOnlyConnected: false,\n          hideIsolatedNodes: false,\n        };\n\n      case \"core_concepts\":\n        return {\n          nodeTypes: [\"concept\", \"fact\"],\n          importanceRange: [0.7, 1.0],\n          confidenceRange: [0.6, 1.0],\n          showOnlyConnected: true,\n          hideIsolatedNodes: true,\n        };\n\n      case \"agent_beliefs\":\n        return {\n          nodeTypes: [\"belief\"],\n          edgeTypes: [\"supports\", \"contradicts\"],\n          confidenceRange: [0.0, 1.0],\n          showOnlyConnected: false,\n          hideIsolatedNodes: false,\n        };\n\n      case \"connected_only\":\n        return {\n          nodeTypes: suggestions.nodeTypes,\n          edgeTypes: suggestions.edgeTypes,\n          showOnlyConnected: true,\n          hideIsolatedNodes: true,\n          maxConnections: undefined,\n        };\n\n      default:\n        return {\n          nodeTypes: suggestions.nodeTypes,\n          edgeTypes: suggestions.edgeTypes,\n          confidenceRange: suggestions.confidenceRange,\n          importanceRange: suggestions.importanceRange,\n          strengthRange: suggestions.strengthRange,\n          agentIds: [],\n          tags: [],\n          showOnlyConnected: false,\n          hideIsolatedNodes: false,\n        };\n    }\n  }\n\n  /**\n   * Validate filter configuration\n   */\n  validateFilters(filters: KnowledgeGraphFilters): {\n    isValid: boolean;\n    errors: string[];\n  } {\n    const errors: string[] = [];\n\n    // Validate confidence range\n    const [minConf, maxConf] = filters.confidenceRange;\n    if (minConf < 0 || minConf > 1 || maxConf < 0 || maxConf > 1) {\n      errors.push(\"Confidence range must be between 0 and 1\");\n    }\n    if (minConf > maxConf) {\n      errors.push(\"Confidence minimum cannot be greater than maximum\");\n    }\n\n    // Validate importance range\n    const [minImp, maxImp] = filters.importanceRange;\n    if (minImp < 0 || minImp > 1 || maxImp < 0 || maxImp > 1) {\n      errors.push(\"Importance range must be between 0 and 1\");\n    }\n    if (minImp > maxImp) {\n      errors.push(\"Importance minimum cannot be greater than maximum\");\n    }\n\n    // Validate strength range\n    const [minStr, maxStr] = filters.strengthRange;\n    if (minStr < 0 || minStr > 1 || maxStr < 0 || maxStr > 1) {\n      errors.push(\"Strength range must be between 0 and 1\");\n    }\n    if (minStr > maxStr) {\n      errors.push(\"Strength minimum cannot be greater than maximum\");\n    }\n\n    // Validate time range\n    if (filters.timeRange) {\n      const [startDate, endDate] = filters.timeRange.map((d) => new Date(d));\n      if (startDate > endDate) {\n        errors.push(\"Start date cannot be after end date\");\n      }\n    }\n\n    // Validate max connections\n    if (filters.maxConnections !== undefined && filters.maxConnections < 0) {\n      errors.push(\"Maximum connections cannot be negative\");\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n}\n\n// Export singleton instance\nexport const knowledgeGraphFilterEngine = new KnowledgeGraphFilterEngine();\n"],"names":["KnowledgeGraphFilterEngine","knowledgeGraphFilterEngine","applyFilters","graph","filters","allNodes","allEdges","layers","forEach","layer","push","nodes","edges","originalNodeCount","length","originalEdgeCount","filterCriteria","filteredNodes","applyNodeFilters","filteredEdges","applyEdgeFilters","connectivityResult","applyConnectivityFilters","searchQuery","searchResult","applySearchFilter","metadata","filteredNodeCount","filteredEdgeCount","criteria","nodeTypes","filter","node","includes","type","join","minConf","maxConf","confidenceRange","confidence","toFixed","minImp","maxImp","importanceRange","importance","timeRange","startDate","endDate","map","d","Date","nodeDate","lastUpdated","toLocaleDateString","agentIds","agentId","some","id","tags","tag","edgeTypes","edge","minStr","maxStr","strengthRange","strength","nodeIds","Set","n","has","source","target","nodeConnections","Map","set","get","showOnlyConnected","hideIsolatedNodes","maxConnections","finalNodeIds","query","toLowerCase","trim","matchingNodes","title","content","metadataString","JSON","stringify","edgeMatchingNodeIds","edgeText","add","allMatchingNodeIds","getFilterSuggestions","e","flatMap","confidences","importances","strengths","Math","min","max","sort","createFilterPreset","presetName","suggestions","weekAgo","setDate","getDate","undefined","validateFilters","errors","isValid"],"mappings":"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"}