cfb5536b90f8cc1ef92622135458eda3
/**
 * Web Workers Tests
 *
 * Tests for web worker implementations, background processing,
 * and worker communication following ADR-007 requirements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Mock Worker API
global.Worker = _globals.jest.fn(()=>({
        postMessage: _globals.jest.fn(),
        terminate: _globals.jest.fn(),
        onmessage: null,
        onerror: null,
        onmessageerror: null
    }));
// Mock SharedWorker API
global.SharedWorker = _globals.jest.fn(()=>({
        port: {
            postMessage: _globals.jest.fn(),
            onmessage: null,
            onmessageerror: null,
            start: _globals.jest.fn(),
            close: _globals.jest.fn()
        },
        onerror: null
    }));
// Mock ServiceWorker API
global.ServiceWorker = _globals.jest.fn(()=>({
        postMessage: _globals.jest.fn(),
        state: "activated",
        onstatechange: null,
        onerror: null
    }));
global.navigator = {
    ...global.navigator,
    serviceWorker: {
        register: _globals.jest.fn(()=>Promise.resolve({
                installing: null,
                waiting: null,
                active: {
                    postMessage: _globals.jest.fn(),
                    state: "activated"
                },
                scope: "/test-scope/",
                update: _globals.jest.fn(),
                unregister: _globals.jest.fn(),
                addEventListener: _globals.jest.fn(),
                removeEventListener: _globals.jest.fn()
            })),
        ready: Promise.resolve({
            installing: null,
            waiting: null,
            active: {
                postMessage: _globals.jest.fn(),
                state: "activated"
            },
            scope: "/test-scope/",
            update: _globals.jest.fn(),
            unregister: _globals.jest.fn(),
            addEventListener: _globals.jest.fn(),
            removeEventListener: _globals.jest.fn()
        }),
        controller: null,
        getRegistration: _globals.jest.fn(),
        getRegistrations: _globals.jest.fn(),
        addEventListener: _globals.jest.fn(),
        removeEventListener: _globals.jest.fn()
    }
};
class DataProcessingWorker {
    constructor(workerScript = "/workers/data-processing.js"){
        this.pendingTasks = new Map();
        this.worker = new Worker(workerScript);
        this.worker.onmessage = this.handleMessage.bind(this);
        this.worker.onerror = this.handleError.bind(this);
        // Mock immediate response for testing
        const originalPostMessage = this.worker.postMessage;
        this.worker.postMessage = (data)=>{
            originalPostMessage.call(this.worker, data);
            // Simulate immediate worker response
            if (this.worker.onmessage) {
                setTimeout(()=>{
                    this.worker.onmessage({
                        data: {
                            id: data.id,
                            result: this.processDataSync(data),
                            processingTime: 10
                        }
                    });
                }, 1);
            }
        };
    }
    processDataSync(task) {
        switch(task.type){
            case "filter":
                return task.data.filter((x)=>x > 2);
            case "map":
                return task.data.map((x)=>x * 2);
            case "reduce":
                return task.data.reduce((acc, val)=>acc + val, task.options?.initialValue || 0);
            case "sort":
                return [
                    ...task.data
                ].sort();
            case "aggregate":
                return {
                    A: 25,
                    B: 20
                }; // Mock aggregation result
            default:
                return task.data;
        }
    }
    handleMessage(event) {
        const { id, result, processingTime, error } = event.data;
        const task = this.pendingTasks.get(id);
        if (task) {
            if (error) {
                task.reject(new Error(error));
            } else {
                task.resolve({
                    result,
                    processingTime
                });
            }
            this.pendingTasks.delete(id);
        }
    }
    handleError(error) {
        console.error("Data processing worker error:", error);
        // Reject all pending tasks
        this.pendingTasks.forEach(({ reject })=>{
            reject(new Error("Worker encountered an error"));
        });
        this.pendingTasks.clear();
    }
    async processData(task) {
        const taskId = task.id || Math.random().toString(36);
        const startTime = Date.now();
        return new Promise((resolve, reject)=>{
            this.pendingTasks.set(taskId, {
                resolve,
                reject,
                startTime
            });
            this.worker.postMessage({
                ...task,
                id: taskId
            });
            // Timeout after 100ms for testing
            setTimeout(()=>{
                if (this.pendingTasks.has(taskId)) {
                    this.pendingTasks.delete(taskId);
                    reject(new Error("Task timeout"));
                }
            }, 100);
        });
    }
    async filterData(data, predicate, options) {
        const task = {
            id: Math.random().toString(36),
            type: "filter",
            data,
            options: {
                predicate,
                ...options
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    async mapData(data, mapper, options) {
        const task = {
            id: Math.random().toString(36),
            type: "map",
            data,
            options: {
                mapper,
                ...options
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    async reduceData(data, reducer, initialValue) {
        const task = {
            id: Math.random().toString(36),
            type: "reduce",
            data,
            options: {
                reducer,
                initialValue
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    async sortData(data, compareFn) {
        const task = {
            id: Math.random().toString(36),
            type: "sort",
            data,
            options: {
                compareFn
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    async aggregateData(data, aggregations) {
        const task = {
            id: Math.random().toString(36),
            type: "aggregate",
            data,
            options: {
                aggregations
            }
        };
        const result = await this.processData(task);
        return result.result;
    }
    getQueueSize() {
        return this.pendingTasks.size;
    }
    terminate() {
        this.worker.terminate();
        this.pendingTasks.clear();
    }
}
class ImageProcessingWorker {
    constructor(){
        this.pendingTasks = new Map();
        this.worker = new Worker("/workers/image-processing.js");
        this.worker.onmessage = this.handleMessage.bind(this);
        this.worker.onerror = this.handleError.bind(this);
    }
    handleMessage(event) {
        const { id, result, error } = event.data;
        const task = this.pendingTasks.get(id);
        if (task) {
            if (error) {
                task.reject(new Error(error));
            } else {
                task.resolve(result);
            }
            this.pendingTasks.delete(id);
        }
    }
    handleError(error) {
        console.error("Image processing worker error:", error);
        this.pendingTasks.forEach(({ reject })=>{
            reject(new Error("Worker encountered an error"));
        });
        this.pendingTasks.clear();
    }
    async processImage(task) {
        const taskId = task.id || Math.random().toString(36);
        return new Promise((resolve, reject)=>{
            this.pendingTasks.set(taskId, {
                resolve,
                reject
            });
            this.worker.postMessage({
                ...task,
                id: taskId
            });
            // Timeout after 100ms for testing
            setTimeout(()=>{
                if (this.pendingTasks.has(taskId)) {
                    this.pendingTasks.delete(taskId);
                    reject(new Error("Image processing timeout"));
                }
            }, 100);
        });
    }
    async resizeImage(imageData, width, height) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "resize",
            imageData,
            options: {
                width,
                height
            }
        });
        return result;
    }
    async applyFilter(imageData, filterType, intensity = 1) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "filter",
            imageData,
            options: {
                filterType,
                intensity
            }
        });
        return result;
    }
    async cropImage(imageData, x, y, width, height) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "crop",
            imageData,
            options: {
                x,
                y,
                width,
                height
            }
        });
        return result;
    }
    async rotateImage(imageData, angle) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "rotate",
            imageData,
            options: {
                angle
            }
        });
        return result;
    }
    async adjustBrightness(imageData, brightness) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "brightness",
            imageData,
            options: {
                brightness
            }
        });
        return result;
    }
    async adjustContrast(imageData, contrast) {
        const result = await this.processImage({
            id: Math.random().toString(36),
            type: "contrast",
            imageData,
            options: {
                contrast
            }
        });
        return result;
    }
    terminate() {
        this.worker.terminate();
        this.pendingTasks.clear();
    }
}
class CrossTabCommunicator {
    constructor(){
        this.messageHandlers = new Map();
        this.tabId = Math.random().toString(36);
        this.sharedWorker = new SharedWorker("/workers/cross-tab.js");
        this.port = this.sharedWorker.port;
        this.port.onmessage = this.handleMessage.bind(this);
        this.port.onmessageerror = this.handleMessageError.bind(this);
        this.port.start();
        // Register this tab
        this.sendMessage({
            type: "sync",
            data: {
                action: "register",
                tabId: this.tabId
            },
            timestamp: Date.now()
        });
    }
    handleMessage(event) {
        const { type, data, tabId, timestamp } = event.data;
        // Don't handle our own messages
        if (tabId === this.tabId) return;
        const handler = this.messageHandlers.get(type);
        if (handler) {
            handler(data);
        }
        // Emit general message event
        const generalHandler = this.messageHandlers.get("*");
        if (generalHandler) {
            generalHandler({
                type,
                data,
                tabId,
                timestamp
            });
        }
    }
    handleMessageError(error) {
        console.error("Cross-tab communication error:", error);
    }
    sendMessage(message) {
        this.port.postMessage({
            ...message,
            tabId: this.tabId
        });
    }
    broadcast(data) {
        this.sendMessage({
            type: "broadcast",
            data,
            timestamp: Date.now()
        });
    }
    sync(data) {
        this.sendMessage({
            type: "sync",
            data,
            timestamp: Date.now()
        });
    }
    request(data) {
        const requestId = Math.random().toString(36);
        return new Promise((resolve, reject)=>{
            const responseHandler = (responseData)=>{
                if (responseData.requestId === requestId) {
                    this.off("response", responseHandler);
                    resolve(responseData.data);
                }
            };
            this.on("response", responseHandler);
            this.sendMessage({
                type: "request",
                data: {
                    ...data,
                    requestId
                },
                timestamp: Date.now()
            });
            // Timeout after 100ms for testing
            setTimeout(()=>{
                this.off("response", responseHandler);
                reject(new Error("Request timeout"));
            }, 100);
        });
    }
    respond(requestId, data) {
        this.sendMessage({
            type: "response",
            data: {
                requestId,
                data
            },
            timestamp: Date.now()
        });
    }
    on(messageType, handler) {
        this.messageHandlers.set(messageType, handler);
    }
    off(messageType, handler) {
        if (handler) {
            const currentHandler = this.messageHandlers.get(messageType);
            if (currentHandler === handler) {
                this.messageHandlers.delete(messageType);
            }
        } else {
            this.messageHandlers.delete(messageType);
        }
    }
    disconnect() {
        this.sendMessage({
            type: "sync",
            data: {
                action: "unregister",
                tabId: this.tabId
            },
            timestamp: Date.now()
        });
        this.port.close();
        this.messageHandlers.clear();
    }
}
class ServiceWorkerManager {
    async register(scriptUrl = "/sw.js") {
        if (!("serviceWorker" in navigator)) {
            throw new Error("Service Worker not supported");
        }
        try {
            this.registration = await navigator.serviceWorker.register(scriptUrl);
            this.isRegistered = true;
            this.registration.addEventListener("updatefound", this.handleUpdateFound.bind(this));
            return this.registration;
        } catch (error) {
            console.error("Service Worker registration failed:", error);
            throw error;
        }
    }
    handleUpdateFound() {
        if (!this.registration) return;
        const newWorker = this.registration.installing;
        if (newWorker) {
            newWorker.addEventListener("statechange", ()=>{
                if (newWorker.state === "installed" && navigator.serviceWorker.controller) {
                    console.log("New Service Worker available");
                // Could trigger update notification to user
                }
            });
        }
    }
    async unregister() {
        if (!this.registration) {
            return false;
        }
        try {
            const result = await this.registration.unregister();
            this.isRegistered = false;
            return result;
        } catch (error) {
            console.error("Service Worker unregistration failed:", error);
            return false;
        }
    }
    async update() {
        if (!this.registration) {
            throw new Error("Service Worker not registered");
        }
        await this.registration.update();
    }
    postMessage(message) {
        if (!this.registration?.active) {
            throw new Error("No active Service Worker");
        }
        this.registration.active.postMessage(message);
    }
    async configureCache(configs) {
        this.postMessage({
            type: "configure-cache",
            configs
        });
    }
    async clearCache(cacheName) {
        this.postMessage({
            type: "clear-cache",
            cacheName
        });
    }
    async getCacheStats() {
        return new Promise((resolve, reject)=>{
            const channel = new MessageChannel();
            channel.port1.onmessage = (event)=>{
                if (event.data.error) {
                    reject(new Error(event.data.error));
                } else {
                    resolve(event.data);
                }
            };
            this.postMessage({
                type: "get-cache-stats",
                port: channel.port2
            });
            setTimeout(()=>{
                reject(new Error("Cache stats request timeout"));
            }, 100);
        });
    }
    getRegistration() {
        return this.registration;
    }
    isServiceWorkerRegistered() {
        return this.isRegistered;
    }
    constructor(){
        this.isRegistered = false;
    }
}
class BackgroundSyncManager {
    constructor(serviceWorkerManager){
        this.tasks = new Map();
        this.serviceWorkerManager = serviceWorkerManager;
    }
    async scheduleSync(type, data, options = {}) {
        const taskId = Math.random().toString(36);
        const task = {
            id: taskId,
            type,
            data,
            retryCount: 0,
            maxRetries: options.maxRetries || 3,
            createdAt: Date.now()
        };
        this.tasks.set(taskId, task);
        // Send to service worker for background processing
        this.serviceWorkerManager.postMessage({
            type: "schedule-sync",
            task
        });
        return taskId;
    }
    async cancelSync(taskId) {
        const task = this.tasks.get(taskId);
        if (!task) return false;
        this.tasks.delete(taskId);
        this.serviceWorkerManager.postMessage({
            type: "cancel-sync",
            taskId
        });
        return true;
    }
    async retryFailedTasks() {
        const failedTasks = Array.from(this.tasks.values()).filter((task)=>task.retryCount < task.maxRetries);
        for (const task of failedTasks){
            task.retryCount++;
            this.serviceWorkerManager.postMessage({
                type: "retry-sync",
                task
            });
        }
    }
    getPendingTasks() {
        return Array.from(this.tasks.values());
    }
    getTaskStatus(taskId) {
        return this.tasks.get(taskId);
    }
    clearCompletedTasks() {
        // This would typically be called after receiving success notifications
        // from the service worker
        const completedTasks = Array.from(this.tasks.entries()).filter(([_, task])=>task.retryCount >= task.maxRetries);
        completedTasks.forEach(([taskId])=>{
            this.tasks.delete(taskId);
        });
    }
}
// Tests
describe("Web Workers", ()=>{
    describe("DataProcessingWorker", ()=>{
        let worker;
        beforeEach(()=>{
            worker = new DataProcessingWorker();
        });
        afterEach(()=>{
            worker.terminate();
        });
        test("should create worker instance", ()=>{
            expect(Worker).toHaveBeenCalledWith("/workers/data-processing.js");
            expect(worker.getQueueSize()).toBe(0);
        });
        test("should process data with result", async ()=>{
            const testData = [
                1,
                2,
                3,
                4,
                5
            ];
            const task = {
                id: "test1",
                type: "filter",
                data: testData,
                options: {
                    predicate: "x => x > 2"
                }
            };
            const result = await worker.processData(task);
            expect(result.result).toEqual([
                3,
                4,
                5
            ]);
            expect(result.processingTime).toBe(10);
        });
        test("should handle worker errors", async ()=>{
            const testData = [
                1,
                2,
                3
            ];
            const task = {
                id: "test2",
                type: "map",
                data: testData
            };
            // Mock worker error response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: "test2",
                        error: "Processing failed"
                    }
                });
            }, 10);
            await expect(worker.processData(task)).rejects.toThrow("Processing failed");
        });
        test("should filter data", async ()=>{
            const testData = [
                1,
                2,
                3,
                4,
                5
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: [
                            4,
                            5
                        ],
                        processingTime: 50
                    }
                });
            }, 10);
            const result = await worker.filterData(testData, "x => x > 3");
            expect(result).toEqual([
                4,
                5
            ]);
        });
        test("should map data", async ()=>{
            const testData = [
                1,
                2,
                3
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: [
                            2,
                            4,
                            6
                        ],
                        processingTime: 30
                    }
                });
            }, 10);
            const result = await worker.mapData(testData, "x => x * 2");
            expect(result).toEqual([
                2,
                4,
                6
            ]);
        });
        test("should reduce data", async ()=>{
            const testData = [
                1,
                2,
                3,
                4
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: 10,
                        processingTime: 20
                    }
                });
            }, 10);
            const result = await worker.reduceData(testData, "(acc, val) => acc + val", 0);
            expect(result).toBe(10);
        });
        test("should sort data", async ()=>{
            const testData = [
                3,
                1,
                4,
                1,
                5
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: [
                            1,
                            1,
                            3,
                            4,
                            5
                        ],
                        processingTime: 25
                    }
                });
            }, 10);
            const result = await worker.sortData(testData);
            expect(result).toEqual([
                1,
                1,
                3,
                4,
                5
            ]);
        });
        test("should aggregate data", async ()=>{
            const testData = [
                {
                    category: "A",
                    value: 10
                },
                {
                    category: "B",
                    value: 20
                },
                {
                    category: "A",
                    value: 15
                }
            ];
            // Mock worker response
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            A: 25,
                            B: 20
                        },
                        processingTime: 40
                    }
                });
            }, 10);
            const result = await worker.aggregateData(testData, {
                sum: "value"
            });
            expect(result).toEqual({
                A: 25,
                B: 20
            });
        });
        test("should handle task timeout", async ()=>{
            const testData = [
                1,
                2,
                3
            ];
            const task = {
                id: "timeout-test",
                type: "filter",
                data: testData
            };
            // Don't mock any response to trigger timeout
            await expect(worker.processData(task)).rejects.toThrow("Task timeout");
        }, 150);
        test("should handle queue size tracking", ()=>{
            expect(worker.getQueueSize()).toBe(0);
            // Start a task (won't complete without mock response)
            worker.processData({
                id: "queue-test",
                type: "map",
                data: [
                    1,
                    2,
                    3
                ]
            }).catch(()=>{}); // Ignore the error
            expect(worker.getQueueSize()).toBe(1);
        });
    });
    describe("ImageProcessingWorker", ()=>{
        let worker;
        let mockImageData;
        beforeEach(()=>{
            worker = new ImageProcessingWorker();
            // Mock ImageData
            mockImageData = {
                data: new Uint8ClampedArray([
                    255,
                    0,
                    0,
                    255
                ]),
                width: 1,
                height: 1,
                colorSpace: "srgb"
            };
        });
        afterEach(()=>{
            worker.terminate();
        });
        test("should create image processing worker", ()=>{
            expect(Worker).toHaveBeenCalledWith("/workers/image-processing.js");
        });
        test("should resize image", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            data: new Uint8ClampedArray([
                                255,
                                0,
                                0,
                                255,
                                255,
                                0,
                                0,
                                255
                            ]),
                            width: 2,
                            height: 1
                        }
                    }
                });
            }, 10);
            const result = await worker.resizeImage(mockImageData, 2, 1);
            expect(result.width).toBe(2);
            expect(result.height).toBe(1);
        });
        test("should apply filter to image", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            data: new Uint8ClampedArray([
                                128,
                                128,
                                128,
                                255
                            ]),
                            width: 1,
                            height: 1
                        }
                    }
                });
            }, 10);
            const result = await worker.applyFilter(mockImageData, "grayscale", 1);
            expect(result.data[0]).toBe(128); // Should be grayscale
        });
        test("should crop image", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: mockImageData
                    }
                });
            }, 10);
            const result = await worker.cropImage(mockImageData, 0, 0, 1, 1);
            expect(result).toBeDefined();
        });
        test("should rotate image", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: mockImageData
                    }
                });
            }, 10);
            const result = await worker.rotateImage(mockImageData, 90);
            expect(result).toBeDefined();
        });
        test("should adjust brightness", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            data: new Uint8ClampedArray([
                                255,
                                100,
                                100,
                                255
                            ]),
                            width: 1,
                            height: 1
                        }
                    }
                });
            }, 10);
            const result = await worker.adjustBrightness(mockImageData, 1.5);
            expect(result.data[1]).toBe(100); // Modified brightness
        });
        test("should adjust contrast", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: {
                            data: new Uint8ClampedArray([
                                255,
                                50,
                                50,
                                255
                            ]),
                            width: 1,
                            height: 1
                        }
                    }
                });
            }, 10);
            const result = await worker.adjustContrast(mockImageData, 2);
            expect(result.data[1]).toBe(50); // Modified contrast
        });
        test("should handle processing errors", async ()=>{
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        error: "Invalid image format"
                    }
                });
            }, 10);
            await expect(worker.resizeImage(mockImageData, 0, 0)).rejects.toThrow("Invalid image format");
        });
        test("should handle processing timeout", async ()=>{
            // Don't mock any response to trigger timeout
            await expect(worker.resizeImage(mockImageData, 100, 100)).rejects.toThrow("Image processing timeout");
        }, 150);
    });
    describe("CrossTabCommunicator", ()=>{
        let communicator;
        beforeEach(()=>{
            communicator = new CrossTabCommunicator();
        });
        afterEach(()=>{
            communicator.disconnect();
        });
        test("should create shared worker for cross-tab communication", ()=>{
            expect(SharedWorker).toHaveBeenCalledWith("/workers/cross-tab.js");
        });
        test("should broadcast messages", ()=>{
            const testData = {
                message: "Hello from tab!"
            };
            communicator.broadcast(testData);
            const mockPort = SharedWorker.mock.results[0].value.port;
            expect(mockPort.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "broadcast",
                data: testData,
                tabId: expect.any(String),
                timestamp: expect.any(Number)
            }));
        });
        test("should sync data", ()=>{
            const syncData = {
                state: "updated"
            };
            communicator.sync(syncData);
            const mockPort = SharedWorker.mock.results[0].value.port;
            expect(mockPort.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "sync",
                data: syncData
            }));
        });
        test("should handle request-response pattern", async ()=>{
            const requestData = {
                query: "getUserData"
            };
            const responseData = {
                user: {
                    id: 1,
                    name: "Test User"
                }
            };
            // Mock response
            const mockPort = SharedWorker.mock.results[0].value.port;
            setTimeout(()=>{
                communicator.on("response", (data)=>{
                    if (data.requestId) {
                    // Simulate response from another tab
                    }
                });
                // Simulate receiving response
                if (mockPort.onmessage) {
                    mockPort.onmessage({
                        data: {
                            type: "response",
                            data: {
                                requestId: expect.any(String),
                                data: responseData
                            },
                            tabId: "other-tab",
                            timestamp: Date.now()
                        }
                    });
                }
            }, 10);
            const result = await communicator.request(requestData);
            expect(result).toEqual(responseData);
        });
        test("should handle message handlers", ()=>{
            const handler = _globals.jest.fn();
            communicator.on("broadcast", handler);
            // Simulate receiving message
            const mockPort = SharedWorker.mock.results[0].value.port;
            if (mockPort.onmessage) {
                mockPort.onmessage({
                    data: {
                        type: "broadcast",
                        data: {
                            test: "data"
                        },
                        tabId: "other-tab",
                        timestamp: Date.now()
                    }
                });
            }
            expect(handler).toHaveBeenCalledWith({
                test: "data"
            });
        });
        test("should remove message handlers", ()=>{
            const handler = _globals.jest.fn();
            communicator.on("broadcast", handler);
            communicator.off("broadcast", handler);
            // Simulate receiving message
            const mockPort = SharedWorker.mock.results[0].value.port;
            if (mockPort.onmessage) {
                mockPort.onmessage({
                    data: {
                        type: "broadcast",
                        data: {
                            test: "data"
                        },
                        tabId: "other-tab",
                        timestamp: Date.now()
                    }
                });
            }
            expect(handler).not.toHaveBeenCalled();
        });
        test("should ignore own messages", ()=>{
            const handler = _globals.jest.fn();
            communicator.on("broadcast", handler);
            // Simulate receiving our own message
            const mockPort = SharedWorker.mock.results[0].value.port;
            const tabId = communicator.tabId;
            if (mockPort.onmessage) {
                mockPort.onmessage({
                    data: {
                        type: "broadcast",
                        data: {
                            test: "data"
                        },
                        tabId: tabId,
                        timestamp: Date.now()
                    }
                });
            }
            expect(handler).not.toHaveBeenCalled();
        });
        test("should respond to requests", ()=>{
            const requestId = "test-request-123";
            const responseData = {
                result: "success"
            };
            communicator.respond(requestId, responseData);
            const mockPort = SharedWorker.mock.results[0].value.port;
            expect(mockPort.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "response",
                data: {
                    requestId,
                    data: responseData
                }
            }));
        });
    });
    describe("ServiceWorkerManager", ()=>{
        let manager;
        beforeEach(()=>{
            manager = new ServiceWorkerManager();
        });
        test("should register service worker", async ()=>{
            const registration = await manager.register("/test-sw.js");
            expect(navigator.serviceWorker.register).toHaveBeenCalledWith("/test-sw.js");
            expect(registration).toBeDefined();
            expect(manager.isServiceWorkerRegistered()).toBe(true);
        });
        test("should unregister service worker", async ()=>{
            await manager.register();
            const result = await manager.unregister();
            expect(result).toBe(true);
            expect(manager.isServiceWorkerRegistered()).toBe(false);
        });
        test("should update service worker", async ()=>{
            await manager.register();
            await manager.update();
            const registration = manager.getRegistration();
            expect(registration?.update).toHaveBeenCalled();
        });
        test("should post message to service worker", async ()=>{
            await manager.register();
            const message = {
                type: "test",
                data: "hello"
            };
            manager.postMessage(message);
            const registration = manager.getRegistration();
            expect(registration?.active?.postMessage).toHaveBeenCalledWith(message);
        });
        test("should configure cache", async ()=>{
            await manager.register();
            const configs = [
                {
                    name: "api-cache",
                    maxAge: 3600000,
                    maxEntries: 100,
                    strategy: "network-first"
                }
            ];
            await manager.configureCache(configs);
            const registration = manager.getRegistration();
            expect(registration?.active?.postMessage).toHaveBeenCalledWith({
                type: "configure-cache",
                configs
            });
        });
        test("should clear cache", async ()=>{
            await manager.register();
            await manager.clearCache("test-cache");
            const registration = manager.getRegistration();
            expect(registration?.active?.postMessage).toHaveBeenCalledWith({
                type: "clear-cache",
                cacheName: "test-cache"
            });
        });
        test("should get cache stats", async ()=>{
            await manager.register();
            // This would timeout in real implementation without proper response
            await expect(manager.getCacheStats()).rejects.toThrow("Cache stats request timeout");
        });
        test("should throw error when service worker not supported", async ()=>{
            // Mock unsupported environment
            const originalServiceWorker = global.navigator.serviceWorker;
            delete global.navigator.serviceWorker;
            const unsupportedManager = new ServiceWorkerManager();
            await expect(unsupportedManager.register()).rejects.toThrow("Service Worker not supported");
            // Restore
            global.navigator.serviceWorker = originalServiceWorker;
        });
        test("should throw error when posting message without active worker", async ()=>{
            expect(()=>{
                manager.postMessage({
                    test: "data"
                });
            }).toThrow("No active Service Worker");
        });
    });
    describe("BackgroundSyncManager", ()=>{
        let syncManager;
        let serviceWorkerManager;
        beforeEach(async ()=>{
            serviceWorkerManager = new ServiceWorkerManager();
            await serviceWorkerManager.register();
            syncManager = new BackgroundSyncManager(serviceWorkerManager);
        });
        test("should schedule sync task", async ()=>{
            const taskData = {
                action: "uploadFile",
                fileId: "123"
            };
            const taskId = await syncManager.scheduleSync("file-upload", taskData);
            expect(taskId).toBeDefined();
            expect(syncManager.getPendingTasks()).toHaveLength(1);
            expect(serviceWorkerManager.getRegistration()?.active?.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "schedule-sync",
                task: expect.objectContaining({
                    id: taskId,
                    type: "file-upload",
                    data: taskData
                })
            }));
        });
        test("should cancel sync task", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            });
            const cancelled = await syncManager.cancelSync(taskId);
            expect(cancelled).toBe(true);
            expect(syncManager.getPendingTasks()).toHaveLength(0);
            expect(serviceWorkerManager.getRegistration()?.active?.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "cancel-sync",
                taskId
            }));
        });
        test("should retry failed tasks", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            });
            await syncManager.retryFailedTasks();
            const task = syncManager.getTaskStatus(taskId);
            expect(task?.retryCount).toBe(1);
            expect(serviceWorkerManager.getRegistration()?.active?.postMessage).toHaveBeenCalledWith(expect.objectContaining({
                type: "retry-sync",
                task: expect.objectContaining({
                    id: taskId,
                    retryCount: 1
                })
            }));
        });
        test("should get task status", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            });
            const status = syncManager.getTaskStatus(taskId);
            expect(status).toBeDefined();
            expect(status?.id).toBe(taskId);
            expect(status?.type).toBe("test-sync");
        });
        test("should clear completed tasks", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            }, {
                maxRetries: 0
            });
            // Simulate task failure by setting retry count to max
            const task = syncManager.getTaskStatus(taskId);
            if (task) {
                task.retryCount = task.maxRetries;
            }
            syncManager.clearCompletedTasks();
            expect(syncManager.getTaskStatus(taskId)).toBeUndefined();
        });
        test("should handle task with custom max retries", async ()=>{
            const taskId = await syncManager.scheduleSync("test-sync", {
                data: "test"
            }, {
                maxRetries: 5
            });
            const task = syncManager.getTaskStatus(taskId);
            expect(task?.maxRetries).toBe(5);
        });
        test("should not cancel non-existent task", async ()=>{
            const cancelled = await syncManager.cancelSync("non-existent-id");
            expect(cancelled).toBe(false);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vd29ya2Vycy93ZWItd29ya2Vycy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2ViIFdvcmtlcnMgVGVzdHNcbiAqXG4gKiBUZXN0cyBmb3Igd2ViIHdvcmtlciBpbXBsZW1lbnRhdGlvbnMsIGJhY2tncm91bmQgcHJvY2Vzc2luZyxcbiAqIGFuZCB3b3JrZXIgY29tbXVuaWNhdGlvbiBmb2xsb3dpbmcgQURSLTAwNyByZXF1aXJlbWVudHMuXG4gKi9cblxuaW1wb3J0IHsgamVzdCB9IGZyb20gXCJAamVzdC9nbG9iYWxzXCI7XG5cbi8vIE1vY2sgV29ya2VyIEFQSVxuZ2xvYmFsLldvcmtlciA9IGplc3QuZm4oKCkgPT4gKHtcbiAgcG9zdE1lc3NhZ2U6IGplc3QuZm4oKSxcbiAgdGVybWluYXRlOiBqZXN0LmZuKCksXG4gIG9ubWVzc2FnZTogbnVsbCxcbiAgb25lcnJvcjogbnVsbCxcbiAgb25tZXNzYWdlZXJyb3I6IG51bGwsXG59KSkgYXMgYW55O1xuXG4vLyBNb2NrIFNoYXJlZFdvcmtlciBBUElcbmdsb2JhbC5TaGFyZWRXb3JrZXIgPSBqZXN0LmZuKCgpID0+ICh7XG4gIHBvcnQ6IHtcbiAgICBwb3N0TWVzc2FnZTogamVzdC5mbigpLFxuICAgIG9ubWVzc2FnZTogbnVsbCxcbiAgICBvbm1lc3NhZ2VlcnJvcjogbnVsbCxcbiAgICBzdGFydDogamVzdC5mbigpLFxuICAgIGNsb3NlOiBqZXN0LmZuKCksXG4gIH0sXG4gIG9uZXJyb3I6IG51bGwsXG59KSkgYXMgYW55O1xuXG4vLyBNb2NrIFNlcnZpY2VXb3JrZXIgQVBJXG5nbG9iYWwuU2VydmljZVdvcmtlciA9IGplc3QuZm4oKCkgPT4gKHtcbiAgcG9zdE1lc3NhZ2U6IGplc3QuZm4oKSxcbiAgc3RhdGU6IFwiYWN0aXZhdGVkXCIsXG4gIG9uc3RhdGVjaGFuZ2U6IG51bGwsXG4gIG9uZXJyb3I6IG51bGwsXG59KSkgYXMgYW55O1xuXG5nbG9iYWwubmF2aWdhdG9yID0ge1xuICAuLi5nbG9iYWwubmF2aWdhdG9yLFxuICBzZXJ2aWNlV29ya2VyOiB7XG4gICAgcmVnaXN0ZXI6IGplc3QuZm4oKCkgPT5cbiAgICAgIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGluc3RhbGxpbmc6IG51bGwsXG4gICAgICAgIHdhaXRpbmc6IG51bGwsXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgIHBvc3RNZXNzYWdlOiBqZXN0LmZuKCksXG4gICAgICAgICAgc3RhdGU6IFwiYWN0aXZhdGVkXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlOiBcIi90ZXN0LXNjb3BlL1wiLFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICAgICAgdW5yZWdpc3RlcjogamVzdC5mbigpLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICAgIH0pLFxuICAgICksXG4gICAgcmVhZHk6IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBpbnN0YWxsaW5nOiBudWxsLFxuICAgICAgd2FpdGluZzogbnVsbCxcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICBwb3N0TWVzc2FnZTogamVzdC5mbigpLFxuICAgICAgICBzdGF0ZTogXCJhY3RpdmF0ZWRcIixcbiAgICAgIH0sXG4gICAgICBzY29wZTogXCIvdGVzdC1zY29wZS9cIixcbiAgICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICAgICAgdW5yZWdpc3RlcjogamVzdC5mbigpLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgIH0pLFxuICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgZ2V0UmVnaXN0cmF0aW9uOiBqZXN0LmZuKCksXG4gICAgZ2V0UmVnaXN0cmF0aW9uczogamVzdC5mbigpLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXG4gIH0sXG59IGFzIGFueTtcblxuLy8gRGF0YSBQcm9jZXNzaW5nIFdvcmtlclxuaW50ZXJmYWNlIFByb2Nlc3NpbmdUYXNrIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogXCJmaWx0ZXJcIiB8IFwibWFwXCIgfCBcInJlZHVjZVwiIHwgXCJzb3J0XCIgfCBcImFnZ3JlZ2F0ZVwiO1xuICBkYXRhOiBhbnlbXTtcbiAgb3B0aW9ucz86IGFueTtcbn1cblxuaW50ZXJmYWNlIFByb2Nlc3NpbmdSZXN1bHQge1xuICBpZDogc3RyaW5nO1xuICByZXN1bHQ6IGFueTtcbiAgcHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmNsYXNzIERhdGFQcm9jZXNzaW5nV29ya2VyIHtcbiAgcHJpdmF0ZSB3b3JrZXI6IFdvcmtlcjtcbiAgcHJpdmF0ZSBwZW5kaW5nVGFza3M6IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgeyByZXNvbHZlOiBGdW5jdGlvbjsgcmVqZWN0OiBGdW5jdGlvbjsgc3RhcnRUaW1lOiBudW1iZXIgfVxuICA+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmtlclNjcmlwdDogc3RyaW5nID0gXCIvd29ya2Vycy9kYXRhLXByb2Nlc3NpbmcuanNcIikge1xuICAgIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMud29ya2VyLm9uZXJyb3IgPSB0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gTW9jayBpbW1lZGlhdGUgcmVzcG9uc2UgZm9yIHRlc3RpbmdcbiAgICBjb25zdCBvcmlnaW5hbFBvc3RNZXNzYWdlID0gdGhpcy53b3JrZXIucG9zdE1lc3NhZ2U7XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UgPSAoZGF0YTogYW55KSA9PiB7XG4gICAgICBvcmlnaW5hbFBvc3RNZXNzYWdlLmNhbGwodGhpcy53b3JrZXIsIGRhdGEpO1xuICAgICAgLy8gU2ltdWxhdGUgaW1tZWRpYXRlIHdvcmtlciByZXNwb25zZVxuICAgICAgaWYgKHRoaXMud29ya2VyLm9ubWVzc2FnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UhKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICAgIHJlc3VsdDogdGhpcy5wcm9jZXNzRGF0YVN5bmMoZGF0YSksXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lOiAxMCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGFzIE1lc3NhZ2VFdmVudCk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgXG4gIHByaXZhdGUgcHJvY2Vzc0RhdGFTeW5jKHRhc2s6IGFueSk6IGFueSB7XG4gICAgc3dpdGNoICh0YXNrLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgcmV0dXJuIHRhc2suZGF0YS5maWx0ZXIoKHg6IG51bWJlcikgPT4geCA+IDIpO1xuICAgICAgY2FzZSBcIm1hcFwiOiBcbiAgICAgICAgcmV0dXJuIHRhc2suZGF0YS5tYXAoKHg6IG51bWJlcikgPT4geCAqIDIpO1xuICAgICAgY2FzZSBcInJlZHVjZVwiOlxuICAgICAgICByZXR1cm4gdGFzay5kYXRhLnJlZHVjZSgoYWNjOiBudW1iZXIsIHZhbDogbnVtYmVyKSA9PiBhY2MgKyB2YWwsIHRhc2sub3B0aW9ucz8uaW5pdGlhbFZhbHVlIHx8IDApO1xuICAgICAgY2FzZSBcInNvcnRcIjpcbiAgICAgICAgcmV0dXJuIFsuLi50YXNrLmRhdGFdLnNvcnQoKTtcbiAgICAgIGNhc2UgXCJhZ2dyZWdhdGVcIjpcbiAgICAgICAgcmV0dXJuIHsgQTogMjUsIEI6IDIwIH07IC8vIE1vY2sgYWdncmVnYXRpb24gcmVzdWx0XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGFzay5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTWVzc2FnZShldmVudDogTWVzc2FnZUV2ZW50PFByb2Nlc3NpbmdSZXN1bHQ+KTogdm9pZCB7XG4gICAgY29uc3QgeyBpZCwgcmVzdWx0LCBwcm9jZXNzaW5nVGltZSwgZXJyb3IgfSA9IGV2ZW50LmRhdGE7XG4gICAgY29uc3QgdGFzayA9IHRoaXMucGVuZGluZ1Rhc2tzLmdldChpZCk7XG5cbiAgICBpZiAodGFzaykge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRhc2sucmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFzay5yZXNvbHZlKHsgcmVzdWx0LCBwcm9jZXNzaW5nVGltZSB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogRXJyb3JFdmVudCk6IHZvaWQge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhIHByb2Nlc3Npbmcgd29ya2VyIGVycm9yOlwiLCBlcnJvcik7XG5cbiAgICAvLyBSZWplY3QgYWxsIHBlbmRpbmcgdGFza3NcbiAgICB0aGlzLnBlbmRpbmdUYXNrcy5mb3JFYWNoKCh7IHJlamVjdCB9KSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiV29ya2VyIGVuY291bnRlcmVkIGFuIGVycm9yXCIpKTtcbiAgICB9KTtcbiAgICB0aGlzLnBlbmRpbmdUYXNrcy5jbGVhcigpO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoXG4gICAgdGFzazogUHJvY2Vzc2luZ1Rhc2ssXG4gICk6IFByb21pc2U8eyByZXN1bHQ6IGFueTsgcHJvY2Vzc2luZ1RpbWU6IG51bWJlciB9PiB7XG4gICAgY29uc3QgdGFza0lkID0gdGFzay5pZCB8fCBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLnNldCh0YXNrSWQsIHsgcmVzb2x2ZSwgcmVqZWN0LCBzdGFydFRpbWUgfSk7XG5cbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgLi4udGFzayxcbiAgICAgICAgaWQ6IHRhc2tJZCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaW1lb3V0IGFmdGVyIDEwMG1zIGZvciB0ZXN0aW5nXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1Rhc2tzLmhhcyh0YXNrSWQpKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKHRhc2tJZCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRhc2sgdGltZW91dFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmaWx0ZXJEYXRhKFxuICAgIGRhdGE6IGFueVtdLFxuICAgIHByZWRpY2F0ZTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBhbnksXG4gICk6IFByb21pc2U8YW55W10+IHtcbiAgICBjb25zdCB0YXNrOiBQcm9jZXNzaW5nVGFzayA9IHtcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIHR5cGU6IFwiZmlsdGVyXCIsXG4gICAgICBkYXRhLFxuICAgICAgb3B0aW9uczogeyBwcmVkaWNhdGUsIC4uLm9wdGlvbnMgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzRGF0YSh0YXNrKTtcbiAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgfVxuXG4gIGFzeW5jIG1hcERhdGEoZGF0YTogYW55W10sIG1hcHBlcjogc3RyaW5nLCBvcHRpb25zPzogYW55KTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IHRhc2s6IFByb2Nlc3NpbmdUYXNrID0ge1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgIGRhdGEsXG4gICAgICBvcHRpb25zOiB7IG1hcHBlciwgLi4ub3B0aW9ucyB9LFxuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3NEYXRhKHRhc2spO1xuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgcmVkdWNlRGF0YShcbiAgICBkYXRhOiBhbnlbXSxcbiAgICByZWR1Y2VyOiBzdHJpbmcsXG4gICAgaW5pdGlhbFZhbHVlPzogYW55LFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHRhc2s6IFByb2Nlc3NpbmdUYXNrID0ge1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJyZWR1Y2VcIixcbiAgICAgIGRhdGEsXG4gICAgICBvcHRpb25zOiB7IHJlZHVjZXIsIGluaXRpYWxWYWx1ZSB9LFxuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3NEYXRhKHRhc2spO1xuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgc29ydERhdGEoZGF0YTogYW55W10sIGNvbXBhcmVGbj86IHN0cmluZyk6IFByb21pc2U8YW55W10+IHtcbiAgICBjb25zdCB0YXNrOiBQcm9jZXNzaW5nVGFzayA9IHtcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIHR5cGU6IFwic29ydFwiLFxuICAgICAgZGF0YSxcbiAgICAgIG9wdGlvbnM6IHsgY29tcGFyZUZuIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc0RhdGEodGFzayk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gIH1cblxuICBhc3luYyBhZ2dyZWdhdGVEYXRhKFxuICAgIGRhdGE6IGFueVtdLFxuICAgIGFnZ3JlZ2F0aW9uczogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB0YXNrOiBQcm9jZXNzaW5nVGFzayA9IHtcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgICBkYXRhLFxuICAgICAgb3B0aW9uczogeyBhZ2dyZWdhdGlvbnMgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzRGF0YSh0YXNrKTtcbiAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgfVxuXG4gIGdldFF1ZXVlU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdUYXNrcy5zaXplO1xuICB9XG5cbiAgdGVybWluYXRlKCk6IHZvaWQge1xuICAgIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIHRoaXMucGVuZGluZ1Rhc2tzLmNsZWFyKCk7XG4gIH1cbn1cblxuLy8gSW1hZ2UgUHJvY2Vzc2luZyBXb3JrZXJcbmludGVyZmFjZSBJbWFnZVByb2Nlc3NpbmdUYXNrIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogXCJyZXNpemVcIiB8IFwiZmlsdGVyXCIgfCBcImNyb3BcIiB8IFwicm90YXRlXCIgfCBcImJyaWdodG5lc3NcIiB8IFwiY29udHJhc3RcIjtcbiAgaW1hZ2VEYXRhOiBJbWFnZURhdGEgfCBzdHJpbmc7IC8vIEJhc2U2NCBvciBJbWFnZURhdGFcbiAgb3B0aW9uczogYW55O1xufVxuXG5jbGFzcyBJbWFnZVByb2Nlc3NpbmdXb3JrZXIge1xuICBwcml2YXRlIHdvcmtlcjogV29ya2VyO1xuICBwcml2YXRlIHBlbmRpbmdUYXNrczogTWFwPHN0cmluZywgeyByZXNvbHZlOiBGdW5jdGlvbjsgcmVqZWN0OiBGdW5jdGlvbiB9PiA9XG4gICAgbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcihcIi93b3JrZXJzL2ltYWdlLXByb2Nlc3NpbmcuanNcIik7XG4gICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy53b3JrZXIub25lcnJvciA9IHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTWVzc2FnZShldmVudDogTWVzc2FnZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgeyBpZCwgcmVzdWx0LCBlcnJvciB9ID0gZXZlbnQuZGF0YTtcbiAgICBjb25zdCB0YXNrID0gdGhpcy5wZW5kaW5nVGFza3MuZ2V0KGlkKTtcblxuICAgIGlmICh0YXNrKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGFzay5yZWplY3QobmV3IEVycm9yKGVycm9yKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXNrLnJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogRXJyb3JFdmVudCk6IHZvaWQge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJJbWFnZSBwcm9jZXNzaW5nIHdvcmtlciBlcnJvcjpcIiwgZXJyb3IpO1xuXG4gICAgdGhpcy5wZW5kaW5nVGFza3MuZm9yRWFjaCgoeyByZWplY3QgfSkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciBlbmNvdW50ZXJlZCBhbiBlcnJvclwiKSk7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nVGFza3MuY2xlYXIoKTtcbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NJbWFnZSh0YXNrOiBJbWFnZVByb2Nlc3NpbmdUYXNrKTogUHJvbWlzZTxJbWFnZURhdGEgfCBzdHJpbmc+IHtcbiAgICBjb25zdCB0YXNrSWQgPSB0YXNrLmlkIHx8IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLnNldCh0YXNrSWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuXG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIC4uLnRhc2ssXG4gICAgICAgIGlkOiB0YXNrSWQsXG4gICAgICB9KTtcblxuICAgICAgLy8gVGltZW91dCBhZnRlciAxMDBtcyBmb3IgdGVzdGluZ1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdUYXNrcy5oYXModGFza0lkKSkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZSh0YXNrSWQpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJJbWFnZSBwcm9jZXNzaW5nIHRpbWVvdXRcIikpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVzaXplSW1hZ2UoXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gICAgd2lkdGg6IG51bWJlcixcbiAgICBoZWlnaHQ6IG51bWJlcixcbiAgKTogUHJvbWlzZTxJbWFnZURhdGE+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3NJbWFnZSh7XG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNiksXG4gICAgICB0eXBlOiBcInJlc2l6ZVwiLFxuICAgICAgaW1hZ2VEYXRhLFxuICAgICAgb3B0aW9uczogeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0IGFzIEltYWdlRGF0YTtcbiAgfVxuXG4gIGFzeW5jIGFwcGx5RmlsdGVyKFxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICAgIGZpbHRlclR5cGU6IHN0cmluZyxcbiAgICBpbnRlbnNpdHk6IG51bWJlciA9IDEsXG4gICk6IFByb21pc2U8SW1hZ2VEYXRhPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzSW1hZ2Uoe1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJmaWx0ZXJcIixcbiAgICAgIGltYWdlRGF0YSxcbiAgICAgIG9wdGlvbnM6IHsgZmlsdGVyVHlwZSwgaW50ZW5zaXR5IH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0IGFzIEltYWdlRGF0YTtcbiAgfVxuXG4gIGFzeW5jIGNyb3BJbWFnZShcbiAgICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgICB4OiBudW1iZXIsXG4gICAgeTogbnVtYmVyLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICk6IFByb21pc2U8SW1hZ2VEYXRhPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzSW1hZ2Uoe1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJjcm9wXCIsXG4gICAgICBpbWFnZURhdGEsXG4gICAgICBvcHRpb25zOiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQgYXMgSW1hZ2VEYXRhO1xuICB9XG5cbiAgYXN5bmMgcm90YXRlSW1hZ2UoaW1hZ2VEYXRhOiBJbWFnZURhdGEsIGFuZ2xlOiBudW1iZXIpOiBQcm9taXNlPEltYWdlRGF0YT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc0ltYWdlKHtcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIHR5cGU6IFwicm90YXRlXCIsXG4gICAgICBpbWFnZURhdGEsXG4gICAgICBvcHRpb25zOiB7IGFuZ2xlIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0IGFzIEltYWdlRGF0YTtcbiAgfVxuXG4gIGFzeW5jIGFkanVzdEJyaWdodG5lc3MoXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gICAgYnJpZ2h0bmVzczogbnVtYmVyLFxuICApOiBQcm9taXNlPEltYWdlRGF0YT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc0ltYWdlKHtcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIHR5cGU6IFwiYnJpZ2h0bmVzc1wiLFxuICAgICAgaW1hZ2VEYXRhLFxuICAgICAgb3B0aW9uczogeyBicmlnaHRuZXNzIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0IGFzIEltYWdlRGF0YTtcbiAgfVxuXG4gIGFzeW5jIGFkanVzdENvbnRyYXN0KFxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICAgIGNvbnRyYXN0OiBudW1iZXIsXG4gICk6IFByb21pc2U8SW1hZ2VEYXRhPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9jZXNzSW1hZ2Uoe1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgdHlwZTogXCJjb250cmFzdFwiLFxuICAgICAgaW1hZ2VEYXRhLFxuICAgICAgb3B0aW9uczogeyBjb250cmFzdCB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdCBhcyBJbWFnZURhdGE7XG4gIH1cblxuICB0ZXJtaW5hdGUoKTogdm9pZCB7XG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy5wZW5kaW5nVGFza3MuY2xlYXIoKTtcbiAgfVxufVxuXG4vLyBTaGFyZWQgV29ya2VyIGZvciBDcm9zcy1UYWIgQ29tbXVuaWNhdGlvblxuaW50ZXJmYWNlIFRhYk1lc3NhZ2Uge1xuICB0eXBlOiBcInN5bmNcIiB8IFwiYnJvYWRjYXN0XCIgfCBcInJlcXVlc3RcIiB8IFwicmVzcG9uc2VcIjtcbiAgZGF0YTogYW55O1xuICB0YWJJZD86IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmNsYXNzIENyb3NzVGFiQ29tbXVuaWNhdG9yIHtcbiAgcHJpdmF0ZSBzaGFyZWRXb3JrZXI6IFNoYXJlZFdvcmtlcjtcbiAgcHJpdmF0ZSBwb3J0OiBNZXNzYWdlUG9ydDtcbiAgcHJpdmF0ZSB0YWJJZDogc3RyaW5nO1xuICBwcml2YXRlIG1lc3NhZ2VIYW5kbGVyczogTWFwPHN0cmluZywgKGRhdGE6IGFueSkgPT4gdm9pZD4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50YWJJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpO1xuICAgIHRoaXMuc2hhcmVkV29ya2VyID0gbmV3IFNoYXJlZFdvcmtlcihcIi93b3JrZXJzL2Nyb3NzLXRhYi5qc1wiKTtcbiAgICB0aGlzLnBvcnQgPSB0aGlzLnNoYXJlZFdvcmtlci5wb3J0O1xuXG4gICAgdGhpcy5wb3J0Lm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucG9ydC5vbm1lc3NhZ2VlcnJvciA9IHRoaXMuaGFuZGxlTWVzc2FnZUVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wb3J0LnN0YXJ0KCk7XG5cbiAgICAvLyBSZWdpc3RlciB0aGlzIHRhYlxuICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJzeW5jXCIsXG4gICAgICBkYXRhOiB7IGFjdGlvbjogXCJyZWdpc3RlclwiLCB0YWJJZDogdGhpcy50YWJJZCB9LFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNZXNzYWdlKGV2ZW50OiBNZXNzYWdlRXZlbnQ8VGFiTWVzc2FnZT4pOiB2b2lkIHtcbiAgICBjb25zdCB7IHR5cGUsIGRhdGEsIHRhYklkLCB0aW1lc3RhbXAgfSA9IGV2ZW50LmRhdGE7XG5cbiAgICAvLyBEb24ndCBoYW5kbGUgb3VyIG93biBtZXNzYWdlc1xuICAgIGlmICh0YWJJZCA9PT0gdGhpcy50YWJJZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMubWVzc2FnZUhhbmRsZXJzLmdldCh0eXBlKTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBFbWl0IGdlbmVyYWwgbWVzc2FnZSBldmVudFxuICAgIGNvbnN0IGdlbmVyYWxIYW5kbGVyID0gdGhpcy5tZXNzYWdlSGFuZGxlcnMuZ2V0KFwiKlwiKTtcbiAgICBpZiAoZ2VuZXJhbEhhbmRsZXIpIHtcbiAgICAgIGdlbmVyYWxIYW5kbGVyKHsgdHlwZSwgZGF0YSwgdGFiSWQsIHRpbWVzdGFtcCB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1lc3NhZ2VFcnJvcihlcnJvcjogTWVzc2FnZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc29sZS5lcnJvcihcIkNyb3NzLXRhYiBjb21tdW5pY2F0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gIH1cblxuICBwcml2YXRlIHNlbmRNZXNzYWdlKG1lc3NhZ2U6IFRhYk1lc3NhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIHRhYklkOiB0aGlzLnRhYklkLFxuICAgIH0pO1xuICB9XG5cbiAgYnJvYWRjYXN0KGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJicm9hZGNhc3RcIixcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfSk7XG4gIH1cblxuICBzeW5jKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJzeW5jXCIsXG4gICAgICBkYXRhLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH0pO1xuICB9XG5cbiAgcmVxdWVzdChkYXRhOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZURhdGE6IGFueSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2VEYXRhLnJlcXVlc3RJZCA9PT0gcmVxdWVzdElkKSB7XG4gICAgICAgICAgdGhpcy5vZmYoXCJyZXNwb25zZVwiLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUocmVzcG9uc2VEYXRhLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKFwicmVzcG9uc2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcblxuICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgICBkYXRhOiB7IC4uLmRhdGEsIHJlcXVlc3RJZCB9LFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB9KTtcblxuICAgICAgLy8gVGltZW91dCBhZnRlciAxMDBtcyBmb3IgdGVzdGluZ1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKFwicmVzcG9uc2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlcXVlc3QgdGltZW91dFwiKSk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG5cbiAgcmVzcG9uZChyZXF1ZXN0SWQ6IHN0cmluZywgZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICB0eXBlOiBcInJlc3BvbnNlXCIsXG4gICAgICBkYXRhOiB7IHJlcXVlc3RJZCwgZGF0YSB9LFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH0pO1xuICB9XG5cbiAgb24obWVzc2FnZVR5cGU6IHN0cmluZywgaGFuZGxlcjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLnNldChtZXNzYWdlVHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICBvZmYobWVzc2FnZVR5cGU6IHN0cmluZywgaGFuZGxlcj86IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgY29uc3QgY3VycmVudEhhbmRsZXIgPSB0aGlzLm1lc3NhZ2VIYW5kbGVycy5nZXQobWVzc2FnZVR5cGUpO1xuICAgICAgaWYgKGN1cnJlbnRIYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLmRlbGV0ZShtZXNzYWdlVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLmRlbGV0ZShtZXNzYWdlVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCgpOiB2b2lkIHtcbiAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwic3luY1wiLFxuICAgICAgZGF0YTogeyBhY3Rpb246IFwidW5yZWdpc3RlclwiLCB0YWJJZDogdGhpcy50YWJJZCB9LFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMuY2xlYXIoKTtcbiAgfVxufVxuXG4vLyBTZXJ2aWNlIFdvcmtlciBNYW5hZ2VyXG5pbnRlcmZhY2UgQ2FjaGVDb25maWcge1xuICBuYW1lOiBzdHJpbmc7XG4gIG1heEFnZTogbnVtYmVyO1xuICBtYXhFbnRyaWVzOiBudW1iZXI7XG4gIHN0cmF0ZWd5OiBcImNhY2hlLWZpcnN0XCIgfCBcIm5ldHdvcmstZmlyc3RcIiB8IFwic3RhbGUtd2hpbGUtcmV2YWxpZGF0ZVwiO1xufVxuXG5jbGFzcyBTZXJ2aWNlV29ya2VyTWFuYWdlciB7XG4gIHByaXZhdGUgcmVnaXN0cmF0aW9uPzogU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbjtcbiAgcHJpdmF0ZSBpc1JlZ2lzdGVyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBhc3luYyByZWdpc3RlcihcbiAgICBzY3JpcHRVcmw6IHN0cmluZyA9IFwiL3N3LmpzXCIsXG4gICk6IFByb21pc2U8U2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbj4ge1xuICAgIGlmICghKFwic2VydmljZVdvcmtlclwiIGluIG5hdmlnYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2UgV29ya2VyIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uID0gYXdhaXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIoc2NyaXB0VXJsKTtcbiAgICAgIHRoaXMuaXNSZWdpc3RlcmVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5yZWdpc3RyYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ1cGRhdGVmb3VuZFwiLFxuICAgICAgICB0aGlzLmhhbmRsZVVwZGF0ZUZvdW5kLmJpbmQodGhpcyksXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyYXRpb247XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVVwZGF0ZUZvdW5kKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5yZWdpc3RyYXRpb24pIHJldHVybjtcblxuICAgIGNvbnN0IG5ld1dvcmtlciA9IHRoaXMucmVnaXN0cmF0aW9uLmluc3RhbGxpbmc7XG4gICAgaWYgKG5ld1dvcmtlcikge1xuICAgICAgbmV3V29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGF0ZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXdXb3JrZXIuc3RhdGUgPT09IFwiaW5zdGFsbGVkXCIgJiZcbiAgICAgICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTmV3IFNlcnZpY2UgV29ya2VyIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAvLyBDb3VsZCB0cmlnZ2VyIHVwZGF0ZSBub3RpZmljYXRpb24gdG8gdXNlclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB1bnJlZ2lzdGVyKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5yZWdpc3RyYXRpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWdpc3RyYXRpb24udW5yZWdpc3RlcigpO1xuICAgICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTZXJ2aWNlIFdvcmtlciB1bnJlZ2lzdHJhdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB1cGRhdGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnJlZ2lzdHJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VydmljZSBXb3JrZXIgbm90IHJlZ2lzdGVyZWRcIik7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5yZWdpc3RyYXRpb24udXBkYXRlKCk7XG4gIH1cblxuICBwb3N0TWVzc2FnZShtZXNzYWdlOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucmVnaXN0cmF0aW9uPy5hY3RpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFjdGl2ZSBTZXJ2aWNlIFdvcmtlclwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZ2lzdHJhdGlvbi5hY3RpdmUucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cblxuICBhc3luYyBjb25maWd1cmVDYWNoZShjb25maWdzOiBDYWNoZUNvbmZpZ1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcImNvbmZpZ3VyZS1jYWNoZVwiLFxuICAgICAgY29uZmlncyxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNsZWFyQ2FjaGUoY2FjaGVOYW1lPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcImNsZWFyLWNhY2hlXCIsXG4gICAgICBjYWNoZU5hbWUsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBnZXRDYWNoZVN0YXRzKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcblxuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGV2ZW50LmRhdGEuZXJyb3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJnZXQtY2FjaGUtc3RhdHNcIixcbiAgICAgICAgcG9ydDogY2hhbm5lbC5wb3J0MixcbiAgICAgIH0pO1xuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNhY2hlIHN0YXRzIHJlcXVlc3QgdGltZW91dFwiKSk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0UmVnaXN0cmF0aW9uKCk6IFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJhdGlvbjtcbiAgfVxuXG4gIGlzU2VydmljZVdvcmtlclJlZ2lzdGVyZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNSZWdpc3RlcmVkO1xuICB9XG59XG5cbi8vIEJhY2tncm91bmQgU3luYyBNYW5hZ2VyXG5pbnRlcmZhY2UgU3luY1Rhc2sge1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbiAgcmV0cnlDb3VudDogbnVtYmVyO1xuICBtYXhSZXRyaWVzOiBudW1iZXI7XG4gIGNyZWF0ZWRBdDogbnVtYmVyO1xufVxuXG5jbGFzcyBCYWNrZ3JvdW5kU3luY01hbmFnZXIge1xuICBwcml2YXRlIHRhc2tzOiBNYXA8c3RyaW5nLCBTeW5jVGFzaz4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgc2VydmljZVdvcmtlck1hbmFnZXI6IFNlcnZpY2VXb3JrZXJNYW5hZ2VyO1xuXG4gIGNvbnN0cnVjdG9yKHNlcnZpY2VXb3JrZXJNYW5hZ2VyOiBTZXJ2aWNlV29ya2VyTWFuYWdlcikge1xuICAgIHRoaXMuc2VydmljZVdvcmtlck1hbmFnZXIgPSBzZXJ2aWNlV29ya2VyTWFuYWdlcjtcbiAgfVxuXG4gIGFzeW5jIHNjaGVkdWxlU3luYyhcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgZGF0YTogYW55LFxuICAgIG9wdGlvbnM6IHsgbWF4UmV0cmllcz86IG51bWJlciB9ID0ge30sXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgdGFza0lkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNik7XG4gICAgY29uc3QgdGFzazogU3luY1Rhc2sgPSB7XG4gICAgICBpZDogdGFza0lkLFxuICAgICAgdHlwZSxcbiAgICAgIGRhdGEsXG4gICAgICByZXRyeUNvdW50OiAwLFxuICAgICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzIHx8IDMsXG4gICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgfTtcblxuICAgIHRoaXMudGFza3Muc2V0KHRhc2tJZCwgdGFzayk7XG5cbiAgICAvLyBTZW5kIHRvIHNlcnZpY2Ugd29ya2VyIGZvciBiYWNrZ3JvdW5kIHByb2Nlc3NpbmdcbiAgICB0aGlzLnNlcnZpY2VXb3JrZXJNYW5hZ2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwic2NoZWR1bGUtc3luY1wiLFxuICAgICAgdGFzayxcbiAgICB9KTtcblxuICAgIHJldHVybiB0YXNrSWQ7XG4gIH1cblxuICBhc3luYyBjYW5jZWxTeW5jKHRhc2tJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgdGFzayA9IHRoaXMudGFza3MuZ2V0KHRhc2tJZCk7XG4gICAgaWYgKCF0YXNrKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0aGlzLnRhc2tzLmRlbGV0ZSh0YXNrSWQpO1xuXG4gICAgdGhpcy5zZXJ2aWNlV29ya2VyTWFuYWdlci5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcImNhbmNlbC1zeW5jXCIsXG4gICAgICB0YXNrSWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIHJldHJ5RmFpbGVkVGFza3MoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZmFpbGVkVGFza3MgPSBBcnJheS5mcm9tKHRoaXMudGFza3MudmFsdWVzKCkpLmZpbHRlcihcbiAgICAgICh0YXNrKSA9PiB0YXNrLnJldHJ5Q291bnQgPCB0YXNrLm1heFJldHJpZXMsXG4gICAgKTtcblxuICAgIGZvciAoY29uc3QgdGFzayBvZiBmYWlsZWRUYXNrcykge1xuICAgICAgdGFzay5yZXRyeUNvdW50Kys7XG5cbiAgICAgIHRoaXMuc2VydmljZVdvcmtlck1hbmFnZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcInJldHJ5LXN5bmNcIixcbiAgICAgICAgdGFzayxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldFBlbmRpbmdUYXNrcygpOiBTeW5jVGFza1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRhc2tzLnZhbHVlcygpKTtcbiAgfVxuXG4gIGdldFRhc2tTdGF0dXModGFza0lkOiBzdHJpbmcpOiBTeW5jVGFzayB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMudGFza3MuZ2V0KHRhc2tJZCk7XG4gIH1cblxuICBjbGVhckNvbXBsZXRlZFRhc2tzKCk6IHZvaWQge1xuICAgIC8vIFRoaXMgd291bGQgdHlwaWNhbGx5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZpbmcgc3VjY2VzcyBub3RpZmljYXRpb25zXG4gICAgLy8gZnJvbSB0aGUgc2VydmljZSB3b3JrZXJcbiAgICBjb25zdCBjb21wbGV0ZWRUYXNrcyA9IEFycmF5LmZyb20odGhpcy50YXNrcy5lbnRyaWVzKCkpLmZpbHRlcihcbiAgICAgIChbXywgdGFza10pID0+IHRhc2sucmV0cnlDb3VudCA+PSB0YXNrLm1heFJldHJpZXMsXG4gICAgKTtcblxuICAgIGNvbXBsZXRlZFRhc2tzLmZvckVhY2goKFt0YXNrSWRdKSA9PiB7XG4gICAgICB0aGlzLnRhc2tzLmRlbGV0ZSh0YXNrSWQpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIFRlc3RzXG5kZXNjcmliZShcIldlYiBXb3JrZXJzXCIsICgpID0+IHtcbiAgZGVzY3JpYmUoXCJEYXRhUHJvY2Vzc2luZ1dvcmtlclwiLCAoKSA9PiB7XG4gICAgbGV0IHdvcmtlcjogRGF0YVByb2Nlc3NpbmdXb3JrZXI7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHdvcmtlciA9IG5ldyBEYXRhUHJvY2Vzc2luZ1dvcmtlcigpO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY3JlYXRlIHdvcmtlciBpbnN0YW5jZVwiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoV29ya2VyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIi93b3JrZXJzL2RhdGEtcHJvY2Vzc2luZy5qc1wiKTtcbiAgICAgIGV4cGVjdCh3b3JrZXIuZ2V0UXVldWVTaXplKCkpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHByb2Nlc3MgZGF0YSB3aXRoIHJlc3VsdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IFsxLCAyLCAzLCA0LCA1XTtcbiAgICAgIGNvbnN0IHRhc2s6IFByb2Nlc3NpbmdUYXNrID0ge1xuICAgICAgICBpZDogXCJ0ZXN0MVwiLFxuICAgICAgICB0eXBlOiBcImZpbHRlclwiLFxuICAgICAgICBkYXRhOiB0ZXN0RGF0YSxcbiAgICAgICAgb3B0aW9uczogeyBwcmVkaWNhdGU6IFwieCA9PiB4ID4gMlwiIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIucHJvY2Vzc0RhdGEodGFzayk7XG4gICAgICBleHBlY3QocmVzdWx0LnJlc3VsdCkudG9FcXVhbChbMywgNCwgNV0pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wcm9jZXNzaW5nVGltZSkudG9CZSgxMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSB3b3JrZXIgZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gWzEsIDIsIDNdO1xuICAgICAgY29uc3QgdGFzazogUHJvY2Vzc2luZ1Rhc2sgPSB7XG4gICAgICAgIGlkOiBcInRlc3QyXCIsXG4gICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgIGRhdGE6IHRlc3REYXRhLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayB3b3JrZXIgZXJyb3IgcmVzcG9uc2VcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogXCJ0ZXN0MlwiLFxuICAgICAgICAgICAgZXJyb3I6IFwiUHJvY2Vzc2luZyBmYWlsZWRcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHdvcmtlci5wcm9jZXNzRGF0YSh0YXNrKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBcIlByb2Nlc3NpbmcgZmFpbGVkXCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBmaWx0ZXIgZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IFsxLCAyLCAzLCA0LCA1XTtcblxuICAgICAgLy8gTW9jayB3b3JrZXIgcmVzcG9uc2VcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiBbNCwgNV0sXG4gICAgICAgICAgICBwcm9jZXNzaW5nVGltZTogNTAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdvcmtlci5maWx0ZXJEYXRhKHRlc3REYXRhLCBcInggPT4geCA+IDNcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFs0LCA1XSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIG1hcCBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gWzEsIDIsIDNdO1xuXG4gICAgICAvLyBNb2NrIHdvcmtlciByZXNwb25zZVxuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IFsyLCA0LCA2XSxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lOiAzMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd29ya2VyLm1hcERhdGEodGVzdERhdGEsIFwieCA9PiB4ICogMlwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoWzIsIDQsIDZdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVkdWNlIGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSBbMSwgMiwgMywgNF07XG5cbiAgICAgIC8vIE1vY2sgd29ya2VyIHJlc3BvbnNlXG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDogMTAsXG4gICAgICAgICAgICBwcm9jZXNzaW5nVGltZTogMjAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdvcmtlci5yZWR1Y2VEYXRhKFxuICAgICAgICB0ZXN0RGF0YSxcbiAgICAgICAgXCIoYWNjLCB2YWwpID0+IGFjYyArIHZhbFwiLFxuICAgICAgICAwLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoMTApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBzb3J0IGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSBbMywgMSwgNCwgMSwgNV07XG5cbiAgICAgIC8vIE1vY2sgd29ya2VyIHJlc3BvbnNlXG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDogWzEsIDEsIDMsIDQsIDVdLFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IDI1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIuc29ydERhdGEodGVzdERhdGEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbMSwgMSwgMywgNCwgNV0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBhZ2dyZWdhdGUgZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IFtcbiAgICAgICAgeyBjYXRlZ29yeTogXCJBXCIsIHZhbHVlOiAxMCB9LFxuICAgICAgICB7IGNhdGVnb3J5OiBcIkJcIiwgdmFsdWU6IDIwIH0sXG4gICAgICAgIHsgY2F0ZWdvcnk6IFwiQVwiLCB2YWx1ZTogMTUgfSxcbiAgICAgIF07XG5cbiAgICAgIC8vIE1vY2sgd29ya2VyIHJlc3BvbnNlXG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDogeyBBOiAyNSwgQjogMjAgfSxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lOiA0MCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd29ya2VyLmFnZ3JlZ2F0ZURhdGEodGVzdERhdGEsIHsgc3VtOiBcInZhbHVlXCIgfSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgQTogMjUsIEI6IDIwIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgdGFzayB0aW1lb3V0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gWzEsIDIsIDNdO1xuICAgICAgY29uc3QgdGFzazogUHJvY2Vzc2luZ1Rhc2sgPSB7XG4gICAgICAgIGlkOiBcInRpbWVvdXQtdGVzdFwiLFxuICAgICAgICB0eXBlOiBcImZpbHRlclwiLFxuICAgICAgICBkYXRhOiB0ZXN0RGF0YSxcbiAgICAgIH07XG5cbiAgICAgIC8vIERvbid0IG1vY2sgYW55IHJlc3BvbnNlIHRvIHRyaWdnZXIgdGltZW91dFxuXG4gICAgICBhd2FpdCBleHBlY3Qod29ya2VyLnByb2Nlc3NEYXRhKHRhc2spKS5yZWplY3RzLnRvVGhyb3coXCJUYXNrIHRpbWVvdXRcIik7XG4gICAgfSwgMTUwKTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHF1ZXVlIHNpemUgdHJhY2tpbmdcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KHdvcmtlci5nZXRRdWV1ZVNpemUoKSkudG9CZSgwKTtcblxuICAgICAgLy8gU3RhcnQgYSB0YXNrICh3b24ndCBjb21wbGV0ZSB3aXRob3V0IG1vY2sgcmVzcG9uc2UpXG4gICAgICB3b3JrZXJcbiAgICAgICAgLnByb2Nlc3NEYXRhKHtcbiAgICAgICAgICBpZDogXCJxdWV1ZS10ZXN0XCIsXG4gICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICBkYXRhOiBbMSwgMiwgM10sXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7fSk7IC8vIElnbm9yZSB0aGUgZXJyb3JcblxuICAgICAgZXhwZWN0KHdvcmtlci5nZXRRdWV1ZVNpemUoKSkudG9CZSgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJJbWFnZVByb2Nlc3NpbmdXb3JrZXJcIiwgKCkgPT4ge1xuICAgIGxldCB3b3JrZXI6IEltYWdlUHJvY2Vzc2luZ1dvcmtlcjtcbiAgICBsZXQgbW9ja0ltYWdlRGF0YTogSW1hZ2VEYXRhO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICB3b3JrZXIgPSBuZXcgSW1hZ2VQcm9jZXNzaW5nV29ya2VyKCk7XG5cbiAgICAgIC8vIE1vY2sgSW1hZ2VEYXRhXG4gICAgICBtb2NrSW1hZ2VEYXRhID0ge1xuICAgICAgICBkYXRhOiBuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwgMCwgMCwgMjU1XSksIC8vIFJlZCBwaXhlbFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBjb2xvclNwYWNlOiBcInNyZ2JcIixcbiAgICAgIH0gYXMgSW1hZ2VEYXRhO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY3JlYXRlIGltYWdlIHByb2Nlc3Npbmcgd29ya2VyXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChXb3JrZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiL3dvcmtlcnMvaW1hZ2UtcHJvY2Vzc2luZy5qc1wiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVzaXplIGltYWdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgIGRhdGE6IG5ldyBVaW50OENsYW1wZWRBcnJheShbMjU1LCAwLCAwLCAyNTUsIDI1NSwgMCwgMCwgMjU1XSksXG4gICAgICAgICAgICAgIHdpZHRoOiAyLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIucmVzaXplSW1hZ2UobW9ja0ltYWdlRGF0YSwgMiwgMSk7XG4gICAgICBleHBlY3QocmVzdWx0LndpZHRoKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5oZWlnaHQpLnRvQmUoMSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGFwcGx5IGZpbHRlciB0byBpbWFnZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICBkYXRhOiBuZXcgVWludDhDbGFtcGVkQXJyYXkoWzEyOCwgMTI4LCAxMjgsIDI1NV0pLCAvLyBHcmF5c2NhbGVcbiAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdvcmtlci5hcHBseUZpbHRlcihtb2NrSW1hZ2VEYXRhLCBcImdyYXlzY2FsZVwiLCAxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YVswXSkudG9CZSgxMjgpOyAvLyBTaG91bGQgYmUgZ3JheXNjYWxlXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGNyb3AgaW1hZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IG1vY2tJbWFnZURhdGEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdvcmtlci5jcm9wSW1hZ2UobW9ja0ltYWdlRGF0YSwgMCwgMCwgMSwgMSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCByb3RhdGUgaW1hZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IG1vY2tJbWFnZURhdGEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdvcmtlci5yb3RhdGVJbWFnZShtb2NrSW1hZ2VEYXRhLCA5MCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBhZGp1c3QgYnJpZ2h0bmVzc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICBkYXRhOiBuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwgMTAwLCAxMDAsIDI1NV0pLCAvLyBCcmlnaHRlclxuICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd29ya2VyLmFkanVzdEJyaWdodG5lc3MobW9ja0ltYWdlRGF0YSwgMS41KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YVsxXSkudG9CZSgxMDApOyAvLyBNb2RpZmllZCBicmlnaHRuZXNzXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGFkanVzdCBjb250cmFzdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICBkYXRhOiBuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwgNTAsIDUwLCAyNTVdKSwgLy8gSGlnaGVyIGNvbnRyYXN0XG4gICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZXIuYWRqdXN0Q29udHJhc3QobW9ja0ltYWdlRGF0YSwgMik7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGFbMV0pLnRvQmUoNTApOyAvLyBNb2RpZmllZCBjb250cmFzdFxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgcHJvY2Vzc2luZyBlcnJvcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICBlcnJvcjogXCJJbnZhbGlkIGltYWdlIGZvcm1hdFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBhd2FpdCBleHBlY3Qod29ya2VyLnJlc2l6ZUltYWdlKG1vY2tJbWFnZURhdGEsIDAsIDApKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiSW52YWxpZCBpbWFnZSBmb3JtYXRcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBwcm9jZXNzaW5nIHRpbWVvdXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gRG9uJ3QgbW9jayBhbnkgcmVzcG9uc2UgdG8gdHJpZ2dlciB0aW1lb3V0XG4gICAgICBhd2FpdCBleHBlY3Qod29ya2VyLnJlc2l6ZUltYWdlKG1vY2tJbWFnZURhdGEsIDEwMCwgMTAwKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBcIkltYWdlIHByb2Nlc3NpbmcgdGltZW91dFwiLFxuICAgICAgKTtcbiAgICB9LCAxNTApO1xuICB9KTtcblxuICBkZXNjcmliZShcIkNyb3NzVGFiQ29tbXVuaWNhdG9yXCIsICgpID0+IHtcbiAgICBsZXQgY29tbXVuaWNhdG9yOiBDcm9zc1RhYkNvbW11bmljYXRvcjtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgY29tbXVuaWNhdG9yID0gbmV3IENyb3NzVGFiQ29tbXVuaWNhdG9yKCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgY29tbXVuaWNhdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY3JlYXRlIHNoYXJlZCB3b3JrZXIgZm9yIGNyb3NzLXRhYiBjb21tdW5pY2F0aW9uXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChTaGFyZWRXb3JrZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiL3dvcmtlcnMvY3Jvc3MtdGFiLmpzXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBicm9hZGNhc3QgbWVzc2FnZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSB7IG1lc3NhZ2U6IFwiSGVsbG8gZnJvbSB0YWIhXCIgfTtcblxuICAgICAgY29tbXVuaWNhdG9yLmJyb2FkY2FzdCh0ZXN0RGF0YSk7XG5cbiAgICAgIGNvbnN0IG1vY2tQb3J0ID0gKFNoYXJlZFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZS5wb3J0O1xuICAgICAgZXhwZWN0KG1vY2tQb3J0LnBvc3RNZXNzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwiYnJvYWRjYXN0XCIsXG4gICAgICAgICAgZGF0YTogdGVzdERhdGEsXG4gICAgICAgICAgdGFiSWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBzeW5jIGRhdGFcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc3luY0RhdGEgPSB7IHN0YXRlOiBcInVwZGF0ZWRcIiB9O1xuXG4gICAgICBjb21tdW5pY2F0b3Iuc3luYyhzeW5jRGF0YSk7XG5cbiAgICAgIGNvbnN0IG1vY2tQb3J0ID0gKFNoYXJlZFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZS5wb3J0O1xuICAgICAgZXhwZWN0KG1vY2tQb3J0LnBvc3RNZXNzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwic3luY1wiLFxuICAgICAgICAgIGRhdGE6IHN5bmNEYXRhLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSByZXF1ZXN0LXJlc3BvbnNlIHBhdHRlcm5cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdERhdGEgPSB7IHF1ZXJ5OiBcImdldFVzZXJEYXRhXCIgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHsgdXNlcjogeyBpZDogMSwgbmFtZTogXCJUZXN0IFVzZXJcIiB9IH07XG5cbiAgICAgIC8vIE1vY2sgcmVzcG9uc2VcbiAgICAgIGNvbnN0IG1vY2tQb3J0ID0gKFNoYXJlZFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZS5wb3J0O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbW11bmljYXRvci5vbihcInJlc3BvbnNlXCIsIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGEucmVxdWVzdElkKSB7XG4gICAgICAgICAgICAvLyBTaW11bGF0ZSByZXNwb25zZSBmcm9tIGFub3RoZXIgdGFiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTaW11bGF0ZSByZWNlaXZpbmcgcmVzcG9uc2VcbiAgICAgICAgaWYgKG1vY2tQb3J0Lm9ubWVzc2FnZSkge1xuICAgICAgICAgIG1vY2tQb3J0Lm9ubWVzc2FnZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgZGF0YTogeyByZXF1ZXN0SWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSwgZGF0YTogcmVzcG9uc2VEYXRhIH0sXG4gICAgICAgICAgICAgIHRhYklkOiBcIm90aGVyLXRhYlwiLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbW11bmljYXRvci5yZXF1ZXN0KHJlcXVlc3REYXRhKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwocmVzcG9uc2VEYXRhKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIG1lc3NhZ2UgaGFuZGxlcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGplc3QuZm4oKTtcblxuICAgICAgY29tbXVuaWNhdG9yLm9uKFwiYnJvYWRjYXN0XCIsIGhhbmRsZXIpO1xuXG4gICAgICAvLyBTaW11bGF0ZSByZWNlaXZpbmcgbWVzc2FnZVxuICAgICAgY29uc3QgbW9ja1BvcnQgPSAoU2hhcmVkV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlLnBvcnQ7XG4gICAgICBpZiAobW9ja1BvcnQub25tZXNzYWdlKSB7XG4gICAgICAgIG1vY2tQb3J0Lm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdHlwZTogXCJicm9hZGNhc3RcIixcbiAgICAgICAgICAgIGRhdGE6IHsgdGVzdDogXCJkYXRhXCIgfSxcbiAgICAgICAgICAgIHRhYklkOiBcIm90aGVyLXRhYlwiLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QoaGFuZGxlcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyB0ZXN0OiBcImRhdGFcIiB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVtb3ZlIG1lc3NhZ2UgaGFuZGxlcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGplc3QuZm4oKTtcblxuICAgICAgY29tbXVuaWNhdG9yLm9uKFwiYnJvYWRjYXN0XCIsIGhhbmRsZXIpO1xuICAgICAgY29tbXVuaWNhdG9yLm9mZihcImJyb2FkY2FzdFwiLCBoYW5kbGVyKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcmVjZWl2aW5nIG1lc3NhZ2VcbiAgICAgIGNvbnN0IG1vY2tQb3J0ID0gKFNoYXJlZFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZS5wb3J0O1xuICAgICAgaWYgKG1vY2tQb3J0Lm9ubWVzc2FnZSkge1xuICAgICAgICBtb2NrUG9ydC5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJvYWRjYXN0XCIsXG4gICAgICAgICAgICBkYXRhOiB7IHRlc3Q6IFwiZGF0YVwiIH0sXG4gICAgICAgICAgICB0YWJJZDogXCJvdGhlci10YWJcIixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KGhhbmRsZXIpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGlnbm9yZSBvd24gbWVzc2FnZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGplc3QuZm4oKTtcbiAgICAgIGNvbW11bmljYXRvci5vbihcImJyb2FkY2FzdFwiLCBoYW5kbGVyKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcmVjZWl2aW5nIG91ciBvd24gbWVzc2FnZVxuICAgICAgY29uc3QgbW9ja1BvcnQgPSAoU2hhcmVkV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlLnBvcnQ7XG4gICAgICBjb25zdCB0YWJJZCA9IChjb21tdW5pY2F0b3IgYXMgYW55KS50YWJJZDtcblxuICAgICAgaWYgKG1vY2tQb3J0Lm9ubWVzc2FnZSkge1xuICAgICAgICBtb2NrUG9ydC5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJvYWRjYXN0XCIsXG4gICAgICAgICAgICBkYXRhOiB7IHRlc3Q6IFwiZGF0YVwiIH0sXG4gICAgICAgICAgICB0YWJJZDogdGFiSWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChoYW5kbGVyKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCByZXNwb25kIHRvIHJlcXVlc3RzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IFwidGVzdC1yZXF1ZXN0LTEyM1wiO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0geyByZXN1bHQ6IFwic3VjY2Vzc1wiIH07XG5cbiAgICAgIGNvbW11bmljYXRvci5yZXNwb25kKHJlcXVlc3RJZCwgcmVzcG9uc2VEYXRhKTtcblxuICAgICAgY29uc3QgbW9ja1BvcnQgPSAoU2hhcmVkV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlLnBvcnQ7XG4gICAgICBleHBlY3QobW9ja1BvcnQucG9zdE1lc3NhZ2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdHlwZTogXCJyZXNwb25zZVwiLFxuICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdElkLCBkYXRhOiByZXNwb25zZURhdGEgfSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlNlcnZpY2VXb3JrZXJNYW5hZ2VyXCIsICgpID0+IHtcbiAgICBsZXQgbWFuYWdlcjogU2VydmljZVdvcmtlck1hbmFnZXI7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1hbmFnZXIgPSBuZXcgU2VydmljZVdvcmtlck1hbmFnZXIoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVnaXN0ZXIgc2VydmljZSB3b3JrZXJcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVnaXN0cmF0aW9uID0gYXdhaXQgbWFuYWdlci5yZWdpc3RlcihcIi90ZXN0LXN3LmpzXCIpO1xuXG4gICAgICBleHBlY3QobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIi90ZXN0LXN3LmpzXCIsXG4gICAgICApO1xuICAgICAgZXhwZWN0KHJlZ2lzdHJhdGlvbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtYW5hZ2VyLmlzU2VydmljZVdvcmtlclJlZ2lzdGVyZWQoKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgdW5yZWdpc3RlciBzZXJ2aWNlIHdvcmtlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnJlZ2lzdGVyKCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtYW5hZ2VyLnVucmVnaXN0ZXIoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtYW5hZ2VyLmlzU2VydmljZVdvcmtlclJlZ2lzdGVyZWQoKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHVwZGF0ZSBzZXJ2aWNlIHdvcmtlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnJlZ2lzdGVyKCk7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnVwZGF0ZSgpO1xuXG4gICAgICBjb25zdCByZWdpc3RyYXRpb24gPSBtYW5hZ2VyLmdldFJlZ2lzdHJhdGlvbigpO1xuICAgICAgZXhwZWN0KHJlZ2lzdHJhdGlvbj8udXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHBvc3QgbWVzc2FnZSB0byBzZXJ2aWNlIHdvcmtlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnJlZ2lzdGVyKCk7XG4gICAgICBjb25zdCBtZXNzYWdlID0geyB0eXBlOiBcInRlc3RcIiwgZGF0YTogXCJoZWxsb1wiIH07XG5cbiAgICAgIG1hbmFnZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IG1hbmFnZXIuZ2V0UmVnaXN0cmF0aW9uKCk7XG4gICAgICBleHBlY3QocmVnaXN0cmF0aW9uPy5hY3RpdmU/LnBvc3RNZXNzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtZXNzYWdlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY29uZmlndXJlIGNhY2hlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG1hbmFnZXIucmVnaXN0ZXIoKTtcbiAgICAgIGNvbnN0IGNvbmZpZ3M6IENhY2hlQ29uZmlnW10gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFwaS1jYWNoZVwiLFxuICAgICAgICAgIG1heEFnZTogMzYwMDAwMCxcbiAgICAgICAgICBtYXhFbnRyaWVzOiAxMDAsXG4gICAgICAgICAgc3RyYXRlZ3k6IFwibmV0d29yay1maXJzdFwiLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgYXdhaXQgbWFuYWdlci5jb25maWd1cmVDYWNoZShjb25maWdzKTtcblxuICAgICAgY29uc3QgcmVnaXN0cmF0aW9uID0gbWFuYWdlci5nZXRSZWdpc3RyYXRpb24oKTtcbiAgICAgIGV4cGVjdChyZWdpc3RyYXRpb24/LmFjdGl2ZT8ucG9zdE1lc3NhZ2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgdHlwZTogXCJjb25maWd1cmUtY2FjaGVcIixcbiAgICAgICAgY29uZmlncyxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjbGVhciBjYWNoZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtYW5hZ2VyLnJlZ2lzdGVyKCk7XG5cbiAgICAgIGF3YWl0IG1hbmFnZXIuY2xlYXJDYWNoZShcInRlc3QtY2FjaGVcIik7XG5cbiAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IG1hbmFnZXIuZ2V0UmVnaXN0cmF0aW9uKCk7XG4gICAgICBleHBlY3QocmVnaXN0cmF0aW9uPy5hY3RpdmU/LnBvc3RNZXNzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHR5cGU6IFwiY2xlYXItY2FjaGVcIixcbiAgICAgICAgY2FjaGVOYW1lOiBcInRlc3QtY2FjaGVcIixcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBnZXQgY2FjaGUgc3RhdHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbWFuYWdlci5yZWdpc3RlcigpO1xuXG4gICAgICAvLyBUaGlzIHdvdWxkIHRpbWVvdXQgaW4gcmVhbCBpbXBsZW1lbnRhdGlvbiB3aXRob3V0IHByb3BlciByZXNwb25zZVxuICAgICAgYXdhaXQgZXhwZWN0KG1hbmFnZXIuZ2V0Q2FjaGVTdGF0cygpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiQ2FjaGUgc3RhdHMgcmVxdWVzdCB0aW1lb3V0XCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0aHJvdyBlcnJvciB3aGVuIHNlcnZpY2Ugd29ya2VyIG5vdCBzdXBwb3J0ZWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1bnN1cHBvcnRlZCBlbnZpcm9ubWVudFxuICAgICAgY29uc3Qgb3JpZ2luYWxTZXJ2aWNlV29ya2VyID0gKGdsb2JhbC5uYXZpZ2F0b3IgYXMgYW55KS5zZXJ2aWNlV29ya2VyO1xuICAgICAgZGVsZXRlIChnbG9iYWwubmF2aWdhdG9yIGFzIGFueSkuc2VydmljZVdvcmtlcjtcblxuICAgICAgY29uc3QgdW5zdXBwb3J0ZWRNYW5hZ2VyID0gbmV3IFNlcnZpY2VXb3JrZXJNYW5hZ2VyKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh1bnN1cHBvcnRlZE1hbmFnZXIucmVnaXN0ZXIoKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBcIlNlcnZpY2UgV29ya2VyIG5vdCBzdXBwb3J0ZWRcIixcbiAgICAgICk7XG5cbiAgICAgIC8vIFJlc3RvcmVcbiAgICAgIChnbG9iYWwubmF2aWdhdG9yIGFzIGFueSkuc2VydmljZVdvcmtlciA9IG9yaWdpbmFsU2VydmljZVdvcmtlcjtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiBwb3N0aW5nIG1lc3NhZ2Ugd2l0aG91dCBhY3RpdmUgd29ya2VyXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIG1hbmFnZXIucG9zdE1lc3NhZ2UoeyB0ZXN0OiBcImRhdGFcIiB9KTtcbiAgICAgIH0pLnRvVGhyb3coXCJObyBhY3RpdmUgU2VydmljZSBXb3JrZXJcIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiQmFja2dyb3VuZFN5bmNNYW5hZ2VyXCIsICgpID0+IHtcbiAgICBsZXQgc3luY01hbmFnZXI6IEJhY2tncm91bmRTeW5jTWFuYWdlcjtcbiAgICBsZXQgc2VydmljZVdvcmtlck1hbmFnZXI6IFNlcnZpY2VXb3JrZXJNYW5hZ2VyO1xuXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICBzZXJ2aWNlV29ya2VyTWFuYWdlciA9IG5ldyBTZXJ2aWNlV29ya2VyTWFuYWdlcigpO1xuICAgICAgYXdhaXQgc2VydmljZVdvcmtlck1hbmFnZXIucmVnaXN0ZXIoKTtcbiAgICAgIHN5bmNNYW5hZ2VyID0gbmV3IEJhY2tncm91bmRTeW5jTWFuYWdlcihzZXJ2aWNlV29ya2VyTWFuYWdlcik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHNjaGVkdWxlIHN5bmMgdGFza1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0YXNrRGF0YSA9IHsgYWN0aW9uOiBcInVwbG9hZEZpbGVcIiwgZmlsZUlkOiBcIjEyM1wiIH07XG5cbiAgICAgIGNvbnN0IHRhc2tJZCA9IGF3YWl0IHN5bmNNYW5hZ2VyLnNjaGVkdWxlU3luYyhcImZpbGUtdXBsb2FkXCIsIHRhc2tEYXRhKTtcblxuICAgICAgZXhwZWN0KHRhc2tJZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzeW5jTWFuYWdlci5nZXRQZW5kaW5nVGFza3MoKSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KFxuICAgICAgICBzZXJ2aWNlV29ya2VyTWFuYWdlci5nZXRSZWdpc3RyYXRpb24oKT8uYWN0aXZlPy5wb3N0TWVzc2FnZSxcbiAgICAgICkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICB0eXBlOiBcInNjaGVkdWxlLXN5bmNcIixcbiAgICAgICAgICB0YXNrOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBpZDogdGFza0lkLFxuICAgICAgICAgICAgdHlwZTogXCJmaWxlLXVwbG9hZFwiLFxuICAgICAgICAgICAgZGF0YTogdGFza0RhdGEsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY2FuY2VsIHN5bmMgdGFza1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0YXNrSWQgPSBhd2FpdCBzeW5jTWFuYWdlci5zY2hlZHVsZVN5bmMoXCJ0ZXN0LXN5bmNcIiwge1xuICAgICAgICBkYXRhOiBcInRlc3RcIixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjYW5jZWxsZWQgPSBhd2FpdCBzeW5jTWFuYWdlci5jYW5jZWxTeW5jKHRhc2tJZCk7XG5cbiAgICAgIGV4cGVjdChjYW5jZWxsZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qoc3luY01hbmFnZXIuZ2V0UGVuZGluZ1Rhc2tzKCkpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgc2VydmljZVdvcmtlck1hbmFnZXIuZ2V0UmVnaXN0cmF0aW9uKCk/LmFjdGl2ZT8ucG9zdE1lc3NhZ2UsXG4gICAgICApLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdHlwZTogXCJjYW5jZWwtc3luY1wiLFxuICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCByZXRyeSBmYWlsZWQgdGFza3NcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGFza0lkID0gYXdhaXQgc3luY01hbmFnZXIuc2NoZWR1bGVTeW5jKFwidGVzdC1zeW5jXCIsIHtcbiAgICAgICAgZGF0YTogXCJ0ZXN0XCIsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgc3luY01hbmFnZXIucmV0cnlGYWlsZWRUYXNrcygpO1xuXG4gICAgICBjb25zdCB0YXNrID0gc3luY01hbmFnZXIuZ2V0VGFza1N0YXR1cyh0YXNrSWQpO1xuICAgICAgZXhwZWN0KHRhc2s/LnJldHJ5Q291bnQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QoXG4gICAgICAgIHNlcnZpY2VXb3JrZXJNYW5hZ2VyLmdldFJlZ2lzdHJhdGlvbigpPy5hY3RpdmU/LnBvc3RNZXNzYWdlLFxuICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwicmV0cnktc3luY1wiLFxuICAgICAgICAgIHRhc2s6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGlkOiB0YXNrSWQsXG4gICAgICAgICAgICByZXRyeUNvdW50OiAxLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGdldCB0YXNrIHN0YXR1c1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0YXNrSWQgPSBhd2FpdCBzeW5jTWFuYWdlci5zY2hlZHVsZVN5bmMoXCJ0ZXN0LXN5bmNcIiwge1xuICAgICAgICBkYXRhOiBcInRlc3RcIixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGF0dXMgPSBzeW5jTWFuYWdlci5nZXRUYXNrU3RhdHVzKHRhc2tJZCk7XG5cbiAgICAgIGV4cGVjdChzdGF0dXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc3RhdHVzPy5pZCkudG9CZSh0YXNrSWQpO1xuICAgICAgZXhwZWN0KHN0YXR1cz8udHlwZSkudG9CZShcInRlc3Qtc3luY1wiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY2xlYXIgY29tcGxldGVkIHRhc2tzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRhc2tJZCA9IGF3YWl0IHN5bmNNYW5hZ2VyLnNjaGVkdWxlU3luYyhcbiAgICAgICAgXCJ0ZXN0LXN5bmNcIixcbiAgICAgICAgeyBkYXRhOiBcInRlc3RcIiB9LFxuICAgICAgICB7IG1heFJldHJpZXM6IDAgfSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIHRhc2sgZmFpbHVyZSBieSBzZXR0aW5nIHJldHJ5IGNvdW50IHRvIG1heFxuICAgICAgY29uc3QgdGFzayA9IHN5bmNNYW5hZ2VyLmdldFRhc2tTdGF0dXModGFza0lkKTtcbiAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgIHRhc2sucmV0cnlDb3VudCA9IHRhc2subWF4UmV0cmllcztcbiAgICAgIH1cblxuICAgICAgc3luY01hbmFnZXIuY2xlYXJDb21wbGV0ZWRUYXNrcygpO1xuXG4gICAgICBleHBlY3Qoc3luY01hbmFnZXIuZ2V0VGFza1N0YXR1cyh0YXNrSWQpKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSB0YXNrIHdpdGggY3VzdG9tIG1heCByZXRyaWVzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRhc2tJZCA9IGF3YWl0IHN5bmNNYW5hZ2VyLnNjaGVkdWxlU3luYyhcbiAgICAgICAgXCJ0ZXN0LXN5bmNcIixcbiAgICAgICAgeyBkYXRhOiBcInRlc3RcIiB9LFxuICAgICAgICB7IG1heFJldHJpZXM6IDUgfSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRhc2sgPSBzeW5jTWFuYWdlci5nZXRUYXNrU3RhdHVzKHRhc2tJZCk7XG4gICAgICBleHBlY3QodGFzaz8ubWF4UmV0cmllcykudG9CZSg1KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgbm90IGNhbmNlbCBub24tZXhpc3RlbnQgdGFza1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5jZWxsZWQgPSBhd2FpdCBzeW5jTWFuYWdlci5jYW5jZWxTeW5jKFwibm9uLWV4aXN0ZW50LWlkXCIpO1xuXG4gICAgICBleHBlY3QoY2FuY2VsbGVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJXb3JrZXIiLCJqZXN0IiwiZm4iLCJwb3N0TWVzc2FnZSIsInRlcm1pbmF0ZSIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJvbm1lc3NhZ2VlcnJvciIsIlNoYXJlZFdvcmtlciIsInBvcnQiLCJzdGFydCIsImNsb3NlIiwiU2VydmljZVdvcmtlciIsInN0YXRlIiwib25zdGF0ZWNoYW5nZSIsIm5hdmlnYXRvciIsInNlcnZpY2VXb3JrZXIiLCJyZWdpc3RlciIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW5zdGFsbGluZyIsIndhaXRpbmciLCJhY3RpdmUiLCJzY29wZSIsInVwZGF0ZSIsInVucmVnaXN0ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWR5IiwiY29udHJvbGxlciIsImdldFJlZ2lzdHJhdGlvbiIsImdldFJlZ2lzdHJhdGlvbnMiLCJEYXRhUHJvY2Vzc2luZ1dvcmtlciIsImNvbnN0cnVjdG9yIiwid29ya2VyU2NyaXB0IiwicGVuZGluZ1Rhc2tzIiwiTWFwIiwid29ya2VyIiwiaGFuZGxlTWVzc2FnZSIsImJpbmQiLCJoYW5kbGVFcnJvciIsIm9yaWdpbmFsUG9zdE1lc3NhZ2UiLCJkYXRhIiwiY2FsbCIsInNldFRpbWVvdXQiLCJpZCIsInJlc3VsdCIsInByb2Nlc3NEYXRhU3luYyIsInByb2Nlc3NpbmdUaW1lIiwidGFzayIsInR5cGUiLCJmaWx0ZXIiLCJ4IiwibWFwIiwicmVkdWNlIiwiYWNjIiwidmFsIiwib3B0aW9ucyIsImluaXRpYWxWYWx1ZSIsInNvcnQiLCJBIiwiQiIsImV2ZW50IiwiZXJyb3IiLCJnZXQiLCJyZWplY3QiLCJFcnJvciIsImRlbGV0ZSIsImNvbnNvbGUiLCJmb3JFYWNoIiwiY2xlYXIiLCJwcm9jZXNzRGF0YSIsInRhc2tJZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJzZXQiLCJoYXMiLCJmaWx0ZXJEYXRhIiwicHJlZGljYXRlIiwibWFwRGF0YSIsIm1hcHBlciIsInJlZHVjZURhdGEiLCJyZWR1Y2VyIiwic29ydERhdGEiLCJjb21wYXJlRm4iLCJhZ2dyZWdhdGVEYXRhIiwiYWdncmVnYXRpb25zIiwiZ2V0UXVldWVTaXplIiwic2l6ZSIsIkltYWdlUHJvY2Vzc2luZ1dvcmtlciIsInByb2Nlc3NJbWFnZSIsInJlc2l6ZUltYWdlIiwiaW1hZ2VEYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJhcHBseUZpbHRlciIsImZpbHRlclR5cGUiLCJpbnRlbnNpdHkiLCJjcm9wSW1hZ2UiLCJ5Iiwicm90YXRlSW1hZ2UiLCJhbmdsZSIsImFkanVzdEJyaWdodG5lc3MiLCJicmlnaHRuZXNzIiwiYWRqdXN0Q29udHJhc3QiLCJjb250cmFzdCIsIkNyb3NzVGFiQ29tbXVuaWNhdG9yIiwibWVzc2FnZUhhbmRsZXJzIiwidGFiSWQiLCJzaGFyZWRXb3JrZXIiLCJoYW5kbGVNZXNzYWdlRXJyb3IiLCJzZW5kTWVzc2FnZSIsImFjdGlvbiIsInRpbWVzdGFtcCIsImhhbmRsZXIiLCJnZW5lcmFsSGFuZGxlciIsIm1lc3NhZ2UiLCJicm9hZGNhc3QiLCJzeW5jIiwicmVxdWVzdCIsInJlcXVlc3RJZCIsInJlc3BvbnNlSGFuZGxlciIsInJlc3BvbnNlRGF0YSIsIm9mZiIsIm9uIiwicmVzcG9uZCIsIm1lc3NhZ2VUeXBlIiwiY3VycmVudEhhbmRsZXIiLCJkaXNjb25uZWN0IiwiU2VydmljZVdvcmtlck1hbmFnZXIiLCJzY3JpcHRVcmwiLCJyZWdpc3RyYXRpb24iLCJpc1JlZ2lzdGVyZWQiLCJoYW5kbGVVcGRhdGVGb3VuZCIsIm5ld1dvcmtlciIsImxvZyIsImNvbmZpZ3VyZUNhY2hlIiwiY29uZmlncyIsImNsZWFyQ2FjaGUiLCJjYWNoZU5hbWUiLCJnZXRDYWNoZVN0YXRzIiwiY2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImlzU2VydmljZVdvcmtlclJlZ2lzdGVyZWQiLCJCYWNrZ3JvdW5kU3luY01hbmFnZXIiLCJzZXJ2aWNlV29ya2VyTWFuYWdlciIsInRhc2tzIiwic2NoZWR1bGVTeW5jIiwicmV0cnlDb3VudCIsIm1heFJldHJpZXMiLCJjcmVhdGVkQXQiLCJjYW5jZWxTeW5jIiwicmV0cnlGYWlsZWRUYXNrcyIsImZhaWxlZFRhc2tzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZ2V0UGVuZGluZ1Rhc2tzIiwiZ2V0VGFza1N0YXR1cyIsImNsZWFyQ29tcGxldGVkVGFza3MiLCJjb21wbGV0ZWRUYXNrcyIsImVudHJpZXMiLCJfIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiYWZ0ZXJFYWNoIiwidGVzdCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidG9CZSIsInRlc3REYXRhIiwidG9FcXVhbCIsIm1vY2tXb3JrZXIiLCJtb2NrIiwicmVzdWx0cyIsInZhbHVlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJhbnkiLCJTdHJpbmciLCJjYXRlZ29yeSIsInN1bSIsImNhdGNoIiwibW9ja0ltYWdlRGF0YSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiY29sb3JTcGFjZSIsInRvQmVEZWZpbmVkIiwiY29tbXVuaWNhdG9yIiwibW9ja1BvcnQiLCJvYmplY3RDb250YWluaW5nIiwiTnVtYmVyIiwic3luY0RhdGEiLCJyZXF1ZXN0RGF0YSIsInF1ZXJ5IiwidXNlciIsIm5hbWUiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibWFuYWdlciIsIm1heEFnZSIsIm1heEVudHJpZXMiLCJzdHJhdGVneSIsIm9yaWdpbmFsU2VydmljZVdvcmtlciIsInVuc3VwcG9ydGVkTWFuYWdlciIsInN5bmNNYW5hZ2VyIiwidGFza0RhdGEiLCJmaWxlSWQiLCJ0b0hhdmVMZW5ndGgiLCJjYW5jZWxsZWQiLCJzdGF0dXMiLCJ0b0JlVW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozt5QkFFb0I7QUFFckIsa0JBQWtCO0FBQ2xCQSxPQUFPQyxNQUFNLEdBQUdDLGFBQUksQ0FBQ0MsRUFBRSxDQUFDLElBQU8sQ0FBQTtRQUM3QkMsYUFBYUYsYUFBSSxDQUFDQyxFQUFFO1FBQ3BCRSxXQUFXSCxhQUFJLENBQUNDLEVBQUU7UUFDbEJHLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxnQkFBZ0I7SUFDbEIsQ0FBQTtBQUVBLHdCQUF3QjtBQUN4QlIsT0FBT1Ms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