4c864d9d79afabe67efe5dba3b960ee9
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    LLMProvider: function() {
        return LLMProvider;
    },
    useLLM: function() {
        return useLLM;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _llmclient = require("../lib/llm-client");
const _llmsecureclient = require("../lib/llm-secure-client");
const _featureflags = require("../lib/feature-flags");
const _debuglogger = require("../lib/debug-logger");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const logger = (0, _debuglogger.createLogger)("LLM-CONTEXT");
// Create context with default values
const LLMContext = /*#__PURE__*/ (0, _react.createContext)({
    client: (0, _featureflags.isFeatureEnabled)("useSecureApiStorage") ? _llmsecureclient.llmSecureClient : _llmclient.llmClient,
    settings: null,
    updateSettings: ()=>{},
    saveSettings: async ()=>false,
    isProcessing: false,
    setIsProcessing: ()=>{},
    clientType: (0, _featureflags.isFeatureEnabled)("useSecureApiStorage") ? "LLMSecureClient" : "LLMClient"
});
function LLMProvider({ children }) {
    logger.info("LLMProvider rendering");
    const [settings, setSettings] = (0, _react.useState)(null);
    const [isProcessing, setIsProcessing] = (0, _react.useState)(false);
    // Determine which client to use based on feature flag
    const useSecureStorage = (0, _featureflags.isFeatureEnabled)("useSecureApiStorage");
    const activeClient = useSecureStorage ? _llmsecureclient.llmSecureClient : _llmclient.llmClient;
    logger.info("LLMProvider using client:", {
        useSecureStorage,
        clientType: useSecureStorage ? "LLMSecureClient" : "LLMClient"
    });
    // Load initial settings from the client
    (0, _react.useEffect)(()=>{
        logger.info("Loading initial settings from client");
        if (!activeClient) {
            logger.info("No active client available, using defaults");
            setSettings(null);
            return;
        }
        try {
            const clientSettings = activeClient.getSettings();
            logger.info("Retrieved settings from client:", {
                provider: clientSettings?.provider,
                model: clientSettings?.model,
                hasApiKey: !!clientSettings?.apiKey,
                hasApiKeySessionId: !!clientSettings?.apiKeySessionId,
                hasServerRef: clientSettings && typeof clientSettings === "object" && "__server_ref" in clientSettings
            });
            // Create clean merged settings with robust null/undefined handling
            const mergedSettings = {
                provider: clientSettings?.provider || "openai",
                model: clientSettings?.model || "gpt-4o",
                temperature: typeof clientSettings?.temperature === "number" ? clientSettings.temperature : 0.7,
                maxTokens: typeof clientSettings?.maxTokens === "number" ? clientSettings.maxTokens : 1024,
                topP: typeof clientSettings?.topP === "number" ? clientSettings.topP : 0.9,
                frequencyPenalty: typeof clientSettings?.frequencyPenalty === "number" ? clientSettings.frequencyPenalty : 0,
                presencePenalty: typeof clientSettings?.presencePenalty === "number" ? clientSettings.presencePenalty : 0,
                systemFingerprint: typeof clientSettings?.systemFingerprint === "boolean" ? clientSettings.systemFingerprint : false,
                // Handle optional properties - only include if they have valid values
                ...clientSettings?.apiKey && {
                    apiKey: clientSettings.apiKey
                },
                ...clientSettings?.apiKeySessionId && {
                    apiKeySessionId: clientSettings.apiKeySessionId
                },
                ...typeof clientSettings?.maxAutonomousMessages === "number" && {
                    maxAutonomousMessages: clientSettings.maxAutonomousMessages
                },
                ...typeof clientSettings?.conversationCooldown === "number" && {
                    conversationCooldown: clientSettings.conversationCooldown
                }
            };
            setSettings(mergedSettings);
            logger.info("LLM context initialized with settings:", {
                provider: mergedSettings.provider,
                model: mergedSettings.model,
                hasApiKey: !!mergedSettings.apiKey,
                hasApiKeySessionId: !!mergedSettings.apiKeySessionId
            });
        } catch (error) {
            logger.error("Error loading initial settings:", error);
            setSettings(null);
        }
    }, [
        activeClient
    ]);
    // Update settings in the client
    const updateSettings = (newSettings)=>{
        logger.info("updateSettings called with:", {
            provider: newSettings.provider,
            model: newSettings.model,
            hasApiKey: !!newSettings.apiKey,
            hasApiKeySessionId: !!newSettings.apiKeySessionId
        });
        if (!newSettings || typeof newSettings !== "object") {
            logger.error("Invalid settings update");
            return;
        }
        try {
            // Merge new settings with current settings, ensuring required fields are present
            const updatedSettings = {
                // Provide defaults for required fields
                provider: newSettings.provider || settings?.provider || "openai",
                model: newSettings.model || settings?.model || "gpt-4o",
                temperature: newSettings.temperature ?? settings?.temperature ?? 0.7,
                maxTokens: newSettings.maxTokens ?? settings?.maxTokens ?? 1024,
                topP: newSettings.topP ?? settings?.topP ?? 0.9,
                frequencyPenalty: newSettings.frequencyPenalty ?? settings?.frequencyPenalty ?? 0,
                presencePenalty: newSettings.presencePenalty ?? settings?.presencePenalty ?? 0,
                systemFingerprint: newSettings.systemFingerprint ?? settings?.systemFingerprint ?? false,
                // Handle optional properties
                ...newSettings.apiKey !== undefined && {
                    apiKey: newSettings.apiKey
                },
                ...newSettings.apiKeySessionId !== undefined && {
                    apiKeySessionId: newSettings.apiKeySessionId
                },
                ...newSettings.maxAutonomousMessages !== undefined && {
                    maxAutonomousMessages: newSettings.maxAutonomousMessages
                },
                ...newSettings.conversationCooldown !== undefined && {
                    conversationCooldown: newSettings.conversationCooldown
                }
            };
            // Update local state
            setSettings(updatedSettings);
            // Update client settings
            if (activeClient && typeof activeClient.updateSettings === "function") {
                activeClient.updateSettings(updatedSettings);
            } else {
                logger.error("activeClient.updateSettings is not available");
            }
        } catch (error) {
            logger.error("Error updating settings:", error);
        }
    };
    // Save settings to the server
    const saveSettings = async ()=>{
        logger.info("saveSettings called");
        try {
            if (activeClient && typeof activeClient.saveSettings === "function") {
                return await activeClient.saveSettings();
            } else {
                logger.error("activeClient.saveSettings is not available");
                return false;
            }
        } catch (error) {
            logger.error("Error saving settings:", error);
            return false;
        }
    };
    // Context value
    const value = {
        client: activeClient,
        settings,
        updateSettings,
        saveSettings,
        isProcessing,
        setIsProcessing,
        clientType: useSecureStorage ? "LLMSecureClient" : "LLMClient"
    };
    logger.info("LLMProvider rendering with context value:", {
        clientAvailable: !!value.client,
        clientType: useSecureStorage ? "LLMSecureClient" : "LLMClient",
        settingsProvider: value.settings?.provider,
        settingsModel: value.settings?.model,
        isProcessing: value.isProcessing
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LLMContext.Provider, {
        value: value,
        children: children
    });
}
function useLLM() {
    logger.info("useLLM hook called");
    const context = (0, _react.useContext)(LLMContext);
    logger.info("useLLM returning context with:", {
        clientAvailable: !!context.client,
        clientType: context.clientType,
        settingsProvider: context.settings?.provider,
        settingsModel: context.settings?.model,
        isProcessing: context.isProcessing
    });
    return context;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9jb250ZXh0cy9sbG0tY29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwge1xuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3QsXG4gIHVzZVN0YXRlLFxuICB1c2VDYWxsYmFjayxcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IExMTVNldHRpbmdzIH0gZnJvbSBcIkAvbGliL2xsbS1zZXR0aW5nc1wiO1xuaW1wb3J0IHsgbGxtQ2xpZW50IH0gZnJvbSBcIkAvbGliL2xsbS1jbGllbnRcIjtcbmltcG9ydCB7IGxsbVNlY3VyZUNsaWVudCB9IGZyb20gXCJAL2xpYi9sbG0tc2VjdXJlLWNsaWVudFwiO1xuaW1wb3J0IHsgaXNGZWF0dXJlRW5hYmxlZCB9IGZyb20gXCJAL2xpYi9mZWF0dXJlLWZsYWdzXCI7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tIFwiQC9saWIvZGVidWctbG9nZ2VyXCI7XG5cbmNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihcIkxMTS1DT05URVhUXCIpO1xuXG4vLyBDcmVhdGUgdGhlIGNvbnRleHQgd2l0aCBkZWZhdWx0IHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBJTExNQ29udGV4dFR5cGUge1xuICAvLyBDbGllbnQgbWFuYWdlbWVudFxuICBjbGllbnQ6IHR5cGVvZiBsbG1DbGllbnQgfCB0eXBlb2YgbGxtU2VjdXJlQ2xpZW50IHwgbnVsbDtcbiAgY2xpZW50VHlwZTogXCJMTE1DbGllbnRcIiB8IFwiTExNU2VjdXJlQ2xpZW50XCIgfCBudWxsO1xuXG4gIC8vIFNldHRpbmdzIG1hbmFnZW1lbnRcbiAgc2V0dGluZ3M6IExMTVNldHRpbmdzIHwgbnVsbDtcbiAgdXBkYXRlU2V0dGluZ3M6IChuZXdTZXR0aW5nczogUGFydGlhbDxMTE1TZXR0aW5ncz4pID0+IHZvaWQ7XG4gIHNhdmVTZXR0aW5nczogKCkgPT4gUHJvbWlzZTxib29sZWFuPjtcblxuICAvLyBTdGF0dXNcbiAgaXNQcm9jZXNzaW5nOiBib29sZWFuO1xuICBzZXRJc1Byb2Nlc3Npbmc6IChwcm9jZXNzaW5nOiBib29sZWFuKSA9PiB2b2lkO1xufVxuXG4vLyBDcmVhdGUgY29udGV4dCB3aXRoIGRlZmF1bHQgdmFsdWVzXG5jb25zdCBMTE1Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxJTExNQ29udGV4dFR5cGU+KHtcbiAgY2xpZW50OiBpc0ZlYXR1cmVFbmFibGVkKFwidXNlU2VjdXJlQXBpU3RvcmFnZVwiKSA/IGxsbVNlY3VyZUNsaWVudCA6IGxsbUNsaWVudCxcbiAgc2V0dGluZ3M6IG51bGwsXG4gIHVwZGF0ZVNldHRpbmdzOiAoKSA9PiB7fSxcbiAgc2F2ZVNldHRpbmdzOiBhc3luYyAoKSA9PiBmYWxzZSxcbiAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgc2V0SXNQcm9jZXNzaW5nOiAoKSA9PiB7fSxcbiAgY2xpZW50VHlwZTogaXNGZWF0dXJlRW5hYmxlZChcInVzZVNlY3VyZUFwaVN0b3JhZ2VcIilcbiAgICA/IFwiTExNU2VjdXJlQ2xpZW50XCJcbiAgICA6IFwiTExNQ2xpZW50XCIsXG59KTtcblxuLy8gUHJvdmlkZXIgY29tcG9uZW50XG5leHBvcnQgZnVuY3Rpb24gTExNUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBsb2dnZXIuaW5mbyhcIkxMTVByb3ZpZGVyIHJlbmRlcmluZ1wiKTtcbiAgY29uc3QgW3NldHRpbmdzLCBzZXRTZXR0aW5nc10gPSB1c2VTdGF0ZTxMTE1TZXR0aW5ncyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNQcm9jZXNzaW5nLCBzZXRJc1Byb2Nlc3NpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIERldGVybWluZSB3aGljaCBjbGllbnQgdG8gdXNlIGJhc2VkIG9uIGZlYXR1cmUgZmxhZ1xuICBjb25zdCB1c2VTZWN1cmVTdG9yYWdlID0gaXNGZWF0dXJlRW5hYmxlZChcInVzZVNlY3VyZUFwaVN0b3JhZ2VcIik7XG4gIGNvbnN0IGFjdGl2ZUNsaWVudCA9IHVzZVNlY3VyZVN0b3JhZ2UgPyBsbG1TZWN1cmVDbGllbnQgOiBsbG1DbGllbnQ7XG5cbiAgbG9nZ2VyLmluZm8oXCJMTE1Qcm92aWRlciB1c2luZyBjbGllbnQ6XCIsIHtcbiAgICB1c2VTZWN1cmVTdG9yYWdlLFxuICAgIGNsaWVudFR5cGU6IHVzZVNlY3VyZVN0b3JhZ2UgPyBcIkxMTVNlY3VyZUNsaWVudFwiIDogXCJMTE1DbGllbnRcIixcbiAgfSk7XG5cbiAgLy8gTG9hZCBpbml0aWFsIHNldHRpbmdzIGZyb20gdGhlIGNsaWVudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvZ2dlci5pbmZvKFwiTG9hZGluZyBpbml0aWFsIHNldHRpbmdzIGZyb20gY2xpZW50XCIpO1xuXG4gICAgaWYgKCFhY3RpdmVDbGllbnQpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiTm8gYWN0aXZlIGNsaWVudCBhdmFpbGFibGUsIHVzaW5nIGRlZmF1bHRzXCIpO1xuICAgICAgc2V0U2V0dGluZ3MobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsaWVudFNldHRpbmdzID0gYWN0aXZlQ2xpZW50LmdldFNldHRpbmdzKCk7XG4gICAgICBsb2dnZXIuaW5mbyhcIlJldHJpZXZlZCBzZXR0aW5ncyBmcm9tIGNsaWVudDpcIiwge1xuICAgICAgICBwcm92aWRlcjogY2xpZW50U2V0dGluZ3M/LnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogY2xpZW50U2V0dGluZ3M/Lm1vZGVsLFxuICAgICAgICBoYXNBcGlLZXk6ICEhY2xpZW50U2V0dGluZ3M/LmFwaUtleSxcbiAgICAgICAgaGFzQXBpS2V5U2Vzc2lvbklkOiAhIWNsaWVudFNldHRpbmdzPy5hcGlLZXlTZXNzaW9uSWQsXG4gICAgICAgIGhhc1NlcnZlclJlZjpcbiAgICAgICAgICBjbGllbnRTZXR0aW5ncyAmJlxuICAgICAgICAgIHR5cGVvZiBjbGllbnRTZXR0aW5ncyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgIFwiX19zZXJ2ZXJfcmVmXCIgaW4gY2xpZW50U2V0dGluZ3MsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGNsZWFuIG1lcmdlZCBzZXR0aW5ncyB3aXRoIHJvYnVzdCBudWxsL3VuZGVmaW5lZCBoYW5kbGluZ1xuICAgICAgY29uc3QgbWVyZ2VkU2V0dGluZ3M6IExMTVNldHRpbmdzID0ge1xuICAgICAgICBwcm92aWRlcjogY2xpZW50U2V0dGluZ3M/LnByb3ZpZGVyIHx8IFwib3BlbmFpXCIsXG4gICAgICAgIG1vZGVsOiBjbGllbnRTZXR0aW5ncz8ubW9kZWwgfHwgXCJncHQtNG9cIixcbiAgICAgICAgdGVtcGVyYXR1cmU6XG4gICAgICAgICAgdHlwZW9mIGNsaWVudFNldHRpbmdzPy50ZW1wZXJhdHVyZSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyBjbGllbnRTZXR0aW5ncy50ZW1wZXJhdHVyZVxuICAgICAgICAgICAgOiAwLjcsXG4gICAgICAgIG1heFRva2VuczpcbiAgICAgICAgICB0eXBlb2YgY2xpZW50U2V0dGluZ3M/Lm1heFRva2VucyA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyBjbGllbnRTZXR0aW5ncy5tYXhUb2tlbnNcbiAgICAgICAgICAgIDogMTAyNCxcbiAgICAgICAgdG9wUDpcbiAgICAgICAgICB0eXBlb2YgY2xpZW50U2V0dGluZ3M/LnRvcFAgPT09IFwibnVtYmVyXCIgPyBjbGllbnRTZXR0aW5ncy50b3BQIDogMC45LFxuICAgICAgICBmcmVxdWVuY3lQZW5hbHR5OlxuICAgICAgICAgIHR5cGVvZiBjbGllbnRTZXR0aW5ncz8uZnJlcXVlbmN5UGVuYWx0eSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyBjbGllbnRTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5XG4gICAgICAgICAgICA6IDAsXG4gICAgICAgIHByZXNlbmNlUGVuYWx0eTpcbiAgICAgICAgICB0eXBlb2YgY2xpZW50U2V0dGluZ3M/LnByZXNlbmNlUGVuYWx0eSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyBjbGllbnRTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHlcbiAgICAgICAgICAgIDogMCxcbiAgICAgICAgc3lzdGVtRmluZ2VycHJpbnQ6XG4gICAgICAgICAgdHlwZW9mIGNsaWVudFNldHRpbmdzPy5zeXN0ZW1GaW5nZXJwcmludCA9PT0gXCJib29sZWFuXCJcbiAgICAgICAgICAgID8gY2xpZW50U2V0dGluZ3Muc3lzdGVtRmluZ2VycHJpbnRcbiAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIC8vIEhhbmRsZSBvcHRpb25hbCBwcm9wZXJ0aWVzIC0gb25seSBpbmNsdWRlIGlmIHRoZXkgaGF2ZSB2YWxpZCB2YWx1ZXNcbiAgICAgICAgLi4uKGNsaWVudFNldHRpbmdzPy5hcGlLZXkgJiYgeyBhcGlLZXk6IGNsaWVudFNldHRpbmdzLmFwaUtleSB9KSxcbiAgICAgICAgLi4uKGNsaWVudFNldHRpbmdzPy5hcGlLZXlTZXNzaW9uSWQgJiYge1xuICAgICAgICAgIGFwaUtleVNlc3Npb25JZDogY2xpZW50U2V0dGluZ3MuYXBpS2V5U2Vzc2lvbklkLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBjbGllbnRTZXR0aW5ncz8ubWF4QXV0b25vbW91c01lc3NhZ2VzID09PSBcIm51bWJlclwiICYmIHtcbiAgICAgICAgICBtYXhBdXRvbm9tb3VzTWVzc2FnZXM6IGNsaWVudFNldHRpbmdzLm1heEF1dG9ub21vdXNNZXNzYWdlcyxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgY2xpZW50U2V0dGluZ3M/LmNvbnZlcnNhdGlvbkNvb2xkb3duID09PSBcIm51bWJlclwiICYmIHtcbiAgICAgICAgICBjb252ZXJzYXRpb25Db29sZG93bjogY2xpZW50U2V0dGluZ3MuY29udmVyc2F0aW9uQ29vbGRvd24sXG4gICAgICAgIH0pLFxuICAgICAgfTtcblxuICAgICAgc2V0U2V0dGluZ3MobWVyZ2VkU2V0dGluZ3MpO1xuXG4gICAgICBsb2dnZXIuaW5mbyhcIkxMTSBjb250ZXh0IGluaXRpYWxpemVkIHdpdGggc2V0dGluZ3M6XCIsIHtcbiAgICAgICAgcHJvdmlkZXI6IG1lcmdlZFNldHRpbmdzLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogbWVyZ2VkU2V0dGluZ3MubW9kZWwsXG4gICAgICAgIGhhc0FwaUtleTogISFtZXJnZWRTZXR0aW5ncy5hcGlLZXksXG4gICAgICAgIGhhc0FwaUtleVNlc3Npb25JZDogISFtZXJnZWRTZXR0aW5ncy5hcGlLZXlTZXNzaW9uSWQsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgbG9hZGluZyBpbml0aWFsIHNldHRpbmdzOlwiLCBlcnJvcik7XG4gICAgICBzZXRTZXR0aW5ncyhudWxsKTtcbiAgICB9XG4gIH0sIFthY3RpdmVDbGllbnRdKTtcblxuICAvLyBVcGRhdGUgc2V0dGluZ3MgaW4gdGhlIGNsaWVudFxuICBjb25zdCB1cGRhdGVTZXR0aW5ncyA9IChuZXdTZXR0aW5nczogUGFydGlhbDxMTE1TZXR0aW5ncz4pID0+IHtcbiAgICBsb2dnZXIuaW5mbyhcInVwZGF0ZVNldHRpbmdzIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICBwcm92aWRlcjogbmV3U2V0dGluZ3MucHJvdmlkZXIsXG4gICAgICBtb2RlbDogbmV3U2V0dGluZ3MubW9kZWwsXG4gICAgICBoYXNBcGlLZXk6ICEhbmV3U2V0dGluZ3MuYXBpS2V5LFxuICAgICAgaGFzQXBpS2V5U2Vzc2lvbklkOiAhIW5ld1NldHRpbmdzLmFwaUtleVNlc3Npb25JZCxcbiAgICB9KTtcblxuICAgIGlmICghbmV3U2V0dGluZ3MgfHwgdHlwZW9mIG5ld1NldHRpbmdzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHNldHRpbmdzIHVwZGF0ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gTWVyZ2UgbmV3IHNldHRpbmdzIHdpdGggY3VycmVudCBzZXR0aW5ncywgZW5zdXJpbmcgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50XG4gICAgICBjb25zdCB1cGRhdGVkU2V0dGluZ3M6IExMTVNldHRpbmdzID0ge1xuICAgICAgICAvLyBQcm92aWRlIGRlZmF1bHRzIGZvciByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgcHJvdmlkZXI6IG5ld1NldHRpbmdzLnByb3ZpZGVyIHx8IHNldHRpbmdzPy5wcm92aWRlciB8fCBcIm9wZW5haVwiLFxuICAgICAgICBtb2RlbDogbmV3U2V0dGluZ3MubW9kZWwgfHwgc2V0dGluZ3M/Lm1vZGVsIHx8IFwiZ3B0LTRvXCIsXG4gICAgICAgIHRlbXBlcmF0dXJlOiBuZXdTZXR0aW5ncy50ZW1wZXJhdHVyZSA/PyBzZXR0aW5ncz8udGVtcGVyYXR1cmUgPz8gMC43LFxuICAgICAgICBtYXhUb2tlbnM6IG5ld1NldHRpbmdzLm1heFRva2VucyA/PyBzZXR0aW5ncz8ubWF4VG9rZW5zID8/IDEwMjQsXG4gICAgICAgIHRvcFA6IG5ld1NldHRpbmdzLnRvcFAgPz8gc2V0dGluZ3M/LnRvcFAgPz8gMC45LFxuICAgICAgICBmcmVxdWVuY3lQZW5hbHR5OlxuICAgICAgICAgIG5ld1NldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHkgPz8gc2V0dGluZ3M/LmZyZXF1ZW5jeVBlbmFsdHkgPz8gMCxcbiAgICAgICAgcHJlc2VuY2VQZW5hbHR5OlxuICAgICAgICAgIG5ld1NldHRpbmdzLnByZXNlbmNlUGVuYWx0eSA/PyBzZXR0aW5ncz8ucHJlc2VuY2VQZW5hbHR5ID8/IDAsXG4gICAgICAgIHN5c3RlbUZpbmdlcnByaW50OlxuICAgICAgICAgIG5ld1NldHRpbmdzLnN5c3RlbUZpbmdlcnByaW50ID8/IHNldHRpbmdzPy5zeXN0ZW1GaW5nZXJwcmludCA/PyBmYWxzZSxcbiAgICAgICAgLy8gSGFuZGxlIG9wdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgICAgLi4uKG5ld1NldHRpbmdzLmFwaUtleSAhPT0gdW5kZWZpbmVkICYmIHsgYXBpS2V5OiBuZXdTZXR0aW5ncy5hcGlLZXkgfSksXG4gICAgICAgIC4uLihuZXdTZXR0aW5ncy5hcGlLZXlTZXNzaW9uSWQgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgICAgYXBpS2V5U2Vzc2lvbklkOiBuZXdTZXR0aW5ncy5hcGlLZXlTZXNzaW9uSWQsXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4obmV3U2V0dGluZ3MubWF4QXV0b25vbW91c01lc3NhZ2VzICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgIG1heEF1dG9ub21vdXNNZXNzYWdlczogbmV3U2V0dGluZ3MubWF4QXV0b25vbW91c01lc3NhZ2VzLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKG5ld1NldHRpbmdzLmNvbnZlcnNhdGlvbkNvb2xkb3duICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgIGNvbnZlcnNhdGlvbkNvb2xkb3duOiBuZXdTZXR0aW5ncy5jb252ZXJzYXRpb25Db29sZG93bixcbiAgICAgICAgfSksXG4gICAgICB9O1xuXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcbiAgICAgIHNldFNldHRpbmdzKHVwZGF0ZWRTZXR0aW5ncyk7XG5cbiAgICAgIC8vIFVwZGF0ZSBjbGllbnQgc2V0dGluZ3NcbiAgICAgIGlmIChhY3RpdmVDbGllbnQgJiYgdHlwZW9mIGFjdGl2ZUNsaWVudC51cGRhdGVTZXR0aW5ncyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGFjdGl2ZUNsaWVudC51cGRhdGVTZXR0aW5ncyh1cGRhdGVkU2V0dGluZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiYWN0aXZlQ2xpZW50LnVwZGF0ZVNldHRpbmdzIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHVwZGF0aW5nIHNldHRpbmdzOlwiLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNhdmUgc2V0dGluZ3MgdG8gdGhlIHNlcnZlclxuICBjb25zdCBzYXZlU2V0dGluZ3MgPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgbG9nZ2VyLmluZm8oXCJzYXZlU2V0dGluZ3MgY2FsbGVkXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoYWN0aXZlQ2xpZW50ICYmIHR5cGVvZiBhY3RpdmVDbGllbnQuc2F2ZVNldHRpbmdzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFjdGl2ZUNsaWVudC5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcImFjdGl2ZUNsaWVudC5zYXZlU2V0dGluZ3MgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBzYXZpbmcgc2V0dGluZ3M6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29udGV4dCB2YWx1ZVxuICBjb25zdCB2YWx1ZSA9IHtcbiAgICBjbGllbnQ6IGFjdGl2ZUNsaWVudCxcbiAgICBzZXR0aW5ncyxcbiAgICB1cGRhdGVTZXR0aW5ncyxcbiAgICBzYXZlU2V0dGluZ3MsXG4gICAgaXNQcm9jZXNzaW5nLFxuICAgIHNldElzUHJvY2Vzc2luZyxcbiAgICBjbGllbnRUeXBlOiAodXNlU2VjdXJlU3RvcmFnZSA/IFwiTExNU2VjdXJlQ2xpZW50XCIgOiBcIkxMTUNsaWVudFwiKSBhc1xuICAgICAgfCBcIkxMTVNlY3VyZUNsaWVudFwiXG4gICAgICB8IFwiTExNQ2xpZW50XCIsXG4gIH07XG5cbiAgbG9nZ2VyLmluZm8oXCJMTE1Qcm92aWRlciByZW5kZXJpbmcgd2l0aCBjb250ZXh0IHZhbHVlOlwiLCB7XG4gICAgY2xpZW50QXZhaWxhYmxlOiAhIXZhbHVlLmNsaWVudCxcbiAgICBjbGllbnRUeXBlOiB1c2VTZWN1cmVTdG9yYWdlID8gXCJMTE1TZWN1cmVDbGllbnRcIiA6IFwiTExNQ2xpZW50XCIsXG4gICAgc2V0dGluZ3NQcm92aWRlcjogdmFsdWUuc2V0dGluZ3M/LnByb3ZpZGVyLFxuICAgIHNldHRpbmdzTW9kZWw6IHZhbHVlLnNldHRpbmdzPy5tb2RlbCxcbiAgICBpc1Byb2Nlc3Npbmc6IHZhbHVlLmlzUHJvY2Vzc2luZyxcbiAgfSk7XG5cbiAgcmV0dXJuIDxMTE1Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+e2NoaWxkcmVufTwvTExNQ29udGV4dC5Qcm92aWRlcj47XG59XG5cbi8vIEhvb2sgdG8gdXNlIHRoZSBMTE0gY29udGV4dFxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxMTSgpIHtcbiAgbG9nZ2VyLmluZm8oXCJ1c2VMTE0gaG9vayBjYWxsZWRcIik7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KExMTUNvbnRleHQpO1xuICBsb2dnZXIuaW5mbyhcInVzZUxMTSByZXR1cm5pbmcgY29udGV4dCB3aXRoOlwiLCB7XG4gICAgY2xpZW50QXZhaWxhYmxlOiAhIWNvbnRleHQuY2xpZW50LFxuICAgIGNsaWVudFR5cGU6IGNvbnRleHQuY2xpZW50VHlwZSxcbiAgICBzZXR0aW5nc1Byb3ZpZGVyOiBjb250ZXh0LnNldHRpbmdzPy5wcm92aWRlcixcbiAgICBzZXR0aW5nc01vZGVsOiBjb250ZXh0LnNldHRpbmdzPy5tb2RlbCxcbiAgICBpc1Byb2Nlc3Npbmc6IGNvbnRleHQuaXNQcm9jZXNzaW5nLFxuICB9KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG4iXSwibmFtZXMiOlsiTExNUHJvdmlkZXIiLCJ1c2VMTE0iLCJsb2dnZXIiLCJjcmVhdGVMb2dnZXIiLCJMTE1Db250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNsaWVudCIsImlzRmVhdHVyZUVuYWJsZWQiLCJsbG1TZWN1cmVDbGllbnQiLCJsbG1DbGllbnQiLCJzZXR0aW5ncyIsInVwZGF0ZVNldHRpbmdzIiwic2F2ZVNldHRpbmdzIiwiaXNQcm9jZXNzaW5nIiwic2V0SXNQcm9jZXNzaW5nIiwiY2xpZW50VHlwZSIsImNoaWxkcmVuIiwiaW5mbyIsInNldFNldHRpbmdzIiwidXNlU3RhdGUiLCJ1c2VTZWN1cmVTdG9yYWdlIiwiYWN0aXZlQ2xpZW50IiwidXNlRWZmZWN0IiwiY2xpZW50U2V0dGluZ3MiLCJnZXRTZXR0aW5ncyIsInByb3ZpZGVyIiwibW9kZWwiLCJoYXNBcGlLZXkiLCJhcGlLZXkiLCJoYXNBcGlLZXlTZXNzaW9uSWQiLCJhcGlLZXlTZXNzaW9uSWQiLCJoYXNTZXJ2ZXJSZWYiLCJtZXJnZWRTZXR0aW5ncyIsInRlbXBlcmF0dXJlIiwibWF4VG9rZW5zIiwidG9wUCIsImZyZXF1ZW5jeVBlbmFsdHkiLCJwcmVzZW5jZVBlbmFsdHkiLCJzeXN0ZW1GaW5nZXJwcmludCIsIm1heEF1dG9ub21vdXNNZXNzYWdlcyIsImNvbnZlcnNhdGlvbkNvb2xkb3duIiwiZXJyb3IiLCJuZXdTZXR0aW5ncyIsInVwZGF0ZWRTZXR0aW5ncyIsInVuZGVmaW5lZCIsInZhbHVlIiwiY2xpZW50QXZhaWxhYmxlIiwic2V0dGluZ3NQcm92aWRlciIsInNldHRpbmdzTW9kZWwiLCJQcm92aWRlciIsImNvbnRleHQiLCJ1c2VDb250ZXh0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0lBK0NnQkEsV0FBVztlQUFYQTs7SUEyTEFDLE1BQU07ZUFBTkE7Ozs7K0RBbE9UOzJCQUVtQjtpQ0FDTTs4QkFDQzs2QkFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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