f6cf3970285dbb35b934f3e5ca5316f8
/**
 * Specialized Services Tests
 *
 * Tests for compression workers, provider monitoring, knowledge graph utilities,
 * and other specialized service components following ADR-007 requirements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Set short timeout for all tests
_globals.jest.setTimeout(1000);
// Mock Worker for compression service
global.Worker = _globals.jest.fn(()=>({
        postMessage: _globals.jest.fn(),
        terminate: _globals.jest.fn(),
        onmessage: null,
        onerror: null
    }));
// Mock IndexedDB for storage services
global.indexedDB = {
    open: _globals.jest.fn(()=>({
            onsuccess: null,
            onerror: null,
            onupgradeneeded: null,
            result: {
                createObjectStore: _globals.jest.fn(()=>({
                        createIndex: _globals.jest.fn()
                    })),
                transaction: _globals.jest.fn(()=>({
                        objectStore: _globals.jest.fn(()=>({
                                add: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                get: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                delete: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                put: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                getAll: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                clear: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    }))
                            }))
                    }))
            }
        })),
    deleteDatabase: _globals.jest.fn()
};
class CompressionWorker {
    constructor(){
        this.pendingJobs = new Map();
        this.worker = new Worker("/workers/compression.js");
        this.worker.onmessage = this.handleMessage.bind(this);
        this.worker.onerror = this.handleError.bind(this);
    }
    handleMessage(event) {
        const { id, result, error } = event.data;
        const job = this.pendingJobs.get(id);
        if (job) {
            if (error) {
                job.reject(new Error(error));
            } else {
                job.resolve(result);
            }
            this.pendingJobs.delete(id);
        }
    }
    handleError(error) {
        console.error("Compression worker error:", error);
        // Reject all pending jobs
        this.pendingJobs.forEach(({ reject })=>reject(error));
        this.pendingJobs.clear();
    }
    async compress(data, options) {
        const id = Math.random().toString(36);
        return new Promise((resolve, reject)=>{
            this.pendingJobs.set(id, {
                resolve,
                reject
            });
            this.worker.postMessage({
                id,
                action: "compress",
                data,
                options
            });
        });
    }
    async decompress(data, algorithm) {
        const id = Math.random().toString(36);
        return new Promise((resolve, reject)=>{
            this.pendingJobs.set(id, {
                resolve,
                reject
            });
            this.worker.postMessage({
                id,
                action: "decompress",
                data,
                algorithm
            });
        });
    }
    terminate() {
        this.worker.terminate();
        this.pendingJobs.clear();
    }
}
class ProviderMonitoringService {
    recordMetric(providerId, metric) {
        if (!this.metrics.has(providerId)) {
            this.metrics.set(providerId, []);
        }
        const providerMetrics = this.metrics.get(providerId);
        providerMetrics.push(metric);
        // Keep only last 100 metrics
        if (providerMetrics.length > 100) {
            providerMetrics.shift();
        }
        this.checkThresholds(providerId, metric);
    }
    checkThresholds(providerId, metric) {
        const alerts = [];
        if (metric.responseTime > this.thresholds.responseTime) {
            alerts.push({
                id: Math.random().toString(36),
                providerId,
                severity: "warning",
                message: `High response time: ${metric.responseTime}ms`,
                timestamp: new Date(),
                resolved: false
            });
        }
        if (metric.errorRate > this.thresholds.errorRate) {
            alerts.push({
                id: Math.random().toString(36),
                providerId,
                severity: "error",
                message: `High error rate: ${(metric.errorRate * 100).toFixed(2)}%`,
                timestamp: new Date(),
                resolved: false
            });
        }
        if (metric.availability < this.thresholds.availability) {
            alerts.push({
                id: Math.random().toString(36),
                providerId,
                severity: "critical",
                message: `Low availability: ${(metric.availability * 100).toFixed(2)}%`,
                timestamp: new Date(),
                resolved: false
            });
        }
        this.alerts.push(...alerts);
    }
    getMetrics(providerId) {
        return this.metrics.get(providerId) || [];
    }
    getAggregatedMetrics(providerId) {
        const metrics = this.getMetrics(providerId);
        if (metrics.length === 0) return {};
        return {
            responseTime: metrics.reduce((sum, m)=>sum + m.responseTime, 0) / metrics.length,
            successRate: metrics.reduce((sum, m)=>sum + m.successRate, 0) / metrics.length,
            errorRate: metrics.reduce((sum, m)=>sum + m.errorRate, 0) / metrics.length,
            throughput: metrics.reduce((sum, m)=>sum + m.throughput, 0) / metrics.length,
            availability: metrics.reduce((sum, m)=>sum + m.availability, 0) / metrics.length,
            cost: metrics.reduce((sum, m)=>sum + m.cost, 0)
        };
    }
    getAlerts(providerId) {
        return providerId ? this.alerts.filter((alert)=>alert.providerId === providerId) : this.alerts;
    }
    resolveAlert(alertId) {
        const alert = this.alerts.find((a)=>a.id === alertId);
        if (alert) {
            alert.resolved = true;
            return true;
        }
        return false;
    }
    clearResolvedAlerts() {
        this.alerts = this.alerts.filter((alert)=>!alert.resolved);
    }
    constructor(){
        this.metrics = new Map();
        this.alerts = [];
        this.thresholds = {
            responseTime: 1000,
            errorRate: 0.05,
            availability: 0.95
        };
    }
}
class KnowledgeGraphExportService {
    constructor(){
        this.compressionWorker = new CompressionWorker();
    }
    async exportGraph(nodes, edges, options) {
        // Filter nodes and edges
        let filteredNodes = this.filterNodes(nodes, options);
        let filteredEdges = this.filterEdges(edges, options);
        // Generate export data based on format
        let exportData;
        switch(options.format){
            case "json":
                exportData = this.exportToJSON(filteredNodes, filteredEdges, options);
                break;
            case "csv":
                exportData = this.exportToCSV(filteredNodes, filteredEdges, options);
                break;
            case "gexf":
                exportData = this.exportToGEXF(filteredNodes, filteredEdges, options);
                break;
            case "graphml":
                exportData = this.exportToGraphML(filteredNodes, filteredEdges, options);
                break;
            default:
                throw new Error(`Unsupported export format: ${options.format}`);
        }
        // Compress if requested
        if (options.compressed && this.compressionWorker) {
            return await this.compressionWorker.compress(exportData, {
                algorithm: "gzip",
                level: 6,
                chunkSize: 1024 * 1024
            });
        }
        return exportData;
    }
    filterNodes(nodes, options) {
        let filtered = nodes;
        if (options.filterByType) {
            filtered = filtered.filter((node)=>options.filterByType.includes(node.type));
        }
        if (options.filterByConfidence !== undefined) {
            filtered = filtered.filter((node)=>node.metadata.confidence >= options.filterByConfidence);
        }
        return filtered;
    }
    filterEdges(edges, options) {
        return edges; // Simple implementation
    }
    exportToJSON(nodes, edges, options) {
        const data = {
            nodes: options.includeMetadata ? nodes : nodes.map(({ metadata, ...node })=>node),
            edges: edges,
            exportInfo: {
                timestamp: new Date().toISOString(),
                nodeCount: nodes.length,
                edgeCount: edges.length,
                options
            }
        };
        return JSON.stringify(data, null, 2);
    }
    exportToCSV(nodes, edges, options) {
        const nodeHeaders = [
            "id",
            "type",
            "properties"
        ];
        if (options.includeMetadata) {
            nodeHeaders.push("created", "updated", "confidence");
        }
        const edgeHeaders = [
            "id",
            "source",
            "target",
            "type",
            "weight",
            "properties"
        ];
        let csv = "NODES\n";
        csv += nodeHeaders.join(",") + "\n";
        nodes.forEach((node)=>{
            const row = [
                node.id,
                node.type,
                JSON.stringify(node.properties).replace(/"/g, '""')
            ];
            if (options.includeMetadata) {
                row.push(node.metadata.created.toISOString(), node.metadata.updated.toISOString(), node.metadata.confidence.toString());
            }
            csv += row.join(",") + "\n";
        });
        csv += "\nEDGES\n";
        csv += edgeHeaders.join(",") + "\n";
        edges.forEach((edge)=>{
            const row = [
                edge.id,
                edge.source,
                edge.target,
                edge.type,
                edge.weight.toString(),
                JSON.stringify(edge.properties).replace(/"/g, '""')
            ];
            csv += row.join(",") + "\n";
        });
        return csv;
    }
    exportToGEXF(nodes, edges, options) {
        let gexf = '<?xml version="1.0" encoding="UTF-8"?>\n';
        gexf += '<gexf xmlns="http://www.gexf.net/1.2draft" version="1.2">\n';
        gexf += '  <graph mode="static" defaultedgetype="directed">\n';
        // Nodes
        gexf += "    <nodes>\n";
        nodes.forEach((node)=>{
            gexf += `      <node id="${node.id}" label="${node.type}"/>\n`;
        });
        gexf += "    </nodes>\n";
        // Edges
        gexf += "    <edges>\n";
        edges.forEach((edge)=>{
            gexf += `      <edge id="${edge.id}" source="${edge.source}" target="${edge.target}" weight="${edge.weight}"/>\n`;
        });
        gexf += "    </edges>\n";
        gexf += "  </graph>\n";
        gexf += "</gexf>";
        return gexf;
    }
    exportToGraphML(nodes, edges, options) {
        let graphml = '<?xml version="1.0" encoding="UTF-8"?>\n';
        graphml += '<graphml xmlns="http://graphml.graphdrawing.org/xmlns">\n';
        graphml += '  <graph id="knowledge-graph" edgedefault="directed">\n';
        // Nodes
        nodes.forEach((node)=>{
            graphml += `    <node id="${node.id}"/>\n`;
        });
        // Edges
        edges.forEach((edge)=>{
            graphml += `    <edge source="${edge.source}" target="${edge.target}"/>\n`;
        });
        graphml += "  </graph>\n";
        graphml += "</graphml>";
        return graphml;
    }
    terminate() {
        if (this.compressionWorker) {
            this.compressionWorker.terminate();
        }
    }
}
// Storage Service with IndexedDB
class AdvancedStorageService {
    async initialize() {
        return new Promise((resolve, reject)=>{
            const request = indexedDB.open(this.dbName, this.version);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>{
                this.db = request.result;
                resolve();
            };
            request.onupgradeneeded = (event)=>{
                const db = event.target.result;
                // Create object stores
                if (!db.objectStoreNames.contains("agents")) {
                    const agentsStore = db.createObjectStore("agents", {
                        keyPath: "id"
                    });
                    agentsStore.createIndex("type", "type", {
                        unique: false
                    });
                }
                if (!db.objectStoreNames.contains("conversations")) {
                    const conversationsStore = db.createObjectStore("conversations", {
                        keyPath: "id"
                    });
                    conversationsStore.createIndex("timestamp", "timestamp", {
                        unique: false
                    });
                }
                if (!db.objectStoreNames.contains("knowledge")) {
                    const knowledgeStore = db.createObjectStore("knowledge", {
                        keyPath: "id"
                    });
                    knowledgeStore.createIndex("type", "type", {
                        unique: false
                    });
                }
            };
        });
    }
    async store(storeName, data) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.add(data);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve();
        });
    }
    async retrieve(storeName, id) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readonly");
            const store = transaction.objectStore(storeName);
            const request = store.get(id);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve(request.result);
        });
    }
    async retrieveAll(storeName) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readonly");
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve(request.result);
        });
    }
    async update(storeName, data) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.put(data);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve();
        });
    }
    async delete(storeName, id) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.delete(id);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve();
        });
    }
    async clear(storeName) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.clear();
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve();
        });
    }
    constructor(){
        this.dbName = "FreeAgenticsDB";
        this.version = 1;
    }
}
// Tests
describe("Specialized Services", ()=>{
    describe("CompressionWorker", ()=>{
        let compressionWorker;
        beforeEach(()=>{
            compressionWorker = new CompressionWorker();
        });
        afterEach(()=>{
            compressionWorker.terminate();
        });
        test("should create worker instance", ()=>{
            expect(compressionWorker).toBeDefined();
            expect(Worker).toHaveBeenCalledWith("/workers/compression.js");
        });
        test("should compress data", async ()=>{
            const testData = "Hello, World!";
            const options = {
                algorithm: "gzip",
                level: 6,
                chunkSize: 1024
            };
            // Mock successful compression
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: new ArrayBuffer(8)
                    }
                });
            }, 10);
            const result = await compressionWorker.compress(testData, options);
            expect(result).toBeInstanceOf(ArrayBuffer);
        });
        test("should decompress data", async ()=>{
            const testData = new ArrayBuffer(8);
            const algorithm = "gzip";
            // Mock successful decompression
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: "Hello, World!"
                    }
                });
            }, 10);
            const result = await compressionWorker.decompress(testData, algorithm);
            expect(result).toBe("Hello, World!");
        });
        test("should handle compression errors", async ()=>{
            const testData = "Hello, World!";
            const options = {
                algorithm: "gzip",
                level: 6,
                chunkSize: 1024
            };
            // Mock compression error
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        error: "Compression failed"
                    }
                });
            }, 10);
            await expect(compressionWorker.compress(testData, options)).rejects.toThrow("Compression failed");
        });
        test("should handle worker errors", ()=>{
            const mockWorker = Worker.mock.results[0].value;
            const errorEvent = new ErrorEvent("error", {
                message: "Worker crashed"
            });
            expect(()=>{
                mockWorker.onerror(errorEvent);
            }).not.toThrow();
        });
    });
    describe("ProviderMonitoringService", ()=>{
        let monitoringService;
        beforeEach(()=>{
            monitoringService = new ProviderMonitoringService();
        });
        test("should record metrics", ()=>{
            const metric = {
                responseTime: 500,
                successRate: 0.95,
                errorRate: 0.05,
                throughput: 100,
                availability: 0.99,
                cost: 0.001
            };
            monitoringService.recordMetric("provider1", metric);
            const metrics = monitoringService.getMetrics("provider1");
            expect(metrics).toHaveLength(1);
            expect(metrics[0]).toEqual(metric);
        });
        test("should generate alerts for threshold violations", ()=>{
            const highLatencyMetric = {
                responseTime: 2000,
                successRate: 0.95,
                errorRate: 0.05,
                throughput: 100,
                availability: 0.99,
                cost: 0.001
            };
            monitoringService.recordMetric("provider1", highLatencyMetric);
            const alerts = monitoringService.getAlerts("provider1");
            expect(alerts).toHaveLength(1);
            expect(alerts[0].severity).toBe("warning");
            expect(alerts[0].message).toContain("High response time");
        });
        test("should calculate aggregated metrics", ()=>{
            const metrics = [
                {
                    responseTime: 400,
                    successRate: 0.95,
                    errorRate: 0.05,
                    throughput: 100,
                    availability: 0.99,
                    cost: 0.001
                },
                {
                    responseTime: 600,
                    successRate: 0.98,
                    errorRate: 0.02,
                    throughput: 120,
                    availability: 0.97,
                    cost: 0.002
                }
            ];
            metrics.forEach((metric)=>{
                monitoringService.recordMetric("provider1", metric);
            });
            const aggregated = monitoringService.getAggregatedMetrics("provider1");
            expect(aggregated.responseTime).toBe(500); // Average
            expect(aggregated.successRate).toBeCloseTo(0.965, 3);
            expect(aggregated.cost).toBe(0.003); // Sum
        });
        test("should resolve alerts", ()=>{
            const metric = {
                responseTime: 2000,
                successRate: 0.95,
                errorRate: 0.1,
                throughput: 100,
                availability: 0.9,
                cost: 0.001
            };
            monitoringService.recordMetric("provider1", metric);
            const alerts = monitoringService.getAlerts("provider1");
            expect(alerts.length).toBeGreaterThan(0);
            const alertId = alerts[0].id;
            const resolved = monitoringService.resolveAlert(alertId);
            expect(resolved).toBe(true);
            expect(alerts[0].resolved).toBe(true);
        });
        test("should clear resolved alerts", ()=>{
            const metric = {
                responseTime: 2000,
                successRate: 0.95,
                errorRate: 0.1,
                throughput: 100,
                availability: 0.9,
                cost: 0.001
            };
            monitoringService.recordMetric("provider1", metric);
            const alerts = monitoringService.getAlerts();
            // Resolve all alerts
            alerts.forEach((alert)=>{
                monitoringService.resolveAlert(alert.id);
            });
            monitoringService.clearResolvedAlerts();
            const remainingAlerts = monitoringService.getAlerts();
            expect(remainingAlerts).toHaveLength(0);
        });
    });
    describe("KnowledgeGraphExportService", ()=>{
        let exportService;
        let mockNodes;
        let mockEdges;
        beforeEach(()=>{
            exportService = new KnowledgeGraphExportService();
            mockNodes = [
                {
                    id: "node1",
                    type: "agent",
                    properties: {
                        name: "Agent 1"
                    },
                    metadata: {
                        created: new Date("2023-01-01"),
                        updated: new Date("2023-01-02"),
                        confidence: 0.9
                    }
                },
                {
                    id: "node2",
                    type: "concept",
                    properties: {
                        name: "Concept 1"
                    },
                    metadata: {
                        created: new Date("2023-01-01"),
                        updated: new Date("2023-01-02"),
                        confidence: 0.8
                    }
                }
            ];
            mockEdges = [
                {
                    id: "edge1",
                    source: "node1",
                    target: "node2",
                    type: "knows",
                    weight: 0.7,
                    properties: {
                        strength: "strong"
                    }
                }
            ];
        });
        afterEach(()=>{
            exportService.terminate();
        });
        test("should export to JSON format", async ()=>{
            const options = {
                format: "json",
                includeMetadata: true
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(typeof result).toBe("string");
            const parsed = JSON.parse(result);
            expect(parsed.nodes).toHaveLength(2);
            expect(parsed.edges).toHaveLength(1);
            expect(parsed.nodes[0].metadata).toBeDefined();
        });
        test("should export to CSV format", async ()=>{
            const options = {
                format: "csv",
                includeMetadata: false
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(typeof result).toBe("string");
            expect(result).toContain("NODES");
            expect(result).toContain("EDGES");
            expect(result).toContain("node1,agent");
        });
        test("should export to GEXF format", async ()=>{
            const options = {
                format: "gexf",
                includeMetadata: false
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(typeof result).toBe("string");
            expect(result).toContain('<?xml version="1.0"');
            expect(result).toContain("<gexf xmlns=");
            expect(result).toContain('<node id="node1"');
        });
        test("should export to GraphML format", async ()=>{
            const options = {
                format: "graphml",
                includeMetadata: false
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(typeof result).toBe("string");
            expect(result).toContain('<?xml version="1.0"');
            expect(result).toContain("<graphml xmlns=");
            expect(result).toContain('<node id="node1"');
        });
        test("should filter by node type", async ()=>{
            const options = {
                format: "json",
                includeMetadata: false,
                filterByType: [
                    "agent"
                ]
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            const parsed = JSON.parse(result);
            expect(parsed.nodes).toHaveLength(1);
            expect(parsed.nodes[0].type).toBe("agent");
        });
        test("should filter by confidence", async ()=>{
            const options = {
                format: "json",
                includeMetadata: true,
                filterByConfidence: 0.85
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            const parsed = JSON.parse(result);
            expect(parsed.nodes).toHaveLength(1);
            expect(parsed.nodes[0].metadata.confidence).toBeGreaterThanOrEqual(0.85);
        });
        test("should handle compression", async ()=>{
            const options = {
                format: "json",
                includeMetadata: true,
                compressed: true
            };
            // Mock compression worker
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: new ArrayBuffer(100)
                    }
                });
            }, 10);
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(result).toBeInstanceOf(ArrayBuffer);
        });
        test("should handle unsupported format", async ()=>{
            const options = {
                format: "unsupported",
                includeMetadata: false
            };
            await expect(exportService.exportGraph(mockNodes, mockEdges, options)).rejects.toThrow("Unsupported export format");
        });
    });
    describe("AdvancedStorageService", ()=>{
        let storageService;
        beforeEach(async ()=>{
            storageService = new AdvancedStorageService();
            // Mock successful initialization
            const mockRequest = {
                onsuccess: null,
                onerror: null,
                onupgradeneeded: null,
                result: {
                    objectStoreNames: {
                        contains: _globals.jest.fn(()=>false)
                    },
                    createObjectStore: _globals.jest.fn(()=>({
                            createIndex: _globals.jest.fn()
                        })),
                    transaction: _globals.jest.fn(()=>({
                            objectStore: _globals.jest.fn(()=>({
                                    add: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    get: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    getAll: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    put: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    delete: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    clear: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        }))
                                }))
                        }))
                }
            };
            global.indexedDB.open.mockReturnValue(mockRequest);
            // Simulate successful initialization
            setTimeout(()=>{
                if (mockRequest.onsuccess) {
                    mockRequest.onsuccess();
                }
            }, 0);
            await storageService.initialize();
        });
        test("should initialize database", async ()=>{
            expect(global.indexedDB.open).toHaveBeenCalledWith("FreeAgenticsDB", 1);
        });
        test("should store data", async ()=>{
            const testData = {
                id: "test1",
                name: "Test Agent"
            };
            // Mock successful store operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        add: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            await expect(storageService.store("agents", testData)).resolves.toBeUndefined();
        });
        test("should retrieve data", async ()=>{
            const testId = "test1";
            const expectedData = {
                id: "test1",
                name: "Test Agent"
            };
            // Mock successful retrieve operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        get: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null,
                                result: expectedData
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            const result = await storageService.retrieve("agents", testId);
            expect(result).toEqual(expectedData);
        });
        test("should retrieve all data", async ()=>{
            const expectedData = [
                {
                    id: "test1",
                    name: "Test Agent 1"
                },
                {
                    id: "test2",
                    name: "Test Agent 2"
                }
            ];
            // Mock successful retrieveAll operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        getAll: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null,
                                result: expectedData
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            const result = await storageService.retrieveAll("agents");
            expect(result).toEqual(expectedData);
        });
        test("should update data", async ()=>{
            const testData = {
                id: "test1",
                name: "Updated Agent"
            };
            // Mock successful update operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        put: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            await expect(storageService.update("agents", testData)).resolves.toBeUndefined();
        });
        test("should delete data", async ()=>{
            const testId = "test1";
            // Mock successful delete operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        delete: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            await expect(storageService.delete("agents", testId)).resolves.toBeUndefined();
        });
        test("should clear store", async ()=>{
            // Mock successful clear operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        clear: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            await expect(storageService.clear("agents")).resolves.toBeUndefined();
        });
        test("should handle database not initialized error", async ()=>{
            const uninitializedService = new AdvancedStorageService();
            await expect(uninitializedService.store("agents", {})).rejects.toThrow("Database not initialized");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vc2VydmljZXMvc3BlY2lhbGl6ZWQtc2VydmljZXMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNwZWNpYWxpemVkIFNlcnZpY2VzIFRlc3RzXG4gKlxuICogVGVzdHMgZm9yIGNvbXByZXNzaW9uIHdvcmtlcnMsIHByb3ZpZGVyIG1vbml0b3JpbmcsIGtub3dsZWRnZSBncmFwaCB1dGlsaXRpZXMsXG4gKiBhbmQgb3RoZXIgc3BlY2lhbGl6ZWQgc2VydmljZSBjb21wb25lbnRzIGZvbGxvd2luZyBBRFItMDA3IHJlcXVpcmVtZW50cy5cbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSBcIkBqZXN0L2dsb2JhbHNcIjtcblxuLy8gU2V0IHNob3J0IHRpbWVvdXQgZm9yIGFsbCB0ZXN0c1xuamVzdC5zZXRUaW1lb3V0KDEwMDApO1xuXG4vLyBNb2NrIFdvcmtlciBmb3IgY29tcHJlc3Npb24gc2VydmljZVxuZ2xvYmFsLldvcmtlciA9IGplc3QuZm4oKCkgPT4gKHtcbiAgcG9zdE1lc3NhZ2U6IGplc3QuZm4oKSxcbiAgdGVybWluYXRlOiBqZXN0LmZuKCksXG4gIG9ubWVzc2FnZTogbnVsbCxcbiAgb25lcnJvcjogbnVsbCxcbn0pKSBhcyBhbnk7XG5cbi8vIE1vY2sgSW5kZXhlZERCIGZvciBzdG9yYWdlIHNlcnZpY2VzXG5nbG9iYWwuaW5kZXhlZERCID0ge1xuICBvcGVuOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgb25zdWNjZXNzOiBudWxsLFxuICAgIG9uZXJyb3I6IG51bGwsXG4gICAgb251cGdyYWRlbmVlZGVkOiBudWxsLFxuICAgIHJlc3VsdDoge1xuICAgICAgY3JlYXRlT2JqZWN0U3RvcmU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgY3JlYXRlSW5kZXg6IGplc3QuZm4oKSxcbiAgICAgIH0pKSxcbiAgICAgIHRyYW5zYWN0aW9uOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIG9iamVjdFN0b3JlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgYWRkOiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgZGVsZXRlOiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgcHV0OiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgZ2V0QWxsOiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgY2xlYXI6IGplc3QuZm4oKCkgPT4gKHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH0pKSxcbiAgICAgICAgfSkpLFxuICAgICAgfSkpLFxuICAgIH0sXG4gIH0pKSxcbiAgZGVsZXRlRGF0YWJhc2U6IGplc3QuZm4oKSxcbn0gYXMgYW55O1xuXG4vLyBDb21wcmVzc2lvbiBXb3JrZXIgU2VydmljZVxuaW50ZXJmYWNlIENvbXByZXNzaW9uT3B0aW9ucyB7XG4gIGFsZ29yaXRobTogXCJnemlwXCIgfCBcImRlZmxhdGVcIiB8IFwiYnJvdGxpXCI7XG4gIGxldmVsOiBudW1iZXI7XG4gIGNodW5rU2l6ZTogbnVtYmVyO1xufVxuXG5jbGFzcyBDb21wcmVzc2lvbldvcmtlciB7XG4gIHByaXZhdGUgd29ya2VyOiBXb3JrZXI7XG4gIHByaXZhdGUgcGVuZGluZ0pvYnM6IE1hcDxzdHJpbmcsIHsgcmVzb2x2ZTogRnVuY3Rpb247IHJlamVjdDogRnVuY3Rpb24gfT4gPVxuICAgIG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoXCIvd29ya2Vycy9jb21wcmVzc2lvbi5qc1wiKTtcbiAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLndvcmtlci5vbmVycm9yID0gdGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNZXNzYWdlKGV2ZW50OiBNZXNzYWdlRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCB7IGlkLCByZXN1bHQsIGVycm9yIH0gPSBldmVudC5kYXRhO1xuICAgIGNvbnN0IGpvYiA9IHRoaXMucGVuZGluZ0pvYnMuZ2V0KGlkKTtcblxuICAgIGlmIChqb2IpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBqb2IucmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9iLnJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0pvYnMuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBFcnJvckV2ZW50KTogdm9pZCB7XG4gICAgY29uc29sZS5lcnJvcihcIkNvbXByZXNzaW9uIHdvcmtlciBlcnJvcjpcIiwgZXJyb3IpO1xuICAgIC8vIFJlamVjdCBhbGwgcGVuZGluZyBqb2JzXG4gICAgdGhpcy5wZW5kaW5nSm9icy5mb3JFYWNoKCh7IHJlamVjdCB9KSA9PiByZWplY3QoZXJyb3IpKTtcbiAgICB0aGlzLnBlbmRpbmdKb2JzLmNsZWFyKCk7XG4gIH1cblxuICBhc3luYyBjb21wcmVzcyhcbiAgICBkYXRhOiBzdHJpbmcgfCBBcnJheUJ1ZmZlcixcbiAgICBvcHRpb25zOiBDb21wcmVzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ0pvYnMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGFjdGlvbjogXCJjb21wcmVzc1wiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBkZWNvbXByZXNzKGRhdGE6IEFycmF5QnVmZmVyLCBhbGdvcml0aG06IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdKb2JzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkLFxuICAgICAgICBhY3Rpb246IFwiZGVjb21wcmVzc1wiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBhbGdvcml0aG0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHRlcm1pbmF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB0aGlzLnBlbmRpbmdKb2JzLmNsZWFyKCk7XG4gIH1cbn1cblxuLy8gUHJvdmlkZXIgTW9uaXRvcmluZyBTZXJ2aWNlXG5pbnRlcmZhY2UgUHJvdmlkZXJNZXRyaWNzIHtcbiAgcmVzcG9uc2VUaW1lOiBudW1iZXI7XG4gIHN1Y2Nlc3NSYXRlOiBudW1iZXI7XG4gIGVycm9yUmF0ZTogbnVtYmVyO1xuICB0aHJvdWdocHV0OiBudW1iZXI7XG4gIGF2YWlsYWJpbGl0eTogbnVtYmVyO1xuICBjb3N0OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBQcm92aWRlckFsZXJ0IHtcbiAgaWQ6IHN0cmluZztcbiAgcHJvdmlkZXJJZDogc3RyaW5nO1xuICBzZXZlcml0eTogXCJpbmZvXCIgfCBcIndhcm5pbmdcIiB8IFwiZXJyb3JcIiB8IFwiY3JpdGljYWxcIjtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICB0aW1lc3RhbXA6IERhdGU7XG4gIHJlc29sdmVkOiBib29sZWFuO1xufVxuXG5jbGFzcyBQcm92aWRlck1vbml0b3JpbmdTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBtZXRyaWNzOiBNYXA8c3RyaW5nLCBQcm92aWRlck1ldHJpY3NbXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgYWxlcnRzOiBQcm92aWRlckFsZXJ0W10gPSBbXTtcbiAgcHJpdmF0ZSB0aHJlc2hvbGRzID0ge1xuICAgIHJlc3BvbnNlVGltZTogMTAwMCxcbiAgICBlcnJvclJhdGU6IDAuMDUsXG4gICAgYXZhaWxhYmlsaXR5OiAwLjk1LFxuICB9O1xuXG4gIHJlY29yZE1ldHJpYyhwcm92aWRlcklkOiBzdHJpbmcsIG1ldHJpYzogUHJvdmlkZXJNZXRyaWNzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLm1ldHJpY3MuaGFzKHByb3ZpZGVySWQpKSB7XG4gICAgICB0aGlzLm1ldHJpY3Muc2V0KHByb3ZpZGVySWQsIFtdKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm92aWRlck1ldHJpY3MgPSB0aGlzLm1ldHJpY3MuZ2V0KHByb3ZpZGVySWQpITtcbiAgICBwcm92aWRlck1ldHJpY3MucHVzaChtZXRyaWMpO1xuXG4gICAgLy8gS2VlcCBvbmx5IGxhc3QgMTAwIG1ldHJpY3NcbiAgICBpZiAocHJvdmlkZXJNZXRyaWNzLmxlbmd0aCA+IDEwMCkge1xuICAgICAgcHJvdmlkZXJNZXRyaWNzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja1RocmVzaG9sZHMocHJvdmlkZXJJZCwgbWV0cmljKTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tUaHJlc2hvbGRzKHByb3ZpZGVySWQ6IHN0cmluZywgbWV0cmljOiBQcm92aWRlck1ldHJpY3MpOiB2b2lkIHtcbiAgICBjb25zdCBhbGVydHM6IFByb3ZpZGVyQWxlcnRbXSA9IFtdO1xuXG4gICAgaWYgKG1ldHJpYy5yZXNwb25zZVRpbWUgPiB0aGlzLnRocmVzaG9sZHMucmVzcG9uc2VUaW1lKSB7XG4gICAgICBhbGVydHMucHVzaCh7XG4gICAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgc2V2ZXJpdHk6IFwid2FybmluZ1wiLFxuICAgICAgICBtZXNzYWdlOiBgSGlnaCByZXNwb25zZSB0aW1lOiAke21ldHJpYy5yZXNwb25zZVRpbWV9bXNgLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXRyaWMuZXJyb3JSYXRlID4gdGhpcy50aHJlc2hvbGRzLmVycm9yUmF0ZSkge1xuICAgICAgYWxlcnRzLnB1c2goe1xuICAgICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNiksXG4gICAgICAgIHByb3ZpZGVySWQsXG4gICAgICAgIHNldmVyaXR5OiBcImVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBIaWdoIGVycm9yIHJhdGU6ICR7KG1ldHJpYy5lcnJvclJhdGUgKiAxMDApLnRvRml4ZWQoMil9JWAsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1ldHJpYy5hdmFpbGFiaWxpdHkgPCB0aGlzLnRocmVzaG9sZHMuYXZhaWxhYmlsaXR5KSB7XG4gICAgICBhbGVydHMucHVzaCh7XG4gICAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgc2V2ZXJpdHk6IFwiY3JpdGljYWxcIixcbiAgICAgICAgbWVzc2FnZTogYExvdyBhdmFpbGFiaWxpdHk6ICR7KG1ldHJpYy5hdmFpbGFiaWxpdHkgKiAxMDApLnRvRml4ZWQoMil9JWAsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5hbGVydHMucHVzaCguLi5hbGVydHMpO1xuICB9XG5cbiAgZ2V0TWV0cmljcyhwcm92aWRlcklkOiBzdHJpbmcpOiBQcm92aWRlck1ldHJpY3NbXSB7XG4gICAgcmV0dXJuIHRoaXMubWV0cmljcy5nZXQocHJvdmlkZXJJZCkgfHwgW107XG4gIH1cblxuICBnZXRBZ2dyZWdhdGVkTWV0cmljcyhwcm92aWRlcklkOiBzdHJpbmcpOiBQYXJ0aWFsPFByb3ZpZGVyTWV0cmljcz4ge1xuICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLmdldE1ldHJpY3MocHJvdmlkZXJJZCk7XG4gICAgaWYgKG1ldHJpY3MubGVuZ3RoID09PSAwKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VUaW1lOlxuICAgICAgICBtZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLnJlc3BvbnNlVGltZSwgMCkgLyBtZXRyaWNzLmxlbmd0aCxcbiAgICAgIHN1Y2Nlc3NSYXRlOlxuICAgICAgICBtZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLnN1Y2Nlc3NSYXRlLCAwKSAvIG1ldHJpY3MubGVuZ3RoLFxuICAgICAgZXJyb3JSYXRlOlxuICAgICAgICBtZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLmVycm9yUmF0ZSwgMCkgLyBtZXRyaWNzLmxlbmd0aCxcbiAgICAgIHRocm91Z2hwdXQ6XG4gICAgICAgIG1ldHJpY3MucmVkdWNlKChzdW0sIG0pID0+IHN1bSArIG0udGhyb3VnaHB1dCwgMCkgLyBtZXRyaWNzLmxlbmd0aCxcbiAgICAgIGF2YWlsYWJpbGl0eTpcbiAgICAgICAgbWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5hdmFpbGFiaWxpdHksIDApIC8gbWV0cmljcy5sZW5ndGgsXG4gICAgICBjb3N0OiBtZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLmNvc3QsIDApLFxuICAgIH07XG4gIH1cblxuICBnZXRBbGVydHMocHJvdmlkZXJJZD86IHN0cmluZyk6IFByb3ZpZGVyQWxlcnRbXSB7XG4gICAgcmV0dXJuIHByb3ZpZGVySWRcbiAgICAgID8gdGhpcy5hbGVydHMuZmlsdGVyKChhbGVydCkgPT4gYWxlcnQucHJvdmlkZXJJZCA9PT0gcHJvdmlkZXJJZClcbiAgICAgIDogdGhpcy5hbGVydHM7XG4gIH1cblxuICByZXNvbHZlQWxlcnQoYWxlcnRJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYWxlcnQgPSB0aGlzLmFsZXJ0cy5maW5kKChhKSA9PiBhLmlkID09PSBhbGVydElkKTtcbiAgICBpZiAoYWxlcnQpIHtcbiAgICAgIGFsZXJ0LnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjbGVhclJlc29sdmVkQWxlcnRzKCk6IHZvaWQge1xuICAgIHRoaXMuYWxlcnRzID0gdGhpcy5hbGVydHMuZmlsdGVyKChhbGVydCkgPT4gIWFsZXJ0LnJlc29sdmVkKTtcbiAgfVxufVxuXG4vLyBLbm93bGVkZ2UgR3JhcGggRXhwb3J0IFNlcnZpY2VcbmludGVyZmFjZSBLbm93bGVkZ2VOb2RlIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBtZXRhZGF0YToge1xuICAgIGNyZWF0ZWQ6IERhdGU7XG4gICAgdXBkYXRlZDogRGF0ZTtcbiAgICBjb25maWRlbmNlOiBudW1iZXI7XG4gIH07XG59XG5cbmludGVyZmFjZSBLbm93bGVkZ2VFZGdlIHtcbiAgaWQ6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHRhcmdldDogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIHdlaWdodDogbnVtYmVyO1xuICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG5pbnRlcmZhY2UgRXhwb3J0T3B0aW9ucyB7XG4gIGZvcm1hdDogXCJqc29uXCIgfCBcImNzdlwiIHwgXCJnZXhmXCIgfCBcImdyYXBobWxcIjtcbiAgaW5jbHVkZU1ldGFkYXRhOiBib29sZWFuO1xuICBmaWx0ZXJCeVR5cGU/OiBzdHJpbmdbXTtcbiAgZmlsdGVyQnlDb25maWRlbmNlPzogbnVtYmVyO1xuICBjb21wcmVzc2VkPzogYm9vbGVhbjtcbn1cblxuY2xhc3MgS25vd2xlZGdlR3JhcGhFeHBvcnRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBjb21wcmVzc2lvbldvcmtlcj86IENvbXByZXNzaW9uV29ya2VyO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29tcHJlc3Npb25Xb3JrZXIgPSBuZXcgQ29tcHJlc3Npb25Xb3JrZXIoKTtcbiAgfVxuXG4gIGFzeW5jIGV4cG9ydEdyYXBoKFxuICAgIG5vZGVzOiBLbm93bGVkZ2VOb2RlW10sXG4gICAgZWRnZXM6IEtub3dsZWRnZUVkZ2VbXSxcbiAgICBvcHRpb25zOiBFeHBvcnRPcHRpb25zLFxuICApOiBQcm9taXNlPHN0cmluZyB8IEFycmF5QnVmZmVyPiB7XG4gICAgLy8gRmlsdGVyIG5vZGVzIGFuZCBlZGdlc1xuICAgIGxldCBmaWx0ZXJlZE5vZGVzID0gdGhpcy5maWx0ZXJOb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gICAgbGV0IGZpbHRlcmVkRWRnZXMgPSB0aGlzLmZpbHRlckVkZ2VzKGVkZ2VzLCBvcHRpb25zKTtcblxuICAgIC8vIEdlbmVyYXRlIGV4cG9ydCBkYXRhIGJhc2VkIG9uIGZvcm1hdFxuICAgIGxldCBleHBvcnREYXRhOiBzdHJpbmc7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICBleHBvcnREYXRhID0gdGhpcy5leHBvcnRUb0pTT04oZmlsdGVyZWROb2RlcywgZmlsdGVyZWRFZGdlcywgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNzdlwiOlxuICAgICAgICBleHBvcnREYXRhID0gdGhpcy5leHBvcnRUb0NTVihmaWx0ZXJlZE5vZGVzLCBmaWx0ZXJlZEVkZ2VzLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZ2V4ZlwiOlxuICAgICAgICBleHBvcnREYXRhID0gdGhpcy5leHBvcnRUb0dFWEYoZmlsdGVyZWROb2RlcywgZmlsdGVyZWRFZGdlcywgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImdyYXBobWxcIjpcbiAgICAgICAgZXhwb3J0RGF0YSA9IHRoaXMuZXhwb3J0VG9HcmFwaE1MKFxuICAgICAgICAgIGZpbHRlcmVkTm9kZXMsXG4gICAgICAgICAgZmlsdGVyZWRFZGdlcyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZXhwb3J0IGZvcm1hdDogJHtvcHRpb25zLmZvcm1hdH1gKTtcbiAgICB9XG5cbiAgICAvLyBDb21wcmVzcyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAob3B0aW9ucy5jb21wcmVzc2VkICYmIHRoaXMuY29tcHJlc3Npb25Xb3JrZXIpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbXByZXNzaW9uV29ya2VyLmNvbXByZXNzKGV4cG9ydERhdGEsIHtcbiAgICAgICAgYWxnb3JpdGhtOiBcImd6aXBcIixcbiAgICAgICAgbGV2ZWw6IDYsXG4gICAgICAgIGNodW5rU2l6ZTogMTAyNCAqIDEwMjQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0RGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgZmlsdGVyTm9kZXMoXG4gICAgbm9kZXM6IEtub3dsZWRnZU5vZGVbXSxcbiAgICBvcHRpb25zOiBFeHBvcnRPcHRpb25zLFxuICApOiBLbm93bGVkZ2VOb2RlW10ge1xuICAgIGxldCBmaWx0ZXJlZCA9IG5vZGVzO1xuXG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyQnlUeXBlKSB7XG4gICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcigobm9kZSkgPT5cbiAgICAgICAgb3B0aW9ucy5maWx0ZXJCeVR5cGUhLmluY2x1ZGVzKG5vZGUudHlwZSksXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbHRlckJ5Q29uZmlkZW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcihcbiAgICAgICAgKG5vZGUpID0+IG5vZGUubWV0YWRhdGEuY29uZmlkZW5jZSA+PSBvcHRpb25zLmZpbHRlckJ5Q29uZmlkZW5jZSEsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgfVxuXG4gIHByaXZhdGUgZmlsdGVyRWRnZXMoXG4gICAgZWRnZXM6IEtub3dsZWRnZUVkZ2VbXSxcbiAgICBvcHRpb25zOiBFeHBvcnRPcHRpb25zLFxuICApOiBLbm93bGVkZ2VFZGdlW10ge1xuICAgIHJldHVybiBlZGdlczsgLy8gU2ltcGxlIGltcGxlbWVudGF0aW9uXG4gIH1cblxuICBwcml2YXRlIGV4cG9ydFRvSlNPTihcbiAgICBub2RlczogS25vd2xlZGdlTm9kZVtdLFxuICAgIGVkZ2VzOiBLbm93bGVkZ2VFZGdlW10sXG4gICAgb3B0aW9uczogRXhwb3J0T3B0aW9ucyxcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbm9kZXM6IG9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhXG4gICAgICAgID8gbm9kZXNcbiAgICAgICAgOiBub2Rlcy5tYXAoKHsgbWV0YWRhdGEsIC4uLm5vZGUgfSkgPT4gbm9kZSksXG4gICAgICBlZGdlczogZWRnZXMsXG4gICAgICBleHBvcnRJbmZvOiB7XG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBub2RlQ291bnQ6IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgZWRnZUNvdW50OiBlZGdlcy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XG4gIH1cblxuICBwcml2YXRlIGV4cG9ydFRvQ1NWKFxuICAgIG5vZGVzOiBLbm93bGVkZ2VOb2RlW10sXG4gICAgZWRnZXM6IEtub3dsZWRnZUVkZ2VbXSxcbiAgICBvcHRpb25zOiBFeHBvcnRPcHRpb25zLFxuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IG5vZGVIZWFkZXJzID0gW1wiaWRcIiwgXCJ0eXBlXCIsIFwicHJvcGVydGllc1wiXTtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlTWV0YWRhdGEpIHtcbiAgICAgIG5vZGVIZWFkZXJzLnB1c2goXCJjcmVhdGVkXCIsIFwidXBkYXRlZFwiLCBcImNvbmZpZGVuY2VcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZWRnZUhlYWRlcnMgPSBbXG4gICAgICBcImlkXCIsXG4gICAgICBcInNvdXJjZVwiLFxuICAgICAgXCJ0YXJnZXRcIixcbiAgICAgIFwidHlwZVwiLFxuICAgICAgXCJ3ZWlnaHRcIixcbiAgICAgIFwicHJvcGVydGllc1wiLFxuICAgIF07XG5cbiAgICBsZXQgY3N2ID0gXCJOT0RFU1xcblwiO1xuICAgIGNzdiArPSBub2RlSGVhZGVycy5qb2luKFwiLFwiKSArIFwiXFxuXCI7XG5cbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBjb25zdCByb3cgPSBbXG4gICAgICAgIG5vZGUuaWQsXG4gICAgICAgIG5vZGUudHlwZSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9kZS5wcm9wZXJ0aWVzKS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpLFxuICAgICAgXTtcblxuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhKSB7XG4gICAgICAgIHJvdy5wdXNoKFxuICAgICAgICAgIG5vZGUubWV0YWRhdGEuY3JlYXRlZC50b0lTT1N0cmluZygpLFxuICAgICAgICAgIG5vZGUubWV0YWRhdGEudXBkYXRlZC50b0lTT1N0cmluZygpLFxuICAgICAgICAgIG5vZGUubWV0YWRhdGEuY29uZmlkZW5jZS50b1N0cmluZygpLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjc3YgKz0gcm93LmpvaW4oXCIsXCIpICsgXCJcXG5cIjtcbiAgICB9KTtcblxuICAgIGNzdiArPSBcIlxcbkVER0VTXFxuXCI7XG4gICAgY3N2ICs9IGVkZ2VIZWFkZXJzLmpvaW4oXCIsXCIpICsgXCJcXG5cIjtcblxuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgIGNvbnN0IHJvdyA9IFtcbiAgICAgICAgZWRnZS5pZCxcbiAgICAgICAgZWRnZS5zb3VyY2UsXG4gICAgICAgIGVkZ2UudGFyZ2V0LFxuICAgICAgICBlZGdlLnR5cGUsXG4gICAgICAgIGVkZ2Uud2VpZ2h0LnRvU3RyaW5nKCksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGVkZ2UucHJvcGVydGllcykucmVwbGFjZSgvXCIvZywgJ1wiXCInKSxcbiAgICAgIF07XG5cbiAgICAgIGNzdiArPSByb3cuam9pbihcIixcIikgKyBcIlxcblwiO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNzdjtcbiAgfVxuXG4gIHByaXZhdGUgZXhwb3J0VG9HRVhGKFxuICAgIG5vZGVzOiBLbm93bGVkZ2VOb2RlW10sXG4gICAgZWRnZXM6IEtub3dsZWRnZUVkZ2VbXSxcbiAgICBvcHRpb25zOiBFeHBvcnRPcHRpb25zLFxuICApOiBzdHJpbmcge1xuICAgIGxldCBnZXhmID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/Plxcbic7XG4gICAgZ2V4ZiArPSAnPGdleGYgeG1sbnM9XCJodHRwOi8vd3d3LmdleGYubmV0LzEuMmRyYWZ0XCIgdmVyc2lvbj1cIjEuMlwiPlxcbic7XG4gICAgZ2V4ZiArPSAnICA8Z3JhcGggbW9kZT1cInN0YXRpY1wiIGRlZmF1bHRlZGdldHlwZT1cImRpcmVjdGVkXCI+XFxuJztcblxuICAgIC8vIE5vZGVzXG4gICAgZ2V4ZiArPSBcIiAgICA8bm9kZXM+XFxuXCI7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgZ2V4ZiArPSBgICAgICAgPG5vZGUgaWQ9XCIke25vZGUuaWR9XCIgbGFiZWw9XCIke25vZGUudHlwZX1cIi8+XFxuYDtcbiAgICB9KTtcbiAgICBnZXhmICs9IFwiICAgIDwvbm9kZXM+XFxuXCI7XG5cbiAgICAvLyBFZGdlc1xuICAgIGdleGYgKz0gXCIgICAgPGVkZ2VzPlxcblwiO1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgIGdleGYgKz0gYCAgICAgIDxlZGdlIGlkPVwiJHtlZGdlLmlkfVwiIHNvdXJjZT1cIiR7ZWRnZS5zb3VyY2V9XCIgdGFyZ2V0PVwiJHtlZGdlLnRhcmdldH1cIiB3ZWlnaHQ9XCIke2VkZ2Uud2VpZ2h0fVwiLz5cXG5gO1xuICAgIH0pO1xuICAgIGdleGYgKz0gXCIgICAgPC9lZGdlcz5cXG5cIjtcblxuICAgIGdleGYgKz0gXCIgIDwvZ3JhcGg+XFxuXCI7XG4gICAgZ2V4ZiArPSBcIjwvZ2V4Zj5cIjtcblxuICAgIHJldHVybiBnZXhmO1xuICB9XG5cbiAgcHJpdmF0ZSBleHBvcnRUb0dyYXBoTUwoXG4gICAgbm9kZXM6IEtub3dsZWRnZU5vZGVbXSxcbiAgICBlZGdlczogS25vd2xlZGdlRWRnZVtdLFxuICAgIG9wdGlvbnM6IEV4cG9ydE9wdGlvbnMsXG4gICk6IHN0cmluZyB7XG4gICAgbGV0IGdyYXBobWwgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XFxuJztcbiAgICBncmFwaG1sICs9ICc8Z3JhcGhtbCB4bWxucz1cImh0dHA6Ly9ncmFwaG1sLmdyYXBoZHJhd2luZy5vcmcveG1sbnNcIj5cXG4nO1xuICAgIGdyYXBobWwgKz0gJyAgPGdyYXBoIGlkPVwia25vd2xlZGdlLWdyYXBoXCIgZWRnZWRlZmF1bHQ9XCJkaXJlY3RlZFwiPlxcbic7XG5cbiAgICAvLyBOb2Rlc1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGdyYXBobWwgKz0gYCAgICA8bm9kZSBpZD1cIiR7bm9kZS5pZH1cIi8+XFxuYDtcbiAgICB9KTtcblxuICAgIC8vIEVkZ2VzXG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgZ3JhcGhtbCArPSBgICAgIDxlZGdlIHNvdXJjZT1cIiR7ZWRnZS5zb3VyY2V9XCIgdGFyZ2V0PVwiJHtlZGdlLnRhcmdldH1cIi8+XFxuYDtcbiAgICB9KTtcblxuICAgIGdyYXBobWwgKz0gXCIgIDwvZ3JhcGg+XFxuXCI7XG4gICAgZ3JhcGhtbCArPSBcIjwvZ3JhcGhtbD5cIjtcblxuICAgIHJldHVybiBncmFwaG1sO1xuICB9XG5cbiAgdGVybWluYXRlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbXByZXNzaW9uV29ya2VyKSB7XG4gICAgICB0aGlzLmNvbXByZXNzaW9uV29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBTdG9yYWdlIFNlcnZpY2Ugd2l0aCBJbmRleGVkREJcbmNsYXNzIEFkdmFuY2VkU3RvcmFnZVNlcnZpY2Uge1xuICBwcml2YXRlIGRiTmFtZSA9IFwiRnJlZUFnZW50aWNzREJcIjtcbiAgcHJpdmF0ZSB2ZXJzaW9uID0gMTtcbiAgcHJpdmF0ZSBkYj86IElEQkRhdGFiYXNlO1xuXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGIgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGIgPSAoZXZlbnQudGFyZ2V0IGFzIElEQk9wZW5EQlJlcXVlc3QpLnJlc3VsdDtcblxuICAgICAgICAvLyBDcmVhdGUgb2JqZWN0IHN0b3Jlc1xuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoXCJhZ2VudHNcIikpIHtcbiAgICAgICAgICBjb25zdCBhZ2VudHNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFwiYWdlbnRzXCIsIHsga2V5UGF0aDogXCJpZFwiIH0pO1xuICAgICAgICAgIGFnZW50c1N0b3JlLmNyZWF0ZUluZGV4KFwidHlwZVwiLCBcInR5cGVcIiwgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFwiY29udmVyc2F0aW9uc1wiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbnNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFwiY29udmVyc2F0aW9uc1wiLCB7XG4gICAgICAgICAgICBrZXlQYXRoOiBcImlkXCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udmVyc2F0aW9uc1N0b3JlLmNyZWF0ZUluZGV4KFwidGltZXN0YW1wXCIsIFwidGltZXN0YW1wXCIsIHtcbiAgICAgICAgICAgIHVuaXF1ZTogZmFsc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoXCJrbm93bGVkZ2VcIikpIHtcbiAgICAgICAgICBjb25zdCBrbm93bGVkZ2VTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFwia25vd2xlZGdlXCIsIHtcbiAgICAgICAgICAgIGtleVBhdGg6IFwiaWRcIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBrbm93bGVkZ2VTdG9yZS5jcmVhdGVJbmRleChcInR5cGVcIiwgXCJ0eXBlXCIsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHN0b3JlKHN0b3JlTmFtZTogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5hZGQoZGF0YSk7XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmV0cmlldmUoc3RvcmVOYW1lOiBzdHJpbmcsIGlkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkXCIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sIFwicmVhZG9ubHlcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KGlkKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJldHJpZXZlQWxsKHN0b3JlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkXCIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sIFwicmVhZG9ubHlcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0QWxsKCk7XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB1cGRhdGUoc3RvcmVOYW1lOiBzdHJpbmcsIGRhdGE6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkXCIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sIFwicmVhZHdyaXRlXCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dChkYXRhKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBkZWxldGUoc3RvcmVOYW1lOiBzdHJpbmcsIGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5kZWxldGUoaWQpO1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNsZWFyKHN0b3JlTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuY2xlYXIoKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gVGVzdHNcbmRlc2NyaWJlKFwiU3BlY2lhbGl6ZWQgU2VydmljZXNcIiwgKCkgPT4ge1xuICBkZXNjcmliZShcIkNvbXByZXNzaW9uV29ya2VyXCIsICgpID0+IHtcbiAgICBsZXQgY29tcHJlc3Npb25Xb3JrZXI6IENvbXByZXNzaW9uV29ya2VyO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBjb21wcmVzc2lvbldvcmtlciA9IG5ldyBDb21wcmVzc2lvbldvcmtlcigpO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGNvbXByZXNzaW9uV29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjcmVhdGUgd29ya2VyIGluc3RhbmNlXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChjb21wcmVzc2lvbldvcmtlcikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChXb3JrZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiL3dvcmtlcnMvY29tcHJlc3Npb24uanNcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGNvbXByZXNzIGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSBcIkhlbGxvLCBXb3JsZCFcIjtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IENvbXByZXNzaW9uT3B0aW9ucyA9IHtcbiAgICAgICAgYWxnb3JpdGhtOiBcImd6aXBcIixcbiAgICAgICAgbGV2ZWw6IDYsXG4gICAgICAgIGNodW5rU2l6ZTogMTAyNCxcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBjb21wcmVzc2lvblxuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IG5ldyBBcnJheUJ1ZmZlcig4KSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcHJlc3Npb25Xb3JrZXIuY29tcHJlc3ModGVzdERhdGEsIG9wdGlvbnMpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZUluc3RhbmNlT2YoQXJyYXlCdWZmZXIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBkZWNvbXByZXNzIGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gICAgICBjb25zdCBhbGdvcml0aG0gPSBcImd6aXBcIjtcblxuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIGRlY29tcHJlc3Npb25cbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiBcIkhlbGxvLCBXb3JsZCFcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcHJlc3Npb25Xb3JrZXIuZGVjb21wcmVzcyh0ZXN0RGF0YSwgYWxnb3JpdGhtKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJIZWxsbywgV29ybGQhXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgY29tcHJlc3Npb24gZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gXCJIZWxsbywgV29ybGQhXCI7XG4gICAgICBjb25zdCBvcHRpb25zOiBDb21wcmVzc2lvbk9wdGlvbnMgPSB7XG4gICAgICAgIGFsZ29yaXRobTogXCJnemlwXCIsXG4gICAgICAgIGxldmVsOiA2LFxuICAgICAgICBjaHVua1NpemU6IDEwMjQsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIGNvbXByZXNzaW9uIGVycm9yXG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIGVycm9yOiBcIkNvbXByZXNzaW9uIGZhaWxlZFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGNvbXByZXNzaW9uV29ya2VyLmNvbXByZXNzKHRlc3REYXRhLCBvcHRpb25zKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KFwiQ29tcHJlc3Npb24gZmFpbGVkXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgd29ya2VyIGVycm9yc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIGNvbnN0IGVycm9yRXZlbnQgPSBuZXcgRXJyb3JFdmVudChcImVycm9yXCIsIHsgbWVzc2FnZTogXCJXb3JrZXIgY3Jhc2hlZFwiIH0pO1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9uZXJyb3IoZXJyb3JFdmVudCk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlByb3ZpZGVyTW9uaXRvcmluZ1NlcnZpY2VcIiwgKCkgPT4ge1xuICAgIGxldCBtb25pdG9yaW5nU2VydmljZTogUHJvdmlkZXJNb25pdG9yaW5nU2VydmljZTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9uaXRvcmluZ1NlcnZpY2UgPSBuZXcgUHJvdmlkZXJNb25pdG9yaW5nU2VydmljZSgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCByZWNvcmQgbWV0cmljc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtZXRyaWM6IFByb3ZpZGVyTWV0cmljcyA9IHtcbiAgICAgICAgcmVzcG9uc2VUaW1lOiA1MDAsXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiAwLjk1LFxuICAgICAgICBlcnJvclJhdGU6IDAuMDUsXG4gICAgICAgIHRocm91Z2hwdXQ6IDEwMCxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiAwLjk5LFxuICAgICAgICBjb3N0OiAwLjAwMSxcbiAgICAgIH07XG5cbiAgICAgIG1vbml0b3JpbmdTZXJ2aWNlLnJlY29yZE1ldHJpYyhcInByb3ZpZGVyMVwiLCBtZXRyaWMpO1xuICAgICAgY29uc3QgbWV0cmljcyA9IG1vbml0b3JpbmdTZXJ2aWNlLmdldE1ldHJpY3MoXCJwcm92aWRlcjFcIik7XG5cbiAgICAgIGV4cGVjdChtZXRyaWNzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QobWV0cmljc1swXSkudG9FcXVhbChtZXRyaWMpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBnZW5lcmF0ZSBhbGVydHMgZm9yIHRocmVzaG9sZCB2aW9sYXRpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGhpZ2hMYXRlbmN5TWV0cmljOiBQcm92aWRlck1ldHJpY3MgPSB7XG4gICAgICAgIHJlc3BvbnNlVGltZTogMjAwMCwgLy8gQWJvdmUgdGhyZXNob2xkXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiAwLjk1LFxuICAgICAgICBlcnJvclJhdGU6IDAuMDUsXG4gICAgICAgIHRocm91Z2hwdXQ6IDEwMCxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiAwLjk5LFxuICAgICAgICBjb3N0OiAwLjAwMSxcbiAgICAgIH07XG5cbiAgICAgIG1vbml0b3JpbmdTZXJ2aWNlLnJlY29yZE1ldHJpYyhcInByb3ZpZGVyMVwiLCBoaWdoTGF0ZW5jeU1ldHJpYyk7XG4gICAgICBjb25zdCBhbGVydHMgPSBtb25pdG9yaW5nU2VydmljZS5nZXRBbGVydHMoXCJwcm92aWRlcjFcIik7XG5cbiAgICAgIGV4cGVjdChhbGVydHMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChhbGVydHNbMF0uc2V2ZXJpdHkpLnRvQmUoXCJ3YXJuaW5nXCIpO1xuICAgICAgZXhwZWN0KGFsZXJ0c1swXS5tZXNzYWdlKS50b0NvbnRhaW4oXCJIaWdoIHJlc3BvbnNlIHRpbWVcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGNhbGN1bGF0ZSBhZ2dyZWdhdGVkIG1ldHJpY3NcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljczogUHJvdmlkZXJNZXRyaWNzW10gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICByZXNwb25zZVRpbWU6IDQwMCxcbiAgICAgICAgICBzdWNjZXNzUmF0ZTogMC45NSxcbiAgICAgICAgICBlcnJvclJhdGU6IDAuMDUsXG4gICAgICAgICAgdGhyb3VnaHB1dDogMTAwLFxuICAgICAgICAgIGF2YWlsYWJpbGl0eTogMC45OSxcbiAgICAgICAgICBjb3N0OiAwLjAwMSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJlc3BvbnNlVGltZTogNjAwLFxuICAgICAgICAgIHN1Y2Nlc3NSYXRlOiAwLjk4LFxuICAgICAgICAgIGVycm9yUmF0ZTogMC4wMixcbiAgICAgICAgICB0aHJvdWdocHV0OiAxMjAsXG4gICAgICAgICAgYXZhaWxhYmlsaXR5OiAwLjk3LFxuICAgICAgICAgIGNvc3Q6IDAuMDAyLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgbWV0cmljcy5mb3JFYWNoKChtZXRyaWMpID0+IHtcbiAgICAgICAgbW9uaXRvcmluZ1NlcnZpY2UucmVjb3JkTWV0cmljKFwicHJvdmlkZXIxXCIsIG1ldHJpYyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWdncmVnYXRlZCA9IG1vbml0b3JpbmdTZXJ2aWNlLmdldEFnZ3JlZ2F0ZWRNZXRyaWNzKFwicHJvdmlkZXIxXCIpO1xuXG4gICAgICBleHBlY3QoYWdncmVnYXRlZC5yZXNwb25zZVRpbWUpLnRvQmUoNTAwKTsgLy8gQXZlcmFnZVxuICAgICAgZXhwZWN0KGFnZ3JlZ2F0ZWQuc3VjY2Vzc1JhdGUpLnRvQmVDbG9zZVRvKDAuOTY1LCAzKTtcbiAgICAgIGV4cGVjdChhZ2dyZWdhdGVkLmNvc3QpLnRvQmUoMC4wMDMpOyAvLyBTdW1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVzb2x2ZSBhbGVydHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljOiBQcm92aWRlck1ldHJpY3MgPSB7XG4gICAgICAgIHJlc3BvbnNlVGltZTogMjAwMCxcbiAgICAgICAgc3VjY2Vzc1JhdGU6IDAuOTUsXG4gICAgICAgIGVycm9yUmF0ZTogMC4xLCAvLyBIaWdoIGVycm9yIHJhdGVcbiAgICAgICAgdGhyb3VnaHB1dDogMTAwLFxuICAgICAgICBhdmFpbGFiaWxpdHk6IDAuOSwgLy8gTG93IGF2YWlsYWJpbGl0eVxuICAgICAgICBjb3N0OiAwLjAwMSxcbiAgICAgIH07XG5cbiAgICAgIG1vbml0b3JpbmdTZXJ2aWNlLnJlY29yZE1ldHJpYyhcInByb3ZpZGVyMVwiLCBtZXRyaWMpO1xuICAgICAgY29uc3QgYWxlcnRzID0gbW9uaXRvcmluZ1NlcnZpY2UuZ2V0QWxlcnRzKFwicHJvdmlkZXIxXCIpO1xuXG4gICAgICBleHBlY3QoYWxlcnRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgICBjb25zdCBhbGVydElkID0gYWxlcnRzWzBdLmlkO1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSBtb25pdG9yaW5nU2VydmljZS5yZXNvbHZlQWxlcnQoYWxlcnRJZCk7XG5cbiAgICAgIGV4cGVjdChyZXNvbHZlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChhbGVydHNbMF0ucmVzb2x2ZWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGNsZWFyIHJlc29sdmVkIGFsZXJ0c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtZXRyaWM6IFByb3ZpZGVyTWV0cmljcyA9IHtcbiAgICAgICAgcmVzcG9uc2VUaW1lOiAyMDAwLFxuICAgICAgICBzdWNjZXNzUmF0ZTogMC45NSxcbiAgICAgICAgZXJyb3JSYXRlOiAwLjEsXG4gICAgICAgIHRocm91Z2hwdXQ6IDEwMCxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiAwLjksXG4gICAgICAgIGNvc3Q6IDAuMDAxLFxuICAgICAgfTtcblxuICAgICAgbW9uaXRvcmluZ1NlcnZpY2UucmVjb3JkTWV0cmljKFwicHJvdmlkZXIxXCIsIG1ldHJpYyk7XG4gICAgICBjb25zdCBhbGVydHMgPSBtb25pdG9yaW5nU2VydmljZS5nZXRBbGVydHMoKTtcblxuICAgICAgLy8gUmVzb2x2ZSBhbGwgYWxlcnRzXG4gICAgICBhbGVydHMuZm9yRWFjaCgoYWxlcnQpID0+IHtcbiAgICAgICAgbW9uaXRvcmluZ1NlcnZpY2UucmVzb2x2ZUFsZXJ0KGFsZXJ0LmlkKTtcbiAgICAgIH0pO1xuXG4gICAgICBtb25pdG9yaW5nU2VydmljZS5jbGVhclJlc29sdmVkQWxlcnRzKCk7XG4gICAgICBjb25zdCByZW1haW5pbmdBbGVydHMgPSBtb25pdG9yaW5nU2VydmljZS5nZXRBbGVydHMoKTtcblxuICAgICAgZXhwZWN0KHJlbWFpbmluZ0FsZXJ0cykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIktub3dsZWRnZUdyYXBoRXhwb3J0U2VydmljZVwiLCAoKSA9PiB7XG4gICAgbGV0IGV4cG9ydFNlcnZpY2U6IEtub3dsZWRnZUdyYXBoRXhwb3J0U2VydmljZTtcbiAgICBsZXQgbW9ja05vZGVzOiBLbm93bGVkZ2VOb2RlW107XG4gICAgbGV0IG1vY2tFZGdlczogS25vd2xlZGdlRWRnZVtdO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBleHBvcnRTZXJ2aWNlID0gbmV3IEtub3dsZWRnZUdyYXBoRXhwb3J0U2VydmljZSgpO1xuXG4gICAgICBtb2NrTm9kZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJub2RlMVwiLFxuICAgICAgICAgIHR5cGU6IFwiYWdlbnRcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7IG5hbWU6IFwiQWdlbnQgMVwiIH0sXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IG5ldyBEYXRlKFwiMjAyMy0wMS0wMlwiKSxcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibm9kZTJcIixcbiAgICAgICAgICB0eXBlOiBcImNvbmNlcHRcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7IG5hbWU6IFwiQ29uY2VwdCAxXCIgfSxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoXCIyMDIzLTAxLTAxXCIpLFxuICAgICAgICAgICAgdXBkYXRlZDogbmV3IERhdGUoXCIyMDIzLTAxLTAyXCIpLFxuICAgICAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBtb2NrRWRnZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJlZGdlMVwiLFxuICAgICAgICAgIHNvdXJjZTogXCJub2RlMVwiLFxuICAgICAgICAgIHRhcmdldDogXCJub2RlMlwiLFxuICAgICAgICAgIHR5cGU6IFwia25vd3NcIixcbiAgICAgICAgICB3ZWlnaHQ6IDAuNyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7IHN0cmVuZ3RoOiBcInN0cm9uZ1wiIH0sXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGV4cG9ydFNlcnZpY2UudGVybWluYXRlKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGV4cG9ydCB0byBKU09OIGZvcm1hdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBFeHBvcnRPcHRpb25zID0ge1xuICAgICAgICBmb3JtYXQ6IFwianNvblwiLFxuICAgICAgICBpbmNsdWRlTWV0YWRhdGE6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHBvcnRTZXJ2aWNlLmV4cG9ydEdyYXBoKFxuICAgICAgICBtb2NrTm9kZXMsXG4gICAgICAgIG1vY2tFZGdlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdCh0eXBlb2YgcmVzdWx0KS50b0JlKFwic3RyaW5nXCIpO1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyZXN1bHQgYXMgc3RyaW5nKTtcblxuICAgICAgZXhwZWN0KHBhcnNlZC5ub2RlcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHBhcnNlZC5lZGdlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHBhcnNlZC5ub2Rlc1swXS5tZXRhZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZXhwb3J0IHRvIENTViBmb3JtYXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogRXhwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgZm9ybWF0OiBcImNzdlwiLFxuICAgICAgICBpbmNsdWRlTWV0YWRhdGE6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhwb3J0U2VydmljZS5leHBvcnRHcmFwaChcbiAgICAgICAgbW9ja05vZGVzLFxuICAgICAgICBtb2NrRWRnZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdCkudG9CZShcInN0cmluZ1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcIk5PREVTXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiRURHRVNcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJub2RlMSxhZ2VudFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZXhwb3J0IHRvIEdFWEYgZm9ybWF0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IEV4cG9ydE9wdGlvbnMgPSB7XG4gICAgICAgIGZvcm1hdDogXCJnZXhmXCIsXG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YTogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHBvcnRTZXJ2aWNlLmV4cG9ydEdyYXBoKFxuICAgICAgICBtb2NrTm9kZXMsXG4gICAgICAgIG1vY2tFZGdlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdCh0eXBlb2YgcmVzdWx0KS50b0JlKFwic3RyaW5nXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKCc8P3htbCB2ZXJzaW9uPVwiMS4wXCInKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcIjxnZXhmIHhtbG5zPVwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbignPG5vZGUgaWQ9XCJub2RlMVwiJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGV4cG9ydCB0byBHcmFwaE1MIGZvcm1hdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBFeHBvcnRPcHRpb25zID0ge1xuICAgICAgICBmb3JtYXQ6IFwiZ3JhcGhtbFwiLFxuICAgICAgICBpbmNsdWRlTWV0YWRhdGE6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhwb3J0U2VydmljZS5leHBvcnRHcmFwaChcbiAgICAgICAgbW9ja05vZGVzLFxuICAgICAgICBtb2NrRWRnZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdCkudG9CZShcInN0cmluZ1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbignPD94bWwgdmVyc2lvbj1cIjEuMFwiJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCI8Z3JhcGhtbCB4bWxucz1cIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJzxub2RlIGlkPVwibm9kZTFcIicpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBmaWx0ZXIgYnkgbm9kZSB0eXBlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IEV4cG9ydE9wdGlvbnMgPSB7XG4gICAgICAgIGZvcm1hdDogXCJqc29uXCIsXG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YTogZmFsc2UsXG4gICAgICAgIGZpbHRlckJ5VHlwZTogW1wiYWdlbnRcIl0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHBvcnRTZXJ2aWNlLmV4cG9ydEdyYXBoKFxuICAgICAgICBtb2NrTm9kZXMsXG4gICAgICAgIG1vY2tFZGdlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJlc3VsdCBhcyBzdHJpbmcpO1xuXG4gICAgICBleHBlY3QocGFyc2VkLm5vZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocGFyc2VkLm5vZGVzWzBdLnR5cGUpLnRvQmUoXCJhZ2VudFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZmlsdGVyIGJ5IGNvbmZpZGVuY2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogRXhwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgZm9ybWF0OiBcImpzb25cIixcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhOiB0cnVlLFxuICAgICAgICBmaWx0ZXJCeUNvbmZpZGVuY2U6IDAuODUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHBvcnRTZXJ2aWNlLmV4cG9ydEdyYXBoKFxuICAgICAgICBtb2NrTm9kZXMsXG4gICAgICAgIG1vY2tFZGdlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJlc3VsdCBhcyBzdHJpbmcpO1xuXG4gICAgICBleHBlY3QocGFyc2VkLm5vZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocGFyc2VkLm5vZGVzWzBdLm1ldGFkYXRhLmNvbmZpZGVuY2UpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMC44NSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBjb21wcmVzc2lvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBFeHBvcnRPcHRpb25zID0ge1xuICAgICAgICBmb3JtYXQ6IFwianNvblwiLFxuICAgICAgICBpbmNsdWRlTWV0YWRhdGE6IHRydWUsXG4gICAgICAgIGNvbXByZXNzZWQ6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIGNvbXByZXNzaW9uIHdvcmtlclxuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICByZXN1bHQ6IG5ldyBBcnJheUJ1ZmZlcigxMDApLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHBvcnRTZXJ2aWNlLmV4cG9ydEdyYXBoKFxuICAgICAgICBtb2NrTm9kZXMsXG4gICAgICAgIG1vY2tFZGdlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVJbnN0YW5jZU9mKEFycmF5QnVmZmVyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHVuc3VwcG9ydGVkIGZvcm1hdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBFeHBvcnRPcHRpb25zID0ge1xuICAgICAgICBmb3JtYXQ6IFwidW5zdXBwb3J0ZWRcIiBhcyBhbnksXG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YTogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGV4cG9ydFNlcnZpY2UuZXhwb3J0R3JhcGgobW9ja05vZGVzLCBtb2NrRWRnZXMsIG9wdGlvbnMpLFxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coXCJVbnN1cHBvcnRlZCBleHBvcnQgZm9ybWF0XCIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkFkdmFuY2VkU3RvcmFnZVNlcnZpY2VcIiwgKCkgPT4ge1xuICAgIGxldCBzdG9yYWdlU2VydmljZTogQWR2YW5jZWRTdG9yYWdlU2VydmljZTtcblxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgc3RvcmFnZVNlcnZpY2UgPSBuZXcgQWR2YW5jZWRTdG9yYWdlU2VydmljZSgpO1xuXG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBvbnN1Y2Nlc3M6IG51bGwsXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgIG9udXBncmFkZW5lZWRlZDogbnVsbCxcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgb2JqZWN0U3RvcmVOYW1lczoge1xuICAgICAgICAgICAgY29udGFpbnM6IGplc3QuZm4oKCkgPT4gZmFsc2UpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3JlYXRlT2JqZWN0U3RvcmU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIGNyZWF0ZUluZGV4OiBqZXN0LmZuKCksXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgICBhZGQ6IGplc3QuZm4oKCkgPT4gKHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH0pKSxcbiAgICAgICAgICAgICAgZ2V0OiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgICAgIGdldEFsbDogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgICAgICBwdXQ6IGplc3QuZm4oKCkgPT4gKHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH0pKSxcbiAgICAgICAgICAgICAgZGVsZXRlOiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgICAgIGNsZWFyOiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgKGdsb2JhbC5pbmRleGVkREIub3BlbiBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZShtb2NrUmVxdWVzdCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIHN1Y2Nlc3NmdWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAobW9ja1JlcXVlc3Qub25zdWNjZXNzKSB7XG4gICAgICAgICAgbW9ja1JlcXVlc3Qub25zdWNjZXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuXG4gICAgICBhd2FpdCBzdG9yYWdlU2VydmljZS5pbml0aWFsaXplKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGluaXRpYWxpemUgZGF0YWJhc2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgZXhwZWN0KGdsb2JhbC5pbmRleGVkREIub3BlbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJGcmVlQWdlbnRpY3NEQlwiLCAxKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgc3RvcmUgZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgaWQ6IFwidGVzdDFcIiwgbmFtZTogXCJUZXN0IEFnZW50XCIgfTtcblxuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIHN0b3JlIG9wZXJhdGlvblxuICAgICAgY29uc3QgbW9ja1RyYW5zYWN0aW9uID0ge1xuICAgICAgICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGFkZDogamVzdC5mbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5vbnN1Y2Nlc3MpIHJlcXVlc3Qub25zdWNjZXNzKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgIH0pLFxuICAgICAgICB9KSksXG4gICAgICB9O1xuXG4gICAgICAoc3RvcmFnZVNlcnZpY2UgYXMgYW55KS5kYiA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb246IGplc3QuZm4oKCkgPT4gbW9ja1RyYW5zYWN0aW9uKSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc3RvcmFnZVNlcnZpY2Uuc3RvcmUoXCJhZ2VudHNcIiwgdGVzdERhdGEpLFxuICAgICAgKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHJldHJpZXZlIGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdElkID0gXCJ0ZXN0MVwiO1xuICAgICAgY29uc3QgZXhwZWN0ZWREYXRhID0geyBpZDogXCJ0ZXN0MVwiLCBuYW1lOiBcIlRlc3QgQWdlbnRcIiB9O1xuXG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgcmV0cmlldmUgb3BlcmF0aW9uXG4gICAgICBjb25zdCBtb2NrVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIG9iamVjdFN0b3JlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgIG9uc3VjY2VzczogbnVsbCxcbiAgICAgICAgICAgICAgb25lcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgcmVzdWx0OiBleHBlY3RlZERhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm9uc3VjY2VzcykgcmVxdWVzdC5vbnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pKSxcbiAgICAgIH07XG5cbiAgICAgIChzdG9yYWdlU2VydmljZSBhcyBhbnkpLmRiID0ge1xuICAgICAgICB0cmFuc2FjdGlvbjogamVzdC5mbigoKSA9PiBtb2NrVHJhbnNhY3Rpb24pLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RvcmFnZVNlcnZpY2UucmV0cmlldmUoXCJhZ2VudHNcIiwgdGVzdElkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZXhwZWN0ZWREYXRhKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmV0cmlldmUgYWxsIGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwZWN0ZWREYXRhID0gW1xuICAgICAgICB7IGlkOiBcInRlc3QxXCIsIG5hbWU6IFwiVGVzdCBBZ2VudCAxXCIgfSxcbiAgICAgICAgeyBpZDogXCJ0ZXN0MlwiLCBuYW1lOiBcIlRlc3QgQWdlbnQgMlwiIH0sXG4gICAgICBdO1xuXG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgcmV0cmlldmVBbGwgb3BlcmF0aW9uXG4gICAgICBjb25zdCBtb2NrVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIG9iamVjdFN0b3JlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZ2V0QWxsOiBqZXN0LmZuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgIG9uc3VjY2VzczogbnVsbCxcbiAgICAgICAgICAgICAgb25lcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgcmVzdWx0OiBleHBlY3RlZERhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm9uc3VjY2VzcykgcmVxdWVzdC5vbnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pKSxcbiAgICAgIH07XG5cbiAgICAgIChzdG9yYWdlU2VydmljZSBhcyBhbnkpLmRiID0ge1xuICAgICAgICB0cmFuc2FjdGlvbjogamVzdC5mbigoKSA9PiBtb2NrVHJhbnNhY3Rpb24pLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RvcmFnZVNlcnZpY2UucmV0cmlldmVBbGwoXCJhZ2VudHNcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGV4cGVjdGVkRGF0YSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHVwZGF0ZSBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogXCJ0ZXN0MVwiLCBuYW1lOiBcIlVwZGF0ZWQgQWdlbnRcIiB9O1xuXG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgdXBkYXRlIG9wZXJhdGlvblxuICAgICAgY29uc3QgbW9ja1RyYW5zYWN0aW9uID0ge1xuICAgICAgICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHB1dDogamVzdC5mbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5vbnN1Y2Nlc3MpIHJlcXVlc3Qub25zdWNjZXNzKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgIH0pLFxuICAgICAgICB9KSksXG4gICAgICB9O1xuXG4gICAgICAoc3RvcmFnZVNlcnZpY2UgYXMgYW55KS5kYiA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb246IGplc3QuZm4oKCkgPT4gbW9ja1RyYW5zYWN0aW9uKSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc3RvcmFnZVNlcnZpY2UudXBkYXRlKFwiYWdlbnRzXCIsIHRlc3REYXRhKSxcbiAgICAgICkucmVzb2x2ZXMudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBkZWxldGUgZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0SWQgPSBcInRlc3QxXCI7XG5cbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBkZWxldGUgb3BlcmF0aW9uXG4gICAgICBjb25zdCBtb2NrVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIG9iamVjdFN0b3JlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZGVsZXRlOiBqZXN0LmZuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm9uc3VjY2VzcykgcmVxdWVzdC5vbnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pKSxcbiAgICAgIH07XG5cbiAgICAgIChzdG9yYWdlU2VydmljZSBhcyBhbnkpLmRiID0ge1xuICAgICAgICB0cmFuc2FjdGlvbjogamVzdC5mbigoKSA9PiBtb2NrVHJhbnNhY3Rpb24pLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzdG9yYWdlU2VydmljZS5kZWxldGUoXCJhZ2VudHNcIiwgdGVzdElkKSxcbiAgICAgICkucmVzb2x2ZXMudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjbGVhciBzdG9yZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgY2xlYXIgb3BlcmF0aW9uXG4gICAgICBjb25zdCBtb2NrVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIG9iamVjdFN0b3JlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgY2xlYXI6IGplc3QuZm4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH07XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlcXVlc3Qub25zdWNjZXNzKSByZXF1ZXN0Lm9uc3VjY2VzcygpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgKHN0b3JhZ2VTZXJ2aWNlIGFzIGFueSkuZGIgPSB7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBqZXN0LmZuKCgpID0+IG1vY2tUcmFuc2FjdGlvbiksXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc3RvcmFnZVNlcnZpY2UuY2xlYXIoXCJhZ2VudHNcIikpLnJlc29sdmVzLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGRhdGFiYXNlIG5vdCBpbml0aWFsaXplZCBlcnJvclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1bmluaXRpYWxpemVkU2VydmljZSA9IG5ldyBBZHZhbmNlZFN0b3JhZ2VTZXJ2aWNlKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh1bmluaXRpYWxpemVkU2VydmljZS5zdG9yZShcImFnZW50c1wiLCB7fSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgXCJEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIixcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsInNldFRpbWVvdXQiLCJnbG9iYWwiLCJXb3JrZXIiLCJmbiIsInBvc3RNZXNzYWdlIiwidGVybWluYXRlIiwib25tZXNzYWdlIiwib25lcnJvciIsImluZGV4ZWREQiIsIm9wZW4iLCJvbnN1Y2Nlc3MiLCJvbnVwZ3JhZGVuZWVkZWQiLCJyZXN1bHQiLCJjcmVhdGVPYmplY3RTdG9yZSIsImNyZWF0ZUluZGV4IiwidHJhbnNhY3Rpb24iLCJvYmplY3RTdG9yZSIsImFkZCIsImdldCIsImRlbGV0ZSIsInB1dCIsImdldEFsbCIsImNsZWFyIiwiZGVsZXRlRGF0YWJhc2UiLCJDb21wcmVzc2lvbldvcmtlciIsImNvbnN0cnVjdG9yIiwicGVuZGluZ0pvYnMiLCJNYXAiLCJ3b3JrZXIiLCJoYW5kbGVNZXNzYWdlIiwiYmluZCIsImhhbmRsZUVycm9yIiwiZXZlbnQiLCJpZCIsImVycm9yIiwiZGF0YSIsImpvYiIsInJlamVjdCIsIkVycm9yIiwicmVzb2x2ZSIsImNvbnNvbGUiLCJmb3JFYWNoIiwiY29tcHJlc3MiLCJvcHRpb25zIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwiUHJvbWlzZSIsInNldCIsImFjdGlvbiIsImRlY29tcHJlc3MiLCJhbGdvcml0aG0iLCJQcm92aWRlck1vbml0b3JpbmdTZXJ2aWNlIiwicmVjb3JkTWV0cmljIiwicHJvdmlkZXJJZCIsIm1ldHJpYyIsIm1ldHJpY3MiLCJoYXMiLCJwcm92aWRlck1ldHJpY3MiLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJjaGVja1RocmVzaG9sZHMiLCJhbGVydHMiLCJyZXNwb25zZVRpbWUiLCJ0aHJlc2hvbGRzIiwic2V2ZXJpdHkiLCJtZXNzYWdlIiwidGltZXN0YW1wIiwiRGF0ZSIsInJlc29sdmVkIiwiZXJyb3JSYXRlIiwidG9GaXhlZCIsImF2YWlsYWJpbGl0eSIsImdldE1ldHJpY3MiLCJnZXRBZ2dyZWdhdGVkTWV0cmljcyIsInJlZHVjZSIsInN1bSIsIm0iLCJzdWNjZXNzUmF0ZSIsInRocm91Z2hwdXQiLCJjb3N0IiwiZ2V0QWxlcnRzIiwiZmlsdGVyIiwiYWxlcnQiLCJyZXNvbHZlQWxlcnQiLCJhbGVydElkIiwiZmluZCIsImEiLCJjbGVhclJlc29sdmVkQWxlcnRzIiwiS25vd2xlZGdlR3JhcGhFeHBvcnRTZXJ2aWNlIiwiY29tcHJlc3Npb25Xb3JrZXIiLCJleHBvcnRHcmFwaCIsIm5vZGVzIiwiZWRnZXMiLCJmaWx0ZXJlZE5vZGVzIiwiZmlsdGVyTm9kZXMiLCJmaWx0ZXJlZEVkZ2VzIiwiZmlsdGVyRWRnZXMiLCJleHBvcnREYXRhIiwiZm9ybWF0IiwiZXhwb3J0VG9KU09OIiwiZXhwb3J0VG9DU1YiLCJleHBvcnRUb0dFWEYiLCJleHBvcnRUb0dyYXBoTUwiLCJjb21wcmVzc2VkIiwibGV2ZWwiLCJjaHVua1NpemUiLCJmaWx0ZXJlZCIsImZpbHRlckJ5VHlwZSIsIm5vZGUiLCJpbmNsdWRlcyIsInR5cGUiLCJmaWx0ZXJCeUNvbmZpZGVuY2UiLCJ1bmRlZmluZWQiLCJtZXRhZGF0YSIsImNvbmZpZGVuY2UiLCJpbmNsdWRlTWV0YWRhdGEiLCJtYXAiLCJleHBvcnRJbmZvIiwidG9JU09TdHJpbmciLCJub2RlQ291bnQiLCJlZGdlQ291bnQiLCJKU09OIiwic3RyaW5naWZ5Iiwibm9kZUhlYWRlcnMiLCJlZGdlSGVhZGVycyIsImNzdiIsImpvaW4iLCJyb3ciLCJwcm9wZXJ0aWVzIiwicmVwbGFjZSIsImNyZWF0ZWQiLCJ1cGRhdGVkIiwiZWRnZSIsInNvdXJjZSIsInRhcmdldCIsIndlaWdodCIsImdleGYiLCJncmFwaG1sIiwiQWR2YW5jZWRTdG9yYWdlU2VydmljZSIsImluaXRpYWxpemUiLCJyZXF1ZXN0IiwiZGJOYW1lIiwidmVyc2lvbiIsImRiIiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwiYWdlbnRzU3RvcmUiLCJrZXlQYXRoIiwidW5pcXVlIiwiY29udmVyc2F0aW9uc1N0b3JlIiwia25vd2xlZGdlU3RvcmUiLCJzdG9yZSIsInN0b3JlTmFtZSIsInJldHJpZXZlIiwicmV0cmlldmVBbGwiLCJ1cGRhdGUiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJhZnRlckVhY2giLCJ0ZXN0IiwiZXhwZWN0IiwidG9CZURlZmluZWQiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInRlc3REYXRhIiwibW9ja1dvcmtlciIsIm1vY2siLCJyZXN1bHRzIiwidmFsdWUiLCJhbnkiLCJTdHJpbmciLCJBcnJheUJ1ZmZlciIsInRvQmVJbnN0YW5jZU9mIiwidG9CZSIsInJlamVjdHMiLCJ0b1Rocm93IiwiZXJyb3JFdmVudCIsIkVycm9yRXZlbnQiLCJub3QiLCJtb25pdG9yaW5nU2VydmljZSIsInRvSGF2ZUxlbmd0aCIsInRvRXF1YWwiLCJoaWdoTGF0ZW5jeU1ldHJpYyIsInRvQ29udGFpbiIsImFnZ3JlZ2F0ZWQiLCJ0b0JlQ2xvc2VUbyIsInRvQmVHcmVhdGVyVGhhbiIsInJlbWFpbmluZ0FsZXJ0cyIsImV4cG9ydFNlcnZpY2UiLCJtb2NrTm9kZXMiLCJtb2NrRWRnZXMiLCJuYW1lIiwic3RyZW5ndGgiLCJwYXJzZWQiLCJwYXJzZSIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJzdG9yYWdlU2VydmljZSIsIm1vY2tSZXF1ZXN0IiwibW9ja1JldHVyblZhbHVlIiwibW9ja1RyYW5zYWN0aW9uIiwicmVzb2x2ZXMiLCJ0b0JlVW5kZWZpbmVkIiwidGVzdElkIiwiZXhwZWN0ZWREYXRhIiwidW5pbml0aWFsaXplZFNlcnZpY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDOzs7O3lCQUVvQjtBQUVyQixrQ0FBa0M7QUFDbENBLGFBQUksQ0FBQ0MsVUFBVSxDQUFDO0FBRWhCLHNDQUFzQztBQUN0Q0MsT0FBT0MsTUFBTSxHQUFHSCxhQUFJLENBQUNJLEVBQUUsQ0FBQyxJQUFPLENBQUE7UUFDN0JDLGFBQWFMLGFBQUksQ0FBQ0ksRUFBRTtRQUNwQkUsV0FBV04sYUFBSSxDQUFDSSxFQUFFO1FBQ2xCRyxXQUFXO1FBQ1hDLFNBQVM7SUFDWCxDQUFBO0FBRUEsc0NBQXNDO0FBQ3RDTixPQUFPTyxTQUFTLEdBQUc7SUFDakJDLE1BQU1WLGFBQUksQ0FBQ0ksRUFBRSxDQUFDLElBQU8sQ0FBQTtZQUNuQk8sV0FBVztZQUNYSCxTQUFTO1lBQ1RJLGlCQUFpQjtZQUNqQkMsUUFBUTtnQkFDTkMsbUJBQW1CZCxhQUFJLENBQUNJLEVBQUUsQ0FBQyxJQUFPLENBQUE7d0JBQ2hDVyxhQUFhZixhQUFJLENBQUNJLEVBQUU7b0JBQ3RCLENBQUE7Z0JBQ0FZLGFBQWFoQixhQUFJLENBQUNJLEVBQUUsQ0FBQyxJQUFPLENBQUE7d0JBQzFCYSxhQUFhakIsYUFBSSxDQUFDSSxFQUFFLENBQUMsSUFBTyxDQUFBO2dDQUMxQmMsS0FBS2xCLGFBQUksQ0FBQ0ksRUFBRSxDQUFDLElBQU8sQ0FBQTt3Q0FBRU8sV0FBVzt3Q0FBTUgsU0FBUztvQ0FBSyxD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