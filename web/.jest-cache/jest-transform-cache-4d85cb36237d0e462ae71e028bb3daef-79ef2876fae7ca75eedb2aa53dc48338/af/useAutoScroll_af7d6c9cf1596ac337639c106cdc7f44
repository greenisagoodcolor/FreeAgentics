698067312dc258d8f97ef4039cf24295
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useAutoScroll", {
    enumerable: true,
    get: function() {
        return useAutoScroll;
    }
});
const _react = require("react");
const _lodashes = require("lodash-es");
function useAutoScroll(containerRef, dependencies = [], options = {}) {
    const { threshold = 50, smoothScrollDuration = 300, enableUserOverride = true, overrideTimeout = 5000, enableKeyboardShortcuts = true, onScrollStateChange, onUserOverride, onAutoScrollResume } = options;
    const [state, setState] = (0, _react.useState)({
        isAutoScrollEnabled: true,
        isAtBottom: true,
        isScrolling: false,
        userOverrideActive: false,
        lastUserScrollTime: null,
        scrollProgress: 1
    });
    const scrollTimeoutRef = (0, _react.useRef)(null);
    const overrideTimeoutRef = (0, _react.useRef)(null);
    const isUserScrollingRef = (0, _react.useRef)(false);
    const lastScrollTopRef = (0, _react.useRef)(0);
    const animationFrameRef = (0, _react.useRef)(null);
    // Calculate if we're at the bottom
    const isAtBottom = (0, _react.useCallback)((container)=>{
        const { scrollTop, scrollHeight, clientHeight } = container;
        return scrollHeight - scrollTop - clientHeight <= threshold;
    }, [
        threshold
    ]);
    // Calculate scroll progress (0 = top, 1 = bottom)
    const getScrollProgress = (0, _react.useCallback)((container)=>{
        const { scrollTop, scrollHeight, clientHeight } = container;
        const maxScroll = scrollHeight - clientHeight;
        return maxScroll > 0 ? scrollTop / maxScroll : 1;
    }, []);
    // Smooth scroll to position
    const smoothScrollTo = (0, _react.useCallback)((container, targetPosition, duration = smoothScrollDuration)=>{
        const startPosition = container.scrollTop;
        const distance = targetPosition - startPosition;
        const startTime = performance.now();
        setState((prev)=>({
                ...prev,
                isScrolling: true
            }));
        const animateScroll = (currentTime)=>{
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            // Easing function (ease-out)
            const easeOut = 1 - Math.pow(1 - progress, 3);
            container.scrollTop = startPosition + distance * easeOut;
            if (progress < 1) {
                animationFrameRef.current = requestAnimationFrame(animateScroll);
            } else {
                setState((prev)=>({
                        ...prev,
                        isScrolling: false
                    }));
                animationFrameRef.current = null;
            }
        };
        animationFrameRef.current = requestAnimationFrame(animateScroll);
    }, [
        smoothScrollDuration
    ]);
    // Scroll to bottom
    const scrollToBottom = (0, _react.useCallback)((smooth = true)=>{
        const container = containerRef.current;
        if (!container) return;
        const targetPosition = container.scrollHeight - container.clientHeight;
        if (smooth) {
            smoothScrollTo(container, targetPosition);
        } else {
            container.scrollTop = targetPosition;
        }
        setState((prev)=>({
                ...prev,
                isAtBottom: true,
                scrollProgress: 1,
                userOverrideActive: false
            }));
    }, [
        containerRef,
        smoothScrollTo
    ]);
    // Scroll to top
    const scrollToTop = (0, _react.useCallback)((smooth = true)=>{
        const container = containerRef.current;
        if (!container) return;
        if (smooth) {
            smoothScrollTo(container, 0);
        } else {
            container.scrollTop = 0;
        }
        setState((prev)=>({
                ...prev,
                isAtBottom: false,
                scrollProgress: 0
            }));
    }, [
        containerRef,
        smoothScrollTo
    ]);
    // Scroll to specific element
    const scrollToElement = (0, _react.useCallback)((element, smooth = true)=>{
        const container = containerRef.current;
        if (!container) return;
        const elementTop = element.offsetTop;
        const containerTop = container.scrollTop;
        const containerHeight = container.clientHeight;
        // Center the element in the viewport
        const targetPosition = elementTop - containerHeight / 2;
        if (smooth) {
            smoothScrollTo(container, Math.max(0, targetPosition));
        } else {
            container.scrollTop = Math.max(0, targetPosition);
        }
    }, [
        containerRef,
        smoothScrollTo
    ]);
    // Enable auto-scroll
    const enableAutoScroll = (0, _react.useCallback)(()=>{
        setState((prev)=>({
                ...prev,
                isAutoScrollEnabled: true,
                userOverrideActive: false
            }));
        // Clear override timeout
        if (overrideTimeoutRef.current) {
            clearTimeout(overrideTimeoutRef.current);
            overrideTimeoutRef.current = null;
        }
        onAutoScrollResume?.();
    }, [
        onAutoScrollResume
    ]);
    // Disable auto-scroll
    const disableAutoScroll = (0, _react.useCallback)(()=>{
        setState((prev)=>({
                ...prev,
                isAutoScrollEnabled: false,
                userOverrideActive: true,
                lastUserScrollTime: Date.now()
            }));
        onUserOverride?.();
    }, [
        onUserOverride
    ]);
    // Toggle auto-scroll
    const toggleAutoScroll = (0, _react.useCallback)(()=>{
        setState((prev)=>{
            if (prev.isAutoScrollEnabled) {
                disableAutoScroll();
                return prev;
            } else {
                enableAutoScroll();
                return prev;
            }
        });
    }, [
        enableAutoScroll,
        disableAutoScroll
    ]);
    // Jump to latest (force scroll to bottom and enable auto-scroll)
    const jumpToLatest = (0, _react.useCallback)(()=>{
        enableAutoScroll();
        scrollToBottom(true);
    }, [
        enableAutoScroll,
        scrollToBottom
    ]);
    // Handle scroll events
    const handleScroll = (0, _react.useCallback)((0, _lodashes.debounce)(()=>{
        const container = containerRef.current;
        if (!container || state.isScrolling) return;
        const currentScrollTop = container.scrollTop;
        const atBottom = isAtBottom(container);
        const progress = getScrollProgress(container);
        // Detect user scrolling (not programmatic)
        const isUserInitiated = !state.isScrolling && Math.abs(currentScrollTop - lastScrollTopRef.current) > 5;
        if (isUserInitiated && enableUserOverride) {
            isUserScrollingRef.current = true;
            // If user scrolled away from bottom, disable auto-scroll
            if (!atBottom && state.isAutoScrollEnabled) {
                setState((prev)=>({
                        ...prev,
                        isAutoScrollEnabled: false,
                        userOverrideActive: true,
                        lastUserScrollTime: Date.now()
                    }));
                onUserOverride?.();
                // Set timeout to re-enable auto-scroll
                if (overrideTimeoutRef.current) {
                    clearTimeout(overrideTimeoutRef.current);
                }
                overrideTimeoutRef.current = setTimeout(()=>{
                    setState((prev)=>({
                            ...prev,
                            isAutoScrollEnabled: true,
                            userOverrideActive: false
                        }));
                    onAutoScrollResume?.();
                }, overrideTimeout);
            }
            // If user scrolled back to bottom, re-enable auto-scroll
            if (atBottom && !state.isAutoScrollEnabled) {
                enableAutoScroll();
            }
        }
        setState((prev)=>({
                ...prev,
                isAtBottom: atBottom,
                scrollProgress: progress
            }));
        lastScrollTopRef.current = currentScrollTop;
        // Clear user scrolling flag after a delay
        setTimeout(()=>{
            isUserScrollingRef.current = false;
        }, 100);
    }, 50), [
        containerRef,
        isAtBottom,
        getScrollProgress,
        enableUserOverride,
        state.isScrolling,
        state.isAutoScrollEnabled,
        overrideTimeout,
        enableAutoScroll,
        onUserOverride,
        onAutoScrollResume
    ]);
    // Auto-scroll when dependencies change
    (0, _react.useEffect)(()=>{
        if (state.isAutoScrollEnabled && state.isAtBottom && !isUserScrollingRef.current) {
            // Small delay to ensure DOM has updated
            setTimeout(()=>{
                scrollToBottom(true);
            }, 10);
        }
    }, [
        ...dependencies,
        state.isAutoScrollEnabled
    ]);
    // Set up scroll listener
    (0, _react.useEffect)(()=>{
        const container = containerRef.current;
        if (!container) return;
        container.addEventListener("scroll", handleScroll, {
            passive: true
        });
        return ()=>{
            container.removeEventListener("scroll", handleScroll);
        };
    }, [
        handleScroll,
        containerRef
    ]);
    // Keyboard shortcuts
    (0, _react.useEffect)(()=>{
        if (!enableKeyboardShortcuts) return;
        const handleKeyDown = (event)=>{
            // Only handle if no input elements are focused
            if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA") {
                return;
            }
            switch(event.key){
                case "End":
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        jumpToLatest();
                    }
                    break;
                case "Home":
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        scrollToTop(true);
                    }
                    break;
                case " ":
                    if (event.shiftKey) {
                        event.preventDefault();
                        toggleAutoScroll();
                    }
                    break;
            }
        };
        document.addEventListener("keydown", handleKeyDown);
        return ()=>{
            document.removeEventListener("keydown", handleKeyDown);
        };
    }, [
        enableKeyboardShortcuts,
        jumpToLatest,
        scrollToTop,
        toggleAutoScroll
    ]);
    // Notify state changes
    (0, _react.useEffect)(()=>{
        onScrollStateChange?.(state.isAutoScrollEnabled, state.isAtBottom);
    }, [
        state.isAutoScrollEnabled,
        state.isAtBottom,
        onScrollStateChange
    ]);
    // Cleanup
    (0, _react.useEffect)(()=>{
        return ()=>{
            if (scrollTimeoutRef.current) {
                clearTimeout(scrollTimeoutRef.current);
            }
            if (overrideTimeoutRef.current) {
                clearTimeout(overrideTimeoutRef.current);
            }
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
        };
    }, []);
    return {
        scrollToBottom,
        scrollToTop,
        scrollToElement,
        enableAutoScroll,
        disableAutoScroll,
        toggleAutoScroll,
        jumpToLatest,
        state
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9ob29rcy91c2VBdXRvU2Nyb2xsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBBdXRvU2Nyb2xsT3B0aW9ucyB7XG4gIHRocmVzaG9sZD86IG51bWJlcjsgLy8gRGlzdGFuY2UgZnJvbSBib3R0b20gdG8gY29uc2lkZXIgXCJhdCBib3R0b21cIiAoZGVmYXVsdDogNTBweClcbiAgc21vb3RoU2Nyb2xsRHVyYXRpb24/OiBudW1iZXI7IC8vIER1cmF0aW9uIGZvciBzbW9vdGggc2Nyb2xsaW5nIChkZWZhdWx0OiAzMDBtcylcbiAgZW5hYmxlVXNlck92ZXJyaWRlPzogYm9vbGVhbjsgLy8gQWxsb3cgdXNlciBzY3JvbGxpbmcgdG8gZGlzYWJsZSBhdXRvLXNjcm9sbCAoZGVmYXVsdDogdHJ1ZSlcbiAgb3ZlcnJpZGVUaW1lb3V0PzogbnVtYmVyOyAvLyBUaW1lIGJlZm9yZSByZS1lbmFibGluZyBhdXRvLXNjcm9sbCBhZnRlciB1c2VyIHNjcm9sbCAoZGVmYXVsdDogNTAwMG1zKVxuICBlbmFibGVLZXlib2FyZFNob3J0Y3V0cz86IGJvb2xlYW47IC8vIEVuYWJsZSBrZXlib2FyZCBzaG9ydGN1dHMgZm9yIHNjcm9sbCBjb250cm9sIChkZWZhdWx0OiB0cnVlKVxuICBvblNjcm9sbFN0YXRlQ2hhbmdlPzogKFxuICAgIGlzQXV0b1Njcm9sbEVuYWJsZWQ6IGJvb2xlYW4sXG4gICAgaXNBdEJvdHRvbTogYm9vbGVhbixcbiAgKSA9PiB2b2lkO1xuICBvblVzZXJPdmVycmlkZT86ICgpID0+IHZvaWQ7XG4gIG9uQXV0b1Njcm9sbFJlc3VtZT86ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b1Njcm9sbFN0YXRlIHtcbiAgaXNBdXRvU2Nyb2xsRW5hYmxlZDogYm9vbGVhbjtcbiAgaXNBdEJvdHRvbTogYm9vbGVhbjtcbiAgaXNTY3JvbGxpbmc6IGJvb2xlYW47XG4gIHVzZXJPdmVycmlkZUFjdGl2ZTogYm9vbGVhbjtcbiAgbGFzdFVzZXJTY3JvbGxUaW1lOiBudW1iZXIgfCBudWxsO1xuICBzY3JvbGxQcm9ncmVzczogbnVtYmVyOyAvLyAwLTEgcmVwcmVzZW50aW5nIHNjcm9sbCBwb3NpdGlvblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9TY3JvbGxDb250cm9scyB7XG4gIHNjcm9sbFRvQm90dG9tOiAoc21vb3RoPzogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2Nyb2xsVG9Ub3A6IChzbW9vdGg/OiBib29sZWFuKSA9PiB2b2lkO1xuICBzY3JvbGxUb0VsZW1lbnQ6IChlbGVtZW50OiBIVE1MRWxlbWVudCwgc21vb3RoPzogYm9vbGVhbikgPT4gdm9pZDtcbiAgZW5hYmxlQXV0b1Njcm9sbDogKCkgPT4gdm9pZDtcbiAgZGlzYWJsZUF1dG9TY3JvbGw6ICgpID0+IHZvaWQ7XG4gIHRvZ2dsZUF1dG9TY3JvbGw6ICgpID0+IHZvaWQ7XG4gIGp1bXBUb0xhdGVzdDogKCkgPT4gdm9pZDtcbiAgc3RhdGU6IEF1dG9TY3JvbGxTdGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUF1dG9TY3JvbGwoXG4gIGNvbnRhaW5lclJlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxFbGVtZW50PixcbiAgZGVwZW5kZW5jaWVzOiBhbnlbXSA9IFtdLFxuICBvcHRpb25zOiBBdXRvU2Nyb2xsT3B0aW9ucyA9IHt9LFxuKTogQXV0b1Njcm9sbENvbnRyb2xzIHtcbiAgY29uc3Qge1xuICAgIHRocmVzaG9sZCA9IDUwLFxuICAgIHNtb290aFNjcm9sbER1cmF0aW9uID0gMzAwLFxuICAgIGVuYWJsZVVzZXJPdmVycmlkZSA9IHRydWUsXG4gICAgb3ZlcnJpZGVUaW1lb3V0ID0gNTAwMCxcbiAgICBlbmFibGVLZXlib2FyZFNob3J0Y3V0cyA9IHRydWUsXG4gICAgb25TY3JvbGxTdGF0ZUNoYW5nZSxcbiAgICBvblVzZXJPdmVycmlkZSxcbiAgICBvbkF1dG9TY3JvbGxSZXN1bWUsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8QXV0b1Njcm9sbFN0YXRlPih7XG4gICAgaXNBdXRvU2Nyb2xsRW5hYmxlZDogdHJ1ZSxcbiAgICBpc0F0Qm90dG9tOiB0cnVlLFxuICAgIGlzU2Nyb2xsaW5nOiBmYWxzZSxcbiAgICB1c2VyT3ZlcnJpZGVBY3RpdmU6IGZhbHNlLFxuICAgIGxhc3RVc2VyU2Nyb2xsVGltZTogbnVsbCxcbiAgICBzY3JvbGxQcm9ncmVzczogMSxcbiAgfSk7XG5cbiAgY29uc3Qgc2Nyb2xsVGltZW91dFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBvdmVycmlkZVRpbWVvdXRSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgaXNVc2VyU2Nyb2xsaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgbGFzdFNjcm9sbFRvcFJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgYW5pbWF0aW9uRnJhbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gQ2FsY3VsYXRlIGlmIHdlJ3JlIGF0IHRoZSBib3R0b21cbiAgY29uc3QgaXNBdEJvdHRvbSA9IHVzZUNhbGxiYWNrKFxuICAgIChjb250YWluZXI6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgfSA9IGNvbnRhaW5lcjtcbiAgICAgIHJldHVybiBzY3JvbGxIZWlnaHQgLSBzY3JvbGxUb3AgLSBjbGllbnRIZWlnaHQgPD0gdGhyZXNob2xkO1xuICAgIH0sXG4gICAgW3RocmVzaG9sZF0sXG4gICk7XG5cbiAgLy8gQ2FsY3VsYXRlIHNjcm9sbCBwcm9ncmVzcyAoMCA9IHRvcCwgMSA9IGJvdHRvbSlcbiAgY29uc3QgZ2V0U2Nyb2xsUHJvZ3Jlc3MgPSB1c2VDYWxsYmFjaygoY29udGFpbmVyOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9ID0gY29udGFpbmVyO1xuICAgIGNvbnN0IG1heFNjcm9sbCA9IHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodDtcbiAgICByZXR1cm4gbWF4U2Nyb2xsID4gMCA/IHNjcm9sbFRvcCAvIG1heFNjcm9sbCA6IDE7XG4gIH0sIFtdKTtcblxuICAvLyBTbW9vdGggc2Nyb2xsIHRvIHBvc2l0aW9uXG4gIGNvbnN0IHNtb290aFNjcm9sbFRvID0gdXNlQ2FsbGJhY2soXG4gICAgKFxuICAgICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgICAgIHRhcmdldFBvc2l0aW9uOiBudW1iZXIsXG4gICAgICBkdXJhdGlvbjogbnVtYmVyID0gc21vb3RoU2Nyb2xsRHVyYXRpb24sXG4gICAgKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gY29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGFyZ2V0UG9zaXRpb24gLSBzdGFydFBvc2l0aW9uO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIHNldFN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBpc1Njcm9sbGluZzogdHJ1ZSB9KSk7XG5cbiAgICAgIGNvbnN0IGFuaW1hdGVTY3JvbGwgPSAoY3VycmVudFRpbWU6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGR1cmF0aW9uLCAxKTtcblxuICAgICAgICAvLyBFYXNpbmcgZnVuY3Rpb24gKGVhc2Utb3V0KVxuICAgICAgICBjb25zdCBlYXNlT3V0ID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMyk7XG5cbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IHN0YXJ0UG9zaXRpb24gKyBkaXN0YW5jZSAqIGVhc2VPdXQ7XG5cbiAgICAgICAgaWYgKHByb2dyZXNzIDwgMSkge1xuICAgICAgICAgIGFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZVNjcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0U3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIGlzU2Nyb2xsaW5nOiBmYWxzZSB9KSk7XG4gICAgICAgICAgYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZVNjcm9sbCk7XG4gICAgfSxcbiAgICBbc21vb3RoU2Nyb2xsRHVyYXRpb25dLFxuICApO1xuXG4gIC8vIFNjcm9sbCB0byBib3R0b21cbiAgY29uc3Qgc2Nyb2xsVG9Cb3R0b20gPSB1c2VDYWxsYmFjayhcbiAgICAoc21vb3RoOiBib29sZWFuID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQgLSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuXG4gICAgICBpZiAoc21vb3RoKSB7XG4gICAgICAgIHNtb290aFNjcm9sbFRvKGNvbnRhaW5lciwgdGFyZ2V0UG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IHRhcmdldFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSgocHJldikgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgaXNBdEJvdHRvbTogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsUHJvZ3Jlc3M6IDEsXG4gICAgICAgIHVzZXJPdmVycmlkZUFjdGl2ZTogZmFsc2UsXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBbY29udGFpbmVyUmVmLCBzbW9vdGhTY3JvbGxUb10sXG4gICk7XG5cbiAgLy8gU2Nyb2xsIHRvIHRvcFxuICBjb25zdCBzY3JvbGxUb1RvcCA9IHVzZUNhbGxiYWNrKFxuICAgIChzbW9vdGg6IGJvb2xlYW4gPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG5cbiAgICAgIGlmIChzbW9vdGgpIHtcbiAgICAgICAgc21vb3RoU2Nyb2xsVG8oY29udGFpbmVyLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSgocHJldikgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgaXNBdEJvdHRvbTogZmFsc2UsXG4gICAgICAgIHNjcm9sbFByb2dyZXNzOiAwLFxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgW2NvbnRhaW5lclJlZiwgc21vb3RoU2Nyb2xsVG9dLFxuICApO1xuXG4gIC8vIFNjcm9sbCB0byBzcGVjaWZpYyBlbGVtZW50XG4gIGNvbnN0IHNjcm9sbFRvRWxlbWVudCA9IHVzZUNhbGxiYWNrKFxuICAgIChlbGVtZW50OiBIVE1MRWxlbWVudCwgc21vb3RoOiBib29sZWFuID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgICBjb25zdCBlbGVtZW50VG9wID0gZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICBjb25zdCBjb250YWluZXJUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcblxuICAgICAgLy8gQ2VudGVyIHRoZSBlbGVtZW50IGluIHRoZSB2aWV3cG9ydFxuICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBlbGVtZW50VG9wIC0gY29udGFpbmVySGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKHNtb290aCkge1xuICAgICAgICBzbW9vdGhTY3JvbGxUbyhjb250YWluZXIsIE1hdGgubWF4KDAsIHRhcmdldFBvc2l0aW9uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgdGFyZ2V0UG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2NvbnRhaW5lclJlZiwgc21vb3RoU2Nyb2xsVG9dLFxuICApO1xuXG4gIC8vIEVuYWJsZSBhdXRvLXNjcm9sbFxuICBjb25zdCBlbmFibGVBdXRvU2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzQXV0b1Njcm9sbEVuYWJsZWQ6IHRydWUsXG4gICAgICB1c2VyT3ZlcnJpZGVBY3RpdmU6IGZhbHNlLFxuICAgIH0pKTtcblxuICAgIC8vIENsZWFyIG92ZXJyaWRlIHRpbWVvdXRcbiAgICBpZiAob3ZlcnJpZGVUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dChvdmVycmlkZVRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBvdmVycmlkZVRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgb25BdXRvU2Nyb2xsUmVzdW1lPy4oKTtcbiAgfSwgW29uQXV0b1Njcm9sbFJlc3VtZV0pO1xuXG4gIC8vIERpc2FibGUgYXV0by1zY3JvbGxcbiAgY29uc3QgZGlzYWJsZUF1dG9TY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgaXNBdXRvU2Nyb2xsRW5hYmxlZDogZmFsc2UsXG4gICAgICB1c2VyT3ZlcnJpZGVBY3RpdmU6IHRydWUsXG4gICAgICBsYXN0VXNlclNjcm9sbFRpbWU6IERhdGUubm93KCksXG4gICAgfSkpO1xuXG4gICAgb25Vc2VyT3ZlcnJpZGU/LigpO1xuICB9LCBbb25Vc2VyT3ZlcnJpZGVdKTtcblxuICAvLyBUb2dnbGUgYXV0by1zY3JvbGxcbiAgY29uc3QgdG9nZ2xlQXV0b1Njcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRTdGF0ZSgocHJldikgPT4ge1xuICAgICAgaWYgKHByZXYuaXNBdXRvU2Nyb2xsRW5hYmxlZCkge1xuICAgICAgICBkaXNhYmxlQXV0b1Njcm9sbCgpO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuYWJsZUF1dG9TY3JvbGwoKTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtlbmFibGVBdXRvU2Nyb2xsLCBkaXNhYmxlQXV0b1Njcm9sbF0pO1xuXG4gIC8vIEp1bXAgdG8gbGF0ZXN0IChmb3JjZSBzY3JvbGwgdG8gYm90dG9tIGFuZCBlbmFibGUgYXV0by1zY3JvbGwpXG4gIGNvbnN0IGp1bXBUb0xhdGVzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBlbmFibGVBdXRvU2Nyb2xsKCk7XG4gICAgc2Nyb2xsVG9Cb3R0b20odHJ1ZSk7XG4gIH0sIFtlbmFibGVBdXRvU2Nyb2xsLCBzY3JvbGxUb0JvdHRvbV0pO1xuXG4gIC8vIEhhbmRsZSBzY3JvbGwgZXZlbnRzXG4gIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHVzZUNhbGxiYWNrKFxuICAgIGRlYm91bmNlKCgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXIgfHwgc3RhdGUuaXNTY3JvbGxpbmcpIHJldHVybjtcblxuICAgICAgY29uc3QgY3VycmVudFNjcm9sbFRvcCA9IGNvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICBjb25zdCBhdEJvdHRvbSA9IGlzQXRCb3R0b20oY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gZ2V0U2Nyb2xsUHJvZ3Jlc3MoY29udGFpbmVyKTtcblxuICAgICAgLy8gRGV0ZWN0IHVzZXIgc2Nyb2xsaW5nIChub3QgcHJvZ3JhbW1hdGljKVxuICAgICAgY29uc3QgaXNVc2VySW5pdGlhdGVkID1cbiAgICAgICAgIXN0YXRlLmlzU2Nyb2xsaW5nICYmXG4gICAgICAgIE1hdGguYWJzKGN1cnJlbnRTY3JvbGxUb3AgLSBsYXN0U2Nyb2xsVG9wUmVmLmN1cnJlbnQpID4gNTtcblxuICAgICAgaWYgKGlzVXNlckluaXRpYXRlZCAmJiBlbmFibGVVc2VyT3ZlcnJpZGUpIHtcbiAgICAgICAgaXNVc2VyU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgIC8vIElmIHVzZXIgc2Nyb2xsZWQgYXdheSBmcm9tIGJvdHRvbSwgZGlzYWJsZSBhdXRvLXNjcm9sbFxuICAgICAgICBpZiAoIWF0Qm90dG9tICYmIHN0YXRlLmlzQXV0b1Njcm9sbEVuYWJsZWQpIHtcbiAgICAgICAgICBzZXRTdGF0ZSgocHJldikgPT4gKHtcbiAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICBpc0F1dG9TY3JvbGxFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJPdmVycmlkZUFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGxhc3RVc2VyU2Nyb2xsVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBvblVzZXJPdmVycmlkZT8uKCk7XG5cbiAgICAgICAgICAvLyBTZXQgdGltZW91dCB0byByZS1lbmFibGUgYXV0by1zY3JvbGxcbiAgICAgICAgICBpZiAob3ZlcnJpZGVUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvdmVycmlkZVRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3ZlcnJpZGVUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXRlKChwcmV2KSA9PiAoe1xuICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICBpc0F1dG9TY3JvbGxFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB1c2VyT3ZlcnJpZGVBY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgb25BdXRvU2Nyb2xsUmVzdW1lPy4oKTtcbiAgICAgICAgICB9LCBvdmVycmlkZVRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdXNlciBzY3JvbGxlZCBiYWNrIHRvIGJvdHRvbSwgcmUtZW5hYmxlIGF1dG8tc2Nyb2xsXG4gICAgICAgIGlmIChhdEJvdHRvbSAmJiAhc3RhdGUuaXNBdXRvU2Nyb2xsRW5hYmxlZCkge1xuICAgICAgICAgIGVuYWJsZUF1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSgocHJldikgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgaXNBdEJvdHRvbTogYXRCb3R0b20sXG4gICAgICAgIHNjcm9sbFByb2dyZXNzOiBwcm9ncmVzcyxcbiAgICAgIH0pKTtcblxuICAgICAgbGFzdFNjcm9sbFRvcFJlZi5jdXJyZW50ID0gY3VycmVudFNjcm9sbFRvcDtcblxuICAgICAgLy8gQ2xlYXIgdXNlciBzY3JvbGxpbmcgZmxhZyBhZnRlciBhIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNVc2VyU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSwgNTApLFxuICAgIFtcbiAgICAgIGNvbnRhaW5lclJlZixcbiAgICAgIGlzQXRCb3R0b20sXG4gICAgICBnZXRTY3JvbGxQcm9ncmVzcyxcbiAgICAgIGVuYWJsZVVzZXJPdmVycmlkZSxcbiAgICAgIHN0YXRlLmlzU2Nyb2xsaW5nLFxuICAgICAgc3RhdGUuaXNBdXRvU2Nyb2xsRW5hYmxlZCxcbiAgICAgIG92ZXJyaWRlVGltZW91dCxcbiAgICAgIGVuYWJsZUF1dG9TY3JvbGwsXG4gICAgICBvblVzZXJPdmVycmlkZSxcbiAgICAgIG9uQXV0b1Njcm9sbFJlc3VtZSxcbiAgICBdLFxuICApO1xuXG4gIC8vIEF1dG8tc2Nyb2xsIHdoZW4gZGVwZW5kZW5jaWVzIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChcbiAgICAgIHN0YXRlLmlzQXV0b1Njcm9sbEVuYWJsZWQgJiZcbiAgICAgIHN0YXRlLmlzQXRCb3R0b20gJiZcbiAgICAgICFpc1VzZXJTY3JvbGxpbmdSZWYuY3VycmVudFxuICAgICkge1xuICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIERPTSBoYXMgdXBkYXRlZFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNjcm9sbFRvQm90dG9tKHRydWUpO1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgfSwgWy4uLmRlcGVuZGVuY2llcywgc3RhdGUuaXNBdXRvU2Nyb2xsRW5hYmxlZF0pO1xuXG4gIC8vIFNldCB1cCBzY3JvbGwgbGlzdGVuZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsKTtcbiAgICB9O1xuICB9LCBbaGFuZGxlU2Nyb2xsLCBjb250YWluZXJSZWZdKTtcblxuICAvLyBLZXlib2FyZCBzaG9ydGN1dHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZUtleWJvYXJkU2hvcnRjdXRzKSByZXR1cm47XG5cbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAvLyBPbmx5IGhhbmRsZSBpZiBubyBpbnB1dCBlbGVtZW50cyBhcmUgZm9jdXNlZFxuICAgICAgaWYgKFxuICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50Py50YWdOYW1lID09PSBcIklOUFVUXCIgfHxcbiAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudD8udGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGp1bXBUb0xhdGVzdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2Nyb2xsVG9Ub3AodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRvZ2dsZUF1dG9TY3JvbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xuICAgIH07XG4gIH0sIFtlbmFibGVLZXlib2FyZFNob3J0Y3V0cywganVtcFRvTGF0ZXN0LCBzY3JvbGxUb1RvcCwgdG9nZ2xlQXV0b1Njcm9sbF0pO1xuXG4gIC8vIE5vdGlmeSBzdGF0ZSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgb25TY3JvbGxTdGF0ZUNoYW5nZT8uKHN0YXRlLmlzQXV0b1Njcm9sbEVuYWJsZWQsIHN0YXRlLmlzQXRCb3R0b20pO1xuICB9LCBbc3RhdGUuaXNBdXRvU2Nyb2xsRW5hYmxlZCwgc3RhdGUuaXNBdEJvdHRvbSwgb25TY3JvbGxTdGF0ZUNoYW5nZV0pO1xuXG4gIC8vIENsZWFudXBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHNjcm9sbFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZVRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQob3ZlcnJpZGVUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgc2Nyb2xsVG9Cb3R0b20sXG4gICAgc2Nyb2xsVG9Ub3AsXG4gICAgc2Nyb2xsVG9FbGVtZW50LFxuICAgIGVuYWJsZUF1dG9TY3JvbGwsXG4gICAgZGlzYWJsZUF1dG9TY3JvbGwsXG4gICAgdG9nZ2xlQXV0b1Njcm9sbCxcbiAgICBqdW1wVG9MYXRlc3QsXG4gICAgc3RhdGUsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlQXV0b1Njcm9sbCIsImNvbnRhaW5lclJlZiIsImRlcGVuZGVuY2llcyIsIm9wdGlvbnMiLCJ0aHJlc2hvbGQiLCJzbW9vdGhTY3JvbGxEdXJhdGlvbiIsImVuYWJsZVVzZXJPdmVycmlkZSIsIm92ZXJyaWRlVGltZW91dCIsImVuYWJsZUtleWJvYXJkU2hvcnRjdXRzIiwib25TY3JvbGxTdGF0ZUNoYW5nZSIsIm9uVXNlck92ZXJyaWRlIiwib25BdXRvU2Nyb2xsUmVzdW1lIiwic3RhdGUiLCJzZXRTdGF0ZSIsInVzZVN0YXRlIiwiaXNBdXRvU2Nyb2xsRW5hYmxlZCIsImlzQXRCb3R0b20iLCJpc1Njcm9sbGluZyIsInVzZXJPdmVycmlkZUFjdGl2ZSIsImxhc3RVc2VyU2Nyb2xsVGltZSIsInNjcm9sbFByb2dyZXNzIiwic2Nyb2xsVGltZW91dFJlZiIsInVzZVJlZiIsIm92ZXJyaWRlVGltZW91dFJlZiIsImlzVXNlclNjcm9sbGluZ1JlZiIsImxhc3RTY3JvbGxUb3BSZWYiLCJhbmltYXRpb25GcmFtZVJlZiIsInVzZUNhbGxiYWNrIiwiY29udGFpbmVyIiwic2Nyb2xsVG9wIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0U2Nyb2xsUHJvZ3Jlc3MiLCJtYXhTY3JvbGwiLCJzbW9vdGhTY3JvbGxUbyIsInRhcmdldFBvc2l0aW9uIiwiZHVyYXRpb24iLCJzdGFydFBvc2l0aW9uIiwiZGlzdGFuY2UiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInByZXYiLCJhbmltYXRlU2Nyb2xsIiwiY3VycmVudFRpbWUiLCJlbGFwc2VkIiwicHJvZ3Jlc3MiLCJNYXRoIiwibWluIiwiZWFzZU91dCIsInBvdyIsImN1cnJlbnQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzY3JvbGxUb0JvdHRvbSIsInNtb290aCIsInNjcm9sbFRvVG9wIiwic2Nyb2xsVG9FbGVtZW50IiwiZWxlbWVudCIsImVsZW1lbnRUb3AiLCJvZmZzZXRUb3AiLCJjb250YWluZXJUb3AiLCJjb250YWluZXJIZWlnaHQiLCJtYXgiLCJlbmFibGVBdXRvU2Nyb2xsIiwiY2xlYXJUaW1lb3V0IiwiZGlzYWJsZUF1dG9TY3JvbGwiLCJEYXRlIiwidG9nZ2xlQXV0b1Njcm9sbCIsImp1bXBUb0xhdGVzdCIsImhhbmRsZVNjcm9sbCIsImRlYm91bmNlIiwiY3VycmVudFNjcm9sbFRvcCIsImF0Qm90dG9tIiwiaXNVc2VySW5pdGlhdGVkIiwiYWJzIiwic2V0VGltZW91dCIsInVzZUVmZmVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZUtleURvd24iLCJldmVudCIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsInRhZ05hbWUiLCJrZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsInByZXZlbnREZWZhdWx0Iiwic2hpZnRLZXkiLCJjYW5jZWxBbmltYXRpb25GcmFtZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OytCQXVDZ0JBOzs7ZUFBQUE7Ozt1QkFyQ3lDOzBCQUNoQztBQW9DbEIsU0FBU0EsY0FDZEMsWUFBMEMsRUFDMUNDLGVBQXNCLEVBQUUsRUFDeEJDLFVBQTZCLENBQUMsQ0FBQztJQUUvQixNQUFNLEVBQ0pDLFlBQVksRUFBRSxFQUNkQyx1QkFBdUIsR0FBRyxFQUMxQkMscUJBQXFCLElBQUksRUFDekJDLGtCQUFrQixJQUFJLEVBQ3RCQywwQkFBMEIsSUFBSSxFQUM5QkMsbUJBQW1CLEVBQ25CQyxjQUFjLEVBQ2RDLGtCQUFrQixFQUNuQixHQUFHUjtJQUVKLE1BQU0sQ0FBQ1MsT0FBT0MsU0FBUyxHQUFHQyxJQUFBQSxlQUFRLEVBQWtCO1FBQ2xEQyxxQkFBcUI7UUFDckJDLFlBQVk7UUFDWkMsYUFBYTtRQUNiQyxvQkFBb0I7UUFDcEJDLG9CQUFvQjtRQUNwQkMsZ0JBQWdCO0lBQ2xCO0lBRUEsTUFBTUMsbUJBQW1CQyxJQUFBQSxhQUFNLEVBQXdCO0lBQ3ZELE1BQU1DLHFCQUFxQkQsSUFBQUEsYUFBTSxFQUF3QjtJQUN6RCxNQUFNRSxxQkFBcUJGLElBQUFBLGFBQU0sRUFBQztJQUNsQyxNQUFNRyxtQkFBbUJILElBQUFBLGFBQU0sRUFBQztJQUNoQyxNQUFNSSxvQkFBb0JKLElBQUFBLGFBQU0sRUFBZ0I7SUFFaEQsbUNBQW1DO0lBQ25DLE1BQU1OLGFBQWFXLElBQUFBLGtCQUFXLEVBQzVCLENBQUNDO1FBQ0MsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsWUFBWSxFQUFFLEdBQUdIO1FBQ2xELE9BQU9FLGVBQWVELFlBQVlFLGdCQUFnQjNCO0lBQ3BELEdBQ0E7UUFBQ0E7S0FBVTtJQUdiLGtEQUFrRDtJQUNsRCxNQUFNNEIsb0JBQW9CTCxJQUFBQSxrQkFBVyxFQUFDLENBQUNDO1FBQ3JDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxZQUFZLEVBQUVDLFlBQVksRUFBRSxHQUFHSDtRQUNsRCxNQUFNSyxZQUFZSCxlQUFlQztRQUNqQyxPQUFPRSxZQUFZLElBQUlKLFlBQVlJLFlBQVk7SUFDakQsR0FBRyxFQUFFO0lBRUwsNEJBQTRCO0lBQzVCLE1BQU1DLGlCQUFpQlAsSUFBQUEsa0JBQVcsRUFDaEMsQ0FDRUMsV0FDQU8sZ0JBQ0FDLFdBQW1CL0Isb0JBQW9CO1FBRXZDLE1BQU1nQyxnQkFBZ0JULFVBQVVDLFNBQVM7UUFDekMsTUFBTVMsV0FBV0gsaUJBQWlCRTtRQUNsQyxNQUFNRSxZQUFZQyxZQUFZQyxHQUFHO1FBRWpDNUIsU0FBUyxDQUFDNkIsT0FBVSxDQUFBO2dCQUFFLEdBQUdBLElBQUk7Z0JBQUV6QixhQUFhO1lBQUssQ0FBQTtRQUVqRCxNQUFNMEIsZ0JBQWdCLENBQUNDO1lBQ3JCLE1BQU1DLFVBQVVELGNBQWNMO1lBQzlCLE1BQU1PLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQ0gsVUFBVVQsVUFBVTtZQUU5Qyw2QkFBNkI7WUFDN0IsTUFBTWEsVUFBVSxJQUFJRixLQUFLRyxHQUFHLENBQUMsSUFBSUosVUFBVTtZQUUzQ2xCLFVBQVVDLFNBQVMsR0FBR1EsZ0JBQWdCQyxXQUFXVztZQUVqRCxJQUFJSCxXQUFXLEdBQUc7Z0JBQ2hCcEIsa0JBQWtCeUIsT0FBTyxHQUFHQyxzQkFBc0JUO1lBQ3BELE9BQU87Z0JBQ0w5QixTQUFTLENBQUM2QixPQUFVLENBQUE7d0JBQUUsR0FBR0EsSUFBSTt3QkFBRXpCLGFBQWE7b0JBQU0sQ0FBQTtnQkFDbERTLGtCQUFrQnlCLE9BQU8sR0FBRztZQUM5QjtRQUNGO1FBRUF6QixrQkFBa0J5QixPQUFPLEdBQUdDLHNCQUFzQlQ7SUFDcEQsR0FDQTtRQUFDdEM7S0FBcUI7SUFHeEIsbUJBQW1CO0lBQ25CLE1BQU1nRCxpQkFBaUIxQixJQUFBQSxrQkFBVyxFQUNoQyxDQUFDMkIsU0FBa0IsSUFBSTtRQUNyQixNQUFNMUIsWUFBWTNCLGFBQWFrRCxPQUFPO1FBQ3RDLElBQUksQ0FBQ3ZCLFdBQVc7UUFFaEIsTUFBTU8saUJBQWlCUCxVQUFVRSxZQUFZLEdBQUdGLFVBQVVHLFlBQVk7UUFFdEUsSUFBSXVCLFFBQVE7WUFDVnBCLGVBQWVOLFdBQVdPO1FBQzVCLE9BQU87WUFDTFAsVUFBVUMsU0FBUyxHQUFHTTtRQUN4QjtRQUVBdEIsU0FBUyxDQUFDNkIsT0FBVSxDQUFBO2dCQUNsQixHQUFHQSxJQUFJO2dCQUNQMUIsWUFBWTtnQkFDWkksZ0JBQWdCO2dCQUNoQkYsb0JBQW9CO1lBQ3RCLENBQUE7SUFDRixHQUNBO1FBQUNqQjtRQUFjaUM7S0FBZTtJQUdoQyxnQkFBZ0I7SUFDaEIsTUFBTXFCLGNBQWM1QixJQUFBQSxrQkFBVyxFQUM3QixDQUFDMkIsU0FBa0IsSUFBSTtRQUNyQixNQUFNMUIsWUFBWTNCLGFBQWFrRCxPQUFPO1FBQ3RDLElBQUksQ0FBQ3ZCLFdBQVc7UUFFaEIsSUFBSTBCLFFBQVE7WUFDVnBCLGVBQWVOLFdBQVc7UUFDNUIsT0FBTztZQUNMQSxVQUFVQyxTQUFTLEdBQUc7UUFDeEI7UUFFQWhCLFNBQVMsQ0FBQzZCLE9BQVUsQ0FBQTtnQkFDbEIsR0FBR0EsSUFBSTtnQkFDUDFCLFlBQVk7Z0JBQ1pJLGdCQUFnQjtZQUNsQixDQUFBO0lBQ0YsR0FDQTtRQUFDbkI7UUFBY2lDO0tBQWU7SUFHaEMsNkJBQTZCO0lBQzdCLE1BQU1zQixrQkFBa0I3QixJQUFBQSxrQkFBVyxFQUNqQyxDQUFDOEIsU0FBc0JILFNBQWtCLElBQUk7UUFDM0MsTUFBTTFCLFlBQVkzQixhQUFha0QsT0FBTztRQUN0QyxJQUFJLENBQUN2QixXQUFXO1FBRWhCLE1BQU04QixhQUFhRCxRQUFRRSxTQUFTO1FBQ3BDLE1BQU1DLGVBQWVoQyxVQUFVQyxTQUFTO1FBQ3hDLE1BQU1nQyxrQkFBa0JqQyxVQUFVRyxZQUFZO1FBRTlDLHFDQUFxQztRQUNyQyxNQUFNSSxpQkFBaUJ1QixhQUFhRyxrQkFBa0I7UUFFdEQsSUFBSVAsUUFBUTtZQUNWcEIsZUFBZU4sV0FBV21CLEtBQUtlLEdBQUcsQ0FBQyxHQUFHM0I7UUFDeEMsT0FBTztZQUNMUCxVQUFVQyxTQUFTLEdBQUdrQixLQUFLZSxHQUFHLENBQUMsR0FBRzNCO1FBQ3BDO0lBQ0YsR0FDQTtRQUFDbEM7UUFBY2lDO0tBQWU7SUFHaEMscUJBQXFCO0lBQ3JCLE1BQU02QixtQkFBbUJwQyxJQUFBQSxrQkFBVyxFQUFDO1FBQ25DZCxTQUFTLENBQUM2QixPQUFVLENBQUE7Z0JBQ2xCLEdBQUdBLElBQUk7Z0JBQ1AzQixxQkFBcUI7Z0JBQ3JCRyxvQkFBb0I7WUFDdEIsQ0FBQTtRQUVBLHlCQUF5QjtRQUN6QixJQUFJSyxtQkFBbUI0QixPQUFPLEVBQUU7WUFDOUJhLGFBQWF6QyxtQkFBbUI0QixPQUFPO1lBQ3ZDNUIsbUJBQW1CNEIsT0FBTyxHQUFHO1FBQy9CO1FBRUF4QztJQUNGLEdBQUc7UUFBQ0E7S0FBbUI7SUFFdkIsc0JBQXNCO0lBQ3RCLE1BQU1zRCxvQkFBb0J0QyxJQUFBQSxrQkFBVyxFQUFDO1FBQ3BDZCxTQUFTLENBQUM2QixPQUFVLENBQUE7Z0JBQ2xCLEdBQUdBLElBQUk7Z0JBQ1AzQixxQkFBcUI7Z0JBQ3JCRyxvQkFBb0I7Z0JBQ3BCQyxvQkFBb0IrQyxLQUFLekIsR0FBRztZQUM5QixDQUFBO1FBRUEvQjtJQUNGLEdBQUc7UUFBQ0E7S0FBZTtJQUVuQixxQkFBcUI7SUFDckIsTUFBTXlELG1CQUFtQnhDLElBQUFBLGtCQUFXLEVBQUM7UUFDbkNkLFNBQVMsQ0FBQzZCO1lBQ1IsSUFBSUEsS0FBSzNCLG1CQUFtQixFQUFFO2dCQUM1QmtEO2dCQUNBLE9BQU92QjtZQUNULE9BQU87Z0JBQ0xxQjtnQkFDQSxPQUFPckI7WUFDVDtRQUNGO0lBQ0YsR0FBRztRQUFDcUI7UUFBa0JFO0tBQWtCO0lBRXhDLGlFQUFpRTtJQUNqRSxNQUFNRyxlQUFlekMsSUFBQUEsa0JBQVcsRUFBQztRQUMvQm9DO1FBQ0FWLGVBQWU7SUFDakIsR0FBRztRQUFDVTtRQUFrQlY7S0FBZTtJQUVyQyx1QkFBdUI7SUFDdkIsTUFBTWdCLGVBQWUxQyxJQUFBQSxrQkFBVyxFQUM5QjJDLElBQUFBLGtCQUFRLEVBQUM7UUFDUCxNQUFNMUMsWUFBWTNCLGFBQWFrRCxPQUFPO1FBQ3RDLElBQUksQ0FBQ3ZCLGFBQWFoQixNQUFNSyxXQUFXLEVBQUU7UUFFckMsTUFBTXNELG1CQUFtQjNDLFVBQVVDLFNBQVM7UUFDNUMsTUFBTTJDLFdBQVd4RCxXQUFXWTtRQUM1QixNQUFNa0IsV0FBV2Qsa0JBQWtCSjtRQUVuQywyQ0FBMkM7UUFDM0MsTUFBTTZDLGtCQUNKLENBQUM3RCxNQUFNSyxXQUFXLElBQ2xCOEIsS0FBSzJCLEdBQUcsQ0FBQ0gsbUJBQW1COUMsaUJBQWlCMEIsT0FBTyxJQUFJO1FBRTFELElBQUlzQixtQkFBbUJuRSxvQkFBb0I7WUFDekNrQixtQkFBbUIyQixPQUFPLEdBQUc7WUFFN0IseURBQXlEO1lBQ3pELElBQUksQ0FBQ3FCLFlBQVk1RCxNQUFNRyxtQkFBbUIsRUFBRTtnQkFDMUNGLFNBQVMsQ0FBQzZCLE9BQVUsQ0FBQTt3QkFDbEIsR0FBR0EsSUFBSTt3QkFDUDNCLHFCQUFxQjt3QkFDckJHLG9CQUFvQjt3QkFDcEJDLG9CQUFvQitDLEtBQUt6QixHQUFHO29CQUM5QixDQUFBO2dCQUVBL0I7Z0JBRUEsdUNBQXVDO2dCQUN2QyxJQUFJYSxtQkFBbUI0QixPQUFPLEVBQUU7b0JBQzlCYSxhQUFhekMsbUJBQW1CNEIsT0FBTztnQkFDekM7Z0JBRUE1QixtQkFBbUI0QixPQUFPLEdBQUd3QixXQUFXO29CQUN0QzlELFNBQVMsQ0FBQzZCLE9BQVUsQ0FBQTs0QkFDbEIsR0FBR0EsSUFBSTs0QkFDUDNCLHFCQUFxQjs0QkFDckJHLG9CQUFvQjt3QkFDdEIsQ0FBQTtvQkFDQVA7Z0JBQ0YsR0FBR0o7WUFDTDtZQUVBLHlEQUF5RDtZQUN6RCxJQUFJaUUsWUFBWSxDQUFDNUQsTUFBTUcsbUJBQW1CLEVBQUU7Z0JBQzFDZ0Q7WUFDRjtRQUNGO1FBRUFsRCxTQUFTLENBQUM2QixPQUFVLENBQUE7Z0JBQ2xCLEdBQUdBLElBQUk7Z0JBQ1AxQixZQUFZd0Q7Z0JBQ1pwRCxnQkFBZ0IwQjtZQUNsQixDQUFBO1FBRUFyQixpQkFBaUIwQixPQUFPLEdBQUdvQjtRQUUzQiwwQ0FBMEM7UUFDMUNJLFdBQVc7WUFDVG5ELG1CQUFtQjJCLE9BQU8sR0FBRztRQUMvQixHQUFHO0lBQ0wsR0FBRyxLQUNIO1FBQ0VsRDtRQUNBZTtRQUNBZ0I7UUFDQTFCO1FBQ0FNLE1BQU1LLFdBQVc7UUFDakJMLE1BQU1HLG1CQUFtQjtRQUN6QlI7UUFDQXdEO1FBQ0FyRDtRQUNBQztLQUNEO0lBR0gsdUNBQXVDO0lBQ3ZDaUUsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLElBQ0VoRSxNQUFNRyxtQkFBbUIsSUFDekJILE1BQU1JLFVBQVUsSUFDaEIsQ0FBQ1EsbUJBQW1CMkIsT0FBTyxFQUMzQjtZQUNBLHdDQUF3QztZQUN4Q3dCLFdBQVc7Z0JBQ1R0QixlQUFlO1lBQ2pCLEdBQUc7UUFDTDtJQUNGLEdBQUc7V0FBSW5EO1FBQWNVLE1BQU1HLG1CQUFtQjtLQUFDO0lBRS9DLHlCQUF5QjtJQUN6QjZELElBQUFBLGdCQUFTLEVBQUM7UUFDUixNQUFNaEQsWUFBWTNCLGFBQWFrRCxPQUFPO1FBQ3RDLElBQUksQ0FBQ3ZCLFdBQVc7UUFFaEJBLFVBQVVpRCxnQkFBZ0IsQ0FBQyxVQUFVUixjQUFjO1lBQUVTLFNBQVM7UUFBSztRQUVuRSxPQUFPO1lBQ0xsRCxVQUFVbUQsbUJBQW1CLENBQUMsVUFBVVY7UUFDMUM7SUFDRixHQUFHO1FBQUNBO1FBQWNwRTtLQUFhO0lBRS9CLHFCQUFxQjtJQUNyQjJFLElBQUFBLGdCQUFTLEVBQUM7UUFDUixJQUFJLENBQUNwRSx5QkFBeUI7UUFFOUIsTUFBTXdFLGdCQUFnQixDQUFDQztZQUNyQiwrQ0FBK0M7WUFDL0MsSUFDRUMsU0FBU0MsYUFBYSxFQUFFQyxZQUFZLFdBQ3BDRixTQUFTQyxhQUFhLEVBQUVDLFlBQVksWUFDcEM7Z0JBQ0E7WUFDRjtZQUVBLE9BQVFILE1BQU1JLEdBQUc7Z0JBQ2YsS0FBSztvQkFDSCxJQUFJSixNQUFNSyxPQUFPLElBQUlMLE1BQU1NLE9BQU8sRUFBRTt3QkFDbENOLE1BQU1PLGNBQWM7d0JBQ3BCcEI7b0JBQ0Y7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJYSxNQUFNSyxPQUFPLElBQUlMLE1BQU1NLE9BQU8sRUFBRTt3QkFDbENOLE1BQU1PLGNBQWM7d0JBQ3BCakMsWUFBWTtvQkFDZDtvQkFDQTtnQkFDRixLQUFLO29CQUNILElBQUkwQixNQUFNUSxRQUFRLEVBQUU7d0JBQ2xCUixNQUFNTyxjQUFjO3dCQUNwQnJCO29CQUNGO29CQUNBO1lBQ0o7UUFDRjtRQUVBZSxTQUFTTCxnQkFBZ0IsQ0FBQyxXQUFXRztRQUVyQyxPQUFPO1lBQ0xFLFNBQVNILG1CQUFtQixDQUFDLFdBQVdDO1FBQzFDO0lBQ0YsR0FBRztRQUFDeEU7UUFBeUI0RDtRQUFjYjtRQUFhWTtLQUFpQjtJQUV6RSx1QkFBdUI7SUFDdkJTLElBQUFBLGdCQUFTLEVBQUM7UUFDUm5FLHNCQUFzQkcsTUFBTUcsbUJBQW1CLEVBQUVILE1BQU1JLFVBQVU7SUFDbkUsR0FBRztRQUFDSixNQUFNRyxtQkFBbUI7UUFBRUgsTUFBTUksVUFBVTtRQUFFUDtLQUFvQjtJQUVyRSxVQUFVO0lBQ1ZtRSxJQUFBQSxnQkFBUyxFQUFDO1FBQ1IsT0FBTztZQUNMLElBQUl2RCxpQkFBaUI4QixPQUFPLEVBQUU7Z0JBQzVCYSxhQUFhM0MsaUJBQWlCOEIsT0FBTztZQUN2QztZQUNBLElBQUk1QixtQkFBbUI0QixPQUFPLEVBQUU7Z0JBQzlCYSxhQUFhekMsbUJBQW1CNEIsT0FBTztZQUN6QztZQUNBLElBQUl6QixrQkFBa0J5QixPQUFPLEVBQUU7Z0JBQzdCdUMscUJBQXFCaEUsa0JBQWtCeUIsT0FBTztZQUNoRDtRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMRTtRQUNBRTtRQUNBQztRQUNBTztRQUNBRTtRQUNBRTtRQUNBQztRQUNBeEQ7SUFDRjtBQUNGIn0=