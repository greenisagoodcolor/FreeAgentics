{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/__tests__/lib/performance/performance-monitor.test.ts"],"sourcesContent":["/**\n * Phase 1: lib/performance/performance-monitor.ts Comprehensive Test Suite\n * Target: Complete performance monitoring and benchmarking functionality\n * Goal: Maximum statement coverage for performance analysis utilities\n */\n\nimport {\n  performanceMonitor,\n  PerformanceMetrics,\n  PerformanceBenchmark,\n} from \"../../../lib/performance/performance-monitor\";\n\n// Mock performance API\nconst mockPerformance = {\n  now: jest.fn(() => 1000),\n  mark: jest.fn(),\n  measure: jest.fn(),\n  getEntriesByName: jest.fn(),\n  clearMarks: jest.fn(),\n  clearMeasures: jest.fn(),\n  memory: {\n    usedJSHeapSize: 1024 * 1024, // 1MB\n  },\n};\n\n// Mock navigator.storage\nconst mockNavigatorStorage = {\n  estimate: jest.fn(() => Promise.resolve({ usage: 512 * 1024 })), // 512KB\n};\n\n// Mock localStorage\nconst mockLocalStorage = {\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  getItem: jest.fn(),\n  clear: jest.fn(),\n  length: 0,\n  key: jest.fn(),\n};\n\n// Mock TextEncoder\nconst mockTextEncoder = {\n  encode: jest.fn((str: string) => new Uint8Array(str.length)),\n};\n\n// Setup mocks\nbeforeAll(() => {\n  global.performance = mockPerformance as any;\n  global.navigator = {\n    ...global.navigator,\n    storage: mockNavigatorStorage,\n  } as any;\n  global.localStorage = mockLocalStorage as any;\n  global.TextEncoder = jest.fn(() => mockTextEncoder) as any;\n});\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n  performanceMonitor.clearMetrics();\n\n  // Reset performance.now mock to return incrementing values\n  let timeCounter = 1000;\n  mockPerformance.now.mockImplementation(() => timeCounter++);\n\n  // Setup default mock returns\n  mockPerformance.getEntriesByName.mockReturnValue([\n    {\n      name: \"test_operation\",\n      duration: 100,\n      startTime: 1000,\n      entryType: \"measure\",\n    },\n  ]);\n});\n\nafterEach(() => {\n  jest.clearAllTimers();\n  jest.useRealTimers();\n});\n\ndescribe(\"lib/performance/performance-monitor.ts - Complete Coverage\", () => {\n  describe(\"PerformanceMonitor - Basic Operations\", () => {\n    test(\"starts and ends operation successfully\", async () => {\n      const operationId =\n        await performanceMonitor.startOperation(\"test_operation\");\n\n      expect(operationId).toContain(\"test_operation\");\n      expect(mockPerformance.mark).toHaveBeenCalledWith(`${operationId}_start`);\n\n      const metric = await performanceMonitor.endOperation(operationId);\n\n      expect(mockPerformance.mark).toHaveBeenCalledWith(`${operationId}_end`);\n      expect(mockPerformance.measure).toHaveBeenCalled();\n      expect(metric.operation).toBe(\"test_operation\");\n      expect(metric.duration).toBe(100);\n    });\n\n    test(\"generates unique operation IDs\", async () => {\n      const id1 = await performanceMonitor.startOperation(\"operation\");\n      const id2 = await performanceMonitor.startOperation(\"operation\");\n\n      expect(id1).not.toBe(id2);\n      expect(id1).toContain(\"operation\");\n      expect(id2).toContain(\"operation\");\n    });\n\n    test(\"includes metadata in metrics\", async () => {\n      const operationId =\n        await performanceMonitor.startOperation(\"test_with_metadata\");\n\n      const metadata = {\n        dataSize: 1024,\n        errors: [\"Test error\"],\n        compressionRatio: 0.5,\n      };\n\n      const metric = await performanceMonitor.endOperation(\n        operationId,\n        metadata,\n      );\n\n      expect(metric.dataSize).toBe(1024);\n      expect(metric.errors).toEqual([\"Test error\"]);\n      expect(metric.compressionRatio).toBe(0.5);\n      expect(metric.memoryUsage).toBe(1024 * 1024);\n    });\n\n    test(\"handles missing performance memory\", async () => {\n      const originalMemory = mockPerformance.memory;\n      delete mockPerformance.memory;\n\n      const operationId = await performanceMonitor.startOperation(\"no_memory\");\n      const metric = await performanceMonitor.endOperation(operationId);\n\n      expect(metric.memoryUsage).toBeUndefined();\n\n      mockPerformance.memory = originalMemory;\n    });\n\n    test(\"handles storage estimation failure\", async () => {\n      mockNavigatorStorage.estimate.mockRejectedValue(\n        new Error(\"Storage not available\"),\n      );\n\n      const operationId = await performanceMonitor.startOperation(\"no_storage\");\n      const metric = await performanceMonitor.endOperation(operationId);\n\n      expect(metric.storageUsage).toBeUndefined();\n    });\n\n    test(\"handles missing storage API\", async () => {\n      const originalNavigator = global.navigator;\n      global.navigator = {} as any;\n\n      const operationId = await performanceMonitor.startOperation(\n        \"no_navigator_storage\",\n      );\n      const metric = await performanceMonitor.endOperation(operationId);\n\n      expect(metric.storageUsage).toBeUndefined();\n\n      global.navigator = originalNavigator;\n    });\n  });\n\n  describe(\"Metrics Management\", () => {\n    test(\"maintains metrics history limit\", async () => {\n      // Simulate adding more than max history\n      for (let i = 0; i < 1200; i++) {\n        const operationId = await performanceMonitor.startOperation(\n          `operation_${i}`,\n        );\n        await performanceMonitor.endOperation(operationId);\n      }\n\n      const metrics = performanceMonitor.getMetrics();\n      expect(metrics.length).toBeLessThanOrEqual(1000); // Should be capped at max history\n    });\n\n    test(\"filters metrics by operation\", async () => {\n      const op1Id = await performanceMonitor.startOperation(\"operation1\");\n      await performanceMonitor.endOperation(op1Id);\n\n      const op2Id = await performanceMonitor.startOperation(\"operation2\");\n      await performanceMonitor.endOperation(op2Id);\n\n      const op1Metrics = performanceMonitor.getMetrics(\"operation1\");\n      const op2Metrics = performanceMonitor.getMetrics(\"operation2\");\n\n      expect(op1Metrics).toHaveLength(1);\n      expect(op2Metrics).toHaveLength(1);\n      expect(op1Metrics[0].operation).toBe(\"operation1\");\n      expect(op2Metrics[0].operation).toBe(\"operation2\");\n    });\n\n    test(\"limits returned metrics\", async () => {\n      for (let i = 0; i < 50; i++) {\n        const operationId = await performanceMonitor.startOperation(\"test\");\n        await performanceMonitor.endOperation(operationId);\n      }\n\n      const limited = performanceMonitor.getMetrics(\"test\", 10);\n      expect(limited.length).toBe(10);\n\n      const unlimited = performanceMonitor.getMetrics(\"test\");\n      expect(unlimited.length).toBe(50);\n    });\n\n    test(\"clears all metrics and benchmarks\", async () => {\n      const operationId = await performanceMonitor.startOperation(\"test\");\n      await performanceMonitor.endOperation(operationId);\n\n      expect(performanceMonitor.getMetrics()).toHaveLength(1);\n      expect(performanceMonitor.getBenchmarks()).toHaveLength(1);\n\n      performanceMonitor.clearMetrics();\n\n      expect(performanceMonitor.getMetrics()).toHaveLength(0);\n      expect(performanceMonitor.getBenchmarks()).toHaveLength(0);\n    });\n  });\n\n  describe(\"Benchmark Tracking\", () => {\n    test(\"creates benchmark for new operation\", async () => {\n      const operationId =\n        await performanceMonitor.startOperation(\"new_operation\");\n      await performanceMonitor.endOperation(operationId);\n\n      const benchmarks = performanceMonitor.getBenchmarks();\n      expect(benchmarks).toHaveLength(1);\n\n      const benchmark = benchmarks[0];\n      expect(benchmark.operation).toBe(\"new_operation\");\n      expect(benchmark.totalOperations).toBe(1);\n      expect(benchmark.averageDuration).toBe(100);\n      expect(benchmark.minDuration).toBe(100);\n      expect(benchmark.maxDuration).toBe(100);\n      expect(benchmark.errorRate).toBe(0);\n    });\n\n    test(\"updates existing benchmark with new operation\", async () => {\n      // First operation\n      mockPerformance.getEntriesByName.mockReturnValueOnce([{ duration: 100 }]);\n      const op1Id = await performanceMonitor.startOperation(\"repeat_operation\");\n      await performanceMonitor.endOperation(op1Id);\n\n      // Second operation with different duration\n      mockPerformance.getEntriesByName.mockReturnValueOnce([{ duration: 200 }]);\n      const op2Id = await performanceMonitor.startOperation(\"repeat_operation\");\n      await performanceMonitor.endOperation(op2Id);\n\n      const benchmarks = performanceMonitor.getBenchmarks();\n      expect(benchmarks).toHaveLength(1);\n\n      const benchmark = benchmarks[0];\n      expect(benchmark.totalOperations).toBe(2);\n      expect(benchmark.averageDuration).toBe(150); // (100 + 200) / 2\n      expect(benchmark.minDuration).toBe(100);\n      expect(benchmark.maxDuration).toBe(200);\n    });\n\n    test(\"tracks error rates\", async () => {\n      // Operation with error\n      const op1Id = await performanceMonitor.startOperation(\"error_operation\");\n      await performanceMonitor.endOperation(op1Id, { errors: [\"Test error\"] });\n\n      // Operation without error\n      const op2Id = await performanceMonitor.startOperation(\"error_operation\");\n      await performanceMonitor.endOperation(op2Id);\n\n      const benchmarks = performanceMonitor.getBenchmarks();\n      const benchmark = benchmarks[0];\n\n      expect(benchmark.errorRate).toBe(0.5); // 1 error out of 2 operations\n      expect(benchmark.lastError).toBe(\"Test error\");\n    });\n\n    test(\"handles operation with multiple errors\", async () => {\n      const operationId =\n        await performanceMonitor.startOperation(\"multi_error\");\n      await performanceMonitor.endOperation(operationId, {\n        errors: [\"Error 1\", \"Error 2\", \"Error 3\"],\n      });\n\n      const benchmarks = performanceMonitor.getBenchmarks();\n      const benchmark = benchmarks[0];\n\n      expect(benchmark.errorRate).toBe(1);\n      expect(benchmark.lastError).toBe(\"Error 1\"); // Takes first error\n    });\n\n    test(\"gets average operation time\", async () => {\n      mockPerformance.getEntriesByName.mockReturnValueOnce([{ duration: 150 }]);\n      const operationId =\n        await performanceMonitor.startOperation(\"timed_operation\");\n      await performanceMonitor.endOperation(operationId);\n\n      const avgTime =\n        performanceMonitor.getAverageOperationTime(\"timed_operation\");\n      expect(avgTime).toBe(150);\n\n      const nonExistentAvg =\n        performanceMonitor.getAverageOperationTime(\"nonexistent\");\n      expect(nonExistentAvg).toBe(0);\n    });\n  });\n\n  describe(\"System Health Analysis\", () => {\n    test(\"reports healthy status with good metrics\", async () => {\n      // Add some fast operations\n      for (let i = 0; i < 5; i++) {\n        mockPerformance.getEntriesByName.mockReturnValueOnce([\n          { duration: 100 },\n        ]);\n        const operationId = await performanceMonitor.startOperation(\"fast_op\");\n        await performanceMonitor.endOperation(operationId);\n      }\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.status).toBe(\"healthy\");\n      expect(health.issues).toHaveLength(0);\n      expect(health.metrics.averageResponseTime).toBe(100);\n      expect(health.metrics.errorRate).toBe(0);\n    });\n\n    test(\"reports warning status with elevated response time\", async () => {\n      mockPerformance.getEntriesByName.mockReturnValueOnce([\n        { duration: 1500 },\n      ]);\n      const operationId = await performanceMonitor.startOperation(\"slow_op\");\n      await performanceMonitor.endOperation(operationId);\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.status).toBe(\"warning\");\n      expect(health.issues[0]).toContain(\"Average response time is elevated\");\n      expect(health.recommendations[0]).toContain(\"Monitor performance\");\n    });\n\n    test(\"reports critical status with very high response time\", async () => {\n      mockPerformance.getEntriesByName.mockReturnValueOnce([\n        { duration: 3000 },\n      ]);\n      const operationId =\n        await performanceMonitor.startOperation(\"very_slow_op\");\n      await performanceMonitor.endOperation(operationId);\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.status).toBe(\"critical\");\n      expect(health.issues[0]).toContain(\"Average response time is very high\");\n      expect(health.recommendations[0]).toContain(\"compression\");\n    });\n\n    test(\"reports warning status with elevated error rate\", async () => {\n      // Add operations with errors to trigger elevated error rate\n      for (let i = 0; i < 10; i++) {\n        const operationId =\n          await performanceMonitor.startOperation(\"error_prone\");\n        await performanceMonitor.endOperation(operationId, {\n          errors: i < 1 ? [\"Error\"] : undefined,\n        });\n      }\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.status).toBe(\"warning\");\n      expect(\n        health.issues.some((issue) => issue.includes(\"Elevated error rate\")),\n      ).toBe(true);\n    });\n\n    test(\"reports critical status with high error rate\", async () => {\n      // Add operations with high error rate\n      for (let i = 0; i < 5; i++) {\n        const operationId =\n          await performanceMonitor.startOperation(\"very_error_prone\");\n        await performanceMonitor.endOperation(operationId, {\n          errors: i < 3 ? [\"Error\"] : undefined,\n        });\n      }\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.status).toBe(\"critical\");\n      expect(\n        health.issues.some((issue) => issue.includes(\"High error rate\")),\n      ).toBe(true);\n      expect(\n        health.recommendations.some((rec) =>\n          rec.includes(\"Investigate and fix\"),\n        ),\n      ).toBe(true);\n    });\n\n    test(\"analyzes memory trends\", async () => {\n      // Add metrics with increasing memory usage\n      const memoryValues = [1000, 1100, 1200, 1300, 1400, 1500];\n\n      for (let i = 0; i < memoryValues.length; i++) {\n        mockPerformance.memory.usedJSHeapSize = memoryValues[i];\n        const operationId =\n          await performanceMonitor.startOperation(\"memory_test\");\n        await performanceMonitor.endOperation(operationId);\n      }\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.metrics.memoryTrend).toBe(\"increasing rapidly\");\n      expect(health.status).toBe(\"critical\");\n      expect(\n        health.issues.some((issue) =>\n          issue.includes(\"Memory usage is increasing rapidly\"),\n        ),\n      ).toBe(true);\n    });\n\n    test(\"analyzes storage trends\", async () => {\n      // Add metrics with increasing storage usage\n      const storageValues = [1000, 1100, 1200, 1300, 1400, 1500];\n\n      for (let i = 0; i < storageValues.length; i++) {\n        mockNavigatorStorage.estimate.mockResolvedValueOnce({\n          usage: storageValues[i],\n        });\n        const operationId =\n          await performanceMonitor.startOperation(\"storage_test\");\n        await performanceMonitor.endOperation(operationId);\n      }\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.metrics.storageTrend).toBe(\"increasing rapidly\");\n      expect(\n        health.issues.some((issue) =>\n          issue.includes(\"Storage usage is increasing rapidly\"),\n        ),\n      ).toBe(true);\n    });\n\n    test(\"handles insufficient data for trend analysis\", async () => {\n      // Add only 2 metrics (insufficient for trend analysis)\n      for (let i = 0; i < 2; i++) {\n        const operationId =\n          await performanceMonitor.startOperation(\"insufficient_data\");\n        await performanceMonitor.endOperation(operationId);\n      }\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.metrics.memoryTrend).toBe(\"insufficient data\");\n      expect(health.metrics.storageTrend).toBe(\"insufficient data\");\n    });\n\n    test(\"analyzes stable trends\", async () => {\n      // Add metrics with stable values\n      for (let i = 0; i < 10; i++) {\n        mockPerformance.memory.usedJSHeapSize = 1000; // Stable memory\n        mockNavigatorStorage.estimate.mockResolvedValueOnce({ usage: 500 }); // Stable storage\n        const operationId =\n          await performanceMonitor.startOperation(\"stable_test\");\n        await performanceMonitor.endOperation(operationId);\n      }\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.metrics.memoryTrend).toBe(\"stable\");\n      expect(health.metrics.storageTrend).toBe(\"stable\");\n    });\n\n    test(\"analyzes decreasing trends\", async () => {\n      // Add metrics with decreasing values\n      const values = [1000, 900, 800, 700, 600, 500];\n\n      for (let i = 0; i < values.length; i++) {\n        mockPerformance.memory.usedJSHeapSize = values[i];\n        const operationId =\n          await performanceMonitor.startOperation(\"decreasing_test\");\n        await performanceMonitor.endOperation(operationId);\n      }\n\n      const health = performanceMonitor.getSystemHealth();\n\n      expect(health.metrics.memoryTrend).toBe(\"decreasing rapidly\");\n    });\n  });\n\n  describe(\"Performance Tests\", () => {\n    test(\"runs compression test\", async () => {\n      const results = await performanceMonitor.runPerformanceTest();\n\n      expect(results.compressionTest).toHaveProperty(\"duration\");\n      expect(results.compressionTest).toHaveProperty(\"ratio\");\n      expect(results.compressionTest.duration).toBeGreaterThan(0);\n      expect(results.compressionTest.ratio).toBeGreaterThan(0);\n      expect(mockTextEncoder.encode).toHaveBeenCalled();\n    });\n\n    test(\"runs storage test\", async () => {\n      const results = await performanceMonitor.runPerformanceTest();\n\n      expect(results.storageTest).toHaveProperty(\"duration\");\n      expect(results.storageTest).toHaveProperty(\"throughput\");\n      expect(results.storageTest.duration).toBeGreaterThan(0);\n      expect(results.storageTest.throughput).toBeGreaterThan(0);\n\n      // Verify localStorage was used for testing\n      expect(mockLocalStorage.setItem).toHaveBeenCalled();\n      expect(mockLocalStorage.removeItem).toHaveBeenCalled();\n    });\n\n    test(\"runs validation test\", async () => {\n      const results = await performanceMonitor.runPerformanceTest();\n\n      expect(results.validationTest).toHaveProperty(\"duration\");\n      expect(results.validationTest).toHaveProperty(\"itemsPerSecond\");\n      expect(results.validationTest.duration).toBeGreaterThan(0);\n      expect(results.validationTest.itemsPerSecond).toBeGreaterThan(0);\n    });\n\n    test(\"handles validation test errors\", async () => {\n      // Mock an invalid item that would fail validation\n      const originalTestValidation = performanceMonitor[\"testValidation\"];\n\n      performanceMonitor[\"testValidation\"] = jest\n        .fn()\n        .mockImplementation(async () => {\n          // Simulate validation that throws an error\n          const testItems = [{ id: \"\", name: \"\", createdAt: \"\" }]; // Invalid item\n\n          for (const item of testItems) {\n            if (!item.id || !item.name || !item.createdAt) {\n              throw new Error(\"Validation failed\");\n            }\n          }\n\n          return { duration: 0, itemsPerSecond: 0 };\n        });\n\n      await expect(performanceMonitor.runPerformanceTest()).rejects.toThrow(\n        \"Validation failed\",\n      );\n\n      // Restore original method\n      performanceMonitor[\"testValidation\"] = originalTestValidation;\n    });\n  });\n\n  describe(\"Export and Import\", () => {\n    test(\"exports metrics and benchmarks\", async () => {\n      const operationId =\n        await performanceMonitor.startOperation(\"export_test\");\n      await performanceMonitor.endOperation(operationId);\n\n      const exported = performanceMonitor.exportMetrics();\n\n      expect(exported).toHaveProperty(\"metrics\");\n      expect(exported).toHaveProperty(\"benchmarks\");\n      expect(exported).toHaveProperty(\"exportedAt\");\n      expect(exported.metrics).toHaveLength(1);\n      expect(exported.benchmarks).toHaveLength(1);\n      expect(new Date(exported.exportedAt)).toBeInstanceOf(Date);\n    });\n\n    test(\"exports empty data when no operations performed\", () => {\n      const exported = performanceMonitor.exportMetrics();\n\n      expect(exported.metrics).toHaveLength(0);\n      expect(exported.benchmarks).toHaveLength(0);\n      expect(exported.exportedAt).toBeTruthy();\n    });\n  });\n\n  describe(\"Edge Cases and Error Handling\", () => {\n    test(\"handles performance API errors gracefully\", async () => {\n      mockPerformance.getEntriesByName.mockReturnValue([]);\n\n      const operationId = await performanceMonitor.startOperation(\"no_measure\");\n\n      // This should handle missing performance measure gracefully\n      await expect(\n        performanceMonitor.endOperation(operationId),\n      ).rejects.toThrow();\n    });\n\n    test(\"handles operations with empty metadata\", async () => {\n      const operationId =\n        await performanceMonitor.startOperation(\"empty_metadata\");\n      const metric = await performanceMonitor.endOperation(operationId, {});\n\n      expect(metric.dataSize).toBeUndefined();\n      expect(metric.errors).toBeUndefined();\n      expect(metric.compressionRatio).toBeUndefined();\n    });\n\n    test(\"handles operations with null/undefined metadata\", async () => {\n      const operationId =\n        await performanceMonitor.startOperation(\"null_metadata\");\n      const metric = await performanceMonitor.endOperation(\n        operationId,\n        undefined,\n      );\n\n      expect(metric.dataSize).toBeUndefined();\n      expect(metric.errors).toBeUndefined();\n      expect(metric.compressionRatio).toBeUndefined();\n    });\n\n    test(\"handles division by zero in trend analysis\", () => {\n      const values = [0, 0, 0, 0]; // All zeros\n      const trendResult = performanceMonitor[\"analyzeTrend\"](values);\n\n      // Should handle division by zero gracefully\n      expect(trendResult).toBeDefined();\n    });\n\n    test(\"handles empty values in trend analysis\", () => {\n      const emptyValues: number[] = [];\n      const result = performanceMonitor[\"analyzeTrend\"](emptyValues);\n\n      expect(result).toBe(\"insufficient data\");\n    });\n\n    test(\"handles single value in trend analysis\", () => {\n      const singleValue = [100];\n      const result = performanceMonitor[\"analyzeTrend\"](singleValue);\n\n      expect(result).toBe(\"insufficient data\");\n    });\n\n    test(\"handles concurrent operations\", async () => {\n      const promises = [];\n\n      for (let i = 0; i < 10; i++) {\n        const promise = (async () => {\n          const operationId = await performanceMonitor.startOperation(\n            `concurrent_${i}`,\n          );\n          return performanceMonitor.endOperation(operationId);\n        })();\n        promises.push(promise);\n      }\n\n      const results = await Promise.all(promises);\n\n      expect(results).toHaveLength(10);\n      expect(performanceMonitor.getMetrics()).toHaveLength(10);\n      expect(performanceMonitor.getBenchmarks().length).toBeGreaterThan(0);\n    });\n  });\n});\n"],"names":["mockPerformance","now","jest","fn","mark","measure","getEntriesByName","clearMarks","clearMeasures","memory","usedJSHeapSize","mockNavigatorStorage","estimate","Promise","resolve","usage","mockLocalStorage","setItem","removeItem","getItem","clear","length","key","mockTextEncoder","encode","str","Uint8Array","beforeAll","global","performance","navigator","storage","localStorage","TextEncoder","beforeEach","clearAllMocks","performanceMonitor","clearMetrics","timeCounter","mockImplementation","mockReturnValue","name","duration","startTime","entryType","afterEach","clearAllTimers","useRealTimers","describe","test","operationId","startOperation","expect","toContain","toHaveBeenCalledWith","metric","endOperation","toHaveBeenCalled","operation","toBe","id1","id2","not","metadata","dataSize","errors","compressionRatio","toEqual","memoryUsage","originalMemory","toBeUndefined","mockRejectedValue","Error","storageUsage","originalNavigator","i","metrics","getMetrics","toBeLessThanOrEqual","op1Id","op2Id","op1Metrics","op2Metrics","toHaveLength","limited","unlimited","getBenchmarks","benchmarks","benchmark","totalOperations","averageDuration","minDuration","maxDuration","errorRate","mockReturnValueOnce","lastError","avgTime","getAverageOperationTime","nonExistentAvg","health","getSystemHealth","status","issues","averageResponseTime","recommendations","undefined","some","issue","includes","rec","memoryValues","memoryTrend","storageValues","mockResolvedValueOnce","storageTrend","values","results","runPerformanceTest","compressionTest","toHaveProperty","toBeGreaterThan","ratio","storageTest","throughput","validationTest","itemsPerSecond","originalTestValidation","testItems","id","createdAt","item","rejects","toThrow","exported","exportMetrics","Date","exportedAt","toBeInstanceOf","toBeTruthy","trendResult","toBeDefined","emptyValues","result","singleValue","promises","promise","push","all"],"mappings":"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"}