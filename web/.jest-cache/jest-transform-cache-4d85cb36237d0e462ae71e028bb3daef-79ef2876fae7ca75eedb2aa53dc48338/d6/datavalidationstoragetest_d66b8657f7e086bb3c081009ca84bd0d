bf9355e3819ae0c35de5ea99f58026f2
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _indexeddbstorage = require("../../../lib/storage/indexeddb-storage");
const _datavalidation = require("../../../lib/safety/data-validation");
// Mock IndexedDB
const mockIndexedDB = {
    open: jest.fn(),
    deleteDatabase: jest.fn()
};
const mockObjectStore = {
    add: jest.fn(),
    get: jest.fn(),
    put: jest.fn(),
    delete: jest.fn(),
    clear: jest.fn(),
    getAll: jest.fn(),
    count: jest.fn(),
    createIndex: jest.fn()
};
const mockTransaction = {
    objectStore: jest.fn(()=>mockObjectStore),
    oncomplete: null,
    onerror: null,
    onabort: null
};
const mockDB = {
    transaction: jest.fn(()=>mockTransaction),
    createObjectStore: jest.fn(()=>mockObjectStore),
    close: jest.fn(),
    objectStoreNames: {
        contains: jest.fn()
    }
};
// Override global IndexedDB
global.indexedDB = mockIndexedDB;
describe("Data Storage and Validation", ()=>{
    let storage;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Setup IndexedDB mock
        mockIndexedDB.open.mockReturnValue({
            onsuccess: null,
            onerror: null,
            onupgradeneeded: null,
            result: mockDB
        });
        storage = new _indexeddbstorage.IndexedDBStorage("test-db", 1);
    });
    describe("IndexedDBStorage", ()=>{
        it("initializes database correctly", async ()=>{
            await storage.init();
            expect(mockIndexedDB.open).toHaveBeenCalledWith("test-db", 1);
        });
        it("stores data with validation", async ()=>{
            const data = {
                id: "test-1",
                type: "agent",
                content: {
                    name: "Test Agent",
                    status: "active"
                },
                timestamp: Date.now()
            };
            mockObjectStore.add.mockResolvedValue("test-1");
            const result = await storage.store("agents", data);
            expect(result).toBe("test-1");
            expect(mockObjectStore.add).toHaveBeenCalledWith(data);
        });
        it("retrieves data with integrity check", async ()=>{
            const storedData = {
                id: "test-1",
                type: "agent",
                content: {
                    name: "Test Agent"
                },
                checksum: "abc123"
            };
            mockObjectStore.get.mockResolvedValue(storedData);
            const result = await storage.get("agents", "test-1");
            expect(result).toEqual(storedData);
            expect(mockObjectStore.get).toHaveBeenCalledWith("test-1");
        });
        it("handles storage quota errors", async ()=>{
            mockObjectStore.add.mockRejectedValue(new DOMException("QuotaExceededError"));
            await expect(storage.store("large-data", {
                data: "x".repeat(10000000)
            })).rejects.toThrow("Storage quota exceeded");
        });
        it("supports batch operations", async ()=>{
            const items = Array.from({
                length: 100
            }, (_, i)=>({
                    id: `item-${i}`,
                    value: i
                }));
            mockObjectStore.add.mockResolvedValue(undefined);
            const results = await storage.batchStore("items", items);
            expect(results).toHaveLength(100);
            expect(mockObjectStore.add).toHaveBeenCalledTimes(100);
        });
        it("implements data expiration", async ()=>{
            const expirableData = {
                id: "expire-1",
                content: "temporary",
                expiresAt: Date.now() - 1000
            };
            mockObjectStore.get.mockResolvedValue(expirableData);
            const result = await storage.get("temp", "expire-1");
            expect(result).toBeNull();
            expect(mockObjectStore.delete).toHaveBeenCalledWith("expire-1");
        });
        it("handles concurrent access safely", async ()=>{
            const promises = Array.from({
                length: 10
            }, (_, i)=>storage.store("concurrent", {
                    id: `concurrent-${i}`
                }));
            mockObjectStore.add.mockResolvedValue(undefined);
            const results = await Promise.all(promises);
            expect(results).toHaveLength(10);
        // Should handle all requests without conflicts
        });
    });
    describe("Data Validation", ()=>{
        it("validates data structure before storage", ()=>{
            const validData = {
                id: "valid-1",
                type: "message",
                content: "Hello world",
                timestamp: Date.now()
            };
            const invalidData = {
                // Missing required fields
                content: "Invalid"
            };
            expect((0, _datavalidation.validateStorageData)(validData)).toBe(true);
            expect((0, _datavalidation.validateStorageData)(invalidData)).toBe(false);
        });
        it("sanitizes data before storage", ()=>{
            const unsafeData = {
                id: "unsafe-1",
                content: '<script>alert("xss")</script>',
                userInput: "'; DROP TABLE users; --",
                html: "<img src=x onerror=alert(1)>"
            };
            const sanitized = (0, _datavalidation.sanitizeBeforeStorage)(unsafeData);
            expect(sanitized.content).not.toContain("<script>");
            expect(sanitized.userInput).not.toContain("DROP TABLE");
            expect(sanitized.html).not.toContain("onerror");
        });
        it("validates data types", ()=>{
            const testCases = [
                {
                    data: {
                        id: 123
                    },
                    type: "number",
                    expected: true
                },
                {
                    data: {
                        id: "123"
                    },
                    type: "string",
                    expected: true
                },
                {
                    data: {
                        id: true
                    },
                    type: "boolean",
                    expected: true
                },
                {
                    data: {
                        id: {}
                    },
                    type: "object",
                    expected: true
                },
                {
                    data: {
                        id: []
                    },
                    type: "array",
                    expected: true
                },
                {
                    data: {
                        id: null
                    },
                    type: "null",
                    expected: true
                },
                {
                    data: {
                        id: undefined
                    },
                    type: "undefined",
                    expected: true
                }
            ];
            testCases.forEach(({ data, type, expected })=>{
                expect(validateDataType(data.id, type)).toBe(expected);
            });
        });
        it("checks data size limits", ()=>{
            const smallData = {
                content: "small"
            };
            const largeData = {
                content: "x".repeat(1024 * 1024 * 10)
            }; // 10MB
            expect(validateDataSize(smallData, 1024 * 1024)).toBe(true);
            expect(validateDataSize(largeData, 1024 * 1024)).toBe(false);
        });
        it("validates nested data structures", ()=>{
            const complexData = {
                id: "complex-1",
                agent: {
                    name: "Test Agent",
                    capabilities: [
                        "reasoning",
                        "learning"
                    ],
                    metadata: {
                        created: Date.now(),
                        version: "1.0",
                        tags: new Set([
                            "ai",
                            "agent"
                        ])
                    }
                }
            };
            const schema = {
                id: "string",
                agent: {
                    name: "string",
                    capabilities: "array",
                    metadata: {
                        created: "number",
                        version: "string",
                        tags: "object"
                    }
                }
            };
            expect(validateNestedStructure(complexData, schema)).toBe(true);
        });
    });
    describe("Data Compression", ()=>{
        it("compresses data for storage", async ()=>{
            const originalData = {
                id: "compress-1",
                largeText: "Lorem ipsum ".repeat(1000),
                numbers: Array.from({
                    length: 1000
                }, (_, i)=>i)
            };
            const compressed = await (0, _datavalidation.compressForStorage)(originalData);
            expect(compressed.length).toBeLessThan(JSON.stringify(originalData).length);
            expect(compressed).toHaveProperty("compressed", true);
            expect(compressed).toHaveProperty("algorithm", "gzip");
        });
        it("decompresses data after retrieval", async ()=>{
            const originalData = {
                id: "test",
                content: "Hello world!"
            };
            const compressed = await (0, _datavalidation.compressForStorage)(originalData);
            const decompressed = await (0, _datavalidation.decompressFromStorage)(compressed);
            expect(decompressed).toEqual(originalData);
        });
        it("handles compression errors gracefully", async ()=>{
            const corruptedData = {
                compressed: true,
                algorithm: "gzip",
                data: "corrupted-base64-data"
            };
            const result = await (0, _datavalidation.decompressFromStorage)(corruptedData);
            // Should return original data on decompression failure
            expect(result).toEqual(corruptedData);
        });
    });
    describe("Data Integrity", ()=>{
        it("generates checksums for stored data", ()=>{
            const data = {
                id: "checksum-1",
                content: "Important data"
            };
            const checksum = generateChecksum(data);
            expect(checksum).toBeTruthy();
            expect(checksum).toHaveLength(64); // SHA-256 hex length
        });
        it("verifies data integrity on retrieval", async ()=>{
            const originalData = {
                id: "integrity-1",
                content: "Secure content"
            };
            const storedData = {
                ...originalData,
                checksum: generateChecksum(originalData)
            };
            expect((0, _datavalidation.validateDataIntegrity)(storedData)).toBe(true);
            // Tamper with data
            storedData.content = "Modified content";
            expect((0, _datavalidation.validateDataIntegrity)(storedData)).toBe(false);
        });
        it("detects data corruption", ()=>{
            const corruptedData = {
                id: "corrupt-1",
                content: undefined,
                checksum: "abc123"
            };
            expect(()=>(0, _datavalidation.validateDataIntegrity)(corruptedData)).toThrow("Data corruption detected");
        });
    });
    describe("Storage Security", ()=>{
        it("encrypts sensitive data", async ()=>{
            const sensitiveData = {
                id: "sensitive-1",
                apiKey: "sk-secret-key",
                password: "user-password",
                personalInfo: {
                    ssn: "123-45-6789",
                    creditCard: "1234-5678-9012-3456"
                }
            };
            const stored = await storage.storeSecure("sensitive", sensitiveData);
            // Verify data is encrypted
            expect(mockObjectStore.add).toHaveBeenCalledWith(expect.objectContaining({
                encrypted: true,
                data: expect.not.stringContaining("sk-secret-key")
            }));
        });
        it("implements access control", async ()=>{
            const protectedData = {
                id: "protected-1",
                content: "Protected content",
                permissions: [
                    "read:admin",
                    "write:admin"
                ]
            };
            // Store with permissions
            await storage.store("protected", protectedData);
            // Try to access without permission
            const userContext = {
                roles: [
                    "user"
                ]
            };
            await expect(storage.get("protected", "protected-1", {
                context: userContext
            })).rejects.toThrow("Access denied");
        });
        it("logs access attempts", async ()=>{
            const auditLog = [];
            const auditedStorage = new _indexeddbstorage.IndexedDBStorage("audit-db", 1, {
                onAccess: (event)=>auditLog.push(event)
            });
            await auditedStorage.get("data", "test-1");
            expect(auditLog).toContainEqual(expect.objectContaining({
                action: "get",
                store: "data",
                key: "test-1",
                timestamp: expect.any(Number)
            }));
        });
    });
    describe("Storage Optimization", ()=>{
        it("implements LRU cache", async ()=>{
            const cachedStorage = new _indexeddbstorage.IndexedDBStorage("cache-db", 1, {
                cacheSize: 100
            });
            // Fill cache
            for(let i = 0; i < 150; i++){
                await cachedStorage.store("cache", {
                    id: `item-${i}`
                });
            }
            // Verify oldest items are evicted
            const oldestItem = await cachedStorage.get("cache", "item-0");
            expect(oldestItem).toBeNull();
            // Recent items should still be in cache
            const recentItem = await cachedStorage.get("cache", "item-149");
            expect(recentItem).toBeTruthy();
        });
        it("implements data deduplication", async ()=>{
            const duplicateData = {
                id: "dup-1",
                content: "Same content"
            };
            // Store same data multiple times
            await storage.store("dedup", duplicateData);
            await storage.store("dedup", duplicateData);
            await storage.store("dedup", duplicateData);
            // Should only store once
            expect(mockObjectStore.add).toHaveBeenCalledTimes(1);
            expect(mockObjectStore.put).toHaveBeenCalledTimes(2); // Updates
        });
        it("compacts storage periodically", async ()=>{
            jest.useFakeTimers();
            const autoCompactStorage = new _indexeddbstorage.IndexedDBStorage("compact-db", 1, {
                autoCompact: true,
                compactInterval: 3600000
            });
            // Add and remove data
            for(let i = 0; i < 100; i++){
                await autoCompactStorage.store("data", {
                    id: `item-${i}`
                });
            }
            for(let i = 0; i < 50; i++){
                await autoCompactStorage.delete("data", `item-${i}`);
            }
            // Advance time
            jest.advanceTimersByTime(3600000);
            // Verify compaction occurred
            expect(mockDB.transaction).toHaveBeenCalledWith(expect.any(Array), "readwrite");
            jest.useRealTimers();
        });
    });
});
// Helper functions that would be in the actual implementation
function validateDataType(data, expectedType) {
    if (expectedType === "array") return Array.isArray(data);
    if (expectedType === "null") return data === null;
    return typeof data === expectedType;
}
function validateDataSize(data, maxSize) {
    const size = JSON.stringify(data).length;
    return size <= maxSize;
}
function validateNestedStructure(data, schema) {
    for(const key in schema){
        if (!(key in data)) return false;
        if (typeof schema[key] === "object" && !Array.isArray(schema[key])) {
            if (!validateNestedStructure(data[key], schema[key])) return false;
        } else {
            const expectedType = schema[key];
            if (!validateDataType(data[key], expectedType)) return false;
        }
    }
    return true;
}
function generateChecksum(data) {
    // Simplified checksum generation
    return require("crypto").createHash("sha256").update(JSON.stringify(data)).digest("hex");
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL3N0b3JhZ2UvZGF0YS12YWxpZGF0aW9uLXN0b3JhZ2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmRleGVkREJTdG9yYWdlIH0gZnJvbSBcIkAvbGliL3N0b3JhZ2UvaW5kZXhlZGRiLXN0b3JhZ2VcIjtcbmltcG9ydCB7XG4gIHZhbGlkYXRlU3RvcmFnZURhdGEsXG4gIHNhbml0aXplQmVmb3JlU3RvcmFnZSxcbiAgdmFsaWRhdGVEYXRhSW50ZWdyaXR5LFxuICBjb21wcmVzc0ZvclN0b3JhZ2UsXG4gIGRlY29tcHJlc3NGcm9tU3RvcmFnZSxcbn0gZnJvbSBcIkAvbGliL3NhZmV0eS9kYXRhLXZhbGlkYXRpb25cIjtcblxuLy8gTW9jayBJbmRleGVkREJcbmNvbnN0IG1vY2tJbmRleGVkREIgPSB7XG4gIG9wZW46IGplc3QuZm4oKSxcbiAgZGVsZXRlRGF0YWJhc2U6IGplc3QuZm4oKSxcbn07XG5cbmNvbnN0IG1vY2tPYmplY3RTdG9yZSA9IHtcbiAgYWRkOiBqZXN0LmZuKCksXG4gIGdldDogamVzdC5mbigpLFxuICBwdXQ6IGplc3QuZm4oKSxcbiAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIGNsZWFyOiBqZXN0LmZuKCksXG4gIGdldEFsbDogamVzdC5mbigpLFxuICBjb3VudDogamVzdC5mbigpLFxuICBjcmVhdGVJbmRleDogamVzdC5mbigpLFxufTtcblxuY29uc3QgbW9ja1RyYW5zYWN0aW9uID0ge1xuICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiBtb2NrT2JqZWN0U3RvcmUpLFxuICBvbmNvbXBsZXRlOiBudWxsLFxuICBvbmVycm9yOiBudWxsLFxuICBvbmFib3J0OiBudWxsLFxufTtcblxuY29uc3QgbW9ja0RCID0ge1xuICB0cmFuc2FjdGlvbjogamVzdC5mbigoKSA9PiBtb2NrVHJhbnNhY3Rpb24pLFxuICBjcmVhdGVPYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiBtb2NrT2JqZWN0U3RvcmUpLFxuICBjbG9zZTogamVzdC5mbigpLFxuICBvYmplY3RTdG9yZU5hbWVzOiB7IGNvbnRhaW5zOiBqZXN0LmZuKCkgfSxcbn07XG5cbi8vIE92ZXJyaWRlIGdsb2JhbCBJbmRleGVkREJcbihnbG9iYWwgYXMgYW55KS5pbmRleGVkREIgPSBtb2NrSW5kZXhlZERCO1xuXG5kZXNjcmliZShcIkRhdGEgU3RvcmFnZSBhbmQgVmFsaWRhdGlvblwiLCAoKSA9PiB7XG4gIGxldCBzdG9yYWdlOiBJbmRleGVkREJTdG9yYWdlO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgLy8gU2V0dXAgSW5kZXhlZERCIG1vY2tcbiAgICBtb2NrSW5kZXhlZERCLm9wZW4ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIG9uc3VjY2VzczogbnVsbCxcbiAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICBvbnVwZ3JhZGVuZWVkZWQ6IG51bGwsXG4gICAgICByZXN1bHQ6IG1vY2tEQixcbiAgICB9KTtcblxuICAgIHN0b3JhZ2UgPSBuZXcgSW5kZXhlZERCU3RvcmFnZShcInRlc3QtZGJcIiwgMSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiSW5kZXhlZERCU3RvcmFnZVwiLCAoKSA9PiB7XG4gICAgaXQoXCJpbml0aWFsaXplcyBkYXRhYmFzZSBjb3JyZWN0bHlcIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgYXdhaXQgc3RvcmFnZS5pbml0KCk7XG5cbiAgICAgIGV4cGVjdChtb2NrSW5kZXhlZERCLm9wZW4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwidGVzdC1kYlwiLCAxKTtcbiAgICB9KTtcblxuICAgIGl0KFwic3RvcmVzIGRhdGEgd2l0aCB2YWxpZGF0aW9uXCIsIGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGlkOiBcInRlc3QtMVwiLFxuICAgICAgICB0eXBlOiBcImFnZW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IHsgbmFtZTogXCJUZXN0IEFnZW50XCIsIHN0YXR1czogXCJhY3RpdmVcIiB9LFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB9O1xuXG4gICAgICBtb2NrT2JqZWN0U3RvcmUuYWRkLm1vY2tSZXNvbHZlZFZhbHVlKFwidGVzdC0xXCIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdG9yYWdlLnN0b3JlKFwiYWdlbnRzXCIsIGRhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwidGVzdC0xXCIpO1xuICAgICAgZXhwZWN0KG1vY2tPYmplY3RTdG9yZS5hZGQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGRhdGEpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJyZXRyaWV2ZXMgZGF0YSB3aXRoIGludGVncml0eSBjaGVja1wiLCBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0ge1xuICAgICAgICBpZDogXCJ0ZXN0LTFcIixcbiAgICAgICAgdHlwZTogXCJhZ2VudFwiLFxuICAgICAgICBjb250ZW50OiB7IG5hbWU6IFwiVGVzdCBBZ2VudFwiIH0sXG4gICAgICAgIGNoZWNrc3VtOiBcImFiYzEyM1wiLFxuICAgICAgfTtcblxuICAgICAgbW9ja09iamVjdFN0b3JlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShzdG9yZWREYXRhKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RvcmFnZS5nZXQoXCJhZ2VudHNcIiwgXCJ0ZXN0LTFcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoc3RvcmVkRGF0YSk7XG4gICAgICBleHBlY3QobW9ja09iamVjdFN0b3JlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJ0ZXN0LTFcIik7XG4gICAgfSk7XG5cbiAgICBpdChcImhhbmRsZXMgc3RvcmFnZSBxdW90YSBlcnJvcnNcIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgbW9ja09iamVjdFN0b3JlLmFkZC5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IERPTUV4Y2VwdGlvbihcIlF1b3RhRXhjZWVkZWRFcnJvclwiKSxcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc3RvcmFnZS5zdG9yZShcImxhcmdlLWRhdGFcIiwgeyBkYXRhOiBcInhcIi5yZXBlYXQoMTAwMDAwMDApIH0pLFxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coXCJTdG9yYWdlIHF1b3RhIGV4Y2VlZGVkXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzdXBwb3J0cyBiYXRjaCBvcGVyYXRpb25zXCIsIGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGl0ZW0tJHtpfWAsXG4gICAgICAgIHZhbHVlOiBpLFxuICAgICAgfSkpO1xuXG4gICAgICBtb2NrT2JqZWN0U3RvcmUuYWRkLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdG9yYWdlLmJhdGNoU3RvcmUoXCJpdGVtc1wiLCBpdGVtcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICAgIGV4cGVjdChtb2NrT2JqZWN0U3RvcmUuYWRkKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMTAwKTtcbiAgICB9KTtcblxuICAgIGl0KFwiaW1wbGVtZW50cyBkYXRhIGV4cGlyYXRpb25cIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgY29uc3QgZXhwaXJhYmxlRGF0YSA9IHtcbiAgICAgICAgaWQ6IFwiZXhwaXJlLTFcIixcbiAgICAgICAgY29udGVudDogXCJ0ZW1wb3JhcnlcIixcbiAgICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpIC0gMTAwMCwgLy8gQWxyZWFkeSBleHBpcmVkXG4gICAgICB9O1xuXG4gICAgICBtb2NrT2JqZWN0U3RvcmUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKGV4cGlyYWJsZURhdGEpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdG9yYWdlLmdldChcInRlbXBcIiwgXCJleHBpcmUtMVwiKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChtb2NrT2JqZWN0U3RvcmUuZGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcImV4cGlyZS0xXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJoYW5kbGVzIGNvbmN1cnJlbnQgYWNjZXNzIHNhZmVseVwiLCBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwIH0sIChfLCBpKSA9PlxuICAgICAgICBzdG9yYWdlLnN0b3JlKFwiY29uY3VycmVudFwiLCB7IGlkOiBgY29uY3VycmVudC0ke2l9YCB9KSxcbiAgICAgICk7XG5cbiAgICAgIG1vY2tPYmplY3RTdG9yZS5hZGQubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCgxMCk7XG4gICAgICAvLyBTaG91bGQgaGFuZGxlIGFsbCByZXF1ZXN0cyB3aXRob3V0IGNvbmZsaWN0c1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkRhdGEgVmFsaWRhdGlvblwiLCAoKSA9PiB7XG4gICAgaXQoXCJ2YWxpZGF0ZXMgZGF0YSBzdHJ1Y3R1cmUgYmVmb3JlIHN0b3JhZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWREYXRhID0ge1xuICAgICAgICBpZDogXCJ2YWxpZC0xXCIsXG4gICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICBjb250ZW50OiBcIkhlbGxvIHdvcmxkXCIsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0ge1xuICAgICAgICAvLyBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgICBjb250ZW50OiBcIkludmFsaWRcIixcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVN0b3JhZ2VEYXRhKHZhbGlkRGF0YSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGVTdG9yYWdlRGF0YShpbnZhbGlkRGF0YSkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzYW5pdGl6ZXMgZGF0YSBiZWZvcmUgc3RvcmFnZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB1bnNhZmVEYXRhID0ge1xuICAgICAgICBpZDogXCJ1bnNhZmUtMVwiLFxuICAgICAgICBjb250ZW50OiAnPHNjcmlwdD5hbGVydChcInhzc1wiKTwvc2NyaXB0PicsXG4gICAgICAgIHVzZXJJbnB1dDogXCInOyBEUk9QIFRBQkxFIHVzZXJzOyAtLVwiLFxuICAgICAgICBodG1sOiBcIjxpbWcgc3JjPXggb25lcnJvcj1hbGVydCgxKT5cIixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNhbml0aXplZCA9IHNhbml0aXplQmVmb3JlU3RvcmFnZSh1bnNhZmVEYXRhKTtcblxuICAgICAgZXhwZWN0KHNhbml0aXplZC5jb250ZW50KS5ub3QudG9Db250YWluKFwiPHNjcmlwdD5cIik7XG4gICAgICBleHBlY3Qoc2FuaXRpemVkLnVzZXJJbnB1dCkubm90LnRvQ29udGFpbihcIkRST1AgVEFCTEVcIik7XG4gICAgICBleHBlY3Qoc2FuaXRpemVkLmh0bWwpLm5vdC50b0NvbnRhaW4oXCJvbmVycm9yXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJ2YWxpZGF0ZXMgZGF0YSB0eXBlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXG4gICAgICAgIHsgZGF0YTogeyBpZDogMTIzIH0sIHR5cGU6IFwibnVtYmVyXCIsIGV4cGVjdGVkOiB0cnVlIH0sXG4gICAgICAgIHsgZGF0YTogeyBpZDogXCIxMjNcIiB9LCB0eXBlOiBcInN0cmluZ1wiLCBleHBlY3RlZDogdHJ1ZSB9LFxuICAgICAgICB7IGRhdGE6IHsgaWQ6IHRydWUgfSwgdHlwZTogXCJib29sZWFuXCIsIGV4cGVjdGVkOiB0cnVlIH0sXG4gICAgICAgIHsgZGF0YTogeyBpZDoge30gfSwgdHlwZTogXCJvYmplY3RcIiwgZXhwZWN0ZWQ6IHRydWUgfSxcbiAgICAgICAgeyBkYXRhOiB7IGlkOiBbXSB9LCB0eXBlOiBcImFycmF5XCIsIGV4cGVjdGVkOiB0cnVlIH0sXG4gICAgICAgIHsgZGF0YTogeyBpZDogbnVsbCB9LCB0eXBlOiBcIm51bGxcIiwgZXhwZWN0ZWQ6IHRydWUgfSxcbiAgICAgICAgeyBkYXRhOiB7IGlkOiB1bmRlZmluZWQgfSwgdHlwZTogXCJ1bmRlZmluZWRcIiwgZXhwZWN0ZWQ6IHRydWUgfSxcbiAgICAgIF07XG5cbiAgICAgIHRlc3RDYXNlcy5mb3JFYWNoKCh7IGRhdGEsIHR5cGUsIGV4cGVjdGVkIH0pID0+IHtcbiAgICAgICAgZXhwZWN0KHZhbGlkYXRlRGF0YVR5cGUoZGF0YS5pZCwgdHlwZSkpLnRvQmUoZXhwZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcImNoZWNrcyBkYXRhIHNpemUgbGltaXRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNtYWxsRGF0YSA9IHsgY29udGVudDogXCJzbWFsbFwiIH07XG4gICAgICBjb25zdCBsYXJnZURhdGEgPSB7IGNvbnRlbnQ6IFwieFwiLnJlcGVhdCgxMDI0ICogMTAyNCAqIDEwKSB9OyAvLyAxME1CXG5cbiAgICAgIGV4cGVjdCh2YWxpZGF0ZURhdGFTaXplKHNtYWxsRGF0YSwgMTAyNCAqIDEwMjQpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRlRGF0YVNpemUobGFyZ2VEYXRhLCAxMDI0ICogMTAyNCkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJ2YWxpZGF0ZXMgbmVzdGVkIGRhdGEgc3RydWN0dXJlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wbGV4RGF0YSA9IHtcbiAgICAgICAgaWQ6IFwiY29tcGxleC0xXCIsXG4gICAgICAgIGFnZW50OiB7XG4gICAgICAgICAgbmFtZTogXCJUZXN0IEFnZW50XCIsXG4gICAgICAgICAgY2FwYWJpbGl0aWVzOiBbXCJyZWFzb25pbmdcIiwgXCJsZWFybmluZ1wiXSxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgY3JlYXRlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHZlcnNpb246IFwiMS4wXCIsXG4gICAgICAgICAgICB0YWdzOiBuZXcgU2V0KFtcImFpXCIsIFwiYWdlbnRcIl0pLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY2hlbWEgPSB7XG4gICAgICAgIGlkOiBcInN0cmluZ1wiLFxuICAgICAgICBhZ2VudDoge1xuICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgY2FwYWJpbGl0aWVzOiBcImFycmF5XCIsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIGNyZWF0ZWQ6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgdGFnczogXCJvYmplY3RcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgZXhwZWN0KHZhbGlkYXRlTmVzdGVkU3RydWN0dXJlKGNvbXBsZXhEYXRhLCBzY2hlbWEpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkRhdGEgQ29tcHJlc3Npb25cIiwgKCkgPT4ge1xuICAgIGl0KFwiY29tcHJlc3NlcyBkYXRhIGZvciBzdG9yYWdlXCIsIGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGF0YSA9IHtcbiAgICAgICAgaWQ6IFwiY29tcHJlc3MtMVwiLFxuICAgICAgICBsYXJnZVRleHQ6IFwiTG9yZW0gaXBzdW0gXCIucmVwZWF0KDEwMDApLFxuICAgICAgICBudW1iZXJzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiBpKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBhd2FpdCBjb21wcmVzc0ZvclN0b3JhZ2Uob3JpZ2luYWxEYXRhKTtcblxuICAgICAgZXhwZWN0KGNvbXByZXNzZWQubGVuZ3RoKS50b0JlTGVzc1RoYW4oXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsRGF0YSkubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChjb21wcmVzc2VkKS50b0hhdmVQcm9wZXJ0eShcImNvbXByZXNzZWRcIiwgdHJ1ZSk7XG4gICAgICBleHBlY3QoY29tcHJlc3NlZCkudG9IYXZlUHJvcGVydHkoXCJhbGdvcml0aG1cIiwgXCJnemlwXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJkZWNvbXByZXNzZXMgZGF0YSBhZnRlciByZXRyaWV2YWxcIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxEYXRhID0geyBpZDogXCJ0ZXN0XCIsIGNvbnRlbnQ6IFwiSGVsbG8gd29ybGQhXCIgfTtcblxuICAgICAgY29uc3QgY29tcHJlc3NlZCA9IGF3YWl0IGNvbXByZXNzRm9yU3RvcmFnZShvcmlnaW5hbERhdGEpO1xuICAgICAgY29uc3QgZGVjb21wcmVzc2VkID0gYXdhaXQgZGVjb21wcmVzc0Zyb21TdG9yYWdlKGNvbXByZXNzZWQpO1xuXG4gICAgICBleHBlY3QoZGVjb21wcmVzc2VkKS50b0VxdWFsKG9yaWdpbmFsRGF0YSk7XG4gICAgfSk7XG5cbiAgICBpdChcImhhbmRsZXMgY29tcHJlc3Npb24gZXJyb3JzIGdyYWNlZnVsbHlcIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgY29uc3QgY29ycnVwdGVkRGF0YSA9IHtcbiAgICAgICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICAgICAgYWxnb3JpdGhtOiBcImd6aXBcIixcbiAgICAgICAgZGF0YTogXCJjb3JydXB0ZWQtYmFzZTY0LWRhdGFcIixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlY29tcHJlc3NGcm9tU3RvcmFnZShjb3JydXB0ZWREYXRhKTtcblxuICAgICAgLy8gU2hvdWxkIHJldHVybiBvcmlnaW5hbCBkYXRhIG9uIGRlY29tcHJlc3Npb24gZmFpbHVyZVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChjb3JydXB0ZWREYXRhKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJEYXRhIEludGVncml0eVwiLCAoKSA9PiB7XG4gICAgaXQoXCJnZW5lcmF0ZXMgY2hlY2tzdW1zIGZvciBzdG9yZWQgZGF0YVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBpZDogXCJjaGVja3N1bS0xXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiSW1wb3J0YW50IGRhdGFcIixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNoZWNrc3VtID0gZ2VuZXJhdGVDaGVja3N1bShkYXRhKTtcblxuICAgICAgZXhwZWN0KGNoZWNrc3VtKS50b0JlVHJ1dGh5KCk7XG4gICAgICBleHBlY3QoY2hlY2tzdW0pLnRvSGF2ZUxlbmd0aCg2NCk7IC8vIFNIQS0yNTYgaGV4IGxlbmd0aFxuICAgIH0pO1xuXG4gICAgaXQoXCJ2ZXJpZmllcyBkYXRhIGludGVncml0eSBvbiByZXRyaWV2YWxcIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxEYXRhID0ge1xuICAgICAgICBpZDogXCJpbnRlZ3JpdHktMVwiLFxuICAgICAgICBjb250ZW50OiBcIlNlY3VyZSBjb250ZW50XCIsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdG9yZWREYXRhID0ge1xuICAgICAgICAuLi5vcmlnaW5hbERhdGEsXG4gICAgICAgIGNoZWNrc3VtOiBnZW5lcmF0ZUNoZWNrc3VtKG9yaWdpbmFsRGF0YSksXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QodmFsaWRhdGVEYXRhSW50ZWdyaXR5KHN0b3JlZERhdGEpKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBUYW1wZXIgd2l0aCBkYXRhXG4gICAgICBzdG9yZWREYXRhLmNvbnRlbnQgPSBcIk1vZGlmaWVkIGNvbnRlbnRcIjtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZURhdGFJbnRlZ3JpdHkoc3RvcmVkRGF0YSkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJkZXRlY3RzIGRhdGEgY29ycnVwdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb3JydXB0ZWREYXRhID0ge1xuICAgICAgICBpZDogXCJjb3JydXB0LTFcIixcbiAgICAgICAgY29udGVudDogdW5kZWZpbmVkLCAvLyBDb3JydXB0ZWRcbiAgICAgICAgY2hlY2tzdW06IFwiYWJjMTIzXCIsXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4gdmFsaWRhdGVEYXRhSW50ZWdyaXR5KGNvcnJ1cHRlZERhdGEpKS50b1Rocm93KFxuICAgICAgICBcIkRhdGEgY29ycnVwdGlvbiBkZXRlY3RlZFwiLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJTdG9yYWdlIFNlY3VyaXR5XCIsICgpID0+IHtcbiAgICBpdChcImVuY3J5cHRzIHNlbnNpdGl2ZSBkYXRhXCIsIGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIGNvbnN0IHNlbnNpdGl2ZURhdGEgPSB7XG4gICAgICAgIGlkOiBcInNlbnNpdGl2ZS0xXCIsXG4gICAgICAgIGFwaUtleTogXCJzay1zZWNyZXQta2V5XCIsXG4gICAgICAgIHBhc3N3b3JkOiBcInVzZXItcGFzc3dvcmRcIixcbiAgICAgICAgcGVyc29uYWxJbmZvOiB7XG4gICAgICAgICAgc3NuOiBcIjEyMy00NS02Nzg5XCIsXG4gICAgICAgICAgY3JlZGl0Q2FyZDogXCIxMjM0LTU2NzgtOTAxMi0zNDU2XCIsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdG9yZWQgPSBhd2FpdCBzdG9yYWdlLnN0b3JlU2VjdXJlKFwic2Vuc2l0aXZlXCIsIHNlbnNpdGl2ZURhdGEpO1xuXG4gICAgICAvLyBWZXJpZnkgZGF0YSBpcyBlbmNyeXB0ZWRcbiAgICAgIGV4cGVjdChtb2NrT2JqZWN0U3RvcmUuYWRkKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGVuY3J5cHRlZDogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiBleHBlY3Qubm90LnN0cmluZ0NvbnRhaW5pbmcoXCJzay1zZWNyZXQta2V5XCIpLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcImltcGxlbWVudHMgYWNjZXNzIGNvbnRyb2xcIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgY29uc3QgcHJvdGVjdGVkRGF0YSA9IHtcbiAgICAgICAgaWQ6IFwicHJvdGVjdGVkLTFcIixcbiAgICAgICAgY29udGVudDogXCJQcm90ZWN0ZWQgY29udGVudFwiLFxuICAgICAgICBwZXJtaXNzaW9uczogW1wicmVhZDphZG1pblwiLCBcIndyaXRlOmFkbWluXCJdLFxuICAgICAgfTtcblxuICAgICAgLy8gU3RvcmUgd2l0aCBwZXJtaXNzaW9uc1xuICAgICAgYXdhaXQgc3RvcmFnZS5zdG9yZShcInByb3RlY3RlZFwiLCBwcm90ZWN0ZWREYXRhKTtcblxuICAgICAgLy8gVHJ5IHRvIGFjY2VzcyB3aXRob3V0IHBlcm1pc3Npb25cbiAgICAgIGNvbnN0IHVzZXJDb250ZXh0ID0geyByb2xlczogW1widXNlclwiXSB9O1xuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBzdG9yYWdlLmdldChcInByb3RlY3RlZFwiLCBcInByb3RlY3RlZC0xXCIsIHsgY29udGV4dDogdXNlckNvbnRleHQgfSksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhcIkFjY2VzcyBkZW5pZWRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcImxvZ3MgYWNjZXNzIGF0dGVtcHRzXCIsIGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIGNvbnN0IGF1ZGl0TG9nOiBhbnlbXSA9IFtdO1xuICAgICAgY29uc3QgYXVkaXRlZFN0b3JhZ2UgPSBuZXcgSW5kZXhlZERCU3RvcmFnZShcImF1ZGl0LWRiXCIsIDEsIHtcbiAgICAgICAgb25BY2Nlc3M6IChldmVudCkgPT4gYXVkaXRMb2cucHVzaChldmVudCksXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgYXVkaXRlZFN0b3JhZ2UuZ2V0KFwiZGF0YVwiLCBcInRlc3QtMVwiKTtcblxuICAgICAgZXhwZWN0KGF1ZGl0TG9nKS50b0NvbnRhaW5FcXVhbChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGFjdGlvbjogXCJnZXRcIixcbiAgICAgICAgICBzdG9yZTogXCJkYXRhXCIsXG4gICAgICAgICAga2V5OiBcInRlc3QtMVwiLFxuICAgICAgICAgIHRpbWVzdGFtcDogZXhwZWN0LmFueShOdW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiU3RvcmFnZSBPcHRpbWl6YXRpb25cIiwgKCkgPT4ge1xuICAgIGl0KFwiaW1wbGVtZW50cyBMUlUgY2FjaGVcIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgY29uc3QgY2FjaGVkU3RvcmFnZSA9IG5ldyBJbmRleGVkREJTdG9yYWdlKFwiY2FjaGUtZGJcIiwgMSwge1xuICAgICAgICBjYWNoZVNpemU6IDEwMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGaWxsIGNhY2hlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE1MDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGNhY2hlZFN0b3JhZ2Uuc3RvcmUoXCJjYWNoZVwiLCB7IGlkOiBgaXRlbS0ke2l9YCB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IG9sZGVzdCBpdGVtcyBhcmUgZXZpY3RlZFxuICAgICAgY29uc3Qgb2xkZXN0SXRlbSA9IGF3YWl0IGNhY2hlZFN0b3JhZ2UuZ2V0KFwiY2FjaGVcIiwgXCJpdGVtLTBcIik7XG4gICAgICBleHBlY3Qob2xkZXN0SXRlbSkudG9CZU51bGwoKTtcblxuICAgICAgLy8gUmVjZW50IGl0ZW1zIHNob3VsZCBzdGlsbCBiZSBpbiBjYWNoZVxuICAgICAgY29uc3QgcmVjZW50SXRlbSA9IGF3YWl0IGNhY2hlZFN0b3JhZ2UuZ2V0KFwiY2FjaGVcIiwgXCJpdGVtLTE0OVwiKTtcbiAgICAgIGV4cGVjdChyZWNlbnRJdGVtKS50b0JlVHJ1dGh5KCk7XG4gICAgfSk7XG5cbiAgICBpdChcImltcGxlbWVudHMgZGF0YSBkZWR1cGxpY2F0aW9uXCIsIGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZURhdGEgPSB7IGlkOiBcImR1cC0xXCIsIGNvbnRlbnQ6IFwiU2FtZSBjb250ZW50XCIgfTtcblxuICAgICAgLy8gU3RvcmUgc2FtZSBkYXRhIG11bHRpcGxlIHRpbWVzXG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKFwiZGVkdXBcIiwgZHVwbGljYXRlRGF0YSk7XG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKFwiZGVkdXBcIiwgZHVwbGljYXRlRGF0YSk7XG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKFwiZGVkdXBcIiwgZHVwbGljYXRlRGF0YSk7XG5cbiAgICAgIC8vIFNob3VsZCBvbmx5IHN0b3JlIG9uY2VcbiAgICAgIGV4cGVjdChtb2NrT2JqZWN0U3RvcmUuYWRkKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QobW9ja09iamVjdFN0b3JlLnB1dCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpOyAvLyBVcGRhdGVzXG4gICAgfSk7XG5cbiAgICBpdChcImNvbXBhY3RzIHN0b3JhZ2UgcGVyaW9kaWNhbGx5XCIsIGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xuXG4gICAgICBjb25zdCBhdXRvQ29tcGFjdFN0b3JhZ2UgPSBuZXcgSW5kZXhlZERCU3RvcmFnZShcImNvbXBhY3QtZGJcIiwgMSwge1xuICAgICAgICBhdXRvQ29tcGFjdDogdHJ1ZSxcbiAgICAgICAgY29tcGFjdEludGVydmFsOiAzNjAwMDAwLCAvLyAxIGhvdXJcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgYW5kIHJlbW92ZSBkYXRhXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGF1dG9Db21wYWN0U3RvcmFnZS5zdG9yZShcImRhdGFcIiwgeyBpZDogYGl0ZW0tJHtpfWAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyBpKyspIHtcbiAgICAgICAgYXdhaXQgYXV0b0NvbXBhY3RTdG9yYWdlLmRlbGV0ZShcImRhdGFcIiwgYGl0ZW0tJHtpfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBBZHZhbmNlIHRpbWVcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgzNjAwMDAwKTtcblxuICAgICAgLy8gVmVyaWZ5IGNvbXBhY3Rpb24gb2NjdXJyZWRcbiAgICAgIGV4cGVjdChtb2NrREIudHJhbnNhY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3QuYW55KEFycmF5KSxcbiAgICAgICAgXCJyZWFkd3JpdGVcIixcbiAgICAgICk7XG5cbiAgICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIHRoYXQgd291bGQgYmUgaW4gdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRhVHlwZShkYXRhOiBhbnksIGV4cGVjdGVkVHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFwiYXJyYXlcIikgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFwibnVsbFwiKSByZXR1cm4gZGF0YSA9PT0gbnVsbDtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBleHBlY3RlZFR5cGU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF0YVNpemUoZGF0YTogYW55LCBtYXhTaXplOiBudW1iZXIpOiBib29sZWFuIHtcbiAgY29uc3Qgc2l6ZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpLmxlbmd0aDtcbiAgcmV0dXJuIHNpemUgPD0gbWF4U2l6ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOZXN0ZWRTdHJ1Y3R1cmUoZGF0YTogYW55LCBzY2hlbWE6IGFueSk6IGJvb2xlYW4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoIShrZXkgaW4gZGF0YSkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hW2tleV0pKSB7XG4gICAgICBpZiAoIXZhbGlkYXRlTmVzdGVkU3RydWN0dXJlKGRhdGFba2V5XSwgc2NoZW1hW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKCF2YWxpZGF0ZURhdGFUeXBlKGRhdGFba2V5XSwgZXhwZWN0ZWRUeXBlKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDaGVja3N1bShkYXRhOiBhbnkpOiBzdHJpbmcge1xuICAvLyBTaW1wbGlmaWVkIGNoZWNrc3VtIGdlbmVyYXRpb25cbiAgcmV0dXJuIHJlcXVpcmUoXCJjcnlwdG9cIilcbiAgICAuY3JlYXRlSGFzaChcInNoYTI1NlwiKVxuICAgIC51cGRhdGUoSlNPTi5zdHJpbmdpZnkoZGF0YSkpXG4gICAgLmRpZ2VzdChcImhleFwiKTtcbn1cbiJdLCJuYW1lcyI6WyJtb2NrSW5kZXhlZERCIiwib3BlbiIsImplc3QiLCJmbiIsImRlbGV0ZURhdGFiYXNlIiwibW9ja09iamVjdFN0b3JlIiwiYWRkIiwiZ2V0IiwicHV0IiwiZGVsZXRlIiwiY2xlYXIiLCJnZXRBbGwiLCJjb3VudCIsImNyZWF0ZUluZGV4IiwibW9ja1RyYW5zYWN0aW9uIiwib2JqZWN0U3RvcmUiLCJvbmNvbXBsZXRlIiwib25lcnJvciIsIm9uYWJvcnQiLCJtb2NrREIiLCJ0cmFuc2FjdGlvbiIsImNyZWF0ZU9iamVjdFN0b3JlIiwiY2xvc2UiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJnbG9iYWwiLCJpbmRleGVkREIiLCJkZXNjcmliZSIsInN0b3JhZ2UiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXR1cm5WYWx1ZSIsIm9uc3VjY2VzcyIsIm9udXBncmFkZW5lZWRlZCIsInJlc3VsdCIsIkluZGV4ZWREQlN0b3JhZ2UiLCJpdCIsImluaXQiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImRhdGEiLCJpZCIsInR5cGUiLCJjb250ZW50IiwibmFtZSIsInN0YXR1cyIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInN0b3JlIiwidG9CZSIsInN0b3JlZERhdGEiLCJjaGVja3N1bSIsInRvRXF1YWwiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkRPTUV4Y2VwdGlvbiIsInJlcGVhdCIsInJlamVjdHMiLCJ0b1Rocm93IiwiaXRlbXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsInZhbHVlIiwidW5kZWZpbmVkIiwicmVzdWx0cyIsImJhdGNoU3RvcmUiLCJ0b0hhdmVMZW5ndGgiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJleHBpcmFibGVEYXRhIiwiZXhwaXJlc0F0IiwidG9CZU51bGwiLCJwcm9taXNlcyIsIlByb21pc2UiLCJhbGwiLCJ2YWxpZERhdGEiLCJpbnZhbGlkRGF0YSIsInZhbGlkYXRlU3RvcmFnZURhdGEiLCJ1bnNhZmVEYXRhIiwidXNlcklucHV0IiwiaHRtbCIsInNhbml0aXplZCIsInNhbml0aXplQmVmb3JlU3RvcmFnZSIsIm5vdCIsInRvQ29udGFpbiIsInRlc3RDYXNlcyIsImV4cGVjdGVkIiwiZm9yRWFjaCIsInZhbGlkYXRlRGF0YVR5cGUiLCJzbWFsbERhdGEiLCJsYXJnZURhdGEiLCJ2YWxpZGF0ZURhdGFTaXplIiwiY29tcGxleERhdGEiLCJhZ2VudCIsImNhcGFiaWxpdGllcyIsIm1ldGFkYXRhIiwiY3JlYXRlZCIsInZlcnNpb24iLCJ0YWdzIiwiU2V0Iiwic2NoZW1hIiwidmFsaWRhdGVOZXN0ZWRTdHJ1Y3R1cmUiLCJvcmlnaW5hbERhdGEiLCJsYXJnZVRleHQiLCJudW1iZXJzIiwiY29tcHJlc3NlZCIsImNvbXByZXNzRm9yU3RvcmFnZSIsInRvQmVMZXNzVGhhbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b0hhdmVQcm9wZXJ0eSIsImRlY29tcHJlc3NlZCIsImRlY29tcHJlc3NGcm9tU3RvcmFnZSIsImNvcnJ1cHRlZERhdGEiLCJhbGdvcml0aG0iLCJnZW5lcmF0ZUNoZWNrc3VtIiwidG9CZVRydXRoeSIsInZhbGlkYXRlRGF0YUludGVncml0eSIsInNlbnNpdGl2ZURhdGEiLCJhcGlLZXkiLCJwYXNzd29yZCIsInBlcnNvbmFsSW5mbyIsInNzbiIsImNyZWRpdENhcmQiLCJzdG9yZWQiLCJzdG9yZVNlY3VyZSIsIm9iamVjdENvbnRhaW5pbmciLCJlbmNyeXB0ZWQiLCJzdHJpbmdDb250YWluaW5nIiwicHJvdGVjdGVkRGF0YSIsInBlcm1pc3Npb25zIiwidXNlckNvbnRleHQiLCJyb2xlcyIsImNvbnRleHQiLCJhdWRpdExvZyIsImF1ZGl0ZWRTdG9yYWdlIiwib25BY2Nlc3MiLCJldmVudCIsInB1c2giLCJ0b0NvbnRhaW5FcXVhbCIsImFjdGlvbiIsImtleSIsImFueSIsIk51bWJlciIsImNhY2hlZFN0b3JhZ2UiLCJjYWNoZVNpemUiLCJvbGRlc3RJdGVtIiwicmVjZW50SXRlbSIsImR1cGxpY2F0ZURhdGEiLCJ1c2VGYWtlVGltZXJzIiwiYXV0b0NvbXBhY3RTdG9yYWdlIiwiYXV0b0NvbXBhY3QiLCJjb21wYWN0SW50ZXJ2YWwiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwidXNlUmVhbFRpbWVycyIsImV4cGVjdGVkVHlwZSIsImlzQXJyYXkiLCJtYXhTaXplIiwic2l6ZSIsInJlcXVpcmUiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0Il0sIm1hcHBpbmdzIjoiOzs7O2tDQUFpQztnQ0FPMUI7QUFFUCxpQkFBaUI7QUFDakIsTUFBTUEsZ0JBQWdCO0lBQ3BCQyxNQUFNQyxLQUFLQyxFQUFFO0lBQ2JDLGdCQUFnQkYsS0FBS0MsRUFBRTtBQUN6QjtBQUVBLE1BQU1FLGtCQUFrQjtJQUN0QkMsS0FBS0osS0FBS0MsRUFBRTtJQUNaSSxLQUFLTCxLQUFLQyxFQUFFO0lBQ1pLLEtBQUtOLEtBQUtDLEVBQUU7SUFDWk0sUUFBUVAsS0FBS0MsRUFBRTtJQUNmTyxPQUFPUixLQUFLQyxFQUFFO0lBQ2RRLFFBQVFULEtBQUtDLEVBQUU7SUFDZlMsT0FBT1YsS0FBS0MsRUFBRTtJQUNkVSxhQUFhWCxLQUFLQyxFQUFFO0FBQ3RCO0FBRUEsTUFB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