{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/message-queue.ts"],"sourcesContent":["/**\n * Message Queue Implementation\n *\n * High-performance message queue for real-time agent communication\n * with priority handling, batching, and optimization.\n */\n\nexport type MessagePriority = \"critical\" | \"high\" | \"normal\" | \"low\";\n\nexport interface Message {\n  id: string;\n  type: string;\n  priority: MessagePriority;\n  content: string;\n  timestamp: number;\n  agentId: string;\n  expiresAt?: number;\n  retryCount?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface QueueConfig {\n  maxSize: number;\n  batchSize: number;\n  processingInterval: number;\n  priorityLevels: string[];\n  enableBatching: boolean;\n  enableDeduplication: boolean;\n  retryAttempts: number;\n  retryDelay: number;\n}\n\nexport interface QueueMetrics {\n  totalMessages: number;\n  pendingMessages: number;\n  processedMessages: number;\n  errorCount: number;\n  averageProcessingTime: number;\n  throughput: number;\n  errorRate: number;\n  queueSize: number;\n  averageBatchSize: number;\n}\n\nexport interface MessageProcessor {\n  (\n    message: Message,\n  ): Promise<{ success: boolean; result?: any; error?: string }>;\n}\n\nexport interface BatchProcessor {\n  (\n    messages: Message[],\n  ): Promise<Array<{ success: boolean; result?: any; error?: string }>>;\n}\n\nexport interface MessageQueue {\n  getConfig(): QueueConfig;\n  getMetrics(): QueueMetrics;\n  enqueue(message: Message): Promise<void>;\n  dequeue(): Promise<Message | null>;\n  processNext(): Promise<void>;\n  processBatch(): Promise<void>;\n  setProcessor(processor: MessageProcessor): void;\n  setBatchProcessor(processor: BatchProcessor): void;\n  startAutoProcessing(interval?: number): void;\n  stopAutoProcessing(): void;\n  findMessages(filter: Partial<Message>): Message[];\n  searchMessages(query: string): Message[];\n  removeExpiredMessages(): Promise<void>;\n  compact(): Promise<void>;\n  optimizeBatchSize(): Promise<void>;\n  getDeadLetterQueue(): Message[];\n  performHealthCheck(): Promise<boolean>;\n  recover(): Promise<void>;\n  simulateCorruption(): void;\n  getPerformanceReport(): any;\n}\n\nclass MessageQueueImpl implements MessageQueue {\n  private config: QueueConfig;\n  private messages: Map<string, Message> = new Map();\n  private priorityQueues: Map<MessagePriority, Message[]> = new Map();\n  private deadLetterQueue: Message[] = [];\n  private processor?: MessageProcessor;\n  private batchProcessor?: BatchProcessor;\n  private autoProcessingInterval?: NodeJS.Timeout;\n  private metrics: QueueMetrics;\n  private processingTimes: number[] = [];\n  private batchSizes: number[] = [];\n  private isCorrupted = false;\n\n  constructor(config: QueueConfig) {\n    if (config.maxSize <= 0) {\n      throw new Error(\"Invalid configuration: maxSize must be positive\");\n    }\n\n    this.config = config;\n\n    // Initialize priority queues\n    (config.priorityLevels as MessagePriority[]).forEach((priority) => {\n      this.priorityQueues.set(priority, []);\n    });\n\n    this.metrics = {\n      totalMessages: 0,\n      pendingMessages: 0,\n      processedMessages: 0,\n      errorCount: 0,\n      averageProcessingTime: 0,\n      throughput: 0,\n      errorRate: 0,\n      queueSize: 0,\n      averageBatchSize: 0,\n    };\n  }\n\n  getConfig(): QueueConfig {\n    return { ...this.config };\n  }\n\n  getMetrics(): QueueMetrics {\n    this.updateMetrics();\n    return { ...this.metrics };\n  }\n\n  async enqueue(message: Message): Promise<void> {\n    if (this.messages.size >= this.config.maxSize) {\n      throw new Error(\"Queue full\");\n    }\n\n    // Deduplication\n    if (this.config.enableDeduplication && this.messages.has(message.id)) {\n      return; // Skip duplicate\n    }\n\n    // Add to messages map\n    this.messages.set(message.id, message);\n\n    // Add to priority queue\n    const priorityQueue = this.priorityQueues.get(message.priority);\n    if (priorityQueue) {\n      priorityQueue.push(message);\n      // Sort by timestamp for FIFO within priority\n      priorityQueue.sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    this.metrics.totalMessages++;\n    this.updateMetrics();\n  }\n\n  async dequeue(): Promise<Message | null> {\n    // Check priority queues in order\n    for (const priority of this.config.priorityLevels as MessagePriority[]) {\n      const queue = this.priorityQueues.get(priority);\n      if (queue && queue.length > 0) {\n        const message = queue.shift()!;\n        this.messages.delete(message.id);\n        this.updateMetrics();\n        return message;\n      }\n    }\n    return null;\n  }\n\n  async processNext(): Promise<void> {\n    if (!this.processor) {\n      throw new Error(\"No processor configured\");\n    }\n\n    const message = await this.dequeue();\n    if (!message) {\n      return;\n    }\n\n    const startTime = Date.now();\n\n    try {\n      const result = await this.processor(message);\n\n      if (result.success) {\n        this.metrics.processedMessages++;\n      } else {\n        this.metrics.errorCount++; // Count errors immediately\n        await this.handleProcessingFailure(message);\n      }\n    } catch (error) {\n      this.metrics.errorCount++; // Count errors immediately  \n      await this.handleProcessingFailure(message);\n    }\n\n    const processingTime = Date.now() - startTime;\n    this.processingTimes.push(processingTime);\n\n    // Keep only recent processing times\n    if (this.processingTimes.length > 100) {\n      this.processingTimes = this.processingTimes.slice(-50);\n    }\n\n    this.updateMetrics();\n  }\n\n  private async handleProcessingFailure(message: Message): Promise<void> {\n    const retryCount = (message.retryCount || 0) + 1;\n\n    if (retryCount <= this.config.retryAttempts) {\n      // Retry the message\n      message.retryCount = retryCount;\n      await this.enqueue(message);\n    } else {\n      // Move to dead letter queue (error already counted in processNext)\n      this.deadLetterQueue.push(message);\n    }\n  }\n\n  async processBatch(): Promise<void> {\n    if (!this.batchProcessor) {\n      // Fall back to individual processing\n      for (let i = 0; i < this.config.batchSize; i++) {\n        await this.processNext();\n      }\n      return;\n    }\n\n    const batch: Message[] = [];\n\n    // Collect batch\n    for (let i = 0; i < this.config.batchSize; i++) {\n      const message = await this.dequeue();\n      if (!message) break;\n      batch.push(message);\n    }\n\n    if (batch.length === 0) return;\n\n    const startTime = Date.now();\n\n    try {\n      const results = await this.batchProcessor(batch);\n\n      results.forEach((result, index) => {\n        if (result.success) {\n          this.metrics.processedMessages++;\n        } else {\n          this.handleProcessingFailure(batch[index]);\n        }\n      });\n    } catch (error) {\n      // Handle batch failure\n      batch.forEach((message) => this.handleProcessingFailure(message));\n    }\n\n    const batchTime = Date.now() - startTime;\n    this.batchSizes.push(batch.length);\n    this.processingTimes.push(batchTime / batch.length); // Average per message\n\n    this.updateMetrics();\n  }\n\n  setProcessor(processor: MessageProcessor): void {\n    this.processor = processor;\n  }\n\n  setBatchProcessor(processor: BatchProcessor): void {\n    this.batchProcessor = processor;\n  }\n\n  startAutoProcessing(interval?: number): void {\n    const processingInterval = interval || this.config.processingInterval;\n\n    this.autoProcessingInterval = setInterval(async () => {\n      try {\n        if (this.config.enableBatching) {\n          await this.processBatch();\n        } else {\n          await this.processNext();\n        }\n      } catch (error) {\n        console.error(\"Auto processing error:\", error);\n      }\n    }, processingInterval);\n  }\n\n  stopAutoProcessing(): void {\n    if (this.autoProcessingInterval) {\n      clearInterval(this.autoProcessingInterval);\n      this.autoProcessingInterval = undefined;\n    }\n  }\n\n  findMessages(filter: Partial<Message>): Message[] {\n    const results: Message[] = [];\n\n    this.messages.forEach((message) => {\n      let matches = true;\n\n      Object.entries(filter).forEach(([key, value]) => {\n        if (message[key as keyof Message] !== value) {\n          matches = false;\n        }\n      });\n\n      if (matches) {\n        results.push(message);\n      }\n    });\n\n    return results;\n  }\n\n  searchMessages(query: string): Message[] {\n    const results: Message[] = [];\n    const lowerQuery = query.toLowerCase();\n\n    this.messages.forEach((message) => {\n      if (message.content.toLowerCase().includes(lowerQuery)) {\n        results.push(message);\n      }\n    });\n\n    return results;\n  }\n\n  async removeExpiredMessages(): Promise<void> {\n    const now = Date.now();\n    const expiredIds: string[] = [];\n\n    this.messages.forEach((message, id) => {\n      if (message.expiresAt && message.expiresAt < now) {\n        expiredIds.push(id);\n      }\n    });\n\n    expiredIds.forEach((id) => {\n      const message = this.messages.get(id);\n      if (message) {\n        this.messages.delete(id);\n\n        // Remove from priority queue\n        const priorityQueue = this.priorityQueues.get(message.priority);\n        if (priorityQueue) {\n          const index = priorityQueue.findIndex((m) => m.id === id);\n          if (index >= 0) {\n            priorityQueue.splice(index, 1);\n          }\n        }\n      }\n    });\n\n    this.updateMetrics();\n  }\n\n  async compact(): Promise<void> {\n    // Rebuild priority queues from messages map\n    this.priorityQueues.forEach((queue) => (queue.length = 0));\n\n    this.messages.forEach((message) => {\n      const priorityQueue = this.priorityQueues.get(message.priority);\n      if (priorityQueue) {\n        priorityQueue.push(message);\n      }\n    });\n\n    // Sort each priority queue\n    this.priorityQueues.forEach((queue) => {\n      queue.sort((a, b) => a.timestamp - b.timestamp);\n    });\n\n    this.updateMetrics();\n  }\n\n  async optimizeBatchSize(): Promise<void> {\n    if (this.batchSizes.length < 10) return;\n\n    // Calculate optimal batch size based on performance\n    const recentBatches = this.batchSizes.slice(-20);\n    const averageBatchSize =\n      recentBatches.reduce((a, b) => a + b, 0) / recentBatches.length;\n\n    // Adjust config based on performance metrics\n    if (\n      this.metrics.averageProcessingTime < 50 &&\n      averageBatchSize < this.config.batchSize\n    ) {\n      this.config.batchSize = Math.min(this.config.batchSize + 5, 50);\n    } else if (this.metrics.averageProcessingTime > 200) {\n      this.config.batchSize = Math.max(this.config.batchSize - 5, 1);\n    }\n  }\n\n  getDeadLetterQueue(): Message[] {\n    return [...this.deadLetterQueue];\n  }\n\n  async performHealthCheck(): Promise<boolean> {\n    if (this.isCorrupted) return false;\n\n    // Check queue consistency\n    let totalInQueues = 0;\n    this.priorityQueues.forEach((queue) => {\n      totalInQueues += queue.length;\n    });\n\n    return totalInQueues === this.messages.size;\n  }\n\n  async recover(): Promise<void> {\n    this.isCorrupted = false;\n\n    // Rebuild priority queues\n    await this.compact();\n\n    // Reset metrics\n    this.metrics.errorCount = 0;\n  }\n\n  simulateCorruption(): void {\n    this.isCorrupted = true;\n  }\n\n  getPerformanceReport(): any {\n    const recentProcessingTimes = this.processingTimes.slice(-20);\n    const avgTime =\n      recentProcessingTimes.reduce((a, b) => a + b, 0) /\n      recentProcessingTimes.length;\n\n    // Detect degradation - lowered threshold to be more sensitive to performance issues\n    const degradationDetected = avgTime > 30; // More realistic threshold for degradation\n\n    return {\n      degradationDetected,\n      averageProcessingTime: avgTime,\n      recommendations: degradationDetected\n        ? [\"Consider scaling processing capacity\"]\n        : [],\n    };\n  }\n\n  private updateMetrics(): void {\n    let totalInQueues = 0;\n    this.priorityQueues.forEach((queue) => {\n      totalInQueues += queue.length;\n    });\n\n    this.metrics.pendingMessages = totalInQueues;\n    this.metrics.queueSize = this.messages.size;\n\n    if (this.processingTimes.length > 0) {\n      this.metrics.averageProcessingTime =\n        this.processingTimes.reduce((a, b) => a + b, 0) /\n        this.processingTimes.length;\n    }\n\n    if (this.batchSizes.length > 0) {\n      this.metrics.averageBatchSize =\n        this.batchSizes.reduce((a, b) => a + b, 0) / this.batchSizes.length;\n    }\n\n    this.metrics.errorRate =\n      this.metrics.totalMessages > 0\n        ? this.metrics.errorCount / this.metrics.totalMessages\n        : 0;\n\n    // Calculate throughput (messages per second)\n    if (this.processingTimes.length > 1) {\n      const totalTime = this.processingTimes.reduce((a, b) => a + b, 0);\n      this.metrics.throughput =\n        (this.metrics.processedMessages * 1000) / totalTime;\n    }\n  }\n}\n\nexport function createMessageQueue(config: QueueConfig): MessageQueue {\n  return new MessageQueueImpl(config);\n}\n\nexport async function processMessage(\n  message: Message,\n  processor: MessageProcessor,\n): Promise<{ success: boolean; result?: any; error?: string }> {\n  try {\n    return await processor(message);\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n\nexport async function batchProcessMessages(\n  messages: Message[],\n  processor: MessageProcessor,\n): Promise<Array<{ success: boolean; result?: any; error?: string }>> {\n  const results = [];\n\n  for (const message of messages) {\n    results.push(await processMessage(message, processor));\n  }\n\n  return results;\n}\n\nexport function optimizeQueue(queue: MessageQueue): void {\n  // Perform various optimizations\n  queue.removeExpiredMessages();\n  queue.compact();\n  queue.optimizeBatchSize();\n}\n"],"names":["batchProcessMessages","createMessageQueue","optimizeQueue","processMessage","MessageQueueImpl","constructor","config","messages","Map","priorityQueues","deadLetterQueue","processingTimes","batchSizes","isCorrupted","maxSize","Error","priorityLevels","forEach","priority","set","metrics","totalMessages","pendingMessages","processedMessages","errorCount","averageProcessingTime","throughput","errorRate","queueSize","averageBatchSize","getConfig","getMetrics","updateMetrics","enqueue","message","size","enableDeduplication","has","id","priorityQueue","get","push","sort","a","b","timestamp","dequeue","queue","length","shift","delete","processNext","processor","startTime","Date","now","result","success","handleProcessingFailure","error","processingTime","slice","retryCount","retryAttempts","processBatch","batchProcessor","i","batchSize","batch","results","index","batchTime","setProcessor","setBatchProcessor","startAutoProcessing","interval","processingInterval","autoProcessingInterval","setInterval","enableBatching","console","stopAutoProcessing","clearInterval","undefined","findMessages","filter","matches","Object","entries","key","value","searchMessages","query","lowerQuery","toLowerCase","content","includes","removeExpiredMessages","expiredIds","expiresAt","findIndex","m","splice","compact","optimizeBatchSize","recentBatches","reduce","Math","min","max","getDeadLetterQueue","performHealthCheck","totalInQueues","recover","simulateCorruption","getPerformanceReport","recentProcessingTimes","avgTime","degradationDetected","recommendations","totalTime"],"mappings":"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"}