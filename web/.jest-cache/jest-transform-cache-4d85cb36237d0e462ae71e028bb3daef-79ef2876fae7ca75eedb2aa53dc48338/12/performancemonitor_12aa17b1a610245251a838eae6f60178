6d4071367b275d913c1e4f1d32eede4d
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "performanceMonitor", {
    enumerable: true,
    get: function() {
        return performanceMonitor;
    }
});
class PerformanceMonitor {
    async startOperation(operationName) {
        const operationId = `${operationName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        performance.mark(`${operationId}_start`);
        return operationId;
    }
    async endOperation(operationId, metadata) {
        performance.mark(`${operationId}_end`);
        performance.measure(operationId, `${operationId}_start`, `${operationId}_end`);
        const measure = performance.getEntriesByName(operationId)[0];
        const duration = measure.duration;
        // Get memory usage if available
        let memoryUsage;
        if ("memory" in performance) {
            const memory = performance.memory;
            memoryUsage = memory.usedJSHeapSize;
        }
        // Get storage usage
        let storageUsage;
        try {
            if ("storage" in navigator && "estimate" in navigator.storage) {
                const estimate = await navigator.storage.estimate();
                storageUsage = estimate.usage;
            }
        } catch (error) {
        // Storage API not available
        }
        const metric = {
            timestamp: Date.now(),
            operation: operationId.split("_")[0],
            duration,
            dataSize: metadata?.dataSize,
            memoryUsage,
            storageUsage,
            compressionRatio: metadata?.compressionRatio,
            errors: metadata?.errors
        };
        this.addMetric(metric);
        this.updateBenchmark(metric);
        // Clean up performance entries
        performance.clearMarks(`${operationId}_start`);
        performance.clearMarks(`${operationId}_end`);
        performance.clearMeasures(operationId);
        return metric;
    }
    addMetric(metric) {
        this.metrics.push(metric);
        // Keep only the last N metrics to prevent memory leaks
        if (this.metrics.length > this.maxMetricsHistory) {
            this.metrics = this.metrics.slice(-this.maxMetricsHistory);
        }
    }
    updateBenchmark(metric) {
        const existing = this.benchmarks.get(metric.operation);
        if (existing) {
            const totalOps = existing.totalOperations + 1;
            const totalDuration = existing.averageDuration * existing.totalOperations + metric.duration;
            const updated = {
                operation: metric.operation,
                averageDuration: totalDuration / totalOps,
                minDuration: Math.min(existing.minDuration, metric.duration),
                maxDuration: Math.max(existing.maxDuration, metric.duration),
                totalOperations: totalOps,
                errorRate: metric.errors && metric.errors.length > 0 ? (existing.errorRate * existing.totalOperations + 1) / totalOps : existing.errorRate * existing.totalOperations / totalOps,
                lastError: metric.errors && metric.errors.length > 0 ? metric.errors[0] : existing.lastError
            };
            this.benchmarks.set(metric.operation, updated);
        } else {
            this.benchmarks.set(metric.operation, {
                operation: metric.operation,
                averageDuration: metric.duration,
                minDuration: metric.duration,
                maxDuration: metric.duration,
                totalOperations: 1,
                errorRate: metric.errors && metric.errors.length > 0 ? 1 : 0,
                lastError: metric.errors && metric.errors.length > 0 ? metric.errors[0] : undefined
            });
        }
    }
    getBenchmarks() {
        return Array.from(this.benchmarks.values());
    }
    getMetrics(operation, limit = 100) {
        let filtered = this.metrics;
        if (operation) {
            filtered = this.metrics.filter((m)=>m.operation === operation);
        }
        return filtered.slice(-limit);
    }
    getAverageOperationTime(operation) {
        const benchmark = this.benchmarks.get(operation);
        return benchmark?.averageDuration || 0;
    }
    getSystemHealth() {
        const issues = [];
        const recommendations = [];
        let status = "healthy";
        // Calculate average response time across all operations
        const allBenchmarks = Array.from(this.benchmarks.values());
        const averageResponseTime = allBenchmarks.length > 0 ? allBenchmarks.reduce((sum, b)=>sum + b.averageDuration, 0) / allBenchmarks.length : 0;
        // Calculate overall error rate
        const totalOps = allBenchmarks.reduce((sum, b)=>sum + b.totalOperations, 0);
        const totalErrors = allBenchmarks.reduce((sum, b)=>sum + b.errorRate * b.totalOperations, 0);
        const errorRate = totalOps > 0 ? totalErrors / totalOps : 0;
        // Check for performance issues
        if (averageResponseTime > 2000) {
            status = "critical";
            issues.push(`Average response time is very high: ${averageResponseTime.toFixed(2)}ms`);
            recommendations.push("Consider optimizing data processing or using compression");
        } else if (averageResponseTime > 1000) {
            status = "warning";
            issues.push(`Average response time is elevated: ${averageResponseTime.toFixed(2)}ms`);
            recommendations.push("Monitor performance and consider optimization");
        }
        if (errorRate > 0.1) {
            status = "critical";
            issues.push(`High error rate: ${(errorRate * 100).toFixed(2)}%`);
            recommendations.push("Investigate and fix recurring errors");
        } else if (errorRate > 0.05) {
            if (status !== "critical") status = "warning";
            issues.push(`Elevated error rate: ${(errorRate * 100).toFixed(2)}%`);
        }
        // Analyze memory and storage trends
        const recentMetrics = this.metrics.slice(-50);
        const memoryTrend = this.analyzeTrend(recentMetrics.map((m)=>m.memoryUsage).filter(Boolean));
        const storageTrend = this.analyzeTrend(recentMetrics.map((m)=>m.storageUsage).filter(Boolean));
        if (memoryTrend === "increasing rapidly") {
            status = "critical";
            issues.push("Memory usage is increasing rapidly");
            recommendations.push("Check for memory leaks and optimize data structures");
        }
        if (storageTrend === "increasing rapidly") {
            if (status !== "critical") status = "warning";
            issues.push("Storage usage is increasing rapidly");
            recommendations.push("Consider implementing data cleanup or compression");
        }
        return {
            status,
            issues,
            recommendations,
            metrics: {
                averageResponseTime,
                errorRate,
                memoryTrend,
                storageTrend
            }
        };
    }
    analyzeTrend(values) {
        if (values.length < 3) return "insufficient data";
        const firstHalf = values.slice(0, Math.floor(values.length / 2));
        const secondHalf = values.slice(Math.floor(values.length / 2));
        const firstAvg = firstHalf.reduce((sum, v)=>sum + v, 0) / firstHalf.length;
        const secondAvg = secondHalf.reduce((sum, v)=>sum + v, 0) / secondHalf.length;
        const changePercent = (secondAvg - firstAvg) / firstAvg * 100;
        if (changePercent > 20) return "increasing rapidly";
        if (changePercent > 10) return "increasing";
        if (changePercent < -20) return "decreasing rapidly";
        if (changePercent < -10) return "decreasing";
        return "stable";
    }
    async runPerformanceTest() {
        // Test compression performance
        const compressionTest = await this.testCompression();
        // Test storage performance
        const storageTest = await this.testStorage();
        // Test validation performance
        const validationTest = await this.testValidation();
        return {
            compressionTest,
            storageTest,
            validationTest
        };
    }
    async testCompression() {
        const testData = {
            agents: Array.from({
                length: 100
            }, (_, i)=>({
                    id: `agent_${i}`,
                    name: `Test Agent ${i}`,
                    state: {
                        x: Math.random() * 1000,
                        y: Math.random() * 1000
                    },
                    messages: Array.from({
                        length: 50
                    }, (_, j)=>({
                            id: `msg_${j}`,
                            content: `Test message ${j} with some content to compress`,
                            timestamp: new Date().toISOString()
                        }))
                }))
        };
        const startTime = performance.now();
        const jsonString = JSON.stringify(testData);
        const encoder = new TextEncoder();
        const uint8Array = encoder.encode(jsonString);
        const duration = performance.now() - startTime;
        return {
            duration,
            ratio: jsonString.length / uint8Array.length
        };
    }
    async testStorage() {
        const testItems = Array.from({
            length: 100
        }, (_, i)=>({
                id: `test_${i}`,
                data: `Test data item ${i}`,
                timestamp: Date.now()
            }));
        const startTime = performance.now();
        // Simulate storage operations
        for (const item of testItems){
            localStorage.setItem(`perf_test_${item.id}`, JSON.stringify(item));
        }
        const duration = performance.now() - startTime;
        // Cleanup
        for (const item of testItems){
            localStorage.removeItem(`perf_test_${item.id}`);
        }
        return {
            duration,
            throughput: testItems.length / (duration / 1000)
        };
    }
    async testValidation() {
        const testItems = Array.from({
            length: 1000
        }, (_, i)=>({
                id: `test_${i}`,
                name: `Test Item ${i}`,
                createdAt: new Date().toISOString(),
                metadata: {
                    value: Math.random()
                }
            }));
        const startTime = performance.now();
        // Simulate validation
        for (const item of testItems){
            // Simple validation
            if (!item.id || !item.name || !item.createdAt) {
                throw new Error("Validation failed");
            }
        }
        const duration = performance.now() - startTime;
        return {
            duration,
            itemsPerSecond: testItems.length / (duration / 1000)
        };
    }
    clearMetrics() {
        this.metrics = [];
        this.benchmarks.clear();
    }
    exportMetrics() {
        return {
            metrics: this.metrics,
            benchmarks: Array.from(this.benchmarks.values()),
            exportedAt: new Date().toISOString()
        };
    }
    constructor(){
        this.metrics = [];
        this.maxMetricsHistory = 1000;
        this.benchmarks = new Map();
    }
}
const performanceMonitor = new PerformanceMonitor();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvcGVyZm9ybWFuY2UvcGVyZm9ybWFuY2UtbW9uaXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgUGVyZm9ybWFuY2VNZXRyaWNzIHtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIG9wZXJhdGlvbjogc3RyaW5nO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBkYXRhU2l6ZT86IG51bWJlcjtcbiAgbWVtb3J5VXNhZ2U/OiBudW1iZXI7XG4gIHN0b3JhZ2VVc2FnZT86IG51bWJlcjtcbiAgY29tcHJlc3Npb25SYXRpbz86IG51bWJlcjtcbiAgZXJyb3JzPzogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBQZXJmb3JtYW5jZUJlbmNobWFyayB7XG4gIG9wZXJhdGlvbjogc3RyaW5nO1xuICBhdmVyYWdlRHVyYXRpb246IG51bWJlcjtcbiAgbWluRHVyYXRpb246IG51bWJlcjtcbiAgbWF4RHVyYXRpb246IG51bWJlcjtcbiAgdG90YWxPcGVyYXRpb25zOiBudW1iZXI7XG4gIGVycm9yUmF0ZTogbnVtYmVyO1xuICBsYXN0RXJyb3I/OiBzdHJpbmc7XG59XG5cbmNsYXNzIFBlcmZvcm1hbmNlTW9uaXRvciB7XG4gIHByaXZhdGUgbWV0cmljczogUGVyZm9ybWFuY2VNZXRyaWNzW10gPSBbXTtcbiAgcHJpdmF0ZSBtYXhNZXRyaWNzSGlzdG9yeSA9IDEwMDA7XG4gIHByaXZhdGUgYmVuY2htYXJrcyA9IG5ldyBNYXA8c3RyaW5nLCBQZXJmb3JtYW5jZUJlbmNobWFyaz4oKTtcblxuICBhc3luYyBzdGFydE9wZXJhdGlvbihvcGVyYXRpb25OYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG9wZXJhdGlvbklkID0gYCR7b3BlcmF0aW9uTmFtZX1fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoYCR7b3BlcmF0aW9uSWR9X3N0YXJ0YCk7XG4gICAgcmV0dXJuIG9wZXJhdGlvbklkO1xuICB9XG5cbiAgYXN5bmMgZW5kT3BlcmF0aW9uKFxuICAgIG9wZXJhdGlvbklkOiBzdHJpbmcsXG4gICAgbWV0YWRhdGE/OiB7XG4gICAgICBkYXRhU2l6ZT86IG51bWJlcjtcbiAgICAgIGVycm9ycz86IHN0cmluZ1tdO1xuICAgICAgY29tcHJlc3Npb25SYXRpbz86IG51bWJlcjtcbiAgICB9LFxuICApOiBQcm9taXNlPFBlcmZvcm1hbmNlTWV0cmljcz4ge1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoYCR7b3BlcmF0aW9uSWR9X2VuZGApO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoXG4gICAgICBvcGVyYXRpb25JZCxcbiAgICAgIGAke29wZXJhdGlvbklkfV9zdGFydGAsXG4gICAgICBgJHtvcGVyYXRpb25JZH1fZW5kYCxcbiAgICApO1xuXG4gICAgY29uc3QgbWVhc3VyZSA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXG4gICAgICBvcGVyYXRpb25JZCxcbiAgICApWzBdIGFzIFBlcmZvcm1hbmNlTWVhc3VyZTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IG1lYXN1cmUuZHVyYXRpb247XG5cbiAgICAvLyBHZXQgbWVtb3J5IHVzYWdlIGlmIGF2YWlsYWJsZVxuICAgIGxldCBtZW1vcnlVc2FnZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGlmIChcIm1lbW9yeVwiIGluIHBlcmZvcm1hbmNlKSB7XG4gICAgICBjb25zdCBtZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk7XG4gICAgICBtZW1vcnlVc2FnZSA9IG1lbW9yeS51c2VkSlNIZWFwU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc3RvcmFnZSB1c2FnZVxuICAgIGxldCBzdG9yYWdlVXNhZ2U6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgaWYgKFwic3RvcmFnZVwiIGluIG5hdmlnYXRvciAmJiBcImVzdGltYXRlXCIgaW4gbmF2aWdhdG9yLnN0b3JhZ2UpIHtcbiAgICAgICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5lc3RpbWF0ZSgpO1xuICAgICAgICBzdG9yYWdlVXNhZ2UgPSBlc3RpbWF0ZS51c2FnZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU3RvcmFnZSBBUEkgbm90IGF2YWlsYWJsZVxuICAgIH1cblxuICAgIGNvbnN0IG1ldHJpYzogUGVyZm9ybWFuY2VNZXRyaWNzID0ge1xuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb25JZC5zcGxpdChcIl9cIilbMF0sXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGRhdGFTaXplOiBtZXRhZGF0YT8uZGF0YVNpemUsXG4gICAgICBtZW1vcnlVc2FnZSxcbiAgICAgIHN0b3JhZ2VVc2FnZSxcbiAgICAgIGNvbXByZXNzaW9uUmF0aW86IG1ldGFkYXRhPy5jb21wcmVzc2lvblJhdGlvLFxuICAgICAgZXJyb3JzOiBtZXRhZGF0YT8uZXJyb3JzLFxuICAgIH07XG5cbiAgICB0aGlzLmFkZE1ldHJpYyhtZXRyaWMpO1xuICAgIHRoaXMudXBkYXRlQmVuY2htYXJrKG1ldHJpYyk7XG5cbiAgICAvLyBDbGVhbiB1cCBwZXJmb3JtYW5jZSBlbnRyaWVzXG4gICAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhgJHtvcGVyYXRpb25JZH1fc3RhcnRgKTtcbiAgICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGAke29wZXJhdGlvbklkfV9lbmRgKTtcbiAgICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG9wZXJhdGlvbklkKTtcblxuICAgIHJldHVybiBtZXRyaWM7XG4gIH1cblxuICBwcml2YXRlIGFkZE1ldHJpYyhtZXRyaWM6IFBlcmZvcm1hbmNlTWV0cmljcyk6IHZvaWQge1xuICAgIHRoaXMubWV0cmljcy5wdXNoKG1ldHJpYyk7XG5cbiAgICAvLyBLZWVwIG9ubHkgdGhlIGxhc3QgTiBtZXRyaWNzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgaWYgKHRoaXMubWV0cmljcy5sZW5ndGggPiB0aGlzLm1heE1ldHJpY3NIaXN0b3J5KSB7XG4gICAgICB0aGlzLm1ldHJpY3MgPSB0aGlzLm1ldHJpY3Muc2xpY2UoLXRoaXMubWF4TWV0cmljc0hpc3RvcnkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQmVuY2htYXJrKG1ldHJpYzogUGVyZm9ybWFuY2VNZXRyaWNzKTogdm9pZCB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmJlbmNobWFya3MuZ2V0KG1ldHJpYy5vcGVyYXRpb24pO1xuXG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICBjb25zdCB0b3RhbE9wcyA9IGV4aXN0aW5nLnRvdGFsT3BlcmF0aW9ucyArIDE7XG4gICAgICBjb25zdCB0b3RhbER1cmF0aW9uID1cbiAgICAgICAgZXhpc3RpbmcuYXZlcmFnZUR1cmF0aW9uICogZXhpc3RpbmcudG90YWxPcGVyYXRpb25zICsgbWV0cmljLmR1cmF0aW9uO1xuXG4gICAgICBjb25zdCB1cGRhdGVkOiBQZXJmb3JtYW5jZUJlbmNobWFyayA9IHtcbiAgICAgICAgb3BlcmF0aW9uOiBtZXRyaWMub3BlcmF0aW9uLFxuICAgICAgICBhdmVyYWdlRHVyYXRpb246IHRvdGFsRHVyYXRpb24gLyB0b3RhbE9wcyxcbiAgICAgICAgbWluRHVyYXRpb246IE1hdGgubWluKGV4aXN0aW5nLm1pbkR1cmF0aW9uLCBtZXRyaWMuZHVyYXRpb24pLFxuICAgICAgICBtYXhEdXJhdGlvbjogTWF0aC5tYXgoZXhpc3RpbmcubWF4RHVyYXRpb24sIG1ldHJpYy5kdXJhdGlvbiksXG4gICAgICAgIHRvdGFsT3BlcmF0aW9uczogdG90YWxPcHMsXG4gICAgICAgIGVycm9yUmF0ZTpcbiAgICAgICAgICBtZXRyaWMuZXJyb3JzICYmIG1ldHJpYy5lcnJvcnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyAoZXhpc3RpbmcuZXJyb3JSYXRlICogZXhpc3RpbmcudG90YWxPcGVyYXRpb25zICsgMSkgLyB0b3RhbE9wc1xuICAgICAgICAgICAgOiAoZXhpc3RpbmcuZXJyb3JSYXRlICogZXhpc3RpbmcudG90YWxPcGVyYXRpb25zKSAvIHRvdGFsT3BzLFxuICAgICAgICBsYXN0RXJyb3I6XG4gICAgICAgICAgbWV0cmljLmVycm9ycyAmJiBtZXRyaWMuZXJyb3JzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gbWV0cmljLmVycm9yc1swXVxuICAgICAgICAgICAgOiBleGlzdGluZy5sYXN0RXJyb3IsXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJlbmNobWFya3Muc2V0KG1ldHJpYy5vcGVyYXRpb24sIHVwZGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJlbmNobWFya3Muc2V0KG1ldHJpYy5vcGVyYXRpb24sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBtZXRyaWMub3BlcmF0aW9uLFxuICAgICAgICBhdmVyYWdlRHVyYXRpb246IG1ldHJpYy5kdXJhdGlvbixcbiAgICAgICAgbWluRHVyYXRpb246IG1ldHJpYy5kdXJhdGlvbixcbiAgICAgICAgbWF4RHVyYXRpb246IG1ldHJpYy5kdXJhdGlvbixcbiAgICAgICAgdG90YWxPcGVyYXRpb25zOiAxLFxuICAgICAgICBlcnJvclJhdGU6IG1ldHJpYy5lcnJvcnMgJiYgbWV0cmljLmVycm9ycy5sZW5ndGggPiAwID8gMSA6IDAsXG4gICAgICAgIGxhc3RFcnJvcjpcbiAgICAgICAgICBtZXRyaWMuZXJyb3JzICYmIG1ldHJpYy5lcnJvcnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBtZXRyaWMuZXJyb3JzWzBdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldEJlbmNobWFya3MoKTogUGVyZm9ybWFuY2VCZW5jaG1hcmtbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5iZW5jaG1hcmtzLnZhbHVlcygpKTtcbiAgfVxuXG4gIGdldE1ldHJpY3Mob3BlcmF0aW9uPzogc3RyaW5nLCBsaW1pdCA9IDEwMCk6IFBlcmZvcm1hbmNlTWV0cmljc1tdIHtcbiAgICBsZXQgZmlsdGVyZWQgPSB0aGlzLm1ldHJpY3M7XG5cbiAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICBmaWx0ZXJlZCA9IHRoaXMubWV0cmljcy5maWx0ZXIoKG0pID0+IG0ub3BlcmF0aW9uID09PSBvcGVyYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBmaWx0ZXJlZC5zbGljZSgtbGltaXQpO1xuICB9XG5cbiAgZ2V0QXZlcmFnZU9wZXJhdGlvblRpbWUob3BlcmF0aW9uOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGJlbmNobWFyayA9IHRoaXMuYmVuY2htYXJrcy5nZXQob3BlcmF0aW9uKTtcbiAgICByZXR1cm4gYmVuY2htYXJrPy5hdmVyYWdlRHVyYXRpb24gfHwgMDtcbiAgfVxuXG4gIGdldFN5c3RlbUhlYWx0aCgpOiB7XG4gICAgc3RhdHVzOiBcImhlYWx0aHlcIiB8IFwid2FybmluZ1wiIHwgXCJjcml0aWNhbFwiO1xuICAgIGlzc3Vlczogc3RyaW5nW107XG4gICAgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXTtcbiAgICBtZXRyaWNzOiB7XG4gICAgICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBudW1iZXI7XG4gICAgICBlcnJvclJhdGU6IG51bWJlcjtcbiAgICAgIG1lbW9yeVRyZW5kOiBzdHJpbmc7XG4gICAgICBzdG9yYWdlVHJlbmQ6IHN0cmluZztcbiAgICB9O1xuICB9IHtcbiAgICBjb25zdCBpc3N1ZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCBzdGF0dXM6IFwiaGVhbHRoeVwiIHwgXCJ3YXJuaW5nXCIgfCBcImNyaXRpY2FsXCIgPSBcImhlYWx0aHlcIjtcblxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHJlc3BvbnNlIHRpbWUgYWNyb3NzIGFsbCBvcGVyYXRpb25zXG4gICAgY29uc3QgYWxsQmVuY2htYXJrcyA9IEFycmF5LmZyb20odGhpcy5iZW5jaG1hcmtzLnZhbHVlcygpKTtcbiAgICBjb25zdCBhdmVyYWdlUmVzcG9uc2VUaW1lID1cbiAgICAgIGFsbEJlbmNobWFya3MubGVuZ3RoID4gMFxuICAgICAgICA/IGFsbEJlbmNobWFya3MucmVkdWNlKChzdW0sIGIpID0+IHN1bSArIGIuYXZlcmFnZUR1cmF0aW9uLCAwKSAvXG4gICAgICAgICAgYWxsQmVuY2htYXJrcy5sZW5ndGhcbiAgICAgICAgOiAwO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG92ZXJhbGwgZXJyb3IgcmF0ZVxuICAgIGNvbnN0IHRvdGFsT3BzID0gYWxsQmVuY2htYXJrcy5yZWR1Y2UoXG4gICAgICAoc3VtLCBiKSA9PiBzdW0gKyBiLnRvdGFsT3BlcmF0aW9ucyxcbiAgICAgIDAsXG4gICAgKTtcbiAgICBjb25zdCB0b3RhbEVycm9ycyA9IGFsbEJlbmNobWFya3MucmVkdWNlKFxuICAgICAgKHN1bSwgYikgPT4gc3VtICsgYi5lcnJvclJhdGUgKiBiLnRvdGFsT3BlcmF0aW9ucyxcbiAgICAgIDAsXG4gICAgKTtcbiAgICBjb25zdCBlcnJvclJhdGUgPSB0b3RhbE9wcyA+IDAgPyB0b3RhbEVycm9ycyAvIHRvdGFsT3BzIDogMDtcblxuICAgIC8vIENoZWNrIGZvciBwZXJmb3JtYW5jZSBpc3N1ZXNcbiAgICBpZiAoYXZlcmFnZVJlc3BvbnNlVGltZSA+IDIwMDApIHtcbiAgICAgIHN0YXR1cyA9IFwiY3JpdGljYWxcIjtcbiAgICAgIGlzc3Vlcy5wdXNoKFxuICAgICAgICBgQXZlcmFnZSByZXNwb25zZSB0aW1lIGlzIHZlcnkgaGlnaDogJHthdmVyYWdlUmVzcG9uc2VUaW1lLnRvRml4ZWQoMil9bXNgLFxuICAgICAgKTtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKFxuICAgICAgICBcIkNvbnNpZGVyIG9wdGltaXppbmcgZGF0YSBwcm9jZXNzaW5nIG9yIHVzaW5nIGNvbXByZXNzaW9uXCIsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoYXZlcmFnZVJlc3BvbnNlVGltZSA+IDEwMDApIHtcbiAgICAgIHN0YXR1cyA9IFwid2FybmluZ1wiO1xuICAgICAgaXNzdWVzLnB1c2goXG4gICAgICAgIGBBdmVyYWdlIHJlc3BvbnNlIHRpbWUgaXMgZWxldmF0ZWQ6ICR7YXZlcmFnZVJlc3BvbnNlVGltZS50b0ZpeGVkKDIpfW1zYCxcbiAgICAgICk7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaChcIk1vbml0b3IgcGVyZm9ybWFuY2UgYW5kIGNvbnNpZGVyIG9wdGltaXphdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JSYXRlID4gMC4xKSB7XG4gICAgICBzdGF0dXMgPSBcImNyaXRpY2FsXCI7XG4gICAgICBpc3N1ZXMucHVzaChgSGlnaCBlcnJvciByYXRlOiAkeyhlcnJvclJhdGUgKiAxMDApLnRvRml4ZWQoMil9JWApO1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goXCJJbnZlc3RpZ2F0ZSBhbmQgZml4IHJlY3VycmluZyBlcnJvcnNcIik7XG4gICAgfSBlbHNlIGlmIChlcnJvclJhdGUgPiAwLjA1KSB7XG4gICAgICBpZiAoc3RhdHVzICE9PSBcImNyaXRpY2FsXCIpIHN0YXR1cyA9IFwid2FybmluZ1wiO1xuICAgICAgaXNzdWVzLnB1c2goYEVsZXZhdGVkIGVycm9yIHJhdGU6ICR7KGVycm9yUmF0ZSAqIDEwMCkudG9GaXhlZCgyKX0lYCk7XG4gICAgfVxuXG4gICAgLy8gQW5hbHl6ZSBtZW1vcnkgYW5kIHN0b3JhZ2UgdHJlbmRzXG4gICAgY29uc3QgcmVjZW50TWV0cmljcyA9IHRoaXMubWV0cmljcy5zbGljZSgtNTApO1xuICAgIGNvbnN0IG1lbW9yeVRyZW5kID0gdGhpcy5hbmFseXplVHJlbmQoXG4gICAgICByZWNlbnRNZXRyaWNzLm1hcCgobSkgPT4gbS5tZW1vcnlVc2FnZSkuZmlsdGVyKEJvb2xlYW4pIGFzIG51bWJlcltdLFxuICAgICk7XG4gICAgY29uc3Qgc3RvcmFnZVRyZW5kID0gdGhpcy5hbmFseXplVHJlbmQoXG4gICAgICByZWNlbnRNZXRyaWNzLm1hcCgobSkgPT4gbS5zdG9yYWdlVXNhZ2UpLmZpbHRlcihCb29sZWFuKSBhcyBudW1iZXJbXSxcbiAgICApO1xuXG4gICAgaWYgKG1lbW9yeVRyZW5kID09PSBcImluY3JlYXNpbmcgcmFwaWRseVwiKSB7XG4gICAgICBzdGF0dXMgPSBcImNyaXRpY2FsXCI7XG4gICAgICBpc3N1ZXMucHVzaChcIk1lbW9yeSB1c2FnZSBpcyBpbmNyZWFzaW5nIHJhcGlkbHlcIik7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaChcbiAgICAgICAgXCJDaGVjayBmb3IgbWVtb3J5IGxlYWtzIGFuZCBvcHRpbWl6ZSBkYXRhIHN0cnVjdHVyZXNcIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHN0b3JhZ2VUcmVuZCA9PT0gXCJpbmNyZWFzaW5nIHJhcGlkbHlcIikge1xuICAgICAgaWYgKHN0YXR1cyAhPT0gXCJjcml0aWNhbFwiKSBzdGF0dXMgPSBcIndhcm5pbmdcIjtcbiAgICAgIGlzc3Vlcy5wdXNoKFwiU3RvcmFnZSB1c2FnZSBpcyBpbmNyZWFzaW5nIHJhcGlkbHlcIik7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaChcIkNvbnNpZGVyIGltcGxlbWVudGluZyBkYXRhIGNsZWFudXAgb3IgY29tcHJlc3Npb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1cyxcbiAgICAgIGlzc3VlcyxcbiAgICAgIHJlY29tbWVuZGF0aW9ucyxcbiAgICAgIG1ldHJpY3M6IHtcbiAgICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgICAgICAgZXJyb3JSYXRlLFxuICAgICAgICBtZW1vcnlUcmVuZCxcbiAgICAgICAgc3RvcmFnZVRyZW5kLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhbmFseXplVHJlbmQodmFsdWVzOiBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPCAzKSByZXR1cm4gXCJpbnN1ZmZpY2llbnQgZGF0YVwiO1xuXG4gICAgY29uc3QgZmlyc3RIYWxmID0gdmFsdWVzLnNsaWNlKDAsIE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpKTtcbiAgICBjb25zdCBzZWNvbmRIYWxmID0gdmFsdWVzLnNsaWNlKE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpKTtcblxuICAgIGNvbnN0IGZpcnN0QXZnID1cbiAgICAgIGZpcnN0SGFsZi5yZWR1Y2UoKHN1bSwgdikgPT4gc3VtICsgdiwgMCkgLyBmaXJzdEhhbGYubGVuZ3RoO1xuICAgIGNvbnN0IHNlY29uZEF2ZyA9XG4gICAgICBzZWNvbmRIYWxmLnJlZHVjZSgoc3VtLCB2KSA9PiBzdW0gKyB2LCAwKSAvIHNlY29uZEhhbGYubGVuZ3RoO1xuXG4gICAgY29uc3QgY2hhbmdlUGVyY2VudCA9ICgoc2Vjb25kQXZnIC0gZmlyc3RBdmcpIC8gZmlyc3RBdmcpICogMTAwO1xuXG4gICAgaWYgKGNoYW5nZVBlcmNlbnQgPiAyMCkgcmV0dXJuIFwiaW5jcmVhc2luZyByYXBpZGx5XCI7XG4gICAgaWYgKGNoYW5nZVBlcmNlbnQgPiAxMCkgcmV0dXJuIFwiaW5jcmVhc2luZ1wiO1xuICAgIGlmIChjaGFuZ2VQZXJjZW50IDwgLTIwKSByZXR1cm4gXCJkZWNyZWFzaW5nIHJhcGlkbHlcIjtcbiAgICBpZiAoY2hhbmdlUGVyY2VudCA8IC0xMCkgcmV0dXJuIFwiZGVjcmVhc2luZ1wiO1xuICAgIHJldHVybiBcInN0YWJsZVwiO1xuICB9XG5cbiAgYXN5bmMgcnVuUGVyZm9ybWFuY2VUZXN0KCk6IFByb21pc2U8e1xuICAgIGNvbXByZXNzaW9uVGVzdDogeyBkdXJhdGlvbjogbnVtYmVyOyByYXRpbzogbnVtYmVyIH07XG4gICAgc3RvcmFnZVRlc3Q6IHsgZHVyYXRpb246IG51bWJlcjsgdGhyb3VnaHB1dDogbnVtYmVyIH07XG4gICAgdmFsaWRhdGlvblRlc3Q6IHsgZHVyYXRpb246IG51bWJlcjsgaXRlbXNQZXJTZWNvbmQ6IG51bWJlciB9O1xuICB9PiB7XG4gICAgLy8gVGVzdCBjb21wcmVzc2lvbiBwZXJmb3JtYW5jZVxuICAgIGNvbnN0IGNvbXByZXNzaW9uVGVzdCA9IGF3YWl0IHRoaXMudGVzdENvbXByZXNzaW9uKCk7XG5cbiAgICAvLyBUZXN0IHN0b3JhZ2UgcGVyZm9ybWFuY2VcbiAgICBjb25zdCBzdG9yYWdlVGVzdCA9IGF3YWl0IHRoaXMudGVzdFN0b3JhZ2UoKTtcblxuICAgIC8vIFRlc3QgdmFsaWRhdGlvbiBwZXJmb3JtYW5jZVxuICAgIGNvbnN0IHZhbGlkYXRpb25UZXN0ID0gYXdhaXQgdGhpcy50ZXN0VmFsaWRhdGlvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXByZXNzaW9uVGVzdCxcbiAgICAgIHN0b3JhZ2VUZXN0LFxuICAgICAgdmFsaWRhdGlvblRlc3QsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdGVzdENvbXByZXNzaW9uKCk6IFByb21pc2U8e1xuICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgcmF0aW86IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IHRlc3REYXRhID0ge1xuICAgICAgYWdlbnRzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIGlkOiBgYWdlbnRfJHtpfWAsXG4gICAgICAgIG5hbWU6IGBUZXN0IEFnZW50ICR7aX1gLFxuICAgICAgICBzdGF0ZTogeyB4OiBNYXRoLnJhbmRvbSgpICogMTAwMCwgeTogTWF0aC5yYW5kb20oKSAqIDEwMDAgfSxcbiAgICAgICAgbWVzc2FnZXM6IEFycmF5LmZyb20oeyBsZW5ndGg6IDUwIH0sIChfLCBqKSA9PiAoe1xuICAgICAgICAgIGlkOiBgbXNnXyR7an1gLFxuICAgICAgICAgIGNvbnRlbnQ6IGBUZXN0IG1lc3NhZ2UgJHtqfSB3aXRoIHNvbWUgY29udGVudCB0byBjb21wcmVzc2AsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pKSxcbiAgICAgIH0pKSxcbiAgICB9O1xuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHRlc3REYXRhKTtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgdWludDhBcnJheSA9IGVuY29kZXIuZW5jb2RlKGpzb25TdHJpbmcpO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZHVyYXRpb24sXG4gICAgICByYXRpbzoganNvblN0cmluZy5sZW5ndGggLyB1aW50OEFycmF5Lmxlbmd0aCxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB0ZXN0U3RvcmFnZSgpOiBQcm9taXNlPHtcbiAgICBkdXJhdGlvbjogbnVtYmVyO1xuICAgIHRocm91Z2hwdXQ6IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IHRlc3RJdGVtcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gKHtcbiAgICAgIGlkOiBgdGVzdF8ke2l9YCxcbiAgICAgIGRhdGE6IGBUZXN0IGRhdGEgaXRlbSAke2l9YCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9KSk7XG5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIC8vIFNpbXVsYXRlIHN0b3JhZ2Ugb3BlcmF0aW9uc1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0ZXN0SXRlbXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBwZXJmX3Rlc3RfJHtpdGVtLmlkfWAsIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBkdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgLy8gQ2xlYW51cFxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0ZXN0SXRlbXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGBwZXJmX3Rlc3RfJHtpdGVtLmlkfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIHRocm91Z2hwdXQ6IHRlc3RJdGVtcy5sZW5ndGggLyAoZHVyYXRpb24gLyAxMDAwKSwgLy8gaXRlbXMgcGVyIHNlY29uZFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHRlc3RWYWxpZGF0aW9uKCk6IFByb21pc2U8e1xuICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgaXRlbXNQZXJTZWNvbmQ6IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IHRlc3RJdGVtcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAgfSwgKF8sIGkpID0+ICh7XG4gICAgICBpZDogYHRlc3RfJHtpfWAsXG4gICAgICBuYW1lOiBgVGVzdCBJdGVtICR7aX1gLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBtZXRhZGF0YTogeyB2YWx1ZTogTWF0aC5yYW5kb20oKSB9LFxuICAgIH0pKTtcblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgLy8gU2ltdWxhdGUgdmFsaWRhdGlvblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0ZXN0SXRlbXMpIHtcbiAgICAgIC8vIFNpbXBsZSB2YWxpZGF0aW9uXG4gICAgICBpZiAoIWl0ZW0uaWQgfHwgIWl0ZW0ubmFtZSB8fCAhaXRlbS5jcmVhdGVkQXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgIHJldHVybiB7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIGl0ZW1zUGVyU2Vjb25kOiB0ZXN0SXRlbXMubGVuZ3RoIC8gKGR1cmF0aW9uIC8gMTAwMCksXG4gICAgfTtcbiAgfVxuXG4gIGNsZWFyTWV0cmljcygpOiB2b2lkIHtcbiAgICB0aGlzLm1ldHJpY3MgPSBbXTtcbiAgICB0aGlzLmJlbmNobWFya3MuY2xlYXIoKTtcbiAgfVxuXG4gIGV4cG9ydE1ldHJpY3MoKToge1xuICAgIG1ldHJpY3M6IFBlcmZvcm1hbmNlTWV0cmljc1tdO1xuICAgIGJlbmNobWFya3M6IFBlcmZvcm1hbmNlQmVuY2htYXJrW107XG4gICAgZXhwb3J0ZWRBdDogc3RyaW5nO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0cmljczogdGhpcy5tZXRyaWNzLFxuICAgICAgYmVuY2htYXJrczogQXJyYXkuZnJvbSh0aGlzLmJlbmNobWFya3MudmFsdWVzKCkpLFxuICAgICAgZXhwb3J0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgcGVyZm9ybWFuY2VNb25pdG9yID0gbmV3IFBlcmZvcm1hbmNlTW9uaXRvcigpO1xuXG4vLyBFeHBvcnQgdHlwZXNcbmV4cG9ydCB0eXBlIHsgUGVyZm9ybWFuY2VNZXRyaWNzLCBQZXJmb3JtYW5jZUJlbmNobWFyayB9O1xuIl0sIm5hbWVzIjpbInBlcmZvcm1hbmNlTW9uaXRvciIsIlBlcmZvcm1hbmNlTW9uaXRvciIsInN0YXJ0T3BlcmF0aW9uIiwib3BlcmF0aW9uTmFtZSIsIm9wZXJhdGlvbklkIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInBlcmZvcm1hbmNlIiwibWFyayIsImVuZE9wZXJhdGlvbiIsIm1ldGFkYXRhIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJkdXJhdGlvbiIsIm1lbW9yeVVzYWdlIiwibWVtb3J5IiwidXNlZEpTSGVhcFNpemUiLCJzdG9yYWdlVXNhZ2UiLCJuYXZpZ2F0b3IiLCJzdG9yYWdlIiwiZXN0aW1hdGUiLCJ1c2FnZSIsImVycm9yIiwibWV0cmljIiwidGltZXN0YW1wIiwib3BlcmF0aW9uIiwic3BsaXQiLCJkYXRhU2l6ZSIsImNvbXByZXNzaW9uUmF0aW8iLCJlcnJvcnMiLCJhZGRNZXRyaWMiLCJ1cGRhdGVCZW5jaG1hcmsiLCJjbGVhck1hcmtzIiwiY2xlYXJNZWFzdXJlcyIsIm1ldHJpY3MiLCJwdXNoIiwibGVuZ3RoIiwibWF4TWV0cmljc0hpc3RvcnkiLCJzbGljZSIsImV4aXN0aW5nIiwiYmVuY2htYXJrcyIsImdldCIsInRvdGFsT3BzIiwidG90YWxPcGVyYXRpb25zIiwidG90YWxEdXJhdGlvbiIsImF2ZXJhZ2VEdXJhdGlvbiIsInVwZGF0ZWQiLCJtaW5EdXJhdGlvbiIsIm1pbiIsIm1heER1cmF0aW9uIiwibWF4IiwiZXJyb3JSYXRlIiwibGFzdEVycm9yIiwic2V0IiwidW5kZWZpbmVkIiwiZ2V0QmVuY2htYXJrcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImdldE1ldHJpY3MiLCJsaW1pdCIsImZpbHRlcmVkIiwiZmlsdGVyIiwibSIsImdldEF2ZXJhZ2VPcGVyYXRpb25UaW1lIiwiYmVuY2htYXJrIiwiZ2V0U3lzdGVtSGVhbHRoIiwiaXNzdWVzIiwicmVjb21tZW5kYXRpb25zIiwic3RhdHVzIiwiYWxsQmVuY2htYXJrcyIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJyZWR1Y2UiLCJzdW0iLCJiIiwidG90YWxFcnJvcnMiLCJ0b0ZpeGVkIiwicmVjZW50TWV0cmljcyIsIm1lbW9yeVRyZW5kIiwiYW5hbHl6ZVRyZW5kIiwibWFwIiwiQm9vbGVhbiIsInN0b3JhZ2VUcmVuZCIsImZpcnN0SGFsZiIsImZsb29yIiwic2Vjb25kSGFsZiIsImZpcnN0QXZnIiwidiIsInNlY29uZEF2ZyIsImNoYW5nZVBlcmNlbnQiLCJydW5QZXJmb3JtYW5jZVRlc3QiLCJjb21wcmVzc2lvblRlc3QiLCJ0ZXN0Q29tcHJlc3Npb24iLCJzdG9yYWdlVGVzdCIsInRlc3RTdG9yYWdlIiwidmFsaWRhdGlvblRlc3QiLCJ0ZXN0VmFsaWRhdGlvbiIsInRlc3REYXRhIiwiYWdlbnRzIiwiXyIsImkiLCJpZCIsIm5hbWUiLCJzdGF0ZSIsIngiLCJ5IiwibWVzc2FnZXMiLCJqIiwiY29udGVudCIsInRvSVNPU3RyaW5nIiwic3RhcnRUaW1lIiwianNvblN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJ1aW50OEFycmF5IiwiZW5jb2RlIiwicmF0aW8iLCJ0ZXN0SXRlbXMiLCJkYXRhIiwiaXRlbSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwidGhyb3VnaHB1dCIsImNyZWF0ZWRBdCIsInZhbHVlIiwiRXJyb3IiLCJpdGVtc1BlclNlY29uZCIsImNsZWFyTWV0cmljcyIsImNsZWFyIiwiZXhwb3J0TWV0cmljcyIsImV4cG9ydGVkQXQiLCJNYXAiXSwibWFwcGluZ3MiOiI7Ozs7K0JBcVphQTs7O2VBQUFBOzs7QUFoWWIsTUFBTUM7SUFLSixNQUFNQyxlQUFlQyxhQUFxQixFQUFtQjtRQUMzRCxNQUFNQyxjQUFjLENBQUMsRUFBRUQsY0FBYyxDQUFDLEVBQUVFLEtBQUtDLEdBQUcsR0FBRyxDQUFDLEVBQUVDLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUMvRkMsWUFBWUMsSUFBSSxDQUFDLENBQUMsRUFBRVIsWUFBWSxNQUFNLENBQUM7UUFDdkMsT0FBT0E7SUFDVDtJQUVBLE1BQU1TLGFBQ0pULFdBQW1CLEVBQ25CVSxRQUlDLEVBQzRCO1FBQzdCSCxZ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