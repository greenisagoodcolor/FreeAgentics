{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/markov-blanket.ts"],"sourcesContent":["/**\n * Markov Blanket Implementation\n *\n * Core implementation for Markov blanket calculations and state management\n * supporting active inference and free energy minimization.\n */\n\nexport interface SensorState {\n  value: number;\n  confidence: number;\n}\n\nexport interface ActiveState {\n  value: number;\n  energy: number;\n}\n\nexport interface InternalState {\n  [key: string]: number;\n}\n\nexport interface ExternalState {\n  [key: string]: number;\n}\n\nexport interface MarkovBlanketConfig {\n  learningRate?: number;\n  precision?: number;\n  maxIterations?: number;\n  convergenceThreshold?: number;\n}\n\nexport interface MarkovBlanketState {\n  id: string;\n  agentId: string;\n  sensorStates: Record<string, SensorState>;\n  activeStates: Record<string, ActiveState>;\n  internalStates: InternalState;\n  externalStates: ExternalState;\n  config?: MarkovBlanketConfig;\n  freeEnergy?: number;\n  lastUpdated?: number;\n  convergenceInfo?: {\n    iterations: number;\n    converged: boolean;\n    finalError: number;\n  };\n}\n\nexport type MarkovBlanket = MarkovBlanketState;\n\nconst DEFAULT_CONFIG: MarkovBlanketConfig = {\n  learningRate: 0.01,\n  precision: 0.001,\n  maxIterations: 100,\n  convergenceThreshold: 0.0001,\n};\n\n// Cache for free energy calculations\nconst freeEnergyCache = new WeakMap<\n  MarkovBlanket,\n  { value: number; timestamp: number }\n>();\nconst CACHE_DURATION = 100; // ms\n\nexport function createMarkovBlanket(\n  options: Partial<MarkovBlanketState> & { id: string; agentId: string },\n): MarkovBlanket {\n  if (!options.id || !options.agentId) {\n    throw new Error(\"Invalid Markov blanket configuration\");\n  }\n\n  const blanket: MarkovBlanket = {\n    id: options.id,\n    agentId: options.agentId,\n    sensorStates: options.sensorStates || {},\n    activeStates: options.activeStates || {},\n    internalStates: options.internalStates || {},\n    externalStates: options.externalStates || {},\n    config: { ...DEFAULT_CONFIG, ...options.config },\n    lastUpdated: Date.now(),\n  };\n\n  // Calculate initial free energy\n  blanket.freeEnergy = calculateFreeEnergy(blanket);\n\n  return blanket;\n}\n\nexport function updateMarkovBlanket(\n  blanket: MarkovBlanket,\n  updates: Partial<\n    Pick<\n      MarkovBlanket,\n      \"sensorStates\" | \"activeStates\" | \"internalStates\" | \"externalStates\"\n    >\n  >,\n): MarkovBlanket {\n  const updated: MarkovBlanket = {\n    ...blanket,\n    lastUpdated: Date.now(),\n  };\n\n  // Update sensor states\n  if (updates.sensorStates) {\n    updated.sensorStates = { ...updates.sensorStates };\n  }\n\n  // Update active states with energy constraints\n  if (updates.activeStates) {\n    updated.activeStates = Object.entries(updates.activeStates).reduce(\n      (acc, [key, state]) => {\n        acc[key] = {\n          value: Math.min(Math.max(state.value, 0), 1),\n          energy: Math.max(state.energy, 0),\n        };\n        return acc;\n      },\n      {} as Record<string, ActiveState>,\n    );\n  }\n\n  // Update internal states with normalization\n  if (updates.internalStates) {\n    updated.internalStates = Object.entries(updates.internalStates).reduce(\n      (acc, [key, value]) => {\n        acc[key] = Math.min(Math.max(value, 0), 1);\n        return acc;\n      },\n      {} as InternalState,\n    );\n  }\n\n  // Update external states\n  if (updates.externalStates) {\n    updated.externalStates = { ...updates.externalStates };\n  }\n\n  // Recalculate free energy\n  updated.freeEnergy = calculateFreeEnergy(updated);\n\n  return updated;\n}\n\nexport function calculateFreeEnergy(blanket: MarkovBlanket): number {\n  // Check cache first\n  const cached = freeEnergyCache.get(blanket);\n  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {\n    return cached.value;\n  }\n\n  let freeEnergy = 0;\n\n  // Prediction error component\n  Object.entries(blanket.sensorStates).forEach(([sensorKey, sensor]) => {\n    const beliefKey = `belief_${sensorKey}`;\n    const belief = blanket.internalStates[beliefKey] || 0.5;\n    const predictionError = Math.pow(sensor.value - belief, 2);\n    freeEnergy += predictionError * sensor.confidence;\n  });\n\n  // Entropy component\n  Object.values(blanket.internalStates).forEach((value) => {\n    if (value > 0 && value < 1) {\n      const entropy =\n        -value * Math.log(value) - (1 - value) * Math.log(1 - value);\n      freeEnergy += entropy * 0.1; // Weight the entropy contribution\n    }\n  });\n\n  // Complexity component (deviation from priors)\n  Object.entries(blanket.internalStates).forEach(([key, value]) => {\n    const prior = 0.5; // Assume uniform prior\n    const complexity = Math.pow(value - prior, 2);\n    freeEnergy += complexity * 0.05;\n  });\n\n  // Energy constraints\n  Object.values(blanket.activeStates).forEach((state) => {\n    if (state.value > 0) {\n      const energyCost = state.value * (1 - state.energy);\n      freeEnergy += energyCost * 0.2;\n    }\n  });\n\n  // Cache the result\n  freeEnergyCache.set(blanket, { value: freeEnergy, timestamp: Date.now() });\n\n  return freeEnergy;\n}\n\nexport async function minimizeFreeEnergy(\n  blanket: MarkovBlanket,\n  options?: Partial<MarkovBlanketConfig>,\n): Promise<MarkovBlanket> {\n  const config = { ...blanket.config, ...options };\n  let current = { ...blanket };\n  let iterations = 0;\n  let converged = false;\n  let previousFE = calculateFreeEnergy(current);\n\n  while (iterations < config.maxIterations! && !converged) {\n    const gradient: InternalState = {};\n\n    // Calculate gradient for each internal state\n    Object.keys(current.internalStates).forEach((key) => {\n      const epsilon = 0.001;\n      const original = current.internalStates[key];\n\n      // Forward difference\n      current.internalStates[key] = Math.min(original + epsilon, 1);\n      const feForward = calculateFreeEnergy(current);\n\n      // Backward difference\n      current.internalStates[key] = Math.max(original - epsilon, 0);\n      const feBackward = calculateFreeEnergy(current);\n\n      // Calculate gradient\n      gradient[key] = (feForward - feBackward) / (2 * epsilon);\n\n      // Restore original value\n      current.internalStates[key] = original;\n    });\n\n    // Update internal states based on gradient\n    Object.keys(gradient).forEach((key) => {\n      const update = -gradient[key] * config.learningRate!;\n      current.internalStates[key] = Math.min(\n        Math.max(current.internalStates[key] + update, 0),\n        1,\n      );\n    });\n\n    // Check convergence\n    const currentFE = calculateFreeEnergy(current);\n    const improvement = previousFE - currentFE;\n\n    if (Math.abs(improvement) < config.convergenceThreshold!) {\n      converged = true;\n    }\n\n    previousFE = currentFE;\n    iterations++;\n  }\n\n  return {\n    ...current,\n    freeEnergy: previousFE,\n    convergenceInfo: {\n      iterations,\n      converged,\n      finalError: previousFE,\n    },\n  };\n}\n\nexport function getMarkovBlanketNeighbors(\n  blanket: MarkovBlanket,\n  allBlankets: MarkovBlanket[],\n  options?: {\n    proximityThreshold?: number;\n    considerCommunication?: boolean;\n    considerSharedBeliefs?: boolean;\n  },\n): MarkovBlanket[] {\n  const opts = {\n    proximityThreshold: 0.5,\n    considerCommunication: false,\n    considerSharedBeliefs: false,\n    ...options,\n  };\n\n  return allBlankets.filter((other) => {\n    if (other.id === blanket.id) return false;\n\n    // Check proximity\n    const proximityKey = `proximity_to_${blanket.agentId}`;\n    const proximity = other.externalStates[proximityKey] || 0;\n\n    if (proximity < opts.proximityThreshold) return false;\n\n    // Additional checks if enabled\n    if (opts.considerCommunication) {\n      const communication = other.activeStates.communication?.value || 0;\n      if (communication < 0.3) return false;\n    }\n\n    if (opts.considerSharedBeliefs) {\n      // Check for similar beliefs\n      const beliefSimilarity = Object.keys(blanket.internalStates)\n        .filter((key) => key.startsWith(\"belief_\"))\n        .reduce((sim, key) => {\n          const diff = Math.abs(\n            blanket.internalStates[key] - (other.internalStates[key] || 0.5),\n          );\n          return sim + (1 - diff);\n        }, 0);\n\n      if (beliefSimilarity < 1) return false;\n    }\n\n    return true;\n  });\n}\n\nexport function mergeMarkovBlankets(blankets: MarkovBlanket[]): MarkovBlanket {\n  if (blankets.length === 0) {\n    throw new Error(\"Cannot merge empty array of Markov blankets\");\n  }\n\n  if (blankets.length === 1) {\n    return blankets[0];\n  }\n\n  const merged: MarkovBlanket = {\n    id: `merged-${Date.now()}`,\n    agentId: `coalition-${blankets.map((b) => b.agentId).join(\"-\")}`,\n    sensorStates: {},\n    activeStates: {},\n    internalStates: {},\n    externalStates: {},\n    lastUpdated: Date.now(),\n  };\n\n  // Merge sensor states (union)\n  blankets.forEach((blanket) => {\n    Object.entries(blanket.sensorStates).forEach(([key, state]) => {\n      if (\n        !merged.sensorStates[key] ||\n        state.confidence > merged.sensorStates[key].confidence\n      ) {\n        merged.sensorStates[key] = state;\n      }\n    });\n  });\n\n  // Merge active states (average)\n  const activeStateKeys = new Set<string>();\n  blankets.forEach((blanket) => {\n    Object.keys(blanket.activeStates).forEach((key) =>\n      activeStateKeys.add(key),\n    );\n  });\n\n  activeStateKeys.forEach((key) => {\n    const states = blankets.map((b) => b.activeStates[key]).filter(Boolean);\n\n    if (states.length > 0) {\n      merged.activeStates[key] = {\n        value: states.reduce((sum, s) => sum + s.value, 0) / states.length,\n        energy: states.reduce((sum, s) => sum + s.energy, 0) / states.length,\n      };\n    }\n  });\n\n  // Merge internal states (weighted average based on free energy)\n  const weights = blankets.map((b) => 1 / (b.freeEnergy || 1));\n  const totalWeight = weights.reduce((sum, w) => sum + w, 0);\n\n  const internalKeys = new Set<string>();\n  blankets.forEach((blanket) => {\n    Object.keys(blanket.internalStates).forEach((key) => internalKeys.add(key));\n  });\n\n  internalKeys.forEach((key) => {\n    let weightedSum = 0;\n    let weightSum = 0;\n\n    blankets.forEach((blanket, i) => {\n      if (blanket.internalStates[key] !== undefined) {\n        weightedSum += blanket.internalStates[key] * weights[i];\n        weightSum += weights[i];\n      }\n    });\n\n    if (weightSum > 0) {\n      merged.internalStates[key] = weightedSum / weightSum;\n    }\n  });\n\n  // Calculate free energy for merged blanket\n  merged.freeEnergy = calculateFreeEnergy(merged);\n\n  return merged;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport function validateMarkovBlanket(\n  blanket: Partial<MarkovBlanket>,\n): ValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check required fields\n  if (!blanket.id) errors.push(\"Missing required field: id\");\n  if (!blanket.agentId) errors.push(\"Missing required field: agentId\");\n  if (!blanket.sensorStates)\n    errors.push(\"Missing required field: sensorStates\");\n  if (!blanket.activeStates)\n    errors.push(\"Missing required field: activeStates\");\n  if (!blanket.internalStates)\n    errors.push(\"Missing required field: internalStates\");\n  if (!blanket.externalStates)\n    errors.push(\"Missing required field: externalStates\");\n\n  // Validate state ranges\n  if (blanket.internalStates) {\n    Object.entries(blanket.internalStates).forEach(([key, value]) => {\n      if (value < 0 || value > 1) {\n        errors.push(`Internal state '${key}' out of range: ${value}`);\n      }\n    });\n  }\n\n  if (blanket.activeStates) {\n    Object.entries(blanket.activeStates).forEach(([key, state]) => {\n      if (state.value < 0 || state.value > 1) {\n        errors.push(`Active state '${key}' value out of range: ${state.value}`);\n      }\n      if (state.energy < 0) {\n        errors.push(\n          `Active state '${key}' energy cannot be negative: ${state.energy}`,\n        );\n      }\n    });\n\n    // Check energy conservation\n    const totalActiveValue = Object.values(blanket.activeStates).reduce(\n      (sum, state) => sum + state.value,\n      0,\n    );\n    const totalEnergy = Object.values(blanket.activeStates).reduce(\n      (sum, state) => sum + state.energy,\n      0,\n    );\n\n    if (totalActiveValue > 1 && totalEnergy < 0.1) {\n      warnings.push(\n        \"Energy conservation warning: High activity with low energy\",\n      );\n    }\n  }\n\n  if (blanket.sensorStates) {\n    Object.entries(blanket.sensorStates).forEach(([key, state]) => {\n      if (state.value < 0 || state.value > 1) {\n        errors.push(`Sensor state '${key}' value out of range: ${state.value}`);\n      }\n      if (state.confidence < 0 || state.confidence > 1) {\n        errors.push(\n          `Sensor state '${key}' confidence out of range: ${state.confidence}`,\n        );\n      }\n    });\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n"],"names":["calculateFreeEnergy","createMarkovBlanket","getMarkovBlanketNeighbors","mergeMarkovBlankets","minimizeFreeEnergy","updateMarkovBlanket","validateMarkovBlanket","DEFAULT_CONFIG","learningRate","precision","maxIterations","convergenceThreshold","freeEnergyCache","WeakMap","CACHE_DURATION","options","id","agentId","Error","blanket","sensorStates","activeStates","internalStates","externalStates","config","lastUpdated","Date","now","freeEnergy","updates","updated","Object","entries","reduce","acc","key","state","value","Math","min","max","energy","cached","get","timestamp","forEach","sensorKey","sensor","beliefKey","belief","predictionError","pow","confidence","values","entropy","log","prior","complexity","energyCost","set","current","iterations","converged","previousFE","gradient","keys","epsilon","original","feForward","feBackward","update","currentFE","improvement","abs","convergenceInfo","finalError","allBlankets","opts","proximityThreshold","considerCommunication","considerSharedBeliefs","filter","other","proximityKey","proximity","communication","beliefSimilarity","startsWith","sim","diff","blankets","length","merged","map","b","join","activeStateKeys","Set","add","states","Boolean","sum","s","weights","totalWeight","w","internalKeys","weightedSum","weightSum","i","undefined","errors","warnings","push","totalActiveValue","totalEnergy","isValid"],"mappings":"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"}