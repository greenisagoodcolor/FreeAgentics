{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/performance/performance-monitor.ts"],"sourcesContent":["interface PerformanceMetrics {\n  timestamp: number;\n  operation: string;\n  duration: number;\n  dataSize?: number;\n  memoryUsage?: number;\n  storageUsage?: number;\n  compressionRatio?: number;\n  errors?: string[];\n}\n\ninterface PerformanceBenchmark {\n  operation: string;\n  averageDuration: number;\n  minDuration: number;\n  maxDuration: number;\n  totalOperations: number;\n  errorRate: number;\n  lastError?: string;\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetrics[] = [];\n  private maxMetricsHistory = 1000;\n  private benchmarks = new Map<string, PerformanceBenchmark>();\n\n  async startOperation(operationName: string): Promise<string> {\n    const operationId = `${operationName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    performance.mark(`${operationId}_start`);\n    return operationId;\n  }\n\n  async endOperation(\n    operationId: string,\n    metadata?: {\n      dataSize?: number;\n      errors?: string[];\n      compressionRatio?: number;\n    },\n  ): Promise<PerformanceMetrics> {\n    performance.mark(`${operationId}_end`);\n    performance.measure(\n      operationId,\n      `${operationId}_start`,\n      `${operationId}_end`,\n    );\n\n    const measure = performance.getEntriesByName(\n      operationId,\n    )[0] as PerformanceMeasure;\n    const duration = measure.duration;\n\n    // Get memory usage if available\n    let memoryUsage: number | undefined;\n    if (\"memory\" in performance) {\n      const memory = (performance as any).memory;\n      memoryUsage = memory.usedJSHeapSize;\n    }\n\n    // Get storage usage\n    let storageUsage: number | undefined;\n    try {\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        storageUsage = estimate.usage;\n      }\n    } catch (error) {\n      // Storage API not available\n    }\n\n    const metric: PerformanceMetrics = {\n      timestamp: Date.now(),\n      operation: operationId.split(\"_\")[0],\n      duration,\n      dataSize: metadata?.dataSize,\n      memoryUsage,\n      storageUsage,\n      compressionRatio: metadata?.compressionRatio,\n      errors: metadata?.errors,\n    };\n\n    this.addMetric(metric);\n    this.updateBenchmark(metric);\n\n    // Clean up performance entries\n    performance.clearMarks(`${operationId}_start`);\n    performance.clearMarks(`${operationId}_end`);\n    performance.clearMeasures(operationId);\n\n    return metric;\n  }\n\n  private addMetric(metric: PerformanceMetrics): void {\n    this.metrics.push(metric);\n\n    // Keep only the last N metrics to prevent memory leaks\n    if (this.metrics.length > this.maxMetricsHistory) {\n      this.metrics = this.metrics.slice(-this.maxMetricsHistory);\n    }\n  }\n\n  private updateBenchmark(metric: PerformanceMetrics): void {\n    const existing = this.benchmarks.get(metric.operation);\n\n    if (existing) {\n      const totalOps = existing.totalOperations + 1;\n      const totalDuration =\n        existing.averageDuration * existing.totalOperations + metric.duration;\n\n      const updated: PerformanceBenchmark = {\n        operation: metric.operation,\n        averageDuration: totalDuration / totalOps,\n        minDuration: Math.min(existing.minDuration, metric.duration),\n        maxDuration: Math.max(existing.maxDuration, metric.duration),\n        totalOperations: totalOps,\n        errorRate:\n          metric.errors && metric.errors.length > 0\n            ? (existing.errorRate * existing.totalOperations + 1) / totalOps\n            : (existing.errorRate * existing.totalOperations) / totalOps,\n        lastError:\n          metric.errors && metric.errors.length > 0\n            ? metric.errors[0]\n            : existing.lastError,\n      };\n\n      this.benchmarks.set(metric.operation, updated);\n    } else {\n      this.benchmarks.set(metric.operation, {\n        operation: metric.operation,\n        averageDuration: metric.duration,\n        minDuration: metric.duration,\n        maxDuration: metric.duration,\n        totalOperations: 1,\n        errorRate: metric.errors && metric.errors.length > 0 ? 1 : 0,\n        lastError:\n          metric.errors && metric.errors.length > 0\n            ? metric.errors[0]\n            : undefined,\n      });\n    }\n  }\n\n  getBenchmarks(): PerformanceBenchmark[] {\n    return Array.from(this.benchmarks.values());\n  }\n\n  getMetrics(operation?: string, limit = 100): PerformanceMetrics[] {\n    let filtered = this.metrics;\n\n    if (operation) {\n      filtered = this.metrics.filter((m) => m.operation === operation);\n    }\n\n    return filtered.slice(-limit);\n  }\n\n  getAverageOperationTime(operation: string): number {\n    const benchmark = this.benchmarks.get(operation);\n    return benchmark?.averageDuration || 0;\n  }\n\n  getSystemHealth(): {\n    status: \"healthy\" | \"warning\" | \"critical\";\n    issues: string[];\n    recommendations: string[];\n    metrics: {\n      averageResponseTime: number;\n      errorRate: number;\n      memoryTrend: string;\n      storageTrend: string;\n    };\n  } {\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n    let status: \"healthy\" | \"warning\" | \"critical\" = \"healthy\";\n\n    // Calculate average response time across all operations\n    const allBenchmarks = Array.from(this.benchmarks.values());\n    const averageResponseTime =\n      allBenchmarks.length > 0\n        ? allBenchmarks.reduce((sum, b) => sum + b.averageDuration, 0) /\n          allBenchmarks.length\n        : 0;\n\n    // Calculate overall error rate\n    const totalOps = allBenchmarks.reduce(\n      (sum, b) => sum + b.totalOperations,\n      0,\n    );\n    const totalErrors = allBenchmarks.reduce(\n      (sum, b) => sum + b.errorRate * b.totalOperations,\n      0,\n    );\n    const errorRate = totalOps > 0 ? totalErrors / totalOps : 0;\n\n    // Check for performance issues\n    if (averageResponseTime > 2000) {\n      status = \"critical\";\n      issues.push(\n        `Average response time is very high: ${averageResponseTime.toFixed(2)}ms`,\n      );\n      recommendations.push(\n        \"Consider optimizing data processing or using compression\",\n      );\n    } else if (averageResponseTime > 1000) {\n      status = \"warning\";\n      issues.push(\n        `Average response time is elevated: ${averageResponseTime.toFixed(2)}ms`,\n      );\n      recommendations.push(\"Monitor performance and consider optimization\");\n    }\n\n    if (errorRate > 0.1) {\n      status = \"critical\";\n      issues.push(`High error rate: ${(errorRate * 100).toFixed(2)}%`);\n      recommendations.push(\"Investigate and fix recurring errors\");\n    } else if (errorRate > 0.05) {\n      if (status !== \"critical\") status = \"warning\";\n      issues.push(`Elevated error rate: ${(errorRate * 100).toFixed(2)}%`);\n    }\n\n    // Analyze memory and storage trends\n    const recentMetrics = this.metrics.slice(-50);\n    const memoryTrend = this.analyzeTrend(\n      recentMetrics.map((m) => m.memoryUsage).filter(Boolean) as number[],\n    );\n    const storageTrend = this.analyzeTrend(\n      recentMetrics.map((m) => m.storageUsage).filter(Boolean) as number[],\n    );\n\n    if (memoryTrend === \"increasing rapidly\") {\n      status = \"critical\";\n      issues.push(\"Memory usage is increasing rapidly\");\n      recommendations.push(\n        \"Check for memory leaks and optimize data structures\",\n      );\n    }\n\n    if (storageTrend === \"increasing rapidly\") {\n      if (status !== \"critical\") status = \"warning\";\n      issues.push(\"Storage usage is increasing rapidly\");\n      recommendations.push(\"Consider implementing data cleanup or compression\");\n    }\n\n    return {\n      status,\n      issues,\n      recommendations,\n      metrics: {\n        averageResponseTime,\n        errorRate,\n        memoryTrend,\n        storageTrend,\n      },\n    };\n  }\n\n  private analyzeTrend(values: number[]): string {\n    if (values.length < 3) return \"insufficient data\";\n\n    const firstHalf = values.slice(0, Math.floor(values.length / 2));\n    const secondHalf = values.slice(Math.floor(values.length / 2));\n\n    const firstAvg =\n      firstHalf.reduce((sum, v) => sum + v, 0) / firstHalf.length;\n    const secondAvg =\n      secondHalf.reduce((sum, v) => sum + v, 0) / secondHalf.length;\n\n    const changePercent = ((secondAvg - firstAvg) / firstAvg) * 100;\n\n    if (changePercent > 20) return \"increasing rapidly\";\n    if (changePercent > 10) return \"increasing\";\n    if (changePercent < -20) return \"decreasing rapidly\";\n    if (changePercent < -10) return \"decreasing\";\n    return \"stable\";\n  }\n\n  async runPerformanceTest(): Promise<{\n    compressionTest: { duration: number; ratio: number };\n    storageTest: { duration: number; throughput: number };\n    validationTest: { duration: number; itemsPerSecond: number };\n  }> {\n    // Test compression performance\n    const compressionTest = await this.testCompression();\n\n    // Test storage performance\n    const storageTest = await this.testStorage();\n\n    // Test validation performance\n    const validationTest = await this.testValidation();\n\n    return {\n      compressionTest,\n      storageTest,\n      validationTest,\n    };\n  }\n\n  private async testCompression(): Promise<{\n    duration: number;\n    ratio: number;\n  }> {\n    const testData = {\n      agents: Array.from({ length: 100 }, (_, i) => ({\n        id: `agent_${i}`,\n        name: `Test Agent ${i}`,\n        state: { x: Math.random() * 1000, y: Math.random() * 1000 },\n        messages: Array.from({ length: 50 }, (_, j) => ({\n          id: `msg_${j}`,\n          content: `Test message ${j} with some content to compress`,\n          timestamp: new Date().toISOString(),\n        })),\n      })),\n    };\n\n    const startTime = performance.now();\n    const jsonString = JSON.stringify(testData);\n    const encoder = new TextEncoder();\n    const uint8Array = encoder.encode(jsonString);\n    const duration = performance.now() - startTime;\n\n    return {\n      duration,\n      ratio: jsonString.length / uint8Array.length,\n    };\n  }\n\n  private async testStorage(): Promise<{\n    duration: number;\n    throughput: number;\n  }> {\n    const testItems = Array.from({ length: 100 }, (_, i) => ({\n      id: `test_${i}`,\n      data: `Test data item ${i}`,\n      timestamp: Date.now(),\n    }));\n\n    const startTime = performance.now();\n\n    // Simulate storage operations\n    for (const item of testItems) {\n      localStorage.setItem(`perf_test_${item.id}`, JSON.stringify(item));\n    }\n\n    const duration = performance.now() - startTime;\n\n    // Cleanup\n    for (const item of testItems) {\n      localStorage.removeItem(`perf_test_${item.id}`);\n    }\n\n    return {\n      duration,\n      throughput: testItems.length / (duration / 1000), // items per second\n    };\n  }\n\n  private async testValidation(): Promise<{\n    duration: number;\n    itemsPerSecond: number;\n  }> {\n    const testItems = Array.from({ length: 1000 }, (_, i) => ({\n      id: `test_${i}`,\n      name: `Test Item ${i}`,\n      createdAt: new Date().toISOString(),\n      metadata: { value: Math.random() },\n    }));\n\n    const startTime = performance.now();\n\n    // Simulate validation\n    for (const item of testItems) {\n      // Simple validation\n      if (!item.id || !item.name || !item.createdAt) {\n        throw new Error(\"Validation failed\");\n      }\n    }\n\n    const duration = performance.now() - startTime;\n\n    return {\n      duration,\n      itemsPerSecond: testItems.length / (duration / 1000),\n    };\n  }\n\n  clearMetrics(): void {\n    this.metrics = [];\n    this.benchmarks.clear();\n  }\n\n  exportMetrics(): {\n    metrics: PerformanceMetrics[];\n    benchmarks: PerformanceBenchmark[];\n    exportedAt: string;\n  } {\n    return {\n      metrics: this.metrics,\n      benchmarks: Array.from(this.benchmarks.values()),\n      exportedAt: new Date().toISOString(),\n    };\n  }\n}\n\n// Singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Export types\nexport type { PerformanceMetrics, PerformanceBenchmark };\n"],"names":["performanceMonitor","PerformanceMonitor","startOperation","operationName","operationId","Date","now","Math","random","toString","substr","performance","mark","endOperation","metadata","measure","getEntriesByName","duration","memoryUsage","memory","usedJSHeapSize","storageUsage","navigator","storage","estimate","usage","error","metric","timestamp","operation","split","dataSize","compressionRatio","errors","addMetric","updateBenchmark","clearMarks","clearMeasures","metrics","push","length","maxMetricsHistory","slice","existing","benchmarks","get","totalOps","totalOperations","totalDuration","averageDuration","updated","minDuration","min","maxDuration","max","errorRate","lastError","set","undefined","getBenchmarks","Array","from","values","getMetrics","limit","filtered","filter","m","getAverageOperationTime","benchmark","getSystemHealth","issues","recommendations","status","allBenchmarks","averageResponseTime","reduce","sum","b","totalErrors","toFixed","recentMetrics","memoryTrend","analyzeTrend","map","Boolean","storageTrend","firstHalf","floor","secondHalf","firstAvg","v","secondAvg","changePercent","runPerformanceTest","compressionTest","testCompression","storageTest","testStorage","validationTest","testValidation","testData","agents","_","i","id","name","state","x","y","messages","j","content","toISOString","startTime","jsonString","JSON","stringify","encoder","TextEncoder","uint8Array","encode","ratio","testItems","data","item","localStorage","setItem","removeItem","throughput","createdAt","value","Error","itemsPerSecond","clearMetrics","clear","exportMetrics","exportedAt","Map"],"mappings":";;;;+BAqZaA;;;eAAAA;;;AAhYb,MAAMC;IAKJ,MAAMC,eAAeC,aAAqB,EAAmB;QAC3D,MAAMC,cAAc,CAAC,EAAED,cAAc,CAAC,EAAEE,KAAKC,GAAG,GAAG,CAAC,EAAEC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,MAAM,CAAC,GAAG,GAAG,CAAC;QAC/FC,YAAYC,IAAI,CAAC,CAAC,EAAER,YAAY,MAAM,CAAC;QACvC,OAAOA;IACT;IAEA,MAAMS,aACJT,WAAmB,EACnBU,QAIC,EAC4B;QAC7BH,YAAYC,IAAI,CAAC,CAAC,EAAER,YAAY,IAAI,CAAC;QACrCO,YAAYI,OAAO,CACjBX,aACA,CAAC,EAAEA,YAAY,MAAM,CAAC,EACtB,CAAC,EAAEA,YAAY,IAAI,CAAC;QAGtB,MAAMW,UAAUJ,YAAYK,gBAAgB,CAC1CZ,YACD,CAAC,EAAE;QACJ,MAAMa,WAAWF,QAAQE,QAAQ;QAEjC,gCAAgC;QAChC,IAAIC;QACJ,IAAI,YAAYP,aAAa;YAC3B,MAAMQ,SAAS,AAACR,YAAoBQ,MAAM;YAC1CD,cAAcC,OAAOC,cAAc;QACrC;QAEA,oBAAoB;QACpB,IAAIC;QACJ,IAAI;YACF,IAAI,aAAaC,aAAa,cAAcA,UAAUC,OAAO,EAAE;gBAC7D,MAAMC,WAAW,MAAMF,UAAUC,OAAO,CAACC,QAAQ;gBACjDH,eAAeG,SAASC,KAAK;YAC/B;QACF,EAAE,OAAOC,OAAO;QACd,4BAA4B;QAC9B;QAEA,MAAMC,SAA6B;YACjCC,WAAWvB,KAAKC,GAAG;YACnBuB,WAAWzB,YAAY0B,KAAK,CAAC,IAAI,CAAC,EAAE;YACpCb;YACAc,UAAUjB,UAAUiB;YACpBb;YACAG;YACAW,kBAAkBlB,UAAUkB;YAC5BC,QAAQnB,UAAUmB;QACpB;QAEA,IAAI,CAACC,SAAS,CAACP;QACf,IAAI,CAACQ,eAAe,CAACR;QAErB,+BAA+B;QAC/BhB,YAAYyB,UAAU,CAAC,CAAC,EAAEhC,YAAY,MAAM,CAAC;QAC7CO,YAAYyB,UAAU,CAAC,CAAC,EAAEhC,YAAY,IAAI,CAAC;QAC3CO,YAAY0B,aAAa,CAACjC;QAE1B,OAAOuB;IACT;IAEQO,UAAUP,MAA0B,EAAQ;QAClD,IAAI,CAACW,OAAO,CAACC,IAAI,CAACZ;QAElB,uDAAuD;QACvD,IAAI,IAAI,CAACW,OAAO,CAACE,MAAM,GAAG,IAAI,CAACC,iBAAiB,EAAE;YAChD,IAAI,CAACH,OAAO,GAAG,IAAI,CAACA,OAAO,CAACI,KAAK,CAAC,CAAC,IAAI,CAACD,iBAAiB;QAC3D;IACF;IAEQN,gBAAgBR,MAA0B,EAAQ;QACxD,MAAMgB,WAAW,IAAI,CAACC,UAAU,CAACC,GAAG,CAAClB,OAAOE,SAAS;QAErD,IAAIc,UAAU;YACZ,MAAMG,WAAWH,SAASI,eAAe,GAAG;YAC5C,MAAMC,gBACJL,SAASM,eAAe,GAAGN,SAASI,eAAe,GAAGpB,OAAOV,QAAQ;YAEvE,MAAMiC,UAAgC;gBACpCrB,WAAWF,OAAOE,SAAS;gBAC3BoB,iBAAiBD,gBAAgBF;gBACjCK,aAAa5C,KAAK6C,GAAG,CAACT,SAASQ,WAAW,EAAExB,OAAOV,QAAQ;gBAC3DoC,aAAa9C,KAAK+C,GAAG,CAACX,SAASU,WAAW,EAAE1B,OAAOV,QAAQ;gBAC3D8B,iBAAiBD;gBACjBS,WACE5B,OAAOM,MAAM,IAAIN,OAAOM,MAAM,CAACO,MAAM,GAAG,IACpC,AAACG,CAAAA,SAASY,SAAS,GAAGZ,SAASI,eAAe,GAAG,CAAA,IAAKD,WACtD,AAACH,SAASY,SAAS,GAAGZ,SAASI,eAAe,GAAID;gBACxDU,WACE7B,OAAOM,MAAM,IAAIN,OAAOM,MAAM,CAACO,MAAM,GAAG,IACpCb,OAAOM,MAAM,CAAC,EAAE,GAChBU,SAASa,SAAS;YAC1B;YAEA,IAAI,CAACZ,UAAU,CAACa,GAAG,CAAC9B,OAAOE,SAAS,EAAEqB;QACxC,OAAO;YACL,IAAI,CAACN,UAAU,CAACa,GAAG,CAAC9B,OAAOE,SAAS,EAAE;gBACpCA,WAAWF,OAAOE,SAAS;gBAC3BoB,iBAAiBtB,OAAOV,QAAQ;gBAChCkC,aAAaxB,OAAOV,QAAQ;gBAC5BoC,aAAa1B,OAAOV,QAAQ;gBAC5B8B,iBAAiB;gBACjBQ,WAAW5B,OAAOM,MAAM,IAAIN,OAAOM,MAAM,CAACO,MAAM,GAAG,IAAI,IAAI;gBAC3DgB,WACE7B,OAAOM,MAAM,IAAIN,OAAOM,MAAM,CAACO,MAAM,GAAG,IACpCb,OAAOM,MAAM,CAAC,EAAE,GAChByB;YACR;QACF;IACF;IAEAC,gBAAwC;QACtC,OAAOC,MAAMC,IAAI,CAAC,IAAI,CAACjB,UAAU,CAACkB,MAAM;IAC1C;IAEAC,WAAWlC,SAAkB,EAAEmC,QAAQ,GAAG,EAAwB;QAChE,IAAIC,WAAW,IAAI,CAAC3B,OAAO;QAE3B,IAAIT,WAAW;YACboC,WAAW,IAAI,CAAC3B,OAAO,CAAC4B,MAAM,CAAC,CAACC,IAAMA,EAAEtC,SAAS,KAAKA;QACxD;QAEA,OAAOoC,SAASvB,KAAK,CAAC,CAACsB;IACzB;IAEAI,wBAAwBvC,SAAiB,EAAU;QACjD,MAAMwC,YAAY,IAAI,CAACzB,UAAU,CAACC,GAAG,CAAChB;QACtC,OAAOwC,WAAWpB,mBAAmB;IACvC;IAEAqB,kBAUE;QACA,MAAMC,SAAmB,EAAE;QAC3B,MAAMC,kBAA4B,EAAE;QACpC,IAAIC,SAA6C;QAEjD,wDAAwD;QACxD,MAAMC,gBAAgBd,MAAMC,IAAI,CAAC,IAAI,CAACjB,UAAU,CAACkB,MAAM;QACvD,MAAMa,sBACJD,cAAclC,MAAM,GAAG,IACnBkC,cAAcE,MAAM,CAAC,CAACC,KAAKC,IAAMD,MAAMC,EAAE7B,eAAe,EAAE,KAC1DyB,cAAclC,MAAM,GACpB;QAEN,+BAA+B;QAC/B,MAAMM,WAAW4B,cAAcE,MAAM,CACnC,CAACC,KAAKC,IAAMD,MAAMC,EAAE/B,eAAe,EACnC;QAEF,MAAMgC,cAAcL,cAAcE,MAAM,CACtC,CAACC,KAAKC,IAAMD,MAAMC,EAAEvB,SAAS,GAAGuB,EAAE/B,eAAe,EACjD;QAEF,MAAMQ,YAAYT,WAAW,IAAIiC,cAAcjC,WAAW;QAE1D,+BAA+B;QAC/B,IAAI6B,sBAAsB,MAAM;YAC9BF,SAAS;YACTF,OAAOhC,IAAI,CACT,CAAC,oCAAoC,EAAEoC,oBAAoBK,OAAO,CAAC,GAAG,EAAE,CAAC;YAE3ER,gBAAgBjC,IAAI,CAClB;QAEJ,OAAO,IAAIoC,sBAAsB,MAAM;YACrCF,SAAS;YACTF,OAAOhC,IAAI,CACT,CAAC,mCAAmC,EAAEoC,oBAAoBK,OAAO,CAAC,GAAG,EAAE,CAAC;YAE1ER,gBAAgBjC,IAAI,CAAC;QACvB;QAEA,IAAIgB,YAAY,KAAK;YACnBkB,SAAS;YACTF,OAAOhC,IAAI,CAAC,CAAC,iBAAiB,EAAE,AAACgB,CAAAA,YAAY,GAAE,EAAGyB,OAAO,CAAC,GAAG,CAAC,CAAC;YAC/DR,gBAAgBjC,IAAI,CAAC;QACvB,OAAO,IAAIgB,YAAY,MAAM;YAC3B,IAAIkB,WAAW,YAAYA,SAAS;YACpCF,OAAOhC,IAAI,CAAC,CAAC,qBAAqB,EAAE,AAACgB,CAAAA,YAAY,GAAE,EAAGyB,OAAO,CAAC,GAAG,CAAC,CAAC;QACrE;QAEA,oCAAoC;QACpC,MAAMC,gBAAgB,IAAI,CAAC3C,OAAO,CAACI,KAAK,CAAC,CAAC;QAC1C,MAAMwC,cAAc,IAAI,CAACC,YAAY,CACnCF,cAAcG,GAAG,CAAC,CAACjB,IAAMA,EAAEjD,WAAW,EAAEgD,MAAM,CAACmB;QAEjD,MAAMC,eAAe,IAAI,CAACH,YAAY,CACpCF,cAAcG,GAAG,CAAC,CAACjB,IAAMA,EAAE9C,YAAY,EAAE6C,MAAM,CAACmB;QAGlD,IAAIH,gBAAgB,sBAAsB;YACxCT,SAAS;YACTF,OAAOhC,IAAI,CAAC;YACZiC,gBAAgBjC,IAAI,CAClB;QAEJ;QAEA,IAAI+C,iBAAiB,sBAAsB;YACzC,IAAIb,WAAW,YAAYA,SAAS;YACpCF,OAAOhC,IAAI,CAAC;YACZiC,gBAAgBjC,IAAI,CAAC;QACvB;QAEA,OAAO;YACLkC;YACAF;YACAC;YACAlC,SAAS;gBACPqC;gBACApB;gBACA2B;gBACAI;YACF;QACF;IACF;IAEQH,aAAarB,MAAgB,EAAU;QAC7C,IAAIA,OAAOtB,MAAM,GAAG,GAAG,OAAO;QAE9B,MAAM+C,YAAYzB,OAAOpB,KAAK,CAAC,GAAGnC,KAAKiF,KAAK,CAAC1B,OAAOtB,MAAM,GAAG;QAC7D,MAAMiD,aAAa3B,OAAOpB,KAAK,CAACnC,KAAKiF,KAAK,CAAC1B,OAAOtB,MAAM,GAAG;QAE3D,MAAMkD,WACJH,UAAUX,MAAM,CAAC,CAACC,KAAKc,IAAMd,MAAMc,GAAG,KAAKJ,UAAU/C,MAAM;QAC7D,MAAMoD,YACJH,WAAWb,MAAM,CAAC,CAACC,KAAKc,IAAMd,MAAMc,GAAG,KAAKF,WAAWjD,MAAM;QAE/D,MAAMqD,gBAAgB,AAAED,CAAAA,YAAYF,QAAO,IAAKA,WAAY;QAE5D,IAAIG,gBAAgB,IAAI,OAAO;QAC/B,IAAIA,gBAAgB,IAAI,OAAO;QAC/B,IAAIA,gBAAgB,CAAC,IAAI,OAAO;QAChC,IAAIA,gBAAgB,CAAC,IAAI,OAAO;QAChC,OAAO;IACT;IAEA,MAAMC,qBAIH;QACD,+BAA+B;QAC/B,MAAMC,kBAAkB,MAAM,IAAI,CAACC,eAAe;QAElD,2BAA2B;QAC3B,MAAMC,cAAc,MAAM,IAAI,CAACC,WAAW;QAE1C,8BAA8B;QAC9B,MAAMC,iBAAiB,MAAM,IAAI,CAACC,cAAc;QAEhD,OAAO;YACLL;YACAE;YACAE;QACF;IACF;IAEA,MAAcH,kBAGX;QACD,MAAMK,WAAW;YACfC,QAAQ1C,MAAMC,IAAI,CAAC;gBAAErB,QAAQ;YAAI,GAAG,CAAC+D,GAAGC,IAAO,CAAA;oBAC7CC,IAAI,CAAC,MAAM,EAAED,EAAE,CAAC;oBAChBE,MAAM,CAAC,WAAW,EAAEF,EAAE,CAAC;oBACvBG,OAAO;wBAAEC,GAAGrG,KAAKC,MAAM,KAAK;wBAAMqG,GAAGtG,KAAKC,MAAM,KAAK;oBAAK;oBAC1DsG,UAAUlD,MAAMC,IAAI,CAAC;wBAAErB,QAAQ;oBAAG,GAAG,CAAC+D,GAAGQ,IAAO,CAAA;4BAC9CN,IAAI,CAAC,IAAI,EAAEM,EAAE,CAAC;4BACdC,SAAS,CAAC,aAAa,EAAED,EAAE,8BAA8B,CAAC;4BAC1DnF,WAAW,IAAIvB,OAAO4G,WAAW;wBACnC,CAAA;gBACF,CAAA;QACF;QAEA,MAAMC,YAAYvG,YAAYL,GAAG;QACjC,MAAM6G,aAAaC,KAAKC,SAAS,CAAChB;QAClC,MAAMiB,UAAU,IAAIC;QACpB,MAAMC,aAAaF,QAAQG,MAAM,CAACN;QAClC,MAAMlG,WAAWN,YAAYL,GAAG,KAAK4G;QAErC,OAAO;YACLjG;YACAyG,OAAOP,WAAW3E,MAAM,GAAGgF,WAAWhF,MAAM;QAC9C;IACF;IAEA,MAAc0D,cAGX;QACD,MAAMyB,YAAY/D,MAAMC,IAAI,CAAC;YAAErB,QAAQ;QAAI,GAAG,CAAC+D,GAAGC,IAAO,CAAA;gBACvDC,IAAI,CAAC,KAAK,EAAED,EAAE,CAAC;gBACfoB,MAAM,CAAC,eAAe,EAAEpB,EAAE,CAAC;gBAC3B5E,WAAWvB,KAAKC,GAAG;YACrB,CAAA;QAEA,MAAM4G,YAAYvG,YAAYL,GAAG;QAEjC,8BAA8B;QAC9B,KAAK,MAAMuH,QAAQF,UAAW;YAC5BG,aAAaC,OAAO,CAAC,CAAC,UAAU,EAAEF,KAAKpB,EAAE,CAAC,CAAC,EAAEW,KAAKC,SAAS,CAACQ;QAC9D;QAEA,MAAM5G,WAAWN,YAAYL,GAAG,KAAK4G;QAErC,UAAU;QACV,KAAK,MAAMW,QAAQF,UAAW;YAC5BG,aAAaE,UAAU,CAAC,CAAC,UAAU,EAAEH,KAAKpB,EAAE,CAAC,CAAC;QAChD;QAEA,OAAO;YACLxF;YACAgH,YAAYN,UAAUnF,MAAM,GAAIvB,CAAAA,WAAW,IAAG;QAChD;IACF;IAEA,MAAcmF,iBAGX;QACD,MAAMuB,YAAY/D,MAAMC,IAAI,CAAC;YAAErB,QAAQ;QAAK,GAAG,CAAC+D,GAAGC,IAAO,CAAA;gBACxDC,IAAI,CAAC,KAAK,EAAED,EAAE,CAAC;gBACfE,MAAM,CAAC,UAAU,EAAEF,EAAE,CAAC;gBACtB0B,WAAW,IAAI7H,OAAO4G,WAAW;gBACjCnG,UAAU;oBAAEqH,OAAO5H,KAAKC,MAAM;gBAAG;YACnC,CAAA;QAEA,MAAM0G,YAAYvG,YAAYL,GAAG;QAEjC,sBAAsB;QACtB,KAAK,MAAMuH,QAAQF,UAAW;YAC5B,oBAAoB;YACpB,IAAI,CAACE,KAAKpB,EAAE,IAAI,CAACoB,KAAKnB,IAAI,IAAI,CAACmB,KAAKK,SAAS,EAAE;gBAC7C,MAAM,IAAIE,MAAM;YAClB;QACF;QAEA,MAAMnH,WAAWN,YAAYL,GAAG,KAAK4G;QAErC,OAAO;YACLjG;YACAoH,gBAAgBV,UAAUnF,MAAM,GAAIvB,CAAAA,WAAW,IAAG;QACpD;IACF;IAEAqH,eAAqB;QACnB,IAAI,CAAChG,OAAO,GAAG,EAAE;QACjB,IAAI,CAACM,UAAU,CAAC2F,KAAK;IACvB;IAEAC,gBAIE;QACA,OAAO;YACLlG,SAAS,IAAI,CAACA,OAAO;YACrBM,YAAYgB,MAAMC,IAAI,CAAC,IAAI,CAACjB,UAAU,CAACkB,MAAM;YAC7C2E,YAAY,IAAIpI,OAAO4G,WAAW;QACpC;IACF;;aA3XQ3E,UAAgC,EAAE;aAClCG,oBAAoB;aACpBG,aAAa,IAAI8F;;AA0X3B;AAGO,MAAM1I,qBAAqB,IAAIC"}