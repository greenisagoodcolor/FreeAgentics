{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/rate-limit.ts"],"sourcesContent":["/**\n * Simple in-memory rate limiter\n * For production, use Redis or similar\n */\n\ninterface RateLimitOptions {\n  interval: number; // Time window in milliseconds\n  uniqueTokenPerInterval: number; // Max number of tokens\n}\n\ninterface RateLimitStore {\n  [key: string]: {\n    count: number;\n    resetTime: number;\n  };\n}\n\nclass RateLimiter {\n  private store: RateLimitStore = {};\n  private interval: number;\n  private limit: number;\n\n  constructor(options: RateLimitOptions) {\n    this.interval = options.interval;\n    this.limit = options.uniqueTokenPerInterval;\n  }\n\n  async check(tokens: number, identifier: string): Promise<void> {\n    const now = Date.now();\n    const record = this.store[identifier];\n\n    if (!record || now > record.resetTime) {\n      // Create new record or reset expired one\n      this.store[identifier] = {\n        count: tokens,\n        resetTime: now + this.interval,\n      };\n      return;\n    }\n\n    if (record.count + tokens > this.limit) {\n      const waitTime = record.resetTime - now;\n      throw new Error(\n        `Rate limit exceeded. Try again in ${Math.ceil(waitTime / 1000)} seconds.`,\n      );\n    }\n\n    record.count += tokens;\n  }\n\n  getRemainingTokens(identifier: string): number {\n    const now = Date.now();\n    const record = this.store[identifier];\n\n    if (!record || now > record.resetTime) {\n      return this.limit;\n    }\n\n    return Math.max(0, this.limit - record.count);\n  }\n\n  getResetTime(identifier: string): number {\n    const record = this.store[identifier];\n    return record ? record.resetTime : Date.now() + this.interval;\n  }\n\n  // Clean up expired entries periodically\n  cleanup(): void {\n    const now = Date.now();\n    for (const key in this.store) {\n      if (this.store[key] && this.store[key].resetTime < now) {\n        delete this.store[key];\n      }\n    }\n  }\n}\n\n// Factory function\nexport function rateLimit(options: RateLimitOptions): RateLimiter {\n  const limiter = new RateLimiter(options);\n\n  // Run cleanup every minute\n  setInterval(() => limiter.cleanup(), 60000);\n\n  return limiter;\n}\n\nexport type { RateLimiter, RateLimitOptions };\n"],"names":["rateLimit","RateLimiter","constructor","options","store","interval","limit","uniqueTokenPerInterval","check","tokens","identifier","now","Date","record","resetTime","count","waitTime","Error","Math","ceil","getRemainingTokens","max","getResetTime","cleanup","key","limiter","setInterval"],"mappings":"AAAA;;;CAGC;;;;+BA2EeA;;;eAAAA;;;AA7DhB,MAAMC;IAKJC,YAAYC,OAAyB,CAAE;aAJ/BC,QAAwB,CAAC;QAK/B,IAAI,CAACC,QAAQ,GAAGF,QAAQE,QAAQ;QAChC,IAAI,CAACC,KAAK,GAAGH,QAAQI,sBAAsB;IAC7C;IAEA,MAAMC,MAAMC,MAAc,EAAEC,UAAkB,EAAiB;QAC7D,MAAMC,MAAMC,KAAKD,GAAG;QACpB,MAAME,SAAS,IAAI,CAACT,KAAK,CAACM,WAAW;QAErC,IAAI,CAACG,UAAUF,MAAME,OAAOC,SAAS,EAAE;YACrC,yCAAyC;YACzC,IAAI,CAACV,KAAK,CAACM,WAAW,GAAG;gBACvBK,OAAON;gBACPK,WAAWH,MAAM,IAAI,CAACN,QAAQ;YAChC;YACA;QACF;QAEA,IAAIQ,OAAOE,KAAK,GAAGN,SAAS,IAAI,CAACH,KAAK,EAAE;YACtC,MAAMU,WAAWH,OAAOC,SAAS,GAAGH;YACpC,MAAM,IAAIM,MACR,CAAC,kCAAkC,EAAEC,KAAKC,IAAI,CAACH,WAAW,MAAM,SAAS,CAAC;QAE9E;QAEAH,OAAOE,KAAK,IAAIN;IAClB;IAEAW,mBAAmBV,UAAkB,EAAU;QAC7C,MAAMC,MAAMC,KAAKD,GAAG;QACpB,MAAME,SAAS,IAAI,CAACT,KAAK,CAACM,WAAW;QAErC,IAAI,CAACG,UAAUF,MAAME,OAAOC,SAAS,EAAE;YACrC,OAAO,IAAI,CAACR,KAAK;QACnB;QAEA,OAAOY,KAAKG,GAAG,CAAC,GAAG,IAAI,CAACf,KAAK,GAAGO,OAAOE,KAAK;IAC9C;IAEAO,aAAaZ,UAAkB,EAAU;QACvC,MAAMG,SAAS,IAAI,CAACT,KAAK,CAACM,WAAW;QACrC,OAAOG,SAASA,OAAOC,SAAS,GAAGF,KAAKD,GAAG,KAAK,IAAI,CAACN,QAAQ;IAC/D;IAEA,wCAAwC;IACxCkB,UAAgB;QACd,MAAMZ,MAAMC,KAAKD,GAAG;QACpB,IAAK,MAAMa,OAAO,IAAI,CAACpB,KAAK,CAAE;YAC5B,IAAI,IAAI,CAACA,KAAK,CAACoB,IAAI,IAAI,IAAI,CAACpB,KAAK,CAACoB,IAAI,CAACV,SAAS,GAAGH,KAAK;gBACtD,OAAO,IAAI,CAACP,KAAK,CAACoB,IAAI;YACxB;QACF;IACF;AACF;AAGO,SAASxB,UAAUG,OAAyB;IACjD,MAAMsB,UAAU,IAAIxB,YAAYE;IAEhC,2BAA2B;IAC3BuB,YAAY,IAAMD,QAAQF,OAAO,IAAI;IAErC,OAAOE;AACT"}