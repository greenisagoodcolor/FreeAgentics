f3e078a1fb24a2633f814ca7e25b0a92
/**
 * Comprehensive tests for lib modules to increase coverage
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _utils = require("../lib/utils");
const _encryption = require("../lib/encryption");
const _llmclient = require("../lib/llm-client");
const _llmerrors = require("../lib/llm-errors");
const _security = require("../lib/security");
const _datavalidationstorage = require("../lib/storage/data-validation-storage");
const _api = /*#__PURE__*/ _interop_require_wildcard(require("../lib/api"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock fetch
global.fetch = jest.fn();
describe("Lib Modules Comprehensive Coverage", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe("Utils", ()=>{
        test("cn combines classnames correctly", ()=>{
            expect((0, _utils.cn)("a", "b")).toBe("a b");
            expect((0, _utils.cn)("a", null, "b")).toBe("a b");
            expect((0, _utils.cn)("a", undefined, "b")).toBe("a b");
            expect((0, _utils.cn)()).toBe("");
        });
        test("extractTagsFromMarkdown works", ()=>{
            const markdown = "# Title\n\nContent with #tag1 and #tag2";
            const tags = (0, _utils.extractTagsFromMarkdown)(markdown);
            expect(tags).toContain("tag1");
            expect(tags).toContain("tag2");
        });
        test("formatTimestamp formats dates", ()=>{
            const date = new Date("2024-01-01T12:00:00Z");
            const formatted = (0, _utils.formatTimestamp)(date);
            expect(formatted).toContain("2024");
        });
    });
    describe("Encryption", ()=>{
        test("encrypt and decrypt work together", async ()=>{
            const text = "secret message";
            const encrypted = await (0, _encryption.encrypt)(text);
            expect(encrypted).not.toBe(text);
            const decrypted = await (0, _encryption.decrypt)(encrypted);
            expect(decrypted).toBe(text);
        });
        test("handles empty strings", async ()=>{
            const encrypted = await (0, _encryption.encrypt)("");
            expect(encrypted).toBe("");
            const decrypted = await (0, _encryption.decrypt)("");
            expect(decrypted).toBe("");
        });
    });
    describe("LLM Client", ()=>{
        test("creates client with config", ()=>{
            const client = new _llmclient.LLMClient({
                provider: "openai",
                apiKey: "test-key"
            });
            expect(client.provider).toBe("openai");
        });
        test("sends chat messages", async ()=>{
            const client = new _llmclient.LLMClient({
                provider: "openai",
                apiKey: "test-key"
            });
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        choices: [
                            {
                                message: {
                                    content: "Response"
                                }
                            }
                        ]
                    })
            });
            const response = await client.chat([
                {
                    role: "user",
                    content: "Hello"
                }
            ]);
            expect(response).toBe("Response");
        });
        test("handles errors correctly", async ()=>{
            const client = new _llmclient.LLMClient({
                provider: "openai",
                apiKey: "test-key"
            });
            global.fetch.mockResolvedValueOnce({
                ok: false,
                status: 429,
                statusText: "Rate Limited"
            });
            await expect(client.chat([
                {
                    role: "user",
                    content: "Hello"
                }
            ])).rejects.toThrow(_llmerrors.RateLimitError);
        });
    });
    describe("Security", ()=>{
        test("validates input", ()=>{
            expect((0, _security.validateInput)("safe input")).toBe(true);
            expect((0, _security.validateInput)('<script>alert("xss")</script>')).toBe(false);
            expect((0, _security.validateInput)("")).toBe(false);
        });
        test("sanitizes output", ()=>{
            expect((0, _security.sanitizeOutput)("normal text")).toBe("normal text");
            expect((0, _security.sanitizeOutput)("<script>bad</script>")).toBe("");
            expect((0, _security.sanitizeOutput)("text with <b>html</b>")).toBe("text with html");
        });
        test("checks permissions", ()=>{
            expect((0, _security.checkPermissions)("read", {
                role: "admin"
            })).toBe(true);
            expect((0, _security.checkPermissions)("write", {
                role: "viewer"
            })).toBe(false);
            expect((0, _security.checkPermissions)("delete", {
                role: "editor"
            })).toBe(false);
        });
    });
    describe("Data Validation Storage", ()=>{
        test("creates storage instance", ()=>{
            const storage = new _datavalidationstorage.DataValidationStorage("test-db");
            expect(storage).toBeDefined();
            expect(storage.dbName).toBe("test-db");
        });
        test("validates data before storage", ()=>{
            const storage = new _datavalidationstorage.DataValidationStorage("test-db");
            expect(storage.isValid({
                id: 1,
                name: "test"
            })).toBe(true);
            expect(storage.isValid(null)).toBe(false);
            expect(storage.isValid(undefined)).toBe(false);
            expect(storage.isValid("")).toBe(false);
        });
        test("stores and retrieves data", async ()=>{
            const storage = new _datavalidationstorage.DataValidationStorage("test-db");
            const data = {
                id: 1,
                name: "test item"
            };
            await storage.store("items", data);
            const retrieved = await storage.get("items", 1);
            expect(retrieved).toEqual(data);
        });
    });
    describe("API Client", ()=>{
        test("makes API calls", async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: "result"
                    })
            });
            const result = await _api.apiClient.get("/test");
            expect(result.data).toBe("result");
        });
        test("handles API errors", async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: false,
                status: 500,
                statusText: "Internal Server Error"
            });
            await expect(_api.apiClient.get("/test")).rejects.toThrow("API Error: 500");
        });
        test("includes auth headers", async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            });
            await _api.apiClient.post("/test", {
                data: "test"
            }, {
                headers: {
                    Authorization: "Bearer token"
                }
            });
            expect(global.fetch).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                headers: expect.objectContaining({
                    Authorization: "Bearer token"
                })
            }));
        });
    });
    describe("Error Handling", ()=>{
        test("LLMError has correct properties", ()=>{
            const error = new _llmerrors.LLMError("Test error", "TEST_CODE");
            expect(error.message).toBe("Test error");
            expect(error.code).toBe("TEST_CODE");
            expect(error.name).toBe("LLMError");
        });
        test("RateLimitError extends LLMError", ()=>{
            const error = new _llmerrors.RateLimitError("Too many requests");
            expect(error).toBeInstanceOf(_llmerrors.LLMError);
            expect(error.code).toBe("RATE_LIMIT");
        });
        test("AuthenticationError extends LLMError", ()=>{
            const error = new _llmerrors.AuthenticationError("Invalid API key");
            expect(error).toBeInstanceOf(_llmerrors.LLMError);
            expect(error.code).toBe("AUTH_ERROR");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vY292ZXJhZ2UtbGliLW1vZHVsZXMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbXByZWhlbnNpdmUgdGVzdHMgZm9yIGxpYiBtb2R1bGVzIHRvIGluY3JlYXNlIGNvdmVyYWdlXG4gKi9cblxuaW1wb3J0IHsgY24sIGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duLCBmb3JtYXRUaW1lc3RhbXAgfSBmcm9tIFwiQC9saWIvdXRpbHNcIjtcbmltcG9ydCB7IGVuY3J5cHQsIGRlY3J5cHQgfSBmcm9tIFwiQC9saWIvZW5jcnlwdGlvblwiO1xuaW1wb3J0IHsgTExNQ2xpZW50IH0gZnJvbSBcIkAvbGliL2xsbS1jbGllbnRcIjtcbmltcG9ydCB7XG4gIExMTUVycm9yLFxuICBSYXRlTGltaXRFcnJvcixcbiAgQXV0aGVudGljYXRpb25FcnJvcixcbn0gZnJvbSBcIkAvbGliL2xsbS1lcnJvcnNcIjtcbmltcG9ydCB7XG4gIHZhbGlkYXRlSW5wdXQsXG4gIHNhbml0aXplT3V0cHV0LFxuICBjaGVja1Blcm1pc3Npb25zLFxufSBmcm9tIFwiQC9saWIvc2VjdXJpdHlcIjtcbmltcG9ydCB7IERhdGFWYWxpZGF0aW9uU3RvcmFnZSB9IGZyb20gXCJAL2xpYi9zdG9yYWdlL2RhdGEtdmFsaWRhdGlvbi1zdG9yYWdlXCI7XG5pbXBvcnQgKiBhcyBhcGkgZnJvbSBcIkAvbGliL2FwaVwiO1xuXG4vLyBNb2NrIGZldGNoXG5nbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCk7XG5cbmRlc2NyaWJlKFwiTGliIE1vZHVsZXMgQ29tcHJlaGVuc2l2ZSBDb3ZlcmFnZVwiLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZShcIlV0aWxzXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiY24gY29tYmluZXMgY2xhc3NuYW1lcyBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGNuKFwiYVwiLCBcImJcIikpLnRvQmUoXCJhIGJcIik7XG4gICAgICBleHBlY3QoY24oXCJhXCIsIG51bGwsIFwiYlwiKSkudG9CZShcImEgYlwiKTtcbiAgICAgIGV4cGVjdChjbihcImFcIiwgdW5kZWZpbmVkLCBcImJcIikpLnRvQmUoXCJhIGJcIik7XG4gICAgICBleHBlY3QoY24oKSkudG9CZShcIlwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJleHRyYWN0VGFnc0Zyb21NYXJrZG93biB3b3Jrc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYXJrZG93biA9IFwiIyBUaXRsZVxcblxcbkNvbnRlbnQgd2l0aCAjdGFnMSBhbmQgI3RhZzJcIjtcbiAgICAgIGNvbnN0IHRhZ3MgPSBleHRyYWN0VGFnc0Zyb21NYXJrZG93bihtYXJrZG93bik7XG4gICAgICBleHBlY3QodGFncykudG9Db250YWluKFwidGFnMVwiKTtcbiAgICAgIGV4cGVjdCh0YWdzKS50b0NvbnRhaW4oXCJ0YWcyXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImZvcm1hdFRpbWVzdGFtcCBmb3JtYXRzIGRhdGVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShcIjIwMjQtMDEtMDFUMTI6MDA6MDBaXCIpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0VGltZXN0YW1wKGRhdGUpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9Db250YWluKFwiMjAyNFwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFbmNyeXB0aW9uXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiZW5jcnlwdCBhbmQgZGVjcnlwdCB3b3JrIHRvZ2V0aGVyXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBcInNlY3JldCBtZXNzYWdlXCI7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBlbmNyeXB0KHRleHQpO1xuICAgICAgZXhwZWN0KGVuY3J5cHRlZCkubm90LnRvQmUodGV4dCk7XG5cbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGRlY3J5cHQoZW5jcnlwdGVkKTtcbiAgICAgIGV4cGVjdChkZWNyeXB0ZWQpLnRvQmUodGV4dCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlbXB0eSBzdHJpbmdzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IGVuY3J5cHQoXCJcIik7XG4gICAgICBleHBlY3QoZW5jcnlwdGVkKS50b0JlKFwiXCIpO1xuXG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBkZWNyeXB0KFwiXCIpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZCkudG9CZShcIlwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJMTE0gQ2xpZW50XCIsICgpID0+IHtcbiAgICB0ZXN0KFwiY3JlYXRlcyBjbGllbnQgd2l0aCBjb25maWdcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgY2xpZW50ID0gbmV3IExMTUNsaWVudCh7IHByb3ZpZGVyOiBcIm9wZW5haVwiLCBhcGlLZXk6IFwidGVzdC1rZXlcIiB9KTtcbiAgICAgIGV4cGVjdChjbGllbnQucHJvdmlkZXIpLnRvQmUoXCJvcGVuYWlcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2VuZHMgY2hhdCBtZXNzYWdlc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnQgPSBuZXcgTExNQ2xpZW50KHsgcHJvdmlkZXI6IFwib3BlbmFpXCIsIGFwaUtleTogXCJ0ZXN0LWtleVwiIH0pO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgY2hvaWNlczogW3sgbWVzc2FnZTogeyBjb250ZW50OiBcIlJlc3BvbnNlXCIgfSB9XSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuY2hhdChbeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogXCJIZWxsb1wiIH1dKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlKS50b0JlKFwiUmVzcG9uc2VcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlcnJvcnMgY29ycmVjdGx5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBMTE1DbGllbnQoeyBwcm92aWRlcjogXCJvcGVuYWlcIiwgYXBpS2V5OiBcInRlc3Qta2V5XCIgfSk7XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHN0YXR1czogNDI5LFxuICAgICAgICBzdGF0dXNUZXh0OiBcIlJhdGUgTGltaXRlZFwiLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgY2xpZW50LmNoYXQoW3sgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IFwiSGVsbG9cIiB9XSksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhSYXRlTGltaXRFcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiU2VjdXJpdHlcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJ2YWxpZGF0ZXMgaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KHZhbGlkYXRlSW5wdXQoXCJzYWZlIGlucHV0XCIpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRlSW5wdXQoJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD4nKSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGVJbnB1dChcIlwiKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2FuaXRpemVzIG91dHB1dFwiLCAoKSA9PiB7XG4gICAgICBleHBlY3Qoc2FuaXRpemVPdXRwdXQoXCJub3JtYWwgdGV4dFwiKSkudG9CZShcIm5vcm1hbCB0ZXh0XCIpO1xuICAgICAgZXhwZWN0KHNhbml0aXplT3V0cHV0KFwiPHNjcmlwdD5iYWQ8L3NjcmlwdD5cIikpLnRvQmUoXCJcIik7XG4gICAgICBleHBlY3Qoc2FuaXRpemVPdXRwdXQoXCJ0ZXh0IHdpdGggPGI+aHRtbDwvYj5cIikpLnRvQmUoXCJ0ZXh0IHdpdGggaHRtbFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJjaGVja3MgcGVybWlzc2lvbnNcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGNoZWNrUGVybWlzc2lvbnMoXCJyZWFkXCIsIHsgcm9sZTogXCJhZG1pblwiIH0pKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGNoZWNrUGVybWlzc2lvbnMoXCJ3cml0ZVwiLCB7IHJvbGU6IFwidmlld2VyXCIgfSkpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGNoZWNrUGVybWlzc2lvbnMoXCJkZWxldGVcIiwgeyByb2xlOiBcImVkaXRvclwiIH0pKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJEYXRhIFZhbGlkYXRpb24gU3RvcmFnZVwiLCAoKSA9PiB7XG4gICAgdGVzdChcImNyZWF0ZXMgc3RvcmFnZSBpbnN0YW5jZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gbmV3IERhdGFWYWxpZGF0aW9uU3RvcmFnZShcInRlc3QtZGJcIik7XG4gICAgICBleHBlY3Qoc3RvcmFnZSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzdG9yYWdlLmRiTmFtZSkudG9CZShcInRlc3QtZGJcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwidmFsaWRhdGVzIGRhdGEgYmVmb3JlIHN0b3JhZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IG5ldyBEYXRhVmFsaWRhdGlvblN0b3JhZ2UoXCJ0ZXN0LWRiXCIpO1xuXG4gICAgICBleHBlY3Qoc3RvcmFnZS5pc1ZhbGlkKHsgaWQ6IDEsIG5hbWU6IFwidGVzdFwiIH0pKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHN0b3JhZ2UuaXNWYWxpZChudWxsKSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3Qoc3RvcmFnZS5pc1ZhbGlkKHVuZGVmaW5lZCkpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHN0b3JhZ2UuaXNWYWxpZChcIlwiKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic3RvcmVzIGFuZCByZXRyaWV2ZXMgZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gbmV3IERhdGFWYWxpZGF0aW9uU3RvcmFnZShcInRlc3QtZGJcIik7XG4gICAgICBjb25zdCBkYXRhID0geyBpZDogMSwgbmFtZTogXCJ0ZXN0IGl0ZW1cIiB9O1xuXG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKFwiaXRlbXNcIiwgZGF0YSk7XG4gICAgICBjb25zdCByZXRyaWV2ZWQgPSBhd2FpdCBzdG9yYWdlLmdldChcIml0ZW1zXCIsIDEpO1xuXG4gICAgICBleHBlY3QocmV0cmlldmVkKS50b0VxdWFsKGRhdGEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkFQSSBDbGllbnRcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJtYWtlcyBBUEkgY2FsbHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBcInJlc3VsdFwiIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaS5hcGlDbGllbnQuZ2V0KFwiL3Rlc3RcIik7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQmUoXCJyZXN1bHRcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBBUEkgZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICBzdGF0dXNUZXh0OiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChhcGkuYXBpQ2xpZW50LmdldChcIi90ZXN0XCIpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiQVBJIEVycm9yOiA1MDBcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaW5jbHVkZXMgYXV0aCBoZWFkZXJzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBhcGkuYXBpQ2xpZW50LnBvc3QoXG4gICAgICAgIFwiL3Rlc3RcIixcbiAgICAgICAgeyBkYXRhOiBcInRlc3RcIiB9LFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogeyBBdXRob3JpemF0aW9uOiBcIkJlYXJlciB0b2tlblwiIH0sXG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoZ2xvYmFsLmZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgaGVhZGVyczogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogXCJCZWFyZXIgdG9rZW5cIixcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkVycm9yIEhhbmRsaW5nXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiTExNRXJyb3IgaGFzIGNvcnJlY3QgcHJvcGVydGllc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBMTE1FcnJvcihcIlRlc3QgZXJyb3JcIiwgXCJURVNUX0NPREVcIik7XG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9CZShcIlRlc3QgZXJyb3JcIik7XG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZShcIlRFU1RfQ09ERVwiKTtcbiAgICAgIGV4cGVjdChlcnJvci5uYW1lKS50b0JlKFwiTExNRXJyb3JcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiUmF0ZUxpbWl0RXJyb3IgZXh0ZW5kcyBMTE1FcnJvclwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBSYXRlTGltaXRFcnJvcihcIlRvbyBtYW55IHJlcXVlc3RzXCIpO1xuICAgICAgZXhwZWN0KGVycm9yKS50b0JlSW5zdGFuY2VPZihMTE1FcnJvcik7XG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZShcIlJBVEVfTElNSVRcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIExMTUVycm9yXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJJbnZhbGlkIEFQSSBrZXlcIik7XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVJbnN0YW5jZU9mKExMTUVycm9yKTtcbiAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKFwiQVVUSF9FUlJPUlwiKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmZXRjaCIsImplc3QiLCJmbiIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ0ZXN0IiwiZXhwZWN0IiwiY24iLCJ0b0JlIiwidW5kZWZpbmVkIiwibWFya2Rvd24iLCJ0YWdzIiwiZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24iLCJ0b0NvbnRhaW4iLCJkYXRlIiwiRGF0ZSIsImZvcm1hdHRlZCIsImZvcm1hdFRpbWVzdGFtcCIsInRleHQiLCJlbmNyeXB0ZWQiLCJlbmNyeXB0Iiwibm90IiwiZGVjcnlwdGVkIiwiZGVjcnlwdCIsImNsaWVudCIsIkxMTUNsaWVudCIsInByb3ZpZGVyIiwiYXBpS2V5IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJqc29uIiwiY2hvaWNlcyIsIm1lc3NhZ2UiLCJjb250ZW50IiwicmVzcG9uc2UiLCJjaGF0Iiwicm9sZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJyZWplY3RzIiwidG9UaHJvdyIsIlJhdGVMaW1pdEVycm9yIiwidmFsaWRhdGVJbnB1dCIsInNhbml0aXplT3V0cHV0IiwiY2hlY2tQZXJtaXNzaW9ucyIsInN0b3JhZ2UiLCJEYXRhVmFsaWRhdGlvblN0b3JhZ2UiLCJ0b0JlRGVmaW5lZCIsImRiTmFtZSIsImlzVmFsaWQiLCJpZCIsIm5hbWUiLCJkYXRhIiwic3RvcmUiLCJyZXRyaWV2ZWQiLCJnZXQiLCJ0b0VxdWFsIiwic3VjY2VzcyIsInJlc3VsdCIsImFwaSIsImFwaUNsaWVudCIsInBvc3QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiYW55IiwiU3RyaW5nIiwib2JqZWN0Q29udGFpbmluZyIsImVycm9yIiwiTExNRXJyb3IiLCJjb2RlIiwidG9CZUluc3RhbmNlT2YiLCJBdXRoZW50aWNhdGlvbkVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7Ozt1QkFFNEQ7NEJBQzVCOzJCQUNQOzJC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