7cfbcba1faab283d046d51f649792891
/**
 * Active Inference Tests
 *
 * Tests for active inference, free energy minimization, and belief updating
 * following ADR-007 comprehensive testing requirements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _activeinference = require("../../lib/active-inference");
describe("Active Inference Engine", ()=>{
    let engine;
    let testModel;
    beforeEach(()=>{
        testModel = {
            states: [
                "exploring",
                "exploiting",
                "resting"
            ],
            observations: [
                "high_reward",
                "low_reward",
                "no_reward"
            ],
            actions: [
                "move_forward",
                "turn",
                "wait"
            ],
            // Transition dynamics P(s'|s,a)
            transitionModel: {
                exploring: {
                    move_forward: {
                        exploring: 0.7,
                        exploiting: 0.2,
                        resting: 0.1
                    },
                    turn: {
                        exploring: 0.8,
                        exploiting: 0.1,
                        resting: 0.1
                    },
                    wait: {
                        exploring: 0.3,
                        exploiting: 0.1,
                        resting: 0.6
                    }
                },
                exploiting: {
                    move_forward: {
                        exploring: 0.1,
                        exploiting: 0.8,
                        resting: 0.1
                    },
                    turn: {
                        exploring: 0.3,
                        exploiting: 0.6,
                        resting: 0.1
                    },
                    wait: {
                        exploring: 0.1,
                        exploiting: 0.3,
                        resting: 0.6
                    }
                },
                resting: {
                    move_forward: {
                        exploring: 0.6,
                        exploiting: 0.3,
                        resting: 0.1
                    },
                    turn: {
                        exploring: 0.4,
                        exploiting: 0.2,
                        resting: 0.4
                    },
                    wait: {
                        exploring: 0.1,
                        exploiting: 0.1,
                        resting: 0.8
                    }
                }
            },
            // Observation model P(o|s)
            observationModel: {
                exploring: {
                    high_reward: 0.3,
                    low_reward: 0.5,
                    no_reward: 0.2
                },
                exploiting: {
                    high_reward: 0.7,
                    low_reward: 0.2,
                    no_reward: 0.1
                },
                resting: {
                    high_reward: 0.1,
                    low_reward: 0.2,
                    no_reward: 0.7
                }
            },
            // Prior preferences (negative log probabilities)
            preferences: {
                high_reward: -2.0,
                low_reward: -0.5,
                no_reward: 0.5
            }
        };
        engine = (0, _activeinference.createActiveInferenceEngine)({
            model: testModel,
            precision: 1.0,
            learningRate: 0.1,
            planningHorizon: 3
        });
    });
    describe("Engine Creation and Configuration", ()=>{
        it("creates engine with valid configuration", ()=>{
            expect(engine).toMatchObject({
                model: testModel,
                precision: 1.0,
                learningRate: 0.1,
                planningHorizon: 3
            });
        });
        it("initializes with uniform beliefs", ()=>{
            const beliefs = engine.getCurrentBeliefs();
            const stateProbs = Object.values(beliefs.states);
            expect(Math.abs(stateProbs.reduce((sum, p)=>sum + p, 0) - 1.0)).toBeLessThan(0.001);
            stateProbs.forEach((p)=>{
                expect(p).toBeCloseTo(1.0 / testModel.states.length, 5);
            });
        });
        it("validates model structure", ()=>{
            const invalidModel = {
                ...testModel,
                transitionModel: {}
            };
            expect(()=>{
                (0, _activeinference.createActiveInferenceEngine)({
                    model: invalidModel
                });
            }).toThrow("Invalid generative model");
        });
    });
    describe("Belief Updates", ()=>{
        it("updates beliefs based on observations", ()=>{
            const initialBeliefs = engine.getCurrentBeliefs();
            const observation = {
                type: "observation",
                value: "high_reward",
                confidence: 0.9
            };
            const updatedBeliefs = (0, _activeinference.updateBeliefs)(engine, observation);
            // Should increase belief in exploiting state (high reward association)
            expect(updatedBeliefs.states.exploiting).toBeGreaterThan(initialBeliefs.states.exploiting);
        });
        it("incorporates observation confidence", ()=>{
            const highConfObs = {
                type: "observation",
                value: "high_reward",
                confidence: 0.95
            };
            const lowConfObs = {
                type: "observation",
                value: "high_reward",
                confidence: 0.3
            };
            const highConfBeliefs = (0, _activeinference.updateBeliefs)(engine, highConfObs);
            const lowConfBeliefs = (0, _activeinference.updateBeliefs)(engine, lowConfObs);
            // High confidence should lead to stronger belief updates
            const highConfChange = Math.abs(highConfBeliefs.states.exploiting - 1 / 3);
            const lowConfChange = Math.abs(lowConfBeliefs.states.exploiting - 1 / 3);
            expect(highConfChange).toBeGreaterThan(lowConfChange);
        });
        it("maintains probability normalization", ()=>{
            const observations = [
                {
                    type: "observation",
                    value: "high_reward",
                    confidence: 0.8
                },
                {
                    type: "observation",
                    value: "low_reward",
                    confidence: 0.7
                },
                {
                    type: "observation",
                    value: "no_reward",
                    confidence: 0.9
                }
            ];
            observations.forEach((obs)=>{
                const beliefs = (0, _activeinference.updateBeliefs)(engine, obs);
                const sum = Object.values(beliefs.states).reduce((s, p)=>s + p, 0);
                expect(sum).toBeCloseTo(1.0, 5);
            });
        });
    });
    describe("Free Energy Calculations", ()=>{
        it("calculates variational free energy", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.6,
                    exploiting: 0.3,
                    resting: 0.1
                },
                uncertainty: 0.2
            };
            const observation = "high_reward";
            const freeEnergy = engine.calculateFreeEnergy(beliefs, observation);
            expect(freeEnergy).toBeGreaterThan(0);
            expect(Number.isFinite(freeEnergy)).toBe(true);
        });
        it("increases with prediction error", ()=>{
            // Belief state that predicts low rewards
            const pessimisticBeliefs = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.1,
                    resting: 0.8
                },
                uncertainty: 0.1
            };
            // But observes high reward
            const observation = "high_reward";
            const highError = engine.calculateFreeEnergy(pessimisticBeliefs, observation);
            // Belief state that predicts high rewards
            const optimisticBeliefs = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.8,
                    resting: 0.1
                },
                uncertainty: 0.1
            };
            const lowError = engine.calculateFreeEnergy(optimisticBeliefs, observation);
            expect(highError).toBeGreaterThan(lowError);
        });
        it("includes entropy/uncertainty term", ()=>{
            const certainBeliefs = {
                states: {
                    exploring: 0.98,
                    exploiting: 0.01,
                    resting: 0.01
                },
                uncertainty: 0.01
            };
            const uncertainBeliefs = {
                states: {
                    exploring: 0.34,
                    exploiting: 0.33,
                    resting: 0.33
                },
                uncertainty: 0.8
            };
            const observation = "low_reward";
            const certainFE = engine.calculateFreeEnergy(certainBeliefs, observation);
            const uncertainFE = engine.calculateFreeEnergy(uncertainBeliefs, observation);
            // Higher uncertainty should contribute to free energy
            expect(Math.abs(certainFE - uncertainFE)).toBeGreaterThan(0.1);
        });
    });
    describe("Expected Free Energy", ()=>{
        it("calculates expected free energy for policies", ()=>{
            const policy = [
                {
                    action: "move_forward",
                    timestep: 0
                },
                {
                    action: "turn",
                    timestep: 1
                },
                {
                    action: "wait",
                    timestep: 2
                }
            ];
            const efe = (0, _activeinference.calculateExpectedFreeEnergy)(engine, policy);
            expect(Number.isFinite(efe)).toBe(true);
            expect(efe).toHaveProperty("total");
            expect(efe).toHaveProperty("epistemic");
            expect(efe).toHaveProperty("pragmatic");
        });
        it("balances epistemic and pragmatic value", ()=>{
            const exploratoryPolicy = [
                {
                    action: "turn",
                    timestep: 0
                },
                {
                    action: "move_forward",
                    timestep: 1
                }
            ];
            const exploitativePolicy = [
                {
                    action: "wait",
                    timestep: 0
                },
                {
                    action: "wait",
                    timestep: 1
                }
            ];
            const exploratory = (0, _activeinference.calculateExpectedFreeEnergy)(engine, exploratoryPolicy);
            const exploitative = (0, _activeinference.calculateExpectedFreeEnergy)(engine, exploitativePolicy);
            expect(exploratory.epistemic).toBeLessThan(exploitative.epistemic);
        });
        it("considers future outcomes", ()=>{
            const shortPolicy = [
                {
                    action: "move_forward",
                    timestep: 0
                }
            ];
            const longPolicy = [
                {
                    action: "move_forward",
                    timestep: 0
                },
                {
                    action: "move_forward",
                    timestep: 1
                },
                {
                    action: "move_forward",
                    timestep: 2
                }
            ];
            const shortEFE = (0, _activeinference.calculateExpectedFreeEnergy)(engine, shortPolicy);
            const longEFE = (0, _activeinference.calculateExpectedFreeEnergy)(engine, longPolicy);
            // Longer horizon should affect total expected free energy
            expect(shortEFE.total).not.toBe(longEFE.total);
        });
    });
    describe("Action Selection", ()=>{
        it("selects actions that minimize expected free energy", ()=>{
            const currentBeliefs = {
                states: {
                    exploring: 0.7,
                    exploiting: 0.2,
                    resting: 0.1
                },
                uncertainty: 0.3
            };
            const selectedAction = (0, _activeinference.selectAction)(engine, currentBeliefs);
            expect(testModel.actions).toContain(selectedAction.type);
            expect(selectedAction.confidence).toBeGreaterThan(0);
            expect(selectedAction.confidence).toBeLessThanOrEqual(1);
        });
        it("increases exploration under high uncertainty", ()=>{
            const lowUncertainty = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.8,
                    resting: 0.1
                },
                uncertainty: 0.1
            };
            const highUncertainty = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.8,
                    resting: 0.1
                },
                uncertainty: 0.8
            };
            const lowUncAction = (0, _activeinference.selectAction)(engine, lowUncertainty);
            const highUncAction = (0, _activeinference.selectAction)(engine, highUncertainty);
            // High uncertainty should favor exploratory actions
            expect(highUncAction.type).not.toBe("wait");
        });
        it("respects action constraints", ()=>{
            const constrainedEngine = (0, _activeinference.createActiveInferenceEngine)({
                model: testModel,
                actionConstraints: {
                    wait: {
                        maxFrequency: 0.3
                    }
                }
            });
            const actions = [];
            for(let i = 0; i < 100; i++){
                const action = (0, _activeinference.selectAction)(constrainedEngine, engine.getCurrentBeliefs());
                actions.push(action.type);
            }
            const waitFrequency = actions.filter((a)=>a === "wait").length / actions.length;
            expect(waitFrequency).toBeLessThanOrEqual(0.35); // Allow small variance
        });
    });
    describe("Inference Process", ()=>{
        it("performs complete inference cycle", async ()=>{
            const observation = {
                type: "observation",
                value: "high_reward",
                confidence: 0.9
            };
            const result = await (0, _activeinference.performInference)(engine, observation);
            expect(result).toHaveProperty("beliefs");
            expect(result).toHaveProperty("selectedAction");
            expect(result).toHaveProperty("freeEnergy");
            expect(result).toHaveProperty("confidence");
        });
        it("adapts to changing observations", async ()=>{
            const observations = [
                {
                    type: "observation",
                    value: "no_reward",
                    confidence: 0.9
                },
                {
                    type: "observation",
                    value: "low_reward",
                    confidence: 0.8
                },
                {
                    type: "observation",
                    value: "high_reward",
                    confidence: 0.95
                }
            ];
            const results = [];
            for (const obs of observations){
                const result = await (0, _activeinference.performInference)(engine, obs);
                results.push(result);
            }
            // Should adapt behavior based on observation history
            expect(results[0].selectedAction.type).not.toBe(results[2].selectedAction.type);
        });
        it("maintains computational efficiency", async ()=>{
            const startTime = Date.now();
            const iterations = 100;
            for(let i = 0; i < iterations; i++){
                const obs = {
                    type: "observation",
                    value: [
                        "high_reward",
                        "low_reward",
                        "no_reward"
                    ][i % 3],
                    confidence: 0.8
                };
                await (0, _activeinference.performInference)(engine, obs);
            }
            const totalTime = Date.now() - startTime;
            const avgTime = totalTime / iterations;
            expect(avgTime).toBeLessThan(10); // Should be fast (< 10ms per inference)
        });
    });
    describe("Epistemic and Pragmatic Value", ()=>{
        it("calculates epistemic value (information gain)", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.5,
                    exploiting: 0.3,
                    resting: 0.2
                },
                uncertainty: 0.4
            };
            const action = "move_forward";
            const epistemicValue = (0, _activeinference.calculateEpistemic)(engine, beliefs, action);
            expect(epistemicValue).toBeGreaterThanOrEqual(0);
            expect(Number.isFinite(epistemicValue)).toBe(true);
        });
        it("calculates pragmatic value (goal achievement)", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.2,
                    exploiting: 0.7,
                    resting: 0.1
                },
                uncertainty: 0.2
            };
            const action = "move_forward";
            const pragmaticValue = (0, _activeinference.calculatePragmatic)(engine, beliefs, action);
            expect(Number.isFinite(pragmaticValue)).toBe(true);
        // Should be negative (lower is better) for good actions
        });
        it("trades off exploration vs exploitation", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.4,
                    exploiting: 0.4,
                    resting: 0.2
                },
                uncertainty: 0.5
            };
            const explore = (0, _activeinference.calculateEpistemic)(engine, beliefs, "turn");
            const exploit = (0, _activeinference.calculatePragmatic)(engine, beliefs, "wait");
            // Both values should influence decision
            expect(explore).toBeGreaterThan(0);
            expect(Math.abs(exploit)).toBeGreaterThan(0);
        });
    });
    describe("Variational Free Energy Minimization", ()=>{
        it("minimizes free energy through gradient descent", async ()=>{
            const initialBeliefs = {
                states: {
                    exploring: 0.6,
                    exploiting: 0.2,
                    resting: 0.2
                },
                uncertainty: 0.5
            };
            const observation = "high_reward";
            const initialFE = engine.calculateFreeEnergy(initialBeliefs, observation);
            const optimized = await (0, _activeinference.minimizeVariationalFreeEnergy)(engine, initialBeliefs, observation, {
                maxIterations: 50
            });
            const finalFE = engine.calculateFreeEnergy(optimized, observation);
            expect(finalFE).toBeLessThan(initialFE);
        });
        it("converges to stable solution", async ()=>{
            const beliefs = {
                states: {
                    exploring: 0.33,
                    exploiting: 0.33,
                    resting: 0.34
                },
                uncertainty: 0.3
            };
            const observation = "low_reward";
            const optimized = await (0, _activeinference.minimizeVariationalFreeEnergy)(engine, beliefs, observation, {
                maxIterations: 100,
                tolerance: 0.001
            });
            // Should converge to stable beliefs
            expect(optimized.converged).toBe(true);
            expect(optimized.iterations).toBeLessThan(100);
        });
    });
    describe("Predictive Processing", ()=>{
        it("predicts future sensory outcomes", ()=>{
            const currentBeliefs = {
                states: {
                    exploring: 0.7,
                    exploiting: 0.2,
                    resting: 0.1
                },
                uncertainty: 0.2
            };
            const action = "move_forward";
            const predictions = (0, _activeinference.predictSensoryOutcomes)(engine, currentBeliefs, action);
            expect(predictions).toHaveProperty("high_reward");
            expect(predictions).toHaveProperty("low_reward");
            expect(predictions).toHaveProperty("no_reward");
            const totalProb = Object.values(predictions).reduce((sum, p)=>sum + p, 0);
            expect(totalProb).toBeCloseTo(1.0, 5);
        });
        it("updates predictions based on actions", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.8,
                    resting: 0.1
                },
                uncertainty: 0.1
            };
            const movePredict = (0, _activeinference.predictSensoryOutcomes)(engine, beliefs, "move_forward");
            const waitPredict = (0, _activeinference.predictSensoryOutcomes)(engine, beliefs, "wait");
            // Different actions should lead to different predictions
            expect(movePredict.high_reward).not.toBe(waitPredict.high_reward);
        });
    });
    describe("Policy Evaluation", ()=>{
        it("evaluates action sequences", ()=>{
            const policy = [
                {
                    action: "move_forward",
                    timestep: 0
                },
                {
                    action: "move_forward",
                    timestep: 1
                },
                {
                    action: "turn",
                    timestep: 2
                }
            ];
            const evaluation = (0, _activeinference.evaluateActionPolicy)(engine, policy);
            expect(evaluation).toHaveProperty("expectedReturn");
            expect(evaluation).toHaveProperty("uncertainty");
            expect(evaluation).toHaveProperty("feasibility");
        });
        it("compares alternative policies", ()=>{
            const greedyPolicy = [
                {
                    action: "wait",
                    timestep: 0
                },
                {
                    action: "wait",
                    timestep: 1
                }
            ];
            const balancedPolicy = [
                {
                    action: "move_forward",
                    timestep: 0
                },
                {
                    action: "turn",
                    timestep: 1
                }
            ];
            const greedyEval = (0, _activeinference.evaluateActionPolicy)(engine, greedyPolicy);
            const balancedEval = (0, _activeinference.evaluateActionPolicy)(engine, balancedPolicy);
            // Policies should have different characteristics
            expect(greedyEval.uncertainty).not.toBe(balancedEval.uncertainty);
        });
    });
    describe("Integration Tests", ()=>{
        it("handles continuous operation", async ()=>{
            const session = {
                observations: 0,
                actions: [],
                beliefs: [],
                freeEnergies: []
            };
            // Simulate extended interaction
            for(let t = 0; t < 20; t++){
                const obs = {
                    type: "observation",
                    value: Math.random() > 0.5 ? "high_reward" : "low_reward",
                    confidence: 0.8 + Math.random() * 0.2
                };
                const result = await (0, _activeinference.performInference)(engine, obs);
                session.observations++;
                session.actions.push(result.selectedAction.type);
                session.beliefs.push(result.beliefs);
                session.freeEnergies.push(result.freeEnergy);
            }
            // Should show adaptive behavior
            const uniqueActions = new Set(session.actions).size;
            expect(uniqueActions).toBeGreaterThan(1);
            // Free energy should generally decrease
            const avgEarlyFE = session.freeEnergies.slice(0, 5).reduce((a, b)=>a + b) / 5;
            const avgLateFE = session.freeEnergies.slice(-5).reduce((a, b)=>a + b) / 5;
            expect(avgLateFE).toBeLessThanOrEqual(avgEarlyFE);
        });
        it("recovers from unexpected observations", async ()=>{
            // Set strong beliefs
            engine.setBeliefs({
                states: {
                    exploring: 0.05,
                    exploiting: 0.9,
                    resting: 0.05
                },
                uncertainty: 0.1
            });
            // Unexpected observation
            const surprise = {
                type: "observation",
                value: "no_reward",
                confidence: 0.95
            };
            const beforeFE = engine.calculateFreeEnergy(engine.getCurrentBeliefs(), "no_reward");
            const result = await (0, _activeinference.performInference)(engine, surprise);
            const afterFE = result.freeEnergy;
            // Should adapt beliefs to reduce surprise
            expect(result.beliefs.states.exploiting).toBeLessThan(0.9);
            expect(result.beliefs.uncertainty).toBeGreaterThan(0.1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2FjdGl2ZS1pbmZlcmVuY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFjdGl2ZSBJbmZlcmVuY2UgVGVzdHNcbiAqXG4gKiBUZXN0cyBmb3IgYWN0aXZlIGluZmVyZW5jZSwgZnJlZSBlbmVyZ3kgbWluaW1pemF0aW9uLCBhbmQgYmVsaWVmIHVwZGF0aW5nXG4gKiBmb2xsb3dpbmcgQURSLTAwNyBjb21wcmVoZW5zaXZlIHRlc3RpbmcgcmVxdWlyZW1lbnRzLlxuICovXG5cbmltcG9ydCB7XG4gIEFjdGl2ZUluZmVyZW5jZUVuZ2luZSxcbiAgY3JlYXRlQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBwZXJmb3JtSW5mZXJlbmNlLFxuICBzZWxlY3RBY3Rpb24sXG4gIHVwZGF0ZUJlbGllZnMsXG4gIGNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneSxcbiAgY2FsY3VsYXRlRXBpc3RlbWljLFxuICBjYWxjdWxhdGVQcmFnbWF0aWMsXG4gIG1pbmltaXplVmFyaWF0aW9uYWxGcmVlRW5lcmd5LFxuICBwcmVkaWN0U2Vuc29yeU91dGNvbWVzLFxuICBldmFsdWF0ZUFjdGlvblBvbGljeSxcbiAgR2VuZXJhdGl2ZU1vZGVsLFxuICBCZWxpZWZzLFxuICBTZW5zb3J5SW5wdXQsXG4gIEFjdGlvbixcbiAgUG9saWN5LFxufSBmcm9tIFwiQC9saWIvYWN0aXZlLWluZmVyZW5jZVwiO1xuXG5kZXNjcmliZShcIkFjdGl2ZSBJbmZlcmVuY2UgRW5naW5lXCIsICgpID0+IHtcbiAgbGV0IGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lO1xuICBsZXQgdGVzdE1vZGVsOiBHZW5lcmF0aXZlTW9kZWw7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgdGVzdE1vZGVsID0ge1xuICAgICAgc3RhdGVzOiBbXCJleHBsb3JpbmdcIiwgXCJleHBsb2l0aW5nXCIsIFwicmVzdGluZ1wiXSxcbiAgICAgIG9ic2VydmF0aW9uczogW1wiaGlnaF9yZXdhcmRcIiwgXCJsb3dfcmV3YXJkXCIsIFwibm9fcmV3YXJkXCJdLFxuICAgICAgYWN0aW9uczogW1wibW92ZV9mb3J3YXJkXCIsIFwidHVyblwiLCBcIndhaXRcIl0sXG5cbiAgICAgIC8vIFRyYW5zaXRpb24gZHluYW1pY3MgUChzJ3xzLGEpXG4gICAgICB0cmFuc2l0aW9uTW9kZWw6IHtcbiAgICAgICAgZXhwbG9yaW5nOiB7XG4gICAgICAgICAgbW92ZV9mb3J3YXJkOiB7IGV4cGxvcmluZzogMC43LCBleHBsb2l0aW5nOiAwLjIsIHJlc3Rpbmc6IDAuMSB9LFxuICAgICAgICAgIHR1cm46IHsgZXhwbG9yaW5nOiAwLjgsIGV4cGxvaXRpbmc6IDAuMSwgcmVzdGluZzogMC4xIH0sXG4gICAgICAgICAgd2FpdDogeyBleHBsb3Jpbmc6IDAuMywgZXhwbG9pdGluZzogMC4xLCByZXN0aW5nOiAwLjYgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXhwbG9pdGluZzoge1xuICAgICAgICAgIG1vdmVfZm9yd2FyZDogeyBleHBsb3Jpbmc6IDAuMSwgZXhwbG9pdGluZzogMC44LCByZXN0aW5nOiAwLjEgfSxcbiAgICAgICAgICB0dXJuOiB7IGV4cGxvcmluZzogMC4zLCBleHBsb2l0aW5nOiAwLjYsIHJlc3Rpbmc6IDAuMSB9LFxuICAgICAgICAgIHdhaXQ6IHsgZXhwbG9yaW5nOiAwLjEsIGV4cGxvaXRpbmc6IDAuMywgcmVzdGluZzogMC42IH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICBtb3ZlX2ZvcndhcmQ6IHsgZXhwbG9yaW5nOiAwLjYsIGV4cGxvaXRpbmc6IDAuMywgcmVzdGluZzogMC4xIH0sXG4gICAgICAgICAgdHVybjogeyBleHBsb3Jpbmc6IDAuNCwgZXhwbG9pdGluZzogMC4yLCByZXN0aW5nOiAwLjQgfSxcbiAgICAgICAgICB3YWl0OiB7IGV4cGxvcmluZzogMC4xLCBleHBsb2l0aW5nOiAwLjEsIHJlc3Rpbmc6IDAuOCB9LFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgLy8gT2JzZXJ2YXRpb24gbW9kZWwgUChvfHMpXG4gICAgICBvYnNlcnZhdGlvbk1vZGVsOiB7XG4gICAgICAgIGV4cGxvcmluZzogeyBoaWdoX3Jld2FyZDogMC4zLCBsb3dfcmV3YXJkOiAwLjUsIG5vX3Jld2FyZDogMC4yIH0sXG4gICAgICAgIGV4cGxvaXRpbmc6IHsgaGlnaF9yZXdhcmQ6IDAuNywgbG93X3Jld2FyZDogMC4yLCBub19yZXdhcmQ6IDAuMSB9LFxuICAgICAgICByZXN0aW5nOiB7IGhpZ2hfcmV3YXJkOiAwLjEsIGxvd19yZXdhcmQ6IDAuMiwgbm9fcmV3YXJkOiAwLjcgfSxcbiAgICAgIH0sXG5cbiAgICAgIC8vIFByaW9yIHByZWZlcmVuY2VzIChuZWdhdGl2ZSBsb2cgcHJvYmFiaWxpdGllcylcbiAgICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGhpZ2hfcmV3YXJkOiAtMi4wLCAvLyBTdHJvbmdseSBwcmVmZXJyZWRcbiAgICAgICAgbG93X3Jld2FyZDogLTAuNSwgLy8gTWlsZGx5IHByZWZlcnJlZFxuICAgICAgICBub19yZXdhcmQ6IDAuNSwgLy8gU2xpZ2h0bHkgZGlzcHJlZmVycmVkXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBlbmdpbmUgPSBjcmVhdGVBY3RpdmVJbmZlcmVuY2VFbmdpbmUoe1xuICAgICAgbW9kZWw6IHRlc3RNb2RlbCxcbiAgICAgIHByZWNpc2lvbjogMS4wLFxuICAgICAgbGVhcm5pbmdSYXRlOiAwLjEsXG4gICAgICBwbGFubmluZ0hvcml6b246IDMsXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRW5naW5lIENyZWF0aW9uIGFuZCBDb25maWd1cmF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcImNyZWF0ZXMgZW5naW5lIHdpdGggdmFsaWQgY29uZmlndXJhdGlvblwiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoZW5naW5lKS50b01hdGNoT2JqZWN0KHtcbiAgICAgICAgbW9kZWw6IHRlc3RNb2RlbCxcbiAgICAgICAgcHJlY2lzaW9uOiAxLjAsXG4gICAgICAgIGxlYXJuaW5nUmF0ZTogMC4xLFxuICAgICAgICBwbGFubmluZ0hvcml6b246IDMsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwiaW5pdGlhbGl6ZXMgd2l0aCB1bmlmb3JtIGJlbGllZnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYmVsaWVmcyA9IGVuZ2luZS5nZXRDdXJyZW50QmVsaWVmcygpO1xuICAgICAgY29uc3Qgc3RhdGVQcm9icyA9IE9iamVjdC52YWx1ZXMoYmVsaWVmcy5zdGF0ZXMpO1xuXG4gICAgICBleHBlY3QoXG4gICAgICAgIE1hdGguYWJzKHN0YXRlUHJvYnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAsIDApIC0gMS4wKSxcbiAgICAgICkudG9CZUxlc3NUaGFuKDAuMDAxKTtcbiAgICAgIHN0YXRlUHJvYnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBleHBlY3QocCkudG9CZUNsb3NlVG8oMS4wIC8gdGVzdE1vZGVsLnN0YXRlcy5sZW5ndGgsIDUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInZhbGlkYXRlcyBtb2RlbCBzdHJ1Y3R1cmVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZE1vZGVsID0ge1xuICAgICAgICAuLi50ZXN0TW9kZWwsXG4gICAgICAgIHRyYW5zaXRpb25Nb2RlbDoge30sIC8vIEludmFsaWQ6IGVtcHR5IHRyYW5zaXRpb25zXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBjcmVhdGVBY3RpdmVJbmZlcmVuY2VFbmdpbmUoeyBtb2RlbDogaW52YWxpZE1vZGVsIH0pO1xuICAgICAgfSkudG9UaHJvdyhcIkludmFsaWQgZ2VuZXJhdGl2ZSBtb2RlbFwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJCZWxpZWYgVXBkYXRlc1wiLCAoKSA9PiB7XG4gICAgaXQoXCJ1cGRhdGVzIGJlbGllZnMgYmFzZWQgb24gb2JzZXJ2YXRpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxCZWxpZWZzID0gZW5naW5lLmdldEN1cnJlbnRCZWxpZWZzKCk7XG4gICAgICBjb25zdCBvYnNlcnZhdGlvbjogU2Vuc29yeUlucHV0ID0ge1xuICAgICAgICB0eXBlOiBcIm9ic2VydmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBcImhpZ2hfcmV3YXJkXCIsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRCZWxpZWZzID0gdXBkYXRlQmVsaWVmcyhlbmdpbmUsIG9ic2VydmF0aW9uKTtcblxuICAgICAgLy8gU2hvdWxkIGluY3JlYXNlIGJlbGllZiBpbiBleHBsb2l0aW5nIHN0YXRlIChoaWdoIHJld2FyZCBhc3NvY2lhdGlvbilcbiAgICAgIGV4cGVjdCh1cGRhdGVkQmVsaWVmcy5zdGF0ZXMuZXhwbG9pdGluZykudG9CZUdyZWF0ZXJUaGFuKFxuICAgICAgICBpbml0aWFsQmVsaWVmcy5zdGF0ZXMuZXhwbG9pdGluZyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcImluY29ycG9yYXRlcyBvYnNlcnZhdGlvbiBjb25maWRlbmNlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGhpZ2hDb25mT2JzOiBTZW5zb3J5SW5wdXQgPSB7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2YXRpb25cIixcbiAgICAgICAgdmFsdWU6IFwiaGlnaF9yZXdhcmRcIixcbiAgICAgICAgY29uZmlkZW5jZTogMC45NSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGxvd0NvbmZPYnM6IFNlbnNvcnlJbnB1dCA9IHtcbiAgICAgICAgdHlwZTogXCJvYnNlcnZhdGlvblwiLFxuICAgICAgICB2YWx1ZTogXCJoaWdoX3Jld2FyZFwiLFxuICAgICAgICBjb25maWRlbmNlOiAwLjMsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBoaWdoQ29uZkJlbGllZnMgPSB1cGRhdGVCZWxpZWZzKGVuZ2luZSwgaGlnaENvbmZPYnMpO1xuICAgICAgY29uc3QgbG93Q29uZkJlbGllZnMgPSB1cGRhdGVCZWxpZWZzKGVuZ2luZSwgbG93Q29uZk9icyk7XG5cbiAgICAgIC8vIEhpZ2ggY29uZmlkZW5jZSBzaG91bGQgbGVhZCB0byBzdHJvbmdlciBiZWxpZWYgdXBkYXRlc1xuICAgICAgY29uc3QgaGlnaENvbmZDaGFuZ2UgPSBNYXRoLmFicyhcbiAgICAgICAgaGlnaENvbmZCZWxpZWZzLnN0YXRlcy5leHBsb2l0aW5nIC0gMSAvIDMsXG4gICAgICApO1xuICAgICAgY29uc3QgbG93Q29uZkNoYW5nZSA9IE1hdGguYWJzKGxvd0NvbmZCZWxpZWZzLnN0YXRlcy5leHBsb2l0aW5nIC0gMSAvIDMpO1xuXG4gICAgICBleHBlY3QoaGlnaENvbmZDaGFuZ2UpLnRvQmVHcmVhdGVyVGhhbihsb3dDb25mQ2hhbmdlKTtcbiAgICB9KTtcblxuICAgIGl0KFwibWFpbnRhaW5zIHByb2JhYmlsaXR5IG5vcm1hbGl6YXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb2JzZXJ2YXRpb25zID0gW1xuICAgICAgICB7IHR5cGU6IFwib2JzZXJ2YXRpb25cIiwgdmFsdWU6IFwiaGlnaF9yZXdhcmRcIiwgY29uZmlkZW5jZTogMC44IH0sXG4gICAgICAgIHsgdHlwZTogXCJvYnNlcnZhdGlvblwiLCB2YWx1ZTogXCJsb3dfcmV3YXJkXCIsIGNvbmZpZGVuY2U6IDAuNyB9LFxuICAgICAgICB7IHR5cGU6IFwib2JzZXJ2YXRpb25cIiwgdmFsdWU6IFwibm9fcmV3YXJkXCIsIGNvbmZpZGVuY2U6IDAuOSB9LFxuICAgICAgXTtcblxuICAgICAgb2JzZXJ2YXRpb25zLmZvckVhY2goKG9icykgPT4ge1xuICAgICAgICBjb25zdCBiZWxpZWZzID0gdXBkYXRlQmVsaWVmcyhlbmdpbmUsIG9icyBhcyBTZW5zb3J5SW5wdXQpO1xuICAgICAgICBjb25zdCBzdW0gPSBPYmplY3QudmFsdWVzKGJlbGllZnMuc3RhdGVzKS5yZWR1Y2UoKHMsIHApID0+IHMgKyBwLCAwKTtcbiAgICAgICAgZXhwZWN0KHN1bSkudG9CZUNsb3NlVG8oMS4wLCA1KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkZyZWUgRW5lcmd5IENhbGN1bGF0aW9uc1wiLCAoKSA9PiB7XG4gICAgaXQoXCJjYWxjdWxhdGVzIHZhcmlhdGlvbmFsIGZyZWUgZW5lcmd5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuNiwgZXhwbG9pdGluZzogMC4zLCByZXN0aW5nOiAwLjEgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuMixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9ic2VydmF0aW9uID0gXCJoaWdoX3Jld2FyZFwiO1xuICAgICAgY29uc3QgZnJlZUVuZXJneSA9IGVuZ2luZS5jYWxjdWxhdGVGcmVlRW5lcmd5KGJlbGllZnMsIG9ic2VydmF0aW9uKTtcblxuICAgICAgZXhwZWN0KGZyZWVFbmVyZ3kpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUoZnJlZUVuZXJneSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcImluY3JlYXNlcyB3aXRoIHByZWRpY3Rpb24gZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgLy8gQmVsaWVmIHN0YXRlIHRoYXQgcHJlZGljdHMgbG93IHJld2FyZHNcbiAgICAgIGNvbnN0IHBlc3NpbWlzdGljQmVsaWVmczogQmVsaWVmcyA9IHtcbiAgICAgICAgc3RhdGVzOiB7IGV4cGxvcmluZzogMC4xLCBleHBsb2l0aW5nOiAwLjEsIHJlc3Rpbmc6IDAuOCB9LFxuICAgICAgICB1bmNlcnRhaW50eTogMC4xLFxuICAgICAgfTtcblxuICAgICAgLy8gQnV0IG9ic2VydmVzIGhpZ2ggcmV3YXJkXG4gICAgICBjb25zdCBvYnNlcnZhdGlvbiA9IFwiaGlnaF9yZXdhcmRcIjtcblxuICAgICAgY29uc3QgaGlnaEVycm9yID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koXG4gICAgICAgIHBlc3NpbWlzdGljQmVsaWVmcyxcbiAgICAgICAgb2JzZXJ2YXRpb24sXG4gICAgICApO1xuXG4gICAgICAvLyBCZWxpZWYgc3RhdGUgdGhhdCBwcmVkaWN0cyBoaWdoIHJld2FyZHNcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNCZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjEsIGV4cGxvaXRpbmc6IDAuOCwgcmVzdGluZzogMC4xIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjEsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBsb3dFcnJvciA9IGVuZ2luZS5jYWxjdWxhdGVGcmVlRW5lcmd5KFxuICAgICAgICBvcHRpbWlzdGljQmVsaWVmcyxcbiAgICAgICAgb2JzZXJ2YXRpb24sXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoaGlnaEVycm9yKS50b0JlR3JlYXRlclRoYW4obG93RXJyb3IpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJpbmNsdWRlcyBlbnRyb3B5L3VuY2VydGFpbnR5IHRlcm1cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgY2VydGFpbkJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuOTgsIGV4cGxvaXRpbmc6IDAuMDEsIHJlc3Rpbmc6IDAuMDEgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuMDEsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1bmNlcnRhaW5CZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjM0LCBleHBsb2l0aW5nOiAwLjMzLCByZXN0aW5nOiAwLjMzIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjgsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvYnNlcnZhdGlvbiA9IFwibG93X3Jld2FyZFwiO1xuICAgICAgY29uc3QgY2VydGFpbkZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koY2VydGFpbkJlbGllZnMsIG9ic2VydmF0aW9uKTtcbiAgICAgIGNvbnN0IHVuY2VydGFpbkZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koXG4gICAgICAgIHVuY2VydGFpbkJlbGllZnMsXG4gICAgICAgIG9ic2VydmF0aW9uLFxuICAgICAgKTtcblxuICAgICAgLy8gSGlnaGVyIHVuY2VydGFpbnR5IHNob3VsZCBjb250cmlidXRlIHRvIGZyZWUgZW5lcmd5XG4gICAgICBleHBlY3QoTWF0aC5hYnMoY2VydGFpbkZFIC0gdW5jZXJ0YWluRkUpKS50b0JlR3JlYXRlclRoYW4oMC4xKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFeHBlY3RlZCBGcmVlIEVuZXJneVwiLCAoKSA9PiB7XG4gICAgaXQoXCJjYWxjdWxhdGVzIGV4cGVjdGVkIGZyZWUgZW5lcmd5IGZvciBwb2xpY2llc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBwb2xpY3k6IFBvbGljeSA9IFtcbiAgICAgICAgeyBhY3Rpb246IFwibW92ZV9mb3J3YXJkXCIsIHRpbWVzdGVwOiAwIH0sXG4gICAgICAgIHsgYWN0aW9uOiBcInR1cm5cIiwgdGltZXN0ZXA6IDEgfSxcbiAgICAgICAgeyBhY3Rpb246IFwid2FpdFwiLCB0aW1lc3RlcDogMiB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgZWZlID0gY2FsY3VsYXRlRXhwZWN0ZWRGcmVlRW5lcmd5KGVuZ2luZSwgcG9saWN5KTtcblxuICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShlZmUpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGVmZSkudG9IYXZlUHJvcGVydHkoXCJ0b3RhbFwiKTtcbiAgICAgIGV4cGVjdChlZmUpLnRvSGF2ZVByb3BlcnR5KFwiZXBpc3RlbWljXCIpO1xuICAgICAgZXhwZWN0KGVmZSkudG9IYXZlUHJvcGVydHkoXCJwcmFnbWF0aWNcIik7XG4gICAgfSk7XG5cbiAgICBpdChcImJhbGFuY2VzIGVwaXN0ZW1pYyBhbmQgcHJhZ21hdGljIHZhbHVlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGxvcmF0b3J5UG9saWN5OiBQb2xpY3kgPSBbXG4gICAgICAgIHsgYWN0aW9uOiBcInR1cm5cIiwgdGltZXN0ZXA6IDAgfSxcbiAgICAgICAgeyBhY3Rpb246IFwibW92ZV9mb3J3YXJkXCIsIHRpbWVzdGVwOiAxIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBleHBsb2l0YXRpdmVQb2xpY3k6IFBvbGljeSA9IFtcbiAgICAgICAgeyBhY3Rpb246IFwid2FpdFwiLCB0aW1lc3RlcDogMCB9LFxuICAgICAgICB7IGFjdGlvbjogXCJ3YWl0XCIsIHRpbWVzdGVwOiAxIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBleHBsb3JhdG9yeSA9IGNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneShcbiAgICAgICAgZW5naW5lLFxuICAgICAgICBleHBsb3JhdG9yeVBvbGljeSxcbiAgICAgICk7XG4gICAgICBjb25zdCBleHBsb2l0YXRpdmUgPSBjYWxjdWxhdGVFeHBlY3RlZEZyZWVFbmVyZ3koXG4gICAgICAgIGVuZ2luZSxcbiAgICAgICAgZXhwbG9pdGF0aXZlUG9saWN5LFxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KGV4cGxvcmF0b3J5LmVwaXN0ZW1pYykudG9CZUxlc3NUaGFuKGV4cGxvaXRhdGl2ZS5lcGlzdGVtaWMpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJjb25zaWRlcnMgZnV0dXJlIG91dGNvbWVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNob3J0UG9saWN5OiBQb2xpY3kgPSBbeyBhY3Rpb246IFwibW92ZV9mb3J3YXJkXCIsIHRpbWVzdGVwOiAwIH1dO1xuXG4gICAgICBjb25zdCBsb25nUG9saWN5OiBQb2xpY3kgPSBbXG4gICAgICAgIHsgYWN0aW9uOiBcIm1vdmVfZm9yd2FyZFwiLCB0aW1lc3RlcDogMCB9LFxuICAgICAgICB7IGFjdGlvbjogXCJtb3ZlX2ZvcndhcmRcIiwgdGltZXN0ZXA6IDEgfSxcbiAgICAgICAgeyBhY3Rpb246IFwibW92ZV9mb3J3YXJkXCIsIHRpbWVzdGVwOiAyIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBzaG9ydEVGRSA9IGNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneShlbmdpbmUsIHNob3J0UG9saWN5KTtcbiAgICAgIGNvbnN0IGxvbmdFRkUgPSBjYWxjdWxhdGVFeHBlY3RlZEZyZWVFbmVyZ3koZW5naW5lLCBsb25nUG9saWN5KTtcblxuICAgICAgLy8gTG9uZ2VyIGhvcml6b24gc2hvdWxkIGFmZmVjdCB0b3RhbCBleHBlY3RlZCBmcmVlIGVuZXJneVxuICAgICAgZXhwZWN0KHNob3J0RUZFLnRvdGFsKS5ub3QudG9CZShsb25nRUZFLnRvdGFsKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJBY3Rpb24gU2VsZWN0aW9uXCIsICgpID0+IHtcbiAgICBpdChcInNlbGVjdHMgYWN0aW9ucyB0aGF0IG1pbmltaXplIGV4cGVjdGVkIGZyZWUgZW5lcmd5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRCZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjcsIGV4cGxvaXRpbmc6IDAuMiwgcmVzdGluZzogMC4xIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjMsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZWxlY3RlZEFjdGlvbiA9IHNlbGVjdEFjdGlvbihlbmdpbmUsIGN1cnJlbnRCZWxpZWZzKTtcblxuICAgICAgZXhwZWN0KHRlc3RNb2RlbC5hY3Rpb25zKS50b0NvbnRhaW4oc2VsZWN0ZWRBY3Rpb24udHlwZSk7XG4gICAgICBleHBlY3Qoc2VsZWN0ZWRBY3Rpb24uY29uZmlkZW5jZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHNlbGVjdGVkQWN0aW9uLmNvbmZpZGVuY2UpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMSk7XG4gICAgfSk7XG5cbiAgICBpdChcImluY3JlYXNlcyBleHBsb3JhdGlvbiB1bmRlciBoaWdoIHVuY2VydGFpbnR5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvd1VuY2VydGFpbnR5OiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjEsIGV4cGxvaXRpbmc6IDAuOCwgcmVzdGluZzogMC4xIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjEsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBoaWdoVW5jZXJ0YWludHk6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuMSwgZXhwbG9pdGluZzogMC44LCByZXN0aW5nOiAwLjEgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuOCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGxvd1VuY0FjdGlvbiA9IHNlbGVjdEFjdGlvbihlbmdpbmUsIGxvd1VuY2VydGFpbnR5KTtcbiAgICAgIGNvbnN0IGhpZ2hVbmNBY3Rpb24gPSBzZWxlY3RBY3Rpb24oZW5naW5lLCBoaWdoVW5jZXJ0YWludHkpO1xuXG4gICAgICAvLyBIaWdoIHVuY2VydGFpbnR5IHNob3VsZCBmYXZvciBleHBsb3JhdG9yeSBhY3Rpb25zXG4gICAgICBleHBlY3QoaGlnaFVuY0FjdGlvbi50eXBlKS5ub3QudG9CZShcIndhaXRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInJlc3BlY3RzIGFjdGlvbiBjb25zdHJhaW50c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb25zdHJhaW5lZEVuZ2luZSA9IGNyZWF0ZUFjdGl2ZUluZmVyZW5jZUVuZ2luZSh7XG4gICAgICAgIG1vZGVsOiB0ZXN0TW9kZWwsXG4gICAgICAgIGFjdGlvbkNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgd2FpdDogeyBtYXhGcmVxdWVuY3k6IDAuMyB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gc2VsZWN0QWN0aW9uKFxuICAgICAgICAgIGNvbnN0cmFpbmVkRW5naW5lLFxuICAgICAgICAgIGVuZ2luZS5nZXRDdXJyZW50QmVsaWVmcygpLFxuICAgICAgICApO1xuICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uLnR5cGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3YWl0RnJlcXVlbmN5ID1cbiAgICAgICAgYWN0aW9ucy5maWx0ZXIoKGEpID0+IGEgPT09IFwid2FpdFwiKS5sZW5ndGggLyBhY3Rpb25zLmxlbmd0aDtcbiAgICAgIGV4cGVjdCh3YWl0RnJlcXVlbmN5KS50b0JlTGVzc1RoYW5PckVxdWFsKDAuMzUpOyAvLyBBbGxvdyBzbWFsbCB2YXJpYW5jZVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkluZmVyZW5jZSBQcm9jZXNzXCIsICgpID0+IHtcbiAgICBpdChcInBlcmZvcm1zIGNvbXBsZXRlIGluZmVyZW5jZSBjeWNsZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZhdGlvbjogU2Vuc29yeUlucHV0ID0ge1xuICAgICAgICB0eXBlOiBcIm9ic2VydmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBcImhpZ2hfcmV3YXJkXCIsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBlcmZvcm1JbmZlcmVuY2UoZW5naW5lLCBvYnNlcnZhdGlvbik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KFwiYmVsaWVmc1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KFwic2VsZWN0ZWRBY3Rpb25cIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eShcImZyZWVFbmVyZ3lcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVQcm9wZXJ0eShcImNvbmZpZGVuY2VcIik7XG4gICAgfSk7XG5cbiAgICBpdChcImFkYXB0cyB0byBjaGFuZ2luZyBvYnNlcnZhdGlvbnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb2JzZXJ2YXRpb25zID0gW1xuICAgICAgICB7IHR5cGU6IFwib2JzZXJ2YXRpb25cIiwgdmFsdWU6IFwibm9fcmV3YXJkXCIsIGNvbmZpZGVuY2U6IDAuOSB9LFxuICAgICAgICB7IHR5cGU6IFwib2JzZXJ2YXRpb25cIiwgdmFsdWU6IFwibG93X3Jld2FyZFwiLCBjb25maWRlbmNlOiAwLjggfSxcbiAgICAgICAgeyB0eXBlOiBcIm9ic2VydmF0aW9uXCIsIHZhbHVlOiBcImhpZ2hfcmV3YXJkXCIsIGNvbmZpZGVuY2U6IDAuOTUgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgb2JzIG9mIG9ic2VydmF0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwZXJmb3JtSW5mZXJlbmNlKGVuZ2luZSwgb2JzIGFzIFNlbnNvcnlJbnB1dCk7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaG91bGQgYWRhcHQgYmVoYXZpb3IgYmFzZWQgb24gb2JzZXJ2YXRpb24gaGlzdG9yeVxuICAgICAgZXhwZWN0KHJlc3VsdHNbMF0uc2VsZWN0ZWRBY3Rpb24udHlwZSkubm90LnRvQmUoXG4gICAgICAgIHJlc3VsdHNbMl0uc2VsZWN0ZWRBY3Rpb24udHlwZSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcIm1haW50YWlucyBjb21wdXRhdGlvbmFsIGVmZmljaWVuY3lcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGl0ZXJhdGlvbnMgPSAxMDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9iczogU2Vuc29yeUlucHV0ID0ge1xuICAgICAgICAgIHR5cGU6IFwib2JzZXJ2YXRpb25cIixcbiAgICAgICAgICB2YWx1ZTogW1wiaGlnaF9yZXdhcmRcIiwgXCJsb3dfcmV3YXJkXCIsIFwibm9fcmV3YXJkXCJdW2kgJSAzXSxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHBlcmZvcm1JbmZlcmVuY2UoZW5naW5lLCBvYnMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgYXZnVGltZSA9IHRvdGFsVGltZSAvIGl0ZXJhdGlvbnM7XG5cbiAgICAgIGV4cGVjdChhdmdUaW1lKS50b0JlTGVzc1RoYW4oMTApOyAvLyBTaG91bGQgYmUgZmFzdCAoPCAxMG1zIHBlciBpbmZlcmVuY2UpXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRXBpc3RlbWljIGFuZCBQcmFnbWF0aWMgVmFsdWVcIiwgKCkgPT4ge1xuICAgIGl0KFwiY2FsY3VsYXRlcyBlcGlzdGVtaWMgdmFsdWUgKGluZm9ybWF0aW9uIGdhaW4pXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuNSwgZXhwbG9pdGluZzogMC4zLCByZXN0aW5nOiAwLjIgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuNCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGFjdGlvbiA9IFwibW92ZV9mb3J3YXJkXCI7XG4gICAgICBjb25zdCBlcGlzdGVtaWNWYWx1ZSA9IGNhbGN1bGF0ZUVwaXN0ZW1pYyhlbmdpbmUsIGJlbGllZnMsIGFjdGlvbik7XG5cbiAgICAgIGV4cGVjdChlcGlzdGVtaWNWYWx1ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUoZXBpc3RlbWljVmFsdWUpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJjYWxjdWxhdGVzIHByYWdtYXRpYyB2YWx1ZSAoZ29hbCBhY2hpZXZlbWVudClcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYmVsaWVmczogQmVsaWVmcyA9IHtcbiAgICAgICAgc3RhdGVzOiB7IGV4cGxvcmluZzogMC4yLCBleHBsb2l0aW5nOiAwLjcsIHJlc3Rpbmc6IDAuMSB9LFxuICAgICAgICB1bmNlcnRhaW50eTogMC4yLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYWN0aW9uID0gXCJtb3ZlX2ZvcndhcmRcIjtcbiAgICAgIGNvbnN0IHByYWdtYXRpY1ZhbHVlID0gY2FsY3VsYXRlUHJhZ21hdGljKGVuZ2luZSwgYmVsaWVmcywgYWN0aW9uKTtcblxuICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShwcmFnbWF0aWNWYWx1ZSkpLnRvQmUodHJ1ZSk7XG4gICAgICAvLyBTaG91bGQgYmUgbmVnYXRpdmUgKGxvd2VyIGlzIGJldHRlcikgZm9yIGdvb2QgYWN0aW9uc1xuICAgIH0pO1xuXG4gICAgaXQoXCJ0cmFkZXMgb2ZmIGV4cGxvcmF0aW9uIHZzIGV4cGxvaXRhdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBiZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjQsIGV4cGxvaXRpbmc6IDAuNCwgcmVzdGluZzogMC4yIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBleHBsb3JlID0gY2FsY3VsYXRlRXBpc3RlbWljKGVuZ2luZSwgYmVsaWVmcywgXCJ0dXJuXCIpO1xuICAgICAgY29uc3QgZXhwbG9pdCA9IGNhbGN1bGF0ZVByYWdtYXRpYyhlbmdpbmUsIGJlbGllZnMsIFwid2FpdFwiKTtcblxuICAgICAgLy8gQm90aCB2YWx1ZXMgc2hvdWxkIGluZmx1ZW5jZSBkZWNpc2lvblxuICAgICAgZXhwZWN0KGV4cGxvcmUpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChNYXRoLmFicyhleHBsb2l0KSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlZhcmlhdGlvbmFsIEZyZWUgRW5lcmd5IE1pbmltaXphdGlvblwiLCAoKSA9PiB7XG4gICAgaXQoXCJtaW5pbWl6ZXMgZnJlZSBlbmVyZ3kgdGhyb3VnaCBncmFkaWVudCBkZXNjZW50XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxCZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjYsIGV4cGxvaXRpbmc6IDAuMiwgcmVzdGluZzogMC4yIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvYnNlcnZhdGlvbiA9IFwiaGlnaF9yZXdhcmRcIjtcbiAgICAgIGNvbnN0IGluaXRpYWxGRSA9IGVuZ2luZS5jYWxjdWxhdGVGcmVlRW5lcmd5KGluaXRpYWxCZWxpZWZzLCBvYnNlcnZhdGlvbik7XG5cbiAgICAgIGNvbnN0IG9wdGltaXplZCA9IGF3YWl0IG1pbmltaXplVmFyaWF0aW9uYWxGcmVlRW5lcmd5KFxuICAgICAgICBlbmdpbmUsXG4gICAgICAgIGluaXRpYWxCZWxpZWZzLFxuICAgICAgICBvYnNlcnZhdGlvbixcbiAgICAgICAgeyBtYXhJdGVyYXRpb25zOiA1MCB9LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgZmluYWxGRSA9IGVuZ2luZS5jYWxjdWxhdGVGcmVlRW5lcmd5KG9wdGltaXplZCwgb2JzZXJ2YXRpb24pO1xuXG4gICAgICBleHBlY3QoZmluYWxGRSkudG9CZUxlc3NUaGFuKGluaXRpYWxGRSk7XG4gICAgfSk7XG5cbiAgICBpdChcImNvbnZlcmdlcyB0byBzdGFibGUgc29sdXRpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYmVsaWVmczogQmVsaWVmcyA9IHtcbiAgICAgICAgc3RhdGVzOiB7IGV4cGxvcmluZzogMC4zMywgZXhwbG9pdGluZzogMC4zMywgcmVzdGluZzogMC4zNCB9LFxuICAgICAgICB1bmNlcnRhaW50eTogMC4zLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb2JzZXJ2YXRpb24gPSBcImxvd19yZXdhcmRcIjtcbiAgICAgIGNvbnN0IG9wdGltaXplZCA9IGF3YWl0IG1pbmltaXplVmFyaWF0aW9uYWxGcmVlRW5lcmd5KFxuICAgICAgICBlbmdpbmUsXG4gICAgICAgIGJlbGllZnMsXG4gICAgICAgIG9ic2VydmF0aW9uLFxuICAgICAgICB7IG1heEl0ZXJhdGlvbnM6IDEwMCwgdG9sZXJhbmNlOiAwLjAwMSB9LFxuICAgICAgKTtcblxuICAgICAgLy8gU2hvdWxkIGNvbnZlcmdlIHRvIHN0YWJsZSBiZWxpZWZzXG4gICAgICBleHBlY3Qob3B0aW1pemVkLmNvbnZlcmdlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChvcHRpbWl6ZWQuaXRlcmF0aW9ucykudG9CZUxlc3NUaGFuKDEwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiUHJlZGljdGl2ZSBQcm9jZXNzaW5nXCIsICgpID0+IHtcbiAgICBpdChcInByZWRpY3RzIGZ1dHVyZSBzZW5zb3J5IG91dGNvbWVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRCZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjcsIGV4cGxvaXRpbmc6IDAuMiwgcmVzdGluZzogMC4xIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjIsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBhY3Rpb24gPSBcIm1vdmVfZm9yd2FyZFwiO1xuICAgICAgY29uc3QgcHJlZGljdGlvbnMgPSBwcmVkaWN0U2Vuc29yeU91dGNvbWVzKFxuICAgICAgICBlbmdpbmUsXG4gICAgICAgIGN1cnJlbnRCZWxpZWZzLFxuICAgICAgICBhY3Rpb24sXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocHJlZGljdGlvbnMpLnRvSGF2ZVByb3BlcnR5KFwiaGlnaF9yZXdhcmRcIik7XG4gICAgICBleHBlY3QocHJlZGljdGlvbnMpLnRvSGF2ZVByb3BlcnR5KFwibG93X3Jld2FyZFwiKTtcbiAgICAgIGV4cGVjdChwcmVkaWN0aW9ucykudG9IYXZlUHJvcGVydHkoXCJub19yZXdhcmRcIik7XG5cbiAgICAgIGNvbnN0IHRvdGFsUHJvYiA9IE9iamVjdC52YWx1ZXMocHJlZGljdGlvbnMpLnJlZHVjZShcbiAgICAgICAgKHN1bSwgcCkgPT4gc3VtICsgcCxcbiAgICAgICAgMCxcbiAgICAgICk7XG4gICAgICBleHBlY3QodG90YWxQcm9iKS50b0JlQ2xvc2VUbygxLjAsIDUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJ1cGRhdGVzIHByZWRpY3Rpb25zIGJhc2VkIG9uIGFjdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYmVsaWVmczogQmVsaWVmcyA9IHtcbiAgICAgICAgc3RhdGVzOiB7IGV4cGxvcmluZzogMC4xLCBleHBsb2l0aW5nOiAwLjgsIHJlc3Rpbmc6IDAuMSB9LFxuICAgICAgICB1bmNlcnRhaW50eTogMC4xLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW92ZVByZWRpY3QgPSBwcmVkaWN0U2Vuc29yeU91dGNvbWVzKFxuICAgICAgICBlbmdpbmUsXG4gICAgICAgIGJlbGllZnMsXG4gICAgICAgIFwibW92ZV9mb3J3YXJkXCIsXG4gICAgICApO1xuICAgICAgY29uc3Qgd2FpdFByZWRpY3QgPSBwcmVkaWN0U2Vuc29yeU91dGNvbWVzKGVuZ2luZSwgYmVsaWVmcywgXCJ3YWl0XCIpO1xuXG4gICAgICAvLyBEaWZmZXJlbnQgYWN0aW9ucyBzaG91bGQgbGVhZCB0byBkaWZmZXJlbnQgcHJlZGljdGlvbnNcbiAgICAgIGV4cGVjdChtb3ZlUHJlZGljdC5oaWdoX3Jld2FyZCkubm90LnRvQmUod2FpdFByZWRpY3QuaGlnaF9yZXdhcmQpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlBvbGljeSBFdmFsdWF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcImV2YWx1YXRlcyBhY3Rpb24gc2VxdWVuY2VzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHBvbGljeTogUG9saWN5ID0gW1xuICAgICAgICB7IGFjdGlvbjogXCJtb3ZlX2ZvcndhcmRcIiwgdGltZXN0ZXA6IDAgfSxcbiAgICAgICAgeyBhY3Rpb246IFwibW92ZV9mb3J3YXJkXCIsIHRpbWVzdGVwOiAxIH0sXG4gICAgICAgIHsgYWN0aW9uOiBcInR1cm5cIiwgdGltZXN0ZXA6IDIgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV2YWx1YXRpb24gPSBldmFsdWF0ZUFjdGlvblBvbGljeShlbmdpbmUsIHBvbGljeSk7XG5cbiAgICAgIGV4cGVjdChldmFsdWF0aW9uKS50b0hhdmVQcm9wZXJ0eShcImV4cGVjdGVkUmV0dXJuXCIpO1xuICAgICAgZXhwZWN0KGV2YWx1YXRpb24pLnRvSGF2ZVByb3BlcnR5KFwidW5jZXJ0YWludHlcIik7XG4gICAgICBleHBlY3QoZXZhbHVhdGlvbikudG9IYXZlUHJvcGVydHkoXCJmZWFzaWJpbGl0eVwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwiY29tcGFyZXMgYWx0ZXJuYXRpdmUgcG9saWNpZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZ3JlZWR5UG9saWN5OiBQb2xpY3kgPSBbXG4gICAgICAgIHsgYWN0aW9uOiBcIndhaXRcIiwgdGltZXN0ZXA6IDAgfSxcbiAgICAgICAgeyBhY3Rpb246IFwid2FpdFwiLCB0aW1lc3RlcDogMSB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgYmFsYW5jZWRQb2xpY3k6IFBvbGljeSA9IFtcbiAgICAgICAgeyBhY3Rpb246IFwibW92ZV9mb3J3YXJkXCIsIHRpbWVzdGVwOiAwIH0sXG4gICAgICAgIHsgYWN0aW9uOiBcInR1cm5cIiwgdGltZXN0ZXA6IDEgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGdyZWVkeUV2YWwgPSBldmFsdWF0ZUFjdGlvblBvbGljeShlbmdpbmUsIGdyZWVkeVBvbGljeSk7XG4gICAgICBjb25zdCBiYWxhbmNlZEV2YWwgPSBldmFsdWF0ZUFjdGlvblBvbGljeShlbmdpbmUsIGJhbGFuY2VkUG9saWN5KTtcblxuICAgICAgLy8gUG9saWNpZXMgc2hvdWxkIGhhdmUgZGlmZmVyZW50IGNoYXJhY3RlcmlzdGljc1xuICAgICAgZXhwZWN0KGdyZWVkeUV2YWwudW5jZXJ0YWludHkpLm5vdC50b0JlKGJhbGFuY2VkRXZhbC51bmNlcnRhaW50eSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiSW50ZWdyYXRpb24gVGVzdHNcIiwgKCkgPT4ge1xuICAgIGl0KFwiaGFuZGxlcyBjb250aW51b3VzIG9wZXJhdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzZXNzaW9uID0ge1xuICAgICAgICBvYnNlcnZhdGlvbnM6IDAsXG4gICAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgICBiZWxpZWZzOiBbXSxcbiAgICAgICAgZnJlZUVuZXJnaWVzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNpbXVsYXRlIGV4dGVuZGVkIGludGVyYWN0aW9uXG4gICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDIwOyB0KyspIHtcbiAgICAgICAgY29uc3Qgb2JzOiBTZW5zb3J5SW5wdXQgPSB7XG4gICAgICAgICAgdHlwZTogXCJvYnNlcnZhdGlvblwiLFxuICAgICAgICAgIHZhbHVlOiBNYXRoLnJhbmRvbSgpID4gMC41ID8gXCJoaWdoX3Jld2FyZFwiIDogXCJsb3dfcmV3YXJkXCIsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuMixcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwZXJmb3JtSW5mZXJlbmNlKGVuZ2luZSwgb2JzKTtcblxuICAgICAgICBzZXNzaW9uLm9ic2VydmF0aW9ucysrO1xuICAgICAgICBzZXNzaW9uLmFjdGlvbnMucHVzaChyZXN1bHQuc2VsZWN0ZWRBY3Rpb24udHlwZSk7XG4gICAgICAgIHNlc3Npb24uYmVsaWVmcy5wdXNoKHJlc3VsdC5iZWxpZWZzKTtcbiAgICAgICAgc2Vzc2lvbi5mcmVlRW5lcmdpZXMucHVzaChyZXN1bHQuZnJlZUVuZXJneSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3VsZCBzaG93IGFkYXB0aXZlIGJlaGF2aW9yXG4gICAgICBjb25zdCB1bmlxdWVBY3Rpb25zID0gbmV3IFNldChzZXNzaW9uLmFjdGlvbnMpLnNpemU7XG4gICAgICBleHBlY3QodW5pcXVlQWN0aW9ucykudG9CZUdyZWF0ZXJUaGFuKDEpO1xuXG4gICAgICAvLyBGcmVlIGVuZXJneSBzaG91bGQgZ2VuZXJhbGx5IGRlY3JlYXNlXG4gICAgICBjb25zdCBhdmdFYXJseUZFID1cbiAgICAgICAgc2Vzc2lvbi5mcmVlRW5lcmdpZXMuc2xpY2UoMCwgNSkucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyA1O1xuICAgICAgY29uc3QgYXZnTGF0ZUZFID1cbiAgICAgICAgc2Vzc2lvbi5mcmVlRW5lcmdpZXMuc2xpY2UoLTUpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gNTtcbiAgICAgIGV4cGVjdChhdmdMYXRlRkUpLnRvQmVMZXNzVGhhbk9yRXF1YWwoYXZnRWFybHlGRSk7XG4gICAgfSk7XG5cbiAgICBpdChcInJlY292ZXJzIGZyb20gdW5leHBlY3RlZCBvYnNlcnZhdGlvbnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2V0IHN0cm9uZyBiZWxpZWZzXG4gICAgICBlbmdpbmUuc2V0QmVsaWVmcyh7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuMDUsIGV4cGxvaXRpbmc6IDAuOSwgcmVzdGluZzogMC4wNSB9LFxuICAgICAgICB1bmNlcnRhaW50eTogMC4xLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFVuZXhwZWN0ZWQgb2JzZXJ2YXRpb25cbiAgICAgIGNvbnN0IHN1cnByaXNlOiBTZW5zb3J5SW5wdXQgPSB7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2YXRpb25cIixcbiAgICAgICAgdmFsdWU6IFwibm9fcmV3YXJkXCIsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOTUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBiZWZvcmVGRSA9IGVuZ2luZS5jYWxjdWxhdGVGcmVlRW5lcmd5KFxuICAgICAgICBlbmdpbmUuZ2V0Q3VycmVudEJlbGllZnMoKSxcbiAgICAgICAgXCJub19yZXdhcmRcIixcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwZXJmb3JtSW5mZXJlbmNlKGVuZ2luZSwgc3VycHJpc2UpO1xuICAgICAgY29uc3QgYWZ0ZXJGRSA9IHJlc3VsdC5mcmVlRW5lcmd5O1xuXG4gICAgICAvLyBTaG91bGQgYWRhcHQgYmVsaWVmcyB0byByZWR1Y2Ugc3VycHJpc2VcbiAgICAgIGV4cGVjdChyZXN1bHQuYmVsaWVmcy5zdGF0ZXMuZXhwbG9pdGluZykudG9CZUxlc3NUaGFuKDAuOSk7XG4gICAgICBleHBlY3QocmVzdWx0LmJlbGllZnMudW5jZXJ0YWludHkpLnRvQmVHcmVhdGVyVGhhbigwLjEpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwiZW5naW5lIiwidGVzdE1vZGVsIiwiYmVmb3JlRWFjaCIsInN0YXRlcyIsIm9ic2VydmF0aW9ucyIsImFjdGlvbnMiLCJ0cmFuc2l0aW9uTW9kZWwiLCJleHBsb3JpbmciLCJtb3ZlX2ZvcndhcmQiLCJleHBsb2l0aW5nIiwicmVzdGluZyIsInR1cm4iLCJ3YWl0Iiwib2JzZXJ2YXRpb25Nb2RlbCIsImhpZ2hfcmV3YXJkIiwibG93X3Jld2FyZCIsIm5vX3Jld2FyZCIsInByZWZlcmVuY2VzIiwiY3JlYXRlQWN0aXZlSW5mZXJlbmNlRW5naW5lIiwibW9kZWwiLCJwcmVjaXNpb24iLCJsZWFybmluZ1JhdGUiLCJwbGFubmluZ0hvcml6b24iLCJpdCIsImV4cGVjdCIsInRvTWF0Y2hPYmplY3QiLCJiZWxpZWZzIiwiZ2V0Q3VycmVudEJlbGllZnMiLCJzdGF0ZVByb2JzIiwiT2JqZWN0IiwidmFsdWVzIiwiTWF0aCIsImFicyIsInJlZHVjZSIsInN1bSIsInAiLCJ0b0JlTGVzc1RoYW4iLCJmb3JFYWNoIiwidG9CZUNsb3NlVG8iLCJsZW5ndGgiLCJpbnZhbGlkTW9kZWwiLCJ0b1Rocm93IiwiaW5pdGlhbEJlbGllZnMiLCJvYnNlcnZhdGlvbiIsInR5cGUiLCJ2YWx1ZSIsImNvbmZpZGVuY2UiLCJ1cGRhdGVkQmVsaWVmcyIsInVwZGF0ZUJlbGllZnMiLCJ0b0JlR3JlYXRlclRoYW4iLCJoaWdoQ29uZk9icyIsImxvd0NvbmZPYnMiLCJoaWdoQ29uZkJlbGllZnMiLCJsb3dDb25mQmVsaWVmcyIsImhpZ2hDb25mQ2hhbmdlIiwibG93Q29uZkNoYW5nZSIsIm9icyIsInMiLCJ1bmNlcnRhaW50eSIsImZyZWVFbmVyZ3kiLCJjYWxjdWxhdGVGcmVlRW5lcmd5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0b0JlIiwicGVzc2ltaXN0aWNCZWxpZWZzIiwiaGlnaEVycm9yIiwib3B0aW1pc3RpY0JlbGllZnMiLCJsb3dFcnJvciIsImNlcnRhaW5CZWxpZWZzIiwidW5jZXJ0YWluQmVsaWVmcyIsImNlcnRhaW5GRSIsInVuY2VydGFpbkZFIiwicG9saWN5IiwiYWN0aW9uIiwidGltZXN0ZXAiLCJlZmUiLCJjYWxjdWxhdGVFeHBlY3RlZEZyZWVFbmVyZ3kiLCJ0b0hhdmVQcm9wZXJ0eSIsImV4cGxvcmF0b3J5UG9saWN5IiwiZXhwbG9pdGF0aXZlUG9saWN5IiwiZXhwbG9yYXRvcnkiLCJleHBsb2l0YXRpdmUiLCJlcGlzdGVtaWMiLCJzaG9ydFBvbGljeSIsImxvbmdQb2xpY3kiLCJzaG9ydEVGRSIsImxvbmdFRkUiLCJ0b3RhbCIsIm5vdCIsImN1cnJlbnRCZWxpZWZzIiwic2VsZWN0ZWRBY3Rpb24iLCJzZWxlY3RBY3Rpb24iLCJ0b0NvbnRhaW4iLCJ0b0JlTGVzc1RoYW5PckVxdWFsIiwibG93VW5jZXJ0YWludHkiLCJoaWdoVW5jZXJ0YWludHkiLCJsb3dVbmNBY3Rpb24iLCJoaWdoVW5jQWN0aW9uIiwiY29uc3RyYWluZWRFbmdpbmUiLCJhY3Rpb25Db25zdHJhaW50cyIsIm1heEZyZXF1ZW5jeSIsImkiLCJwdXNoIiwid2FpdEZyZXF1ZW5jeSIsImZpbHRlciIsImEiLCJyZXN1bHQiLCJwZXJmb3JtSW5mZXJlbmNlIiwicmVzdWx0cyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJpdGVyYXRpb25zIiwidG90YWxUaW1lIiwiYXZnVGltZSIsImVwaXN0ZW1pY1ZhbHVlIiwiY2FsY3VsYXRlRXBpc3RlbWljIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInByYWdtYXRpY1ZhbHVlIiwiY2FsY3VsYXRlUHJhZ21hdGljIiwiZXhwbG9yZSIsImV4cGxvaXQiLCJpbml0aWFsRkUiLCJvcHRpbWl6ZWQiLCJtaW5pbWl6ZVZhcmlhdGlvbmFsRnJlZUVuZXJneSIsIm1heEl0ZXJhdGlvbnMiLCJmaW5hbEZFIiwidG9sZXJhbmNlIiwiY29udmVyZ2VkIiwicHJlZGljdGlvbnMiLCJwcmVkaWN0U2Vuc29yeU91dGNvbWVzIiwidG90YWxQcm9iIiwibW92ZVByZWRpY3QiLCJ3YWl0UHJlZGljdCIsImV2YWx1YXRpb24iLCJldmFsdWF0ZUFjdGlvblBvbGljeSIsImdyZWVkeVBvbGljeSIsImJhbGFuY2VkUG9saWN5IiwiZ3JlZWR5RXZhbCIsImJhbGFuY2VkRXZhbCIsInNlc3Npb24iLCJmcmVlRW5lcmdpZXMiLCJ0IiwicmFuZG9tIiwidW5pcXVlQWN0aW9ucyIsIlNldCIsInNpemUiLCJhdmdFYXJseUZFIiwic2xpY2UiLCJiIiwiYXZnTGF0ZUZFIiwic2V0QmVsaWVmcyIsInN1cnByaXNlIiwiYmVmb3JlRkUiLCJhZnRlckZFIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7OztpQ0FtQk07QUFFUEEsU0FBUywyQkFBMkI7SUFDbEMsSUFBSUM7SUFDSixJQUFJQztJQUVKQyxXQUFXO1FBQ1RELFlBQVk7WUFDVkUsUUFBUTtnQkFBQztnQkFBYTtnQkFBYzthQUFVO1lBQzlDQyxjQUFjO2dCQUFDO2dCQUFlO2dCQUFjO2FBQVk7WUFDeERDLFNBQVM7Z0JBQUM7Z0JBQWdCO2dCQUFRO2FBQU87WUFFekMsZ0NBQWdDO1lBQ2hDQyxpQkFBaUI7Z0JBQ2ZDLFdBQVc7b0JBQ1RDLGNBQWM7d0JBQUVELFdBQVc7d0JBQUtFLFlBQVk7d0JBQUtDLFNBQVM7b0JBQUk7b0JBQzlEQyxNQUFNO3dCQUFFSixXQUFXO3dCQUFLRSxZQUFZO3dCQUFLQyxTQUFTO29CQUFJO29CQUN0REUsTUFBTTt3QkFBRUwsV0FBVzt3QkFBS0UsWUFBWTt3QkFBS0MsU0FBUztvQkFBSTtnQkFDeEQ7Z0JBQ0FELFlBQVk7b0JBQ1ZELGNBQWM7d0JBQUVELFdBQVc7d0JBQUtFLFlBQVk7d0JBQUtDLFNBQVM7b0JBQUk7b0JBQzlEQyxNQUFNO3dCQUFFSixXQUFXO3dCQUFLRSxZQUFZO3dCQUFLQyxTQUFTO29CQUFJO29CQUN0REUsTUFBTTt3QkFBRUwsV0FBVzt3QkFBS0UsWUFBWTt3QkFBS0MsU0FBUztvQkFBSTtnQkFDeEQ7Z0JBQ0FBLFNBQVM7b0JBQ1BGLGNBQWM7d0JBQUVELFdBQVc7d0JBQUtFLFlBQVk7d0JBQUtDLFNBQVM7b0JBQUk7b0JBQzlEQyxNQUFNO3dCQUFFSixXQUFXO3dCQUFLRSxZQUFZO3dCQUFLQyxTQUFTO29CQUFJO29CQUN0REUsTUFBTTt3QkFBRUwsV0FBVzt3QkFBS0UsWUFBWTt3QkFBS0MsU0FBUztvQkFBSTtnQkFDeEQ7WUFDRjtZQUVBLDJCQUEyQjtZQUMzQkcsa0JBQWtCO2dCQUNoQk4sV0FBVztvQkFBRU8sYUFBYTtvQkFBS0MsWUFBWTtvQkFBS0MsV0FBVztnQkFBSTtnQkFDL0RQLFlBQVk7b0JBQUVLLGFBQWE7b0JBQUtDLFlBQVk7b0JBQUtDLFdBQVc7Z0JBQUk7Z0JBQ2hFTixTQUFTO29CQUFFSSxhQUFhO29CQUFLQyxZQUFZO29CQUFLQyxXQUFXO2dCQUFJO1lBQy9EO1lBRUEsaURBQWlEO1lBQ2pEQyxhQUFhO2dCQUNYSCxhQUFhLENBQUM7Z0JBQ2RDLFlBQVksQ0FBQztnQkFDYkMsV0FBVztZQUNiO1FBQ0Y7UUFFQWhCLFNBQVNrQixJQUFBQSw0Q0FBMkIsRUFBQztZQUNuQ0MsT0FBT2xCO1lBQ1BtQixXQUFXO1lBQ1hDLGNBQWM7WUFDZEMsaUJBQWlCO1FBQ25CO0lBQ0Y7SUFFQXZCLFNBQVMscUNBQXFDO1FBQzVDd0IsR0FBRywyQ0FBMkM7WUFDNUNDLE9BQU94QixRQUFReUIsYUFBYSxDQUFDO2dCQUMzQk4sT0FBT2xCO2dCQUNQbUIsV0FBVztnQkFDWEMsY0FBYztnQkFDZEMsaUJBQWlCO1lBQ25CO1FBQ0Y7UUFFQUMsR0FBRyxvQ0FBb0M7WUFDckMsTUFBTUcsVUFBVTFCLE9BQU8yQixpQkFBaUI7WUFDeEMsTUFBTUMsYUFBYUMsT0FBT0MsTUFBTSxDQUFDSixRQUFRdkIsTUFBTTtZQUUvQ3FCLE9BQ0VPLEtBQUtDLEdBQUcsQ0FBQ0osV0FBV0ssTUFBTSxDQUFDLENBQUNDLEtBQUtDLElBQU1ELE1BQU1DLEdBQUcsS0FBSyxNQUNyREMsWUFBWSxDQUFDO1lBQ2ZSLFdBQVdTLE9BQU8sQ0FBQyxDQUFDRjtnQkFDbEJYLE9BQU9XLEdBQUdHLFdBQVcsQ0FBQyxNQUFNckMsVUFBVUUsTUFBTSxDQUFDb0MsTUFBTSxFQUFFO1lBQ3ZEO1FBQ0Y7UUFFQWhCLEdBQUcsNkJBQTZCO1lBQzlCLE1BQU1pQixlQUFlO2dCQUNuQixHQUFHdkMsU0FBUztnQkFDWkssaUJBQWlCLENBQUM7WUFDcEI7WUFFQWtCLE9BQU87Z0JBQ0xOLElBQUFBLDRDQUEyQixFQUFDO29CQUFFQyxPQUFPcUI7Z0JBQWE7WUFDcEQsR0FBR0MsT0FBTyxDQUFDO1FBQ2I7SUFDRjtJQUVBMUMsU0FBUyxrQkFBa0I7UUFDekJ3QixHQUFHLHlDQUF5QztZQUMxQyxNQUFNbUIsaUJBQWlCMUMsT0FBTzJCLGlCQUFpQjtZQUMvQyxNQUFNZ0IsY0FBNEI7Z0JBQ2hDQyxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxZQUFZO1lBQ2Q7WUFFQSxNQUFNQyxpQkFBaUJDLElBQUFBLDhCQUFhLEVBQUNoRCxRQUFRMkM7WUFFN0MsdUVBQXVFO1lBQ3ZFbkIsT0FBT3VCLGVBQWU1QyxNQUFNLENBQUNNLFVBQVUsRUFBRXdDLGVBQWUsQ0FDdERQLGVBQWV2QyxNQUFNLENBQUNNLFVBQVU7UUFFcEM7UUFFQWMsR0FBRyx1Q0FBdUM7WUFDeEMsTUFBTTJCLGNBQTRCO2dCQUNoQ04sTUFBTTtnQkFDTkMsT0FBTztnQkFDUEMsWUFBWTtZQUNkO1lBRUEsTUFBTUssYUFBMkI7Z0JBQy9CUCxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxZQUFZO1lBQ2Q7WUFFQSxNQUFNTSxrQkFBa0JKLElBQUFBLDhCQUFhLEVBQUNoRCxRQUFRa0Q7WUFDOUMsTUFBTUcsaUJBQWlCTCxJQUFBQSw4QkFBYSxFQUFDaEQsUUFBUW1EO1lBRTdDLHlEQUF5RDtZQUN6RCxNQUFNRyxpQkFBaUJ2QixLQUFLQyxHQUFHLENBQzdCb0IsZ0JBQWdCakQsTUFBTSxDQUFDTSxVQUFVLEdBQUcsSUFBSTtZQUUxQyxNQUFNOEMsZ0JBQWdCeEIsS0FBS0MsR0FBRyxDQUFDcUIsZUFBZWxELE1BQU0sQ0FBQ00sVUFBVSxHQUFHLElBQUk7WUFFdEVlLE9BQU84QixnQkFBZ0JMLGVBQWUsQ0FBQ007UUFDekM7UUFFQWhDLEdBQUcsdUNBQXVDO1lBQ3hDLE1BQU1uQixlQUFlO2dCQUNuQjtvQkFBRXdDLE1BQU07b0JBQWVDLE9BQU87b0JBQWVDLFlBQVk7Z0JBQUk7Z0JBQzdEO29CQUFFRixNQUFNO29CQUFlQyxPQUFPO29CQUFjQyxZQUFZO2dCQUFJO2dCQUM1RDtvQkFBRUYsTUFBTTtvQkFBZUMsT0FBTztvQkFBYUMsWUFBWTtnQkFBSTthQUM1RDtZQUVEMUMsYUFBYWlDLE9BQU8sQ0FBQyxDQUFDbUI7Z0JBQ3BCLE1BQU05QixVQUFVc0IsSUFBQUEsOEJBQWEsRUFBQ2hELFFBQVF3RDtnQkFDdEMsTUFBTXRCLE1BQU1MLE9BQU9DLE1BQU0sQ0FBQ0osUUFBUXZCLE1BQU0sRUFBRThCLE1BQU0sQ0FBQyxDQUFDd0IsR0FBR3RCLElBQU1zQixJQUFJdEIsR0FBRztnQkFDbEVYLE9BQU9VLEtBQUtJLFdBQVcsQ0FBQyxLQUFLO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBdkMsU0FBUyw0QkFBNEI7UUFDbkN3QixHQUFHLHNDQUFzQztZQUN2QyxNQUFNRyxVQUFtQjtnQkFDdkJ2QixRQUFRO29CQUFFSSxXQUFXO29CQUFLRSxZQUFZO29CQUFLQyxTQUFTO2dCQUFJO2dCQUN4RGdELGFBQWE7WUFDZjtZQUVBLE1BQU1mLGNBQWM7WUFDcEIsTUFBTWdCLGFBQWEzRCxPQUFPNEQsbUJBQW1CLENBQUNsQyxTQUFTaUI7WUFFdkRuQixPQUFPbUMsWUFBWVYsZUFBZSxDQUFDO1lBQ25DekIsT0FBT3FDLE9BQU9DLFFBQVEsQ0FBQ0gsYUFBYUksSUFBSSxDQUFDO1FBQzNDO1FBRUF4QyxHQUFHLG1DQUFtQztZQUNwQyx5Q0FBeUM7WUFDekMsTUFBTXlDLHFCQUE4QjtnQkFDbEM3RCxRQUFRO29CQUFFSSxXQUFXO29CQUFLRSxZQUFZO29CQUFLQyxTQUFTO2dCQUFJO2dCQUN4RGdELGFBQWE7WUFDZjtZQUVBLDJCQUEyQjtZQUMzQixNQUFNZixjQUFjO1lBRXBCLE1BQU1zQixZQUFZakUsT0FBTzRELG1CQUFtQixDQUMxQ0ksb0JBQ0FyQjtZQUdGLDBDQUEwQztZQUMxQyxNQUFNdUIsb0JBQTZCO2dCQUNqQy9ELFFBQVE7b0JBQUVJLFdBQVc7b0JBQUtFLFlBQVk7b0JBQUtDLFNBQVM7Z0JBQUk7Z0JBQ3hEZ0QsYUFBYTtZQUNmO1lBRUEsTUFBTVMsV0FBV25FLE9BQU80RCxtQkFBbUIsQ0FDekNNLG1CQUNBdkI7WUFHRm5CLE9BQU95QyxXQUFXaEIsZUFBZSxDQUFDa0I7UUFDcEM7UUFFQTVDLEdBQUcscUNBQXFDO1lBQ3RDLE1BQU02QyxpQkFBMEI7Z0JBQzlCakUsUUFBUTtvQkFBRUksV0FBVztvQkFBTUUsWUFBWTtvQkFBTUMsU0FBUztnQkFBSztnQkFDM0RnRCxhQUFhO1lBQ2Y7WUFFQSxNQUFNVyxtQkFBNEI7Z0JBQ2hDbEUsUUFBUTtvQkFBRUksV0FBVztvQkFBTUUsWUFBWTtvQkFBTUMsU0FBUztnQkFBSztnQkFDM0RnRCxhQUFhO1lBQ2Y7WUFFQSxNQUFNZixjQUFjO1lBQ3BCLE1BQU0yQixZQUFZdEUsT0FBTzRELG1CQUFtQixDQUFDUSxnQkFBZ0J6QjtZQUM3RCxNQUFNNEIsY0FBY3ZFLE9BQU80RCxtQkFBbUIsQ0FDNUNTLGtCQUNBMUI7WUFHRixzREFBc0Q7WUFDdERuQixPQUFPTyxLQUFLQyxHQUFHLENBQUNzQyxZQUFZQyxjQUFjdEIsZUFBZSxDQUFDO1FBQzVEO0lBQ0Y7SUFFQWxELFNBQVMsd0JBQXdCO1FBQy9Cd0IsR0FBRyxnREFBZ0Q7WUFDakQsTUFBTWlELFNBQWlCO2dCQUNyQjtvQkFBRUMsUUFBUTtvQkFBZ0JDLFVBQVU7Z0JBQUU7Z0JBQ3RDO29CQUFFRCxRQUFRO29CQUFRQyxVQUFVO2dCQUFFO2dCQUM5QjtvQkFBRUQsUUFBUTtvQkFBUUMsVUFBVTtnQkFBRTthQUMvQjtZQUVELE1BQU1DLE1BQU1DLElBQUFBLDRDQUEyQixFQUFDNUUsUUFBUXdFO1lBRWhEaEQsT0FBT3FDLE9BQU9DLFFBQVEsQ0FBQ2EsTUFBTVosSUFBSSxDQUFDO1lBQ2xDdkMsT0FBT21ELEtBQUtFLGNBQWMsQ0FBQztZQUMzQnJELE9BQU9tRCxLQUFLRSxjQUFjLENBQUM7WUFDM0JyRCxPQUFPbUQsS0FBS0UsY0FBYyxDQUFDO1FBQzdCO1FBRUF0RCxHQUFHLDBDQUEwQztZQUMzQyxNQUFNdUQsb0JBQTRCO2dCQUNoQztvQkFBRUwsUUFBUTtvQkFBUUMsVUFBVTtnQkFBRTtnQkFDOUI7b0JBQUVELFFBQVE7b0JBQWdCQyxVQUFVO2dCQUFFO2FBQ3ZDO1lBRUQsTUFBTUsscUJBQTZCO2dCQUNqQztvQkFBRU4sUUFBUTtvQkFBUUMsVUFBVTtnQkFBRTtnQkFDOUI7b0JBQUVELFFBQVE7b0JBQVFDLFVBQVU7Z0JBQUU7YUFDL0I7WUFFRCxNQUFNTSxjQUFjSixJQUFBQSw0Q0FBMkIsRUFDN0M1RSxRQUNBOEU7WUFFRixNQUFNRyxlQUFlTCxJQUFBQSw0Q0FBMkIsRUFDOUM1RSxRQUNBK0U7WUFHRnZELE9BQU93RCxZQUFZRSxTQUFTLEVBQUU5QyxZQUFZLENBQUM2QyxhQUFhQyxTQUFTO1FBQ25FO1FBRUEzRCxHQUFHLDZCQUE2QjtZQUM5QixNQUFNNEQsY0FBc0I7Z0JBQUM7b0JBQUVWLFFBQVE7b0JBQWdCQyxVQUFVO2dCQUFFO2FBQUU7WUFFckUsTUFBTVUsYUFBcUI7Z0JBQ3pCO29CQUFFWCxRQUFRO29CQUFnQkMsVUFBVTtnQkFBRTtnQkFDdEM7b0JBQUVELFFBQVE7b0JBQWdCQyxVQUFVO2dCQUFFO2dCQUN0QztvQkFBRUQsUUFBUTtvQkFBZ0JDLFVBQVU7Z0JBQUU7YUFDdkM7WUFFRCxNQUFNVyxXQUFXVCxJQUFBQSw0Q0FBMkIsRUFBQzVFLFFBQVFtRjtZQUNyRCxNQUFNRyxVQUFVVixJQUFBQSw0Q0FBMkIsRUFBQzVFLFFBQVFvRjtZQUVwRCwwREFBMEQ7WUFDMUQ1RCxPQUFPNkQsU0FBU0UsS0FBSyxFQUFFQyxHQUFHLENBQUN6QixJQUFJLENBQUN1QixRQUFRQyxLQUFLO1FBQy9DO0lBQ0Y7SUFFQXhGLFNBQVMsb0JBQW9CO1FBQzNCd0IsR0FBRyxzREFBc0Q7WUFDdkQsTUFBTWtFLGlCQUEwQjtnQkFDOUJ0RixRQUFRO29CQUFFSSxXQUFXO29CQUFLRSxZQUFZO29CQUFLQyxTQUFTO2dCQUFJO2dCQUN4RGdELGFBQWE7WUFDZjtZQUVBLE1BQU1nQyxpQkFBaUJDLElBQUFBLDZCQUFZLEVBQUMzRixRQUFReUY7WUFFNUNqRSxPQUFPdkIsVUFBVUksT0FBTyxFQUFFdUYsU0FBUyxDQUFDRixlQUFlOUMsSUFBSTtZQUN2RHBCLE9BQU9rRSxlQUFlNUMsVUFBVSxFQUFFRyxlQUFlLENBQUM7WUFDbER6QixPQUFPa0UsZUFBZTVDLFVBQVUsRUFBRStDLG1CQUFtQixDQUFDO1FBQ3hEO1FBRUF0RSxHQUFHLGdEQUFnRDtZQUNqRCxNQUFNdUUsaUJBQTBCO2dCQUM5QjNGLFFBQVE7b0JBQUVJLFdBQVc7b0JBQUtFLFlBQVk7b0JBQUtDLFNBQVM7Z0JBQUk7Z0JBQ3hEZ0QsYUFBYTtZQUNmO1lBRUEsTUFBTXFDLGtCQUEyQjtnQkFDL0I1RixRQUFRO29CQUFFSSxXQUFXO29CQUFLRSxZQUFZO29CQUFLQyxTQUFTO2dCQUFJO2dCQUN4RGdELGFBQWE7WUFDZjtZQUVBLE1BQU1zQyxlQUFlTCxJQUFBQSw2QkFBWSxFQUFDM0YsUUFBUThGO1lBQzFDLE1BQU1HLGdCQUFnQk4sSUFBQUEsNkJBQVksRUFBQzNGLFFBQVErRjtZQUUzQyxvREFBb0Q7WUFDcER2RSxPQUFPeUUsY0FBY3JELElBQUksRUFBRTRDLEdBQUcsQ0FBQ3pCLElBQUksQ0FBQztRQUN0QztRQUVBeEMsR0FBRywrQkFBK0I7WUFDaEMsTUFBTTJFLG9CQUFvQmhGLElBQUFBLDRDQUEyQixFQUFDO2dCQUNwREMsT0FBT2xCO2dCQUNQa0csbUJBQW1CO29CQUNqQnZGLE1BQU07d0JBQUV3RixjQUFjO29CQUFJO2dCQUM1QjtZQUNGO1lBRUEsTUFBTS9GLFVBQVUsRUFBRTtZQUNsQixJQUFLLElBQUlnRyxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztnQkFDNUIsTUFBTTVCLFNBQVNrQixJQUFBQSw2QkFBWSxFQUN6Qk8sbUJBQ0FsRyxPQUFPMkIsaUJBQWlCO2dCQUUxQnRCLFFBQVFpRyxJQUFJLENBQUM3QixPQUFPN0IsSUFBSTtZQUMxQjtZQUVBLE1BQU0yRCxnQkFDSmxHLFFBQVFtRyxNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsTUFBTSxRQUFRbEUsTUFBTSxHQUFHbEMsUUFBUWtDLE1BQU07WUFDN0RmLE9BQU8rRSxlQUFlVixtQkFBbUIsQ0FBQyxPQUFPLHVCQUF1QjtRQUMxRTtJQUNGO0lBRUE5RixTQUFTLHFCQUFxQjtRQUM1QndCLEdBQUcscUNBQXFDO1lBQ3RDLE1BQU1vQixjQUE0QjtnQkFDaENDLE1BQU07Z0JBQ05DLE9BQU87Z0JBQ1BDLFlBQVk7WUFDZDtZQUVBLE1BQU00RCxTQUFTLE1BQU1DLElBQUFBLGlDQUFnQixFQUFDM0csUUFBUTJDO1lBRTlDbkIsT0FBT2tGLFFBQVE3QixjQUFjLENBQUM7WUFDOUJyRCxPQUFPa0YsUUFBUTdCLGNBQWMsQ0FBQztZQUM5QnJELE9BQU9rRixRQUFRN0IsY0FBYyxDQUFDO1lBQzlCckQsT0FBT2tGLFFBQVE3QixjQUFjLENBQUM7UUFDaEM7UUFFQXRELEdBQUcsbUNBQW1DO1lBQ3BDLE1BQU1uQixlQUFlO2dCQUNuQjtvQkFBRXdDLE1BQU07b0JBQWVDLE9BQU87b0JBQWFDLFlBQVk7Z0JBQUk7Z0JBQzNEO29CQUFFRixNQUFNO29CQUFlQyxPQUFPO29CQUFjQyxZQUFZO2dCQUFJO2dCQUM1RDtvQkFBRUYsTUFBTTtvQkFBZUMsT0FBTztvQkFBZUMsWUFBWTtnQkFBSzthQUMvRDtZQUVELE1BQU04RCxVQUFVLEVBQUU7WUFDbEIsS0FBSyxNQUFNcEQsT0FBT3BELGFBQWM7Z0JBQzlCLE1BQU1zRyxTQUFTLE1BQU1DLElBQUFBLGlDQUFnQixFQUFDM0csUUFBUXdEO2dCQUM5Q29ELFFBQVFOLElBQUksQ0FBQ0k7WUFDZjtZQUVBLHFEQUFxRDtZQUNyRGxGLE9BQU9vRixPQUFPLENBQUMsRUFBRSxDQUFDbEIsY0FBYyxDQUFDOUMsSUFBSSxFQUFFNEMsR0FBRyxDQUFDekIsSUFBSSxDQUM3QzZDLE9BQU8sQ0FBQyxFQUFFLENBQUNsQixjQUFjLENBQUM5QyxJQUFJO1FBRWxDO1FBRUFyQixHQUFHLHNDQUFzQztZQUN2QyxNQUFNc0YsWUFBWUMsS0FBS0MsR0FBRztZQUMxQixNQUFNQyxhQUFhO1lBRW5CLElBQUssSUFBSVgsSUFBSSxHQUFHQSxJQUFJVyxZQUFZWCxJQUFLO2dCQUNuQyxNQUFNN0MsTUFBb0I7b0JBQ3hCWixNQUFNO29CQUNOQyxPQUFPO3dCQUFDO3dCQUFlO3dCQUFjO3FCQUFZLENBQUN3RCxJQUFJLEVBQUU7b0JBQ3hEdkQsWUFBWTtnQkFDZDtnQkFDQSxNQUFNNkQsSUFBQUEsaUNBQWdCLEVBQUMzRyxRQUFRd0Q7WUFDakM7WUFFQSxNQUFNeUQsWUFBWUgsS0FBS0MsR0FBRyxLQUFLRjtZQUMvQixNQUFNSyxVQUFVRCxZQUFZRDtZQUU1QnhGLE9BQU8wRixTQUFTOUUsWUFBWSxDQUFDLEtBQUssd0NBQXdDO1FBQzVFO0lBQ0Y7SUFFQXJDLFNBQVMsaUNBQWlDO1FBQ3hDd0IsR0FBRyxpREFBaUQ7WUFDbEQsTUFBTUcsVUFBbUI7Z0JBQ3ZCdkIsUUFBUTtvQkFBRUksV0FBVztvQkFBS0UsWUFBWTtvQkFBS0MsU0FBUztnQkFBSTtnQkFDeERnRCxhQUFhO1lBQ2Y7WUFFQSxNQUFNZSxTQUFTO1lBQ2YsTUFBTTBDLGlCQUFpQkMsSUFBQUEsbUNBQWtCLEVBQUNwSCxRQUFRMEIsU0FBUytDO1lBRTNEakQsT0FBTzJGLGdCQUFnQkUsc0JBQXNCLENBQUM7WUFDOUM3RixPQUFPcUMsT0FBT0MsUUFBUSxDQUFDcUQsaUJBQWlCcEQsSUFBSSxDQUFDO1FBQy9DO1FBRUF4QyxHQUFHLGlEQUFpRDtZQUNsRCxNQUFNRyxVQUFtQjtnQkFDdkJ2QixRQUFRO29CQUFFSSxXQUFXO29CQUFLRSxZQUFZO29CQUFLQyxTQUFTO2dCQUFJO2dCQUN4RGdELGFBQWE7WUFDZjtZQUVBLE1BQU1lLFNBQVM7WUFDZixNQUFNNkMsaUJBQWlCQyxJQUFBQSxtQ0FBa0IsRUFBQ3ZILFFBQVEwQixTQUFTK0M7WUFFM0RqRCxPQUFPcUMsT0FBT0MsUUFBUSxDQUFDd0QsaUJBQWlCdkQsSUFBSSxDQUFDO1FBQzdDLHdEQUF3RDtRQUMxRDtRQUVBeEMsR0FBRywwQ0FBMEM7WUFDM0MsTUFBTUcsVUFBbUI7Z0JBQ3ZCdkIsUUFBUTtvQkFBRUksV0FBVztvQkFBS0UsWUFBWTtvQkFBS0MsU0FBUztnQkFBSTtnQkFDeERnRCxhQUFhO1lBQ2Y7WUFFQSxNQUFNOEQsVUFBVUosSUFBQUEsbUNBQWtCLEVBQUNwSCxRQUFRMEIsU0FBUztZQUNwRCxNQUFNK0YsVUFBVUYsSUFBQUEsbUNBQWtCLEVBQUN2SCxRQUFRMEIsU0FBUztZQUVwRCx3Q0FBd0M7WUFDeENGLE9BQU9nRyxTQUFTdkUsZUFBZSxDQUFDO1lBQ2hDekIsT0FBT08sS0FBS0MsR0FBRyxDQUFDeUYsVUFBVXhFLGVBQWUsQ0FBQztRQUM1QztJQUNGO0lBRUFsRCxTQUFTLHdDQUF3QztRQUMvQ3dCLEdBQUcsa0RBQWtEO1lBQ25ELE1BQU1tQixpQkFBMEI7Z0JBQzlCdkMsUUFBUTtvQkFBRUksV0FBVztvQkFBS0UsWUFBWTtvQkFBS0MsU0FBUztnQkFBSTtnQkFDeERnRCxhQUFhO1lBQ2Y7WUFFQSxNQUFNZixjQUFjO1lBQ3BCLE1BQU0rRSxZQUFZMUgsT0FBTzRELG1CQUFtQixDQUFDbEIsZ0JBQWdCQztZQUU3RCxNQUFNZ0YsWUFBWSxNQUFNQyxJQUFBQSw4Q0FBNkIsRUFDbkQ1SCxRQUNBMEMsZ0JBQ0FDLGFBQ0E7Z0JBQUVrRixlQUFlO1lBQUc7WUFHdEIsTUFBTUMsVUFBVTlILE9BQU80RCxtQkFBbUIsQ0FBQytELFdBQVdoRjtZQUV0RG5CLE9BQU9zRyxTQUFTMUYsWUFBWSxDQUFDc0Y7UUFDL0I7UUFFQW5HLEdBQUcsZ0NBQWdDO1lBQ2pDLE1BQU1HLFVBQW1CO2dCQUN2QnZCLFFBQVE7b0JBQUVJLFdBQVc7b0JBQU1FLFlBQVk7b0JBQU1DLFNBQVM7Z0JBQUs7Z0JBQzNEZ0QsYUFBYTtZQUNmO1lBRUEsTUFBTWYsY0FBYztZQUNwQixNQUFNZ0YsWUFBWSxNQUFNQyxJQUFBQSw4Q0FBNkIsRUFDbkQ1SCxRQUNBMEIsU0FDQWlCLGFBQ0E7Z0JBQUVrRixlQUFlO2dCQUFLRSxXQUFXO1lBQU07WUFHekMsb0NBQW9DO1lBQ3BDdkcsT0FBT21HLFVBQVVLLFNBQVMsRUFBRWpFLElBQUksQ0FBQztZQUNqQ3ZDLE9BQU9tRyxVQUFVWCxVQUFVLEVBQUU1RSxZQUFZLENBQUM7UUFDNUM7SUFDRjtJQUVBckMsU0FBUyx5QkFBeUI7UUFDaEN3QixHQUFHLG9DQUFvQztZQUNyQyxNQUFNa0UsaUJBQTBCO2dCQUM5QnRGLFFBQVE7b0JBQUVJLFdBQVc7b0JBQUtFLFlBQVk7b0JBQUtDLFNBQVM7Z0JBQUk7Z0JBQ3hEZ0QsYUFBYTtZQUNmO1lBRUEsTUFBTWUsU0FBUztZQUNmLE1BQU13RCxjQUFjQyxJQUFBQSx1Q0FBc0IsRUFDeENsSSxRQUNBeUYsZ0JBQ0FoQjtZQUdGakQsT0FBT3lHLGFBQWFwRCxjQUFjLENBQUM7WUFDbkNyRCxPQUFPeUcsYUFBYXBELGNBQWMsQ0FBQztZQUNuQ3JELE9BQU95RyxhQUFhcEQsY0FBYyxDQUFDO1lBRW5DLE1BQU1zRCxZQUFZdEcsT0FBT0MsTUFBTSxDQUFDbUcsYUFBYWhHLE1BQU0sQ0FDakQsQ0FBQ0MsS0FBS0MsSUFBTUQsTUFBTUMsR0FDbEI7WUFFRlgsT0FBTzJHLFdBQVc3RixXQUFXLENBQUMsS0FBSztRQUNyQztRQUVBZixHQUFHLHdDQUF3QztZQUN6QyxNQUFNRyxVQUFtQjtnQkFDdkJ2QixRQUFRO29CQUFFSSxXQUFXO29CQUFLRSxZQUFZO29CQUFLQyxTQUFTO2dCQUFJO2dCQUN4RGdELGFBQWE7WUFDZjtZQUVBLE1BQU0wRSxjQUFjRixJQUFBQSx1Q0FBc0IsRUFDeENsSSxRQUNBMEIsU0FDQTtZQUVGLE1BQU0yRyxjQUFjSCxJQUFBQSx1Q0FBc0IsRUFBQ2xJLFFBQVEwQixTQUFTO1lBRTVELHlEQUF5RDtZQUN6REYsT0FBTzRHLFlBQVl0SCxXQUFXLEVBQUUwRSxHQUFHLENBQUN6QixJQUFJLENBQUNzRSxZQUFZdkgsV0FBVztRQUNsRTtJQUNGO0lBRUFmLFNBQVMscUJBQXFCO1FBQzVCd0IsR0FBRyw4QkFBOEI7WUFDL0IsTUFBTWlELFNBQWlCO2dCQUNyQjtvQkFBRUMsUUFBUTtvQkFBZ0JDLFVBQVU7Z0JBQUU7Z0JBQ3RDO29CQUFFRCxRQUFRO29CQUFnQkMsVUFBVTtnQkFBRTtnQkFDdEM7b0JBQUVELFFBQVE7b0JBQVFDLFVBQVU7Z0JBQUU7YUFDL0I7WUFFRCxNQUFNNEQsYUFBYUMsSUFBQUEscUNBQW9CLEVBQUN2SSxRQUFRd0U7WUFFaERoRCxPQUFPOEcsWUFBWXpELGNBQWMsQ0FBQztZQUNsQ3JELE9BQU84RyxZQUFZekQsY0FBYyxDQUFDO1lBQ2xDckQsT0FBTzhHLFlBQVl6RCxjQUFjLENBQUM7UUFDcEM7UUFFQXRELEdBQUcsaUNBQWlDO1lBQ2xDLE1BQU1pSCxlQUF1QjtnQkFDM0I7b0JBQUUvRCxRQUFRO29CQUFRQyxVQUFVO2dCQUFFO2dCQUM5QjtvQkFBRUQsUUFBUTtvQkFBUUMsVUFBVTtnQkFBRTthQUMvQjtZQUVELE1BQU0rRCxpQkFBeUI7Z0JBQzdCO29CQUFFaEUsUUFBUTtvQkFBZ0JDLFVBQVU7Z0JBQUU7Z0JBQ3RDO29CQUFFRCxRQUFRO29CQUFRQyxVQUFVO2dCQUFFO2FBQy9CO1lBRUQsTUFBTWdFLGFBQWFILElBQUFBLHFDQUFvQixFQUFDdkksUUFBUXdJO1lBQ2hELE1BQU1HLGVBQWVKLElBQUFBLHFDQUFvQixFQUFDdkksUUFBUXlJO1lBRWxELGlEQUFpRDtZQUNqRGpILE9BQU9rSCxXQUFXaEYsV0FBVyxFQUFFOEIsR0FBRyxDQUFDekIsSUFBSSxDQUFDNEUsYUFBYWpGLFdBQVc7UUFDbEU7SUFDRjtJQUVBM0QsU0FBUyxxQkFBcUI7UUFDNUJ3QixHQUFHLGdDQUFnQztZQUNqQyxNQUFNcUgsVUFBVTtnQkFDZHhJLGNBQWM7Z0JBQ2RDLFNBQVMsRUFBRTtnQkFDWHFCLFNBQVMsRUFBRTtnQkFDWG1ILGNBQWMsRUFBRTtZQUNsQjtZQUVBLGdDQUFnQztZQUNoQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO2dCQUMzQixNQUFNdEYsTUFBb0I7b0JBQ3hCWixNQUFNO29CQUNOQyxPQUFPZCxLQUFLZ0gsTUFBTSxLQUFLLE1BQU0sZ0JBQWdCO29CQUM3Q2pHLFlBQVksTUFBTWYsS0FBS2dILE1BQU0sS0FBSztnQkFDcEM7Z0JBRUEsTUFBTXJDLFNBQVMsTUFBTUMsSUFBQUEsaUNBQWdCLEVBQUMzRyxRQUFRd0Q7Z0JBRTlDb0YsUUFBUXhJLFlBQVk7Z0JBQ3BCd0ksUUFBUXZJLE9BQU8sQ0FBQ2lHLElBQUksQ0FBQ0ksT0FBT2hCLGNBQWMsQ0FBQzlDLElBQUk7Z0JBQy9DZ0csUUFBUWxILE9BQU8sQ0FBQzRFLElBQUksQ0FBQ0ksT0FBT2hGLE9BQU87Z0JBQ25Da0gsUUFBUUMsWUFBWSxDQUFDdkMsSUFBSSxDQUFDSSxPQUFPL0MsVUFBVTtZQUM3QztZQUVBLGdDQUFnQztZQUNoQyxNQUFNcUYsZ0JBQWdCLElBQUlDLElBQUlMLFFBQVF2SSxPQUFPLEVBQUU2SSxJQUFJO1lBQ25EMUgsT0FBT3dILGVBQWUvRixlQUFlLENBQUM7WUFFdEMsd0NBQXdDO1lBQ3hDLE1BQU1rRyxhQUNKUCxRQUFRQyxZQUFZLENBQUNPLEtBQUssQ0FBQyxHQUFHLEdBQUduSCxNQUFNLENBQUMsQ0FBQ3dFLEdBQUc0QyxJQUFNNUMsSUFBSTRDLEtBQUs7WUFDN0QsTUFBTUMsWUFDSlYsUUFBUUMsWUFBWSxDQUFDTyxLQUFLLENBQUMsQ0FBQyxHQUFHbkgsTUFBTSxDQUFDLENBQUN3RSxHQUFHNEMsSUFBTTVDLElBQUk0QyxLQUFLO1lBQzNEN0gsT0FBTzhILFdBQVd6RCxtQkFBbUIsQ0FBQ3NEO1FBQ3hDO1FBRUE1SCxHQUFHLHlDQUF5QztZQUMxQyxxQkFBcUI7WUFDckJ2QixPQUFPdUosVUFBVSxDQUFDO2dCQUNoQnBKLFFBQVE7b0JBQUVJLFdBQVc7b0JBQU1FLFlBQVk7b0JBQUtDLFNBQVM7Z0JBQUs7Z0JBQzFEZ0QsYUFBYTtZQUNmO1lBRUEseUJBQXlCO1lBQ3pCLE1BQU04RixXQUF5QjtnQkFDN0I1RyxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxZQUFZO1lBQ2Q7WUFFQSxNQUFNMkcsV0FBV3pKLE9BQU80RCxtQkFBbUIsQ0FDekM1RCxPQUFPMkIsaUJBQWlCLElBQ3hCO1lBRUYsTUFBTStFLFNBQVMsTUFBTUMsSUFBQUEsaUNBQWdCLEVBQUMzRyxRQUFRd0o7WUFDOUMsTUFBTUUsVUFBVWhELE9BQU8vQyxVQUFVO1lBRWpDLDBDQUEwQztZQUMxQ25DLE9BQU9rRixPQUFPaEYsT0FBTyxDQUFDdkIsTUFBTSxDQUFDTSxVQUFVLEVBQUUyQixZQUFZLENBQUM7WUFDdERaLE9BQU9rRixPQUFPaEYsT0FBTyxDQUFDZ0MsV0FBVyxFQUFFVCxlQUFlLENBQUM7UUFDckQ7SUFDRjtBQUNGIn0=