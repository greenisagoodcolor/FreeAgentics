ca30d16501faa8571aa5e90a0759c4b0
// compression-worker.ts
// Web Worker for handling data compression/decompression
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// Simple compression implementation using built-in compression
class CompressionUtils {
    static async compress(data, options = {
        level: 6
    }) {
        const jsonString = JSON.stringify(data);
        const encoder = new TextEncoder();
        const uint8Array = encoder.encode(jsonString);
        // Use CompressionStream if available (modern browsers)
        if ("CompressionStream" in window) {
            const cs = new CompressionStream("gzip");
            const writer = cs.writable.getWriter();
            const reader = cs.readable.getReader();
            writer.write(uint8Array);
            writer.close();
            const chunks = [];
            let done = false;
            while(!done){
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) chunks.push(value);
            }
            // Combine chunks
            const totalLength = chunks.reduce((sum, chunk)=>sum + chunk.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks){
                result.set(chunk, offset);
                offset += chunk.length;
            }
            return result;
        } else {
            // Fallback: simple compression using string manipulation
            return this.fallbackCompress(uint8Array);
        }
    }
    static async decompress(compressedData) {
        if ("DecompressionStream" in window) {
            const ds = new DecompressionStream("gzip");
            const writer = ds.writable.getWriter();
            const reader = ds.readable.getReader();
            writer.write(compressedData);
            writer.close();
            const chunks = [];
            let done = false;
            while(!done){
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) chunks.push(value);
            }
            // Combine chunks
            const totalLength = chunks.reduce((sum, chunk)=>sum + chunk.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks){
                result.set(chunk, offset);
                offset += chunk.length;
            }
            const decoder = new TextDecoder();
            const jsonString = decoder.decode(result);
            return JSON.parse(jsonString);
        } else {
            // Fallback decompression
            const decompressed = this.fallbackDecompress(compressedData);
            const decoder = new TextDecoder();
            const jsonString = decoder.decode(decompressed);
            return JSON.parse(jsonString);
        }
    }
    static fallbackCompress(data) {
        // Simple RLE (Run Length Encoding) compression
        const result = [];
        let i = 0;
        while(i < data.length){
            let count = 1;
            const current = data[i];
            while(i + count < data.length && data[i + count] === current && count < 255){
                count++;
            }
            if (count > 3 || current === 0) {
                // Use RLE for sequences of 4+ or zeros
                result.push(0, count, current);
            } else {
                // Store as-is for small sequences
                for(let j = 0; j < count; j++){
                    result.push(current);
                }
            }
            i += count;
        }
        return new Uint8Array(result);
    }
    static fallbackDecompress(data) {
        const result = [];
        let i = 0;
        while(i < data.length){
            if (data[i] === 0 && i + 2 < data.length) {
                // RLE sequence: 0, count, value
                const count = data[i + 1];
                const value = data[i + 2];
                for(let j = 0; j < count; j++){
                    result.push(value);
                }
                i += 3;
            } else {
                result.push(data[i]);
                i++;
            }
        }
        return new Uint8Array(result);
    }
    static calculateMetrics(original, compressed, processingTime) {
        const originalSize = JSON.stringify(original).length;
        const compressedSize = compressed.length;
        return {
            originalSize,
            compressedSize,
            compressionRatio: (1 - compressedSize / originalSize) * 100,
            processingTime
        };
    }
}
// Worker message handler
self.addEventListener("message", async (event)=>{
    const { id, type, data, options = {} } = event.data;
    const startTime = performance.now();
    try {
        if (type === "compress") {
            const compressed = await CompressionUtils.compress(data, options);
            const processingTime = performance.now() - startTime;
            const metrics = CompressionUtils.calculateMetrics(data, compressed, processingTime);
            const response = {
                id,
                success: true,
                data: compressed,
                metrics
            };
            self.postMessage(response);
        } else if (type === "decompress") {
            const decompressed = await CompressionUtils.decompress(data);
            const processingTime = performance.now() - startTime;
            const response = {
                id,
                success: true,
                data: decompressed,
                metrics: {
                    originalSize: data.length,
                    compressedSize: JSON.stringify(decompressed).length,
                    compressionRatio: 0,
                    processingTime
                }
            };
            self.postMessage(response);
        } else {
            throw new Error(`Unknown compression type: ${type}`);
        }
    } catch (error) {
        const response = {
            id,
            success: false,
            error: error instanceof Error ? error.message : "Unknown error"
        };
        self.postMessage(response);
    }
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvd29ya2Vycy9jb21wcmVzc2lvbi13b3JrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29tcHJlc3Npb24td29ya2VyLnRzXG4vLyBXZWIgV29ya2VyIGZvciBoYW5kbGluZyBkYXRhIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb25cblxuaW50ZXJmYWNlIENvbXByZXNzaW9uTWVzc2FnZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHR5cGU6IFwiY29tcHJlc3NcIiB8IFwiZGVjb21wcmVzc1wiO1xuICBkYXRhOiBhbnk7XG4gIG9wdGlvbnM/OiB7XG4gICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgZm9ybWF0PzogXCJnemlwXCIgfCBcImRlZmxhdGVcIjtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIENvbXByZXNzaW9uUmVzcG9uc2Uge1xuICBpZDogc3RyaW5nO1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhPzogYW55O1xuICBlcnJvcj86IHN0cmluZztcbiAgbWV0cmljcz86IHtcbiAgICBvcmlnaW5hbFNpemU6IG51bWJlcjtcbiAgICBjb21wcmVzc2VkU2l6ZTogbnVtYmVyO1xuICAgIGNvbXByZXNzaW9uUmF0aW86IG51bWJlcjtcbiAgICBwcm9jZXNzaW5nVGltZTogbnVtYmVyO1xuICB9O1xufVxuXG4vLyBTaW1wbGUgY29tcHJlc3Npb24gaW1wbGVtZW50YXRpb24gdXNpbmcgYnVpbHQtaW4gY29tcHJlc3Npb25cbmNsYXNzIENvbXByZXNzaW9uVXRpbHMge1xuICBzdGF0aWMgYXN5bmMgY29tcHJlc3MoXG4gICAgZGF0YTogYW55LFxuICAgIG9wdGlvbnM6IHsgbGV2ZWw/OiBudW1iZXI7IGZvcm1hdD86IFwiZ3ppcFwiIHwgXCJkZWZsYXRlXCIgfSA9IHsgbGV2ZWw6IDYgfSxcbiAgKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCB1aW50OEFycmF5ID0gZW5jb2Rlci5lbmNvZGUoanNvblN0cmluZyk7XG5cbiAgICAvLyBVc2UgQ29tcHJlc3Npb25TdHJlYW0gaWYgYXZhaWxhYmxlIChtb2Rlcm4gYnJvd3NlcnMpXG4gICAgaWYgKFwiQ29tcHJlc3Npb25TdHJlYW1cIiBpbiB3aW5kb3cpIHtcbiAgICAgIGNvbnN0IGNzID0gbmV3IENvbXByZXNzaW9uU3RyZWFtKFwiZ3ppcFwiKTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IGNzLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgY29uc3QgcmVhZGVyID0gY3MucmVhZGFibGUuZ2V0UmVhZGVyKCk7XG5cbiAgICAgIHdyaXRlci53cml0ZSh1aW50OEFycmF5KTtcbiAgICAgIHdyaXRlci5jbG9zZSgpO1xuXG4gICAgICBjb25zdCBjaHVua3M6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmU6IHJlYWRlckRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGRvbmUgPSByZWFkZXJEb25lO1xuICAgICAgICBpZiAodmFsdWUpIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tYmluZSBjaHVua3NcbiAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gY2h1bmtzLnJlZHVjZSgoc3VtLCBjaHVuaykgPT4gc3VtICsgY2h1bmsubGVuZ3RoLCAwKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICByZXN1bHQuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjazogc2ltcGxlIGNvbXByZXNzaW9uIHVzaW5nIHN0cmluZyBtYW5pcHVsYXRpb25cbiAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrQ29tcHJlc3ModWludDhBcnJheSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGRlY29tcHJlc3MoY29tcHJlc3NlZERhdGE6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChcIkRlY29tcHJlc3Npb25TdHJlYW1cIiBpbiB3aW5kb3cpIHtcbiAgICAgIGNvbnN0IGRzID0gbmV3IERlY29tcHJlc3Npb25TdHJlYW0oXCJnemlwXCIpO1xuICAgICAgY29uc3Qgd3JpdGVyID0gZHMud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICBjb25zdCByZWFkZXIgPSBkcy5yZWFkYWJsZS5nZXRSZWFkZXIoKTtcblxuICAgICAgd3JpdGVyLndyaXRlKGNvbXByZXNzZWREYXRhKTtcbiAgICAgIHdyaXRlci5jbG9zZSgpO1xuXG4gICAgICBjb25zdCBjaHVua3M6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmU6IHJlYWRlckRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGRvbmUgPSByZWFkZXJEb25lO1xuICAgICAgICBpZiAodmFsdWUpIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tYmluZSBjaHVua3NcbiAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gY2h1bmtzLnJlZHVjZSgoc3VtLCBjaHVuaykgPT4gc3VtICsgY2h1bmsubGVuZ3RoLCAwKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICByZXN1bHQuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gZGVjb2Rlci5kZWNvZGUocmVzdWx0KTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBkZWNvbXByZXNzaW9uXG4gICAgICBjb25zdCBkZWNvbXByZXNzZWQgPSB0aGlzLmZhbGxiYWNrRGVjb21wcmVzcyhjb21wcmVzc2VkRGF0YSk7XG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gZGVjb2Rlci5kZWNvZGUoZGVjb21wcmVzc2VkKTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGZhbGxiYWNrQ29tcHJlc3MoZGF0YTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICAgIC8vIFNpbXBsZSBSTEUgKFJ1biBMZW5ndGggRW5jb2RpbmcpIGNvbXByZXNzaW9uXG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICAgIGxldCBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIGxldCBjb3VudCA9IDE7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZGF0YVtpXTtcblxuICAgICAgd2hpbGUgKFxuICAgICAgICBpICsgY291bnQgPCBkYXRhLmxlbmd0aCAmJlxuICAgICAgICBkYXRhW2kgKyBjb3VudF0gPT09IGN1cnJlbnQgJiZcbiAgICAgICAgY291bnQgPCAyNTVcbiAgICAgICkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPiAzIHx8IGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgLy8gVXNlIFJMRSBmb3Igc2VxdWVuY2VzIG9mIDQrIG9yIHplcm9zXG4gICAgICAgIHJlc3VsdC5wdXNoKDAsIGNvdW50LCBjdXJyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0b3JlIGFzLWlzIGZvciBzbWFsbCBzZXF1ZW5jZXNcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSArPSBjb3VudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGZhbGxiYWNrRGVjb21wcmVzcyhkYXRhOiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICAgIGxldCBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSAwICYmIGkgKyAyIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gUkxFIHNlcXVlbmNlOiAwLCBjb3VudCwgdmFsdWVcbiAgICAgICAgY29uc3QgY291bnQgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChkYXRhW2ldKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xuICB9XG5cbiAgc3RhdGljIGNhbGN1bGF0ZU1ldHJpY3MoXG4gICAgb3JpZ2luYWw6IGFueSxcbiAgICBjb21wcmVzc2VkOiBVaW50OEFycmF5LFxuICAgIHByb2Nlc3NpbmdUaW1lOiBudW1iZXIsXG4gICkge1xuICAgIGNvbnN0IG9yaWdpbmFsU2l6ZSA9IEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsKS5sZW5ndGg7XG4gICAgY29uc3QgY29tcHJlc3NlZFNpemUgPSBjb21wcmVzc2VkLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBvcmlnaW5hbFNpemUsXG4gICAgICBjb21wcmVzc2VkU2l6ZSxcbiAgICAgIGNvbXByZXNzaW9uUmF0aW86ICgxIC0gY29tcHJlc3NlZFNpemUgLyBvcmlnaW5hbFNpemUpICogMTAwLFxuICAgICAgcHJvY2Vzc2luZ1RpbWUsXG4gICAgfTtcbiAgfVxufVxuXG4vLyBXb3JrZXIgbWVzc2FnZSBoYW5kbGVyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXG4gIFwibWVzc2FnZVwiLFxuICBhc3luYyAoZXZlbnQ6IE1lc3NhZ2VFdmVudDxDb21wcmVzc2lvbk1lc3NhZ2U+KSA9PiB7XG4gICAgY29uc3QgeyBpZCwgdHlwZSwgZGF0YSwgb3B0aW9ucyA9IHt9IH0gPSBldmVudC5kYXRhO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlID09PSBcImNvbXByZXNzXCIpIHtcbiAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IGF3YWl0IENvbXByZXNzaW9uVXRpbHMuY29tcHJlc3MoZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBDb21wcmVzc2lvblV0aWxzLmNhbGN1bGF0ZU1ldHJpY3MoXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjb21wcmVzc2VkLFxuICAgICAgICAgIHByb2Nlc3NpbmdUaW1lLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlOiBDb21wcmVzc2lvblJlc3BvbnNlID0ge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgZGF0YTogY29tcHJlc3NlZCxcbiAgICAgICAgICBtZXRyaWNzLFxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRlY29tcHJlc3NcIikge1xuICAgICAgICBjb25zdCBkZWNvbXByZXNzZWQgPSBhd2FpdCBDb21wcmVzc2lvblV0aWxzLmRlY29tcHJlc3MoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2U6IENvbXByZXNzaW9uUmVzcG9uc2UgPSB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiBkZWNvbXByZXNzZWQsXG4gICAgICAgICAgbWV0cmljczoge1xuICAgICAgICAgICAgb3JpZ2luYWxTaXplOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGNvbXByZXNzZWRTaXplOiBKU09OLnN0cmluZ2lmeShkZWNvbXByZXNzZWQpLmxlbmd0aCxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uUmF0aW86IDAsIC8vIE5vdCBhcHBsaWNhYmxlIGZvciBkZWNvbXByZXNzaW9uXG4gICAgICAgICAgICBwcm9jZXNzaW5nVGltZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbXByZXNzaW9uIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgcmVzcG9uc2U6IENvbXByZXNzaW9uUmVzcG9uc2UgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIsXG4gICAgICB9O1xuXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTtcbiAgICB9XG4gIH0sXG4pO1xuXG4vLyBFeHBvcnQgdHlwZXMgZm9yIFR5cGVTY3JpcHRcbmV4cG9ydCB0eXBlIHsgQ29tcHJlc3Npb25NZXNzYWdlLCBDb21wcmVzc2lvblJlc3BvbnNlIH07XG4iXSwibmFtZXMiOlsiQ29tcHJlc3Npb25VdGlscyIsImNvbXByZXNzIiwiZGF0YSIsIm9wdGlvbnMiLCJsZXZlbCIsImpzb25TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwidWludDhBcnJheSIsImVuY29kZSIsIndpbmRvdyIsImNzIiwiQ29tcHJlc3Npb25TdHJlYW0iLCJ3cml0ZXIiLCJ3cml0YWJsZSIsImdldFdyaXRlciIsInJlYWRlciIsInJlYWRhYmxlIiwiZ2V0UmVhZGVyIiwid3JpdGUiLCJjbG9zZSIsImNodW5rcyIsImRvbmUiLCJ2YWx1ZSIsInJlYWRlckRvbmUiLCJyZWFkIiwicHVzaCIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwic3VtIiwiY2h1bmsiLCJsZW5ndGgiLCJyZXN1bHQiLCJVaW50OEFycmF5Iiwib2Zmc2V0Iiwic2V0IiwiZmFsbGJhY2tDb21wcmVzcyIsImRlY29tcHJlc3MiLCJjb21wcmVzc2VkRGF0YSIsImRzIiwiRGVjb21wcmVzc2lvblN0cmVhbSIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInBhcnNlIiwiZGVjb21wcmVzc2VkIiwiZmFsbGJhY2tEZWNvbXByZXNzIiwiaSIsImNvdW50IiwiY3VycmVudCIsImoiLCJjYWxjdWxhdGVNZXRyaWNzIiwib3JpZ2luYWwiLCJjb21wcmVzc2VkIiwicHJvY2Vzc2luZ1RpbWUiLCJvcmlnaW5hbFNpemUiLCJjb21wcmVzc2VkU2l6ZSIsImNvbXByZXNzaW9uUmF0aW8iLCJzZWxmIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiaWQiLCJ0eXBlIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJtZXRyaWNzIiwicmVzcG9uc2UiLCJzdWNjZXNzIiwicG9zdE1lc3NhZ2UiLCJFcnJvciIsImVycm9yIiwibWVzc2FnZSJdLCJtYXBwaW5ncyI6IkFBQUEsd0JBQXdCO0FBQ3hCLHlEQUF5RDs7Ozs7QUF5QnpELCtEQUErRDtBQUMvRCxNQUFNQTtJQUNKLGFBQWFDLFNBQ1hDLElBQVMsRUFDVEMsVUFBMkQ7UUFBRUMsT0FBTztJQUFFLENBQUMsRUFDbEQ7UUFDckIsTUFBTUMsYUFBYUMsS0FBS0MsU0FBUyxDQUFDTDtRQUNsQyxNQUFNTSxVQUFVLElBQUlDO1FBQ3BCLE1BQU1DLGFBQWFGLFFBQVFHLE1BQU0sQ0FBQ047UUFFbEMsdURBQXVEO1FBQ3ZELElBQUksdUJBQXVCTyxRQUFRO1lBQ2pDLE1BQU1DLEtBQUssSUFBSUMsa0JBQWtCO1lBQ2pDLE1BQU1DLFNBQVNGLEdBQUdHLFFBQVEsQ0FBQ0MsU0FBUztZQUNwQyxNQUFNQyxTQUFTTCxHQUFHTSxRQUFRLENBQUNDLFNBQVM7WUFFcENMLE9BQU9NLEtBQUssQ0FBQ1g7WUFDYkssT0FBT08sS0FBSztZQUVaLE1BQU1DLFNBQXVCLEVBQUU7WUFDL0IsSUFBSUMsT0FBTztZQUVYLE1BQU8sQ0FBQ0EsS0FBTTtnQkFDWixNQUFNLEVBQUVDLEtBQUssRUFBRUQsTUFBTUUsVUFBVSxFQUFFLEdBQUcsTUFBTVIsT0FBT1MsSUFBSTtnQkFDckRILE9BQU9FO2dCQUNQLElBQUlELE9BQU9GLE9BQU9LLElBQUksQ0FBQ0g7WUFDekI7WUFFQSxpQkFBaUI7WUFDakIsTUFBTUksY0FBY04sT0FBT08sTUFBTSxDQUFDLENBQUNDLEtBQUtDLFFBQVVELE1BQU1DLE1BQU1DLE1BQU0sRUFBRTtZQUN0RSxNQUFNQyxTQUFTLElBQUlDLFdBQVdOO1lBQzlCLElBQUlPLFNBQVM7WUFFYixLQUFLLE1BQU1KLFNBQVNULE9BQVE7Z0JBQzFCVyxPQUFPRyxHQUFHLENBQUNMLE9BQU9JO2dCQUNsQkEsVUFBVUosTUFBTUMsTUFBTTtZQUN4QjtZQUVBLE9BQU9DO1FBQ1QsT0FBTztZQUNMLHlEQUF5RDtZQUN6RCxPQUFPLElBQUksQ0FBQ0ksZ0JBQWdCLENBQUM1QjtRQUMvQjtJQUNGO0lBRUEsYUFBYTZCLFdBQVdDLGNBQTBCLEVBQWdCO1FBQ2hFLElBQUkseUJBQXlCNUIsUUFBUTtZQUNuQyxNQUFNNkIsS0FBSyxJQUFJQyxvQkFBb0I7WUFDbkMsTUFBTTNCLFNBQVMwQixHQUFHekIsUUFBUSxDQUFDQyxTQUFTO1lBQ3BDLE1BQU1DLFNBQVN1QixHQUFHdEIsUUFBUSxDQUFDQyxTQUFTO1lBRXBDTCxPQUFPTSxLQUFLLENBQUNtQjtZQUNiekIsT0FBT08sS0FBSztZQUVaLE1BQU1DLFNBQXVCLEVBQUU7WUFDL0IsSUFBSUMsT0FBTztZQUVYLE1BQU8sQ0FBQ0EsS0FBTTtnQkFDWixNQUFNLEVBQUVDLEtBQUssRUFBRUQsTUFBTUUsVUFBVSxFQUFFLEdBQUcsTUFBTVIsT0FBT1MsSUFBSTtnQkFDckRILE9BQU9FO2dCQUNQLElBQUlELE9BQU9GLE9BQU9LLElBQUksQ0FBQ0g7WUFDekI7WUFFQSxpQkFBaUI7WUFDakIsTUFBTUksY0FBY04sT0FBT08sTUFBTSxDQUFDLENBQUNDLEtBQUtDLFFBQVVELE1BQU1DLE1BQU1DLE1BQU0sRUFBRTtZQUN0RSxNQUFNQyxTQUFTLElBQUlDLFdBQVdOO1lBQzlCLElBQUlPLFNBQVM7WUFFYixLQUFLLE1BQU1KLFNBQVNULE9BQVE7Z0JBQzFCVyxPQUFPRyxHQUFHLENBQUNMLE9BQU9JO2dCQUNsQkEsVUFBVUosTUFBTUMsTUFBTTtZQUN4QjtZQUVBLE1BQU1VLFVBQVUsSUFBSUM7WUFDcEIsTUFBTXZDLGFBQWFzQyxRQUFRRSxNQUFNLENBQUNYO1lBQ2xDLE9BQU81QixLQUFLd0MsS0FBSyxDQUFDekM7UUFDcEIsT0FBTztZQUNMLHlCQUF5QjtZQUN6QixNQUFNMEMsZUFBZSxJQUFJLENBQUNDLGtCQUFrQixDQUFDUjtZQUM3QyxNQUFNRyxVQUFVLElBQUlDO1lBQ3BCLE1BQU12QyxhQUFhc0MsUUFBUUUsTUFBTSxDQUFDRTtZQUNsQyxPQUFPekMsS0FBS3dDLEtBQUssQ0FBQ3pDO1FBQ3BCO0lBQ0Y7SUFFQSxPQUFlaUMsaUJBQWlCcEMsSUFBZ0IsRUFBYztRQUM1RCwrQ0FBK0M7UUFDL0MsTUFBTWdDLFNBQW1CLEVBQUU7UUFDM0IsSUFBSWUsSUFBSTtRQUVSLE1BQU9BLElBQUkvQyxLQUFLK0IsTUFBTSxDQUFFO1lBQ3RCLElBQUlpQixRQUFRO1lBQ1osTUFBTUMsVUFBVWpELElBQUksQ0FBQytDLEVBQUU7WUFFdkIsTUFDRUEsSUFBSUMsUUFBUWhELEtBQUsrQixNQUFNLElBQ3ZCL0IsSUFBSSxDQUFDK0MsSUFBSUMsTUFBTSxLQUFLQyxXQUNwQkQsUUFBUSxJQUNSO2dCQUNBQTtZQUNGO1lBRUEsSUFBSUEsUUFBUSxLQUFLQyxZQUFZLEdBQUc7Z0JBQzlCLHVDQUF1QztnQkFDdkNqQixPQUFPTixJQUFJLENBQUMsR0FBR3NCLE9BQU9DO1lBQ3hCLE9BQU87Z0JBQ0wsa0NBQWtDO2dCQUNsQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsT0FBT0UsSUFBSztvQkFDOUJsQixPQUFPTixJQUFJLENBQUN1QjtnQkFDZDtZQUNGO1lBRUFGLEtBQUtDO1FBQ1A7UUFFQSxPQUFPLElBQUlmLFdBQVdEO0lBQ3hCO0lBRUEsT0FBZWMsbUJBQW1COUMsSUFBZ0IsRUFBYztRQUM5RCxNQUFNZ0MsU0FBbUIsRUFBRTtRQUMzQixJQUFJZSxJQUFJO1FBRVIsTUFBT0EsSUFBSS9DLEtBQUsrQixNQUFNLENBQUU7WUFDdEIsSUFBSS9CLElBQUksQ0FBQytDLEVBQUUsS0FBSyxLQUFLQSxJQUFJLElBQUkvQyxLQUFLK0IsTUFBTSxFQUFFO2dCQUN4QyxnQ0FBZ0M7Z0JBQ2hDLE1BQU1pQixRQUFRaEQsSUFBSSxDQUFDK0MsSUFBSSxFQUFFO2dCQUN6QixNQUFNeEIsUUFBUXZCLElBQUksQ0FBQytDLElBQUksRUFBRTtnQkFFekIsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlGLE9BQU9FLElBQUs7b0JBQzlCbEIsT0FBT04sSUFBSSxDQUFDSDtnQkFDZDtnQkFFQXdCLEtBQUs7WUFDUCxPQUFPO2dCQUNMZixPQUFPTixJQUFJLENBQUMxQixJQUFJLENBQUMrQyxFQUFFO2dCQUNuQkE7WUFDRjtRQUNGO1FBRUEsT0FBTyxJQUFJZCxXQUFXRDtJQUN4QjtJQUVBLE9BQU9tQixpQkFDTEMsUUFBYSxFQUNiQyxVQUFzQixFQUN0QkMsY0FBc0IsRUFDdEI7UUFDQSxNQUFNQyxlQUFlbkQsS0FBS0MsU0FBUyxDQUFDK0MsVUFBVXJCLE1BQU07UUFDcEQsTUFBTXlCLGlCQUFpQkgsV0FBV3RCLE1BQU07UUFFeEMsT0FBTztZQUNMd0I7WUFDQUM7WUFDQUMsa0JBQWtCLEFBQUMsQ0FBQSxJQUFJRCxpQkFBaUJELFlBQVcsSUFBSztZQUN4REQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSx5QkFBeUI7QUFDekJJLEtBQUtDLGdCQUFnQixDQUNuQixXQUNBLE9BQU9DO0lBQ0wsTUFBTSxFQUFFQyxFQUFFLEVBQUVDLElBQUksRUFBRTlELElBQUksRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRSxHQUFHMkQsTUFBTTVELElBQUk7SUFDbkQsTUFBTStELFlBQVlDLFlBQVlDLEdBQUc7SUFFakMsSUFBSTtRQUNGLElBQUlILFNBQVMsWUFBWTtZQUN2QixNQUFNVCxhQUFhLE1BQU12RCxpQkFBaUJDLFFBQVEsQ0FBQ0MsTUFBTUM7WUFDekQsTUFBTXFELGlCQUFpQlUsWUFBWUMsR0FBRyxLQUFLRjtZQUMzQyxNQUFNRyxVQUFVcEUsaUJBQWlCcUQsZ0JBQWdCLENBQy9DbkQsTUFDQXFELFlBQ0FDO1lBR0YsTUFBTWEsV0FBZ0M7Z0JBQ3BDTjtnQkFDQU8sU0FBUztnQkFDVHBFLE1BQU1xRDtnQkFDTmE7WUFDRjtZQUVBUixLQUFLVyxXQUFXLENBQUNGO1FBQ25CLE9BQU8sSUFBSUwsU0FBUyxjQUFjO1lBQ2hDLE1BQU1qQixlQUFlLE1BQU0vQyxpQkFBaUJ1QyxVQUFVLENBQUNyQztZQUN2RCxNQUFNc0QsaUJBQWlCVSxZQUFZQyxHQUFHLEtBQUtGO1lBRTNDLE1BQU1JLFdBQWdDO2dCQUNwQ047Z0JBQ0FPLFNBQVM7Z0JBQ1RwRSxNQUFNNkM7Z0JBQ05xQixTQUFTO29CQUNQWCxjQUFjdkQsS0FBSytCLE1BQU07b0JBQ3pCeUIsZ0JBQWdCcEQsS0FBS0MsU0FBUyxDQUFDd0MsY0FBY2QsTUFBTTtvQkFDbkQwQixrQkFBa0I7b0JBQ2xCSDtnQkFDRjtZQUNGO1lBRUFJLEtBQUtXLFdBQVcsQ0FBQ0Y7UUFDbkIsT0FBTztZQUNMLE1BQU0sSUFBSUcsTUFBTSxDQUFDLDBCQUEwQixFQUFFUixLQUFLLENBQUM7UUFDckQ7SUFDRixFQUFFLE9BQU9TLE9BQU87UUFDZCxNQUFNSixXQUFnQztZQUNwQ047WUFDQU8sU0FBUztZQUNURyxPQUFPQSxpQkFBaUJELFFBQVFDLE1BQU1DLE9BQU8sR0FBRztRQUNsRDtRQUVBZCxLQUFLVyxXQUFXLENBQUNGO0lBQ25CO0FBQ0YifQ==