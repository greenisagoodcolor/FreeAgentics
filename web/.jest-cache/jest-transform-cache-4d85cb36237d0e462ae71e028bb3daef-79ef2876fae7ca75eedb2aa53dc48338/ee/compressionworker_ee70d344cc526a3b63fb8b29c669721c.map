{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/workers/compression-worker.ts"],"sourcesContent":["// compression-worker.ts\n// Web Worker for handling data compression/decompression\n\ninterface CompressionMessage {\n  id: string;\n  type: \"compress\" | \"decompress\";\n  data: any;\n  options?: {\n    level?: number;\n    format?: \"gzip\" | \"deflate\";\n  };\n}\n\ninterface CompressionResponse {\n  id: string;\n  success: boolean;\n  data?: any;\n  error?: string;\n  metrics?: {\n    originalSize: number;\n    compressedSize: number;\n    compressionRatio: number;\n    processingTime: number;\n  };\n}\n\n// Simple compression implementation using built-in compression\nclass CompressionUtils {\n  static async compress(\n    data: any,\n    options: { level?: number; format?: \"gzip\" | \"deflate\" } = { level: 6 },\n  ): Promise<Uint8Array> {\n    const jsonString = JSON.stringify(data);\n    const encoder = new TextEncoder();\n    const uint8Array = encoder.encode(jsonString);\n\n    // Use CompressionStream if available (modern browsers)\n    if (\"CompressionStream\" in window) {\n      const cs = new CompressionStream(\"gzip\");\n      const writer = cs.writable.getWriter();\n      const reader = cs.readable.getReader();\n\n      writer.write(uint8Array);\n      writer.close();\n\n      const chunks: Uint8Array[] = [];\n      let done = false;\n\n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) chunks.push(value);\n      }\n\n      // Combine chunks\n      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n      const result = new Uint8Array(totalLength);\n      let offset = 0;\n\n      for (const chunk of chunks) {\n        result.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      return result;\n    } else {\n      // Fallback: simple compression using string manipulation\n      return this.fallbackCompress(uint8Array);\n    }\n  }\n\n  static async decompress(compressedData: Uint8Array): Promise<any> {\n    if (\"DecompressionStream\" in window) {\n      const ds = new DecompressionStream(\"gzip\");\n      const writer = ds.writable.getWriter();\n      const reader = ds.readable.getReader();\n\n      writer.write(compressedData);\n      writer.close();\n\n      const chunks: Uint8Array[] = [];\n      let done = false;\n\n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) chunks.push(value);\n      }\n\n      // Combine chunks\n      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n      const result = new Uint8Array(totalLength);\n      let offset = 0;\n\n      for (const chunk of chunks) {\n        result.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      const decoder = new TextDecoder();\n      const jsonString = decoder.decode(result);\n      return JSON.parse(jsonString);\n    } else {\n      // Fallback decompression\n      const decompressed = this.fallbackDecompress(compressedData);\n      const decoder = new TextDecoder();\n      const jsonString = decoder.decode(decompressed);\n      return JSON.parse(jsonString);\n    }\n  }\n\n  private static fallbackCompress(data: Uint8Array): Uint8Array {\n    // Simple RLE (Run Length Encoding) compression\n    const result: number[] = [];\n    let i = 0;\n\n    while (i < data.length) {\n      let count = 1;\n      const current = data[i];\n\n      while (\n        i + count < data.length &&\n        data[i + count] === current &&\n        count < 255\n      ) {\n        count++;\n      }\n\n      if (count > 3 || current === 0) {\n        // Use RLE for sequences of 4+ or zeros\n        result.push(0, count, current);\n      } else {\n        // Store as-is for small sequences\n        for (let j = 0; j < count; j++) {\n          result.push(current);\n        }\n      }\n\n      i += count;\n    }\n\n    return new Uint8Array(result);\n  }\n\n  private static fallbackDecompress(data: Uint8Array): Uint8Array {\n    const result: number[] = [];\n    let i = 0;\n\n    while (i < data.length) {\n      if (data[i] === 0 && i + 2 < data.length) {\n        // RLE sequence: 0, count, value\n        const count = data[i + 1];\n        const value = data[i + 2];\n\n        for (let j = 0; j < count; j++) {\n          result.push(value);\n        }\n\n        i += 3;\n      } else {\n        result.push(data[i]);\n        i++;\n      }\n    }\n\n    return new Uint8Array(result);\n  }\n\n  static calculateMetrics(\n    original: any,\n    compressed: Uint8Array,\n    processingTime: number,\n  ) {\n    const originalSize = JSON.stringify(original).length;\n    const compressedSize = compressed.length;\n\n    return {\n      originalSize,\n      compressedSize,\n      compressionRatio: (1 - compressedSize / originalSize) * 100,\n      processingTime,\n    };\n  }\n}\n\n// Worker message handler\nself.addEventListener(\n  \"message\",\n  async (event: MessageEvent<CompressionMessage>) => {\n    const { id, type, data, options = {} } = event.data;\n    const startTime = performance.now();\n\n    try {\n      if (type === \"compress\") {\n        const compressed = await CompressionUtils.compress(data, options);\n        const processingTime = performance.now() - startTime;\n        const metrics = CompressionUtils.calculateMetrics(\n          data,\n          compressed,\n          processingTime,\n        );\n\n        const response: CompressionResponse = {\n          id,\n          success: true,\n          data: compressed,\n          metrics,\n        };\n\n        self.postMessage(response);\n      } else if (type === \"decompress\") {\n        const decompressed = await CompressionUtils.decompress(data);\n        const processingTime = performance.now() - startTime;\n\n        const response: CompressionResponse = {\n          id,\n          success: true,\n          data: decompressed,\n          metrics: {\n            originalSize: data.length,\n            compressedSize: JSON.stringify(decompressed).length,\n            compressionRatio: 0, // Not applicable for decompression\n            processingTime,\n          },\n        };\n\n        self.postMessage(response);\n      } else {\n        throw new Error(`Unknown compression type: ${type}`);\n      }\n    } catch (error) {\n      const response: CompressionResponse = {\n        id,\n        success: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n\n      self.postMessage(response);\n    }\n  },\n);\n\n// Export types for TypeScript\nexport type { CompressionMessage, CompressionResponse };\n"],"names":["CompressionUtils","compress","data","options","level","jsonString","JSON","stringify","encoder","TextEncoder","uint8Array","encode","window","cs","CompressionStream","writer","writable","getWriter","reader","readable","getReader","write","close","chunks","done","value","readerDone","read","push","totalLength","reduce","sum","chunk","length","result","Uint8Array","offset","set","fallbackCompress","decompress","compressedData","ds","DecompressionStream","decoder","TextDecoder","decode","parse","decompressed","fallbackDecompress","i","count","current","j","calculateMetrics","original","compressed","processingTime","originalSize","compressedSize","compressionRatio","self","addEventListener","event","id","type","startTime","performance","now","metrics","response","success","postMessage","Error","error","message"],"mappings":"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"}