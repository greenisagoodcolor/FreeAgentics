{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/hooks/useAutonomousconversations.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useRef } from \"react\";\nimport type { Agent, Conversation } from \"@/lib/types\";\nimport {\n  AutonomousConversationSystem,\n  type TriggerType,\n  type AutonomousConversationOptions,\n} from \"@/lib/autonomous-conversation\";\n\ninterface UseAutonomousConversationsOptions {\n  checkInterval?: number;\n  onConversationStart?: (conversation: Conversation) => void;\n  onConversationEnd?: (conversation: Conversation) => void;\n}\n\nexport function useAutonomousConversations(\n  agents: Agent[],\n  activeConversation: Conversation | null,\n  options: UseAutonomousConversationsOptions = {},\n) {\n  const {\n    checkInterval = 5000,\n    onConversationStart,\n    onConversationEnd,\n  } = options;\n\n  const [isEnabled, setIsEnabled] = useState(true);\n  const [lastTrigger, setLastTrigger] = useState<{\n    type: TriggerType;\n    time: Date;\n    participants: string[];\n    topic?: string;\n  } | null>(null);\n\n  // Create refs for the autonomous system and conversation orchestrator\n  const autonomousSystemRef = useRef<AutonomousConversationSystem>(\n    new AutonomousConversationSystem(),\n  );\n\n  // Check for autonomous conversation triggers periodically\n  useEffect(() => {\n    if (!isEnabled || activeConversation) return;\n\n    console.log(\n      \"Autonomous conversation check running, agents:\",\n      agents.length,\n    );\n\n    // Log the autonomous agents\n    const autonomousAgents = agents.filter((agent) => agent.autonomyEnabled);\n    console.log(\n      \"Autonomous agents:\",\n      autonomousAgents.map((a) => a.name),\n    );\n\n    if (autonomousAgents.length < 2) {\n      console.log(\"Not enough autonomous agents to trigger a conversation\");\n      return;\n    }\n\n    const intervalId = setInterval(() => {\n      // Check for autonomous conversation triggers\n      const { shouldTrigger, participants, trigger, topic } =\n        autonomousSystemRef.current.checkAllTriggers(agents);\n\n      if (shouldTrigger && participants.length >= 2) {\n        console.log(\"Autonomous conversation triggered:\", {\n          trigger,\n          participants: participants.map((a) => a.name),\n          topic,\n        });\n\n        // Create the conversation\n        const newConversation =\n          autonomousSystemRef.current.initiateConversation(\n            participants,\n            trigger,\n            topic,\n          );\n\n        if (newConversation && onConversationStart) {\n          // Record the trigger\n          setLastTrigger({\n            type: trigger,\n            time: new Date(),\n            participants: participants.map((a) => a.id),\n            topic,\n          });\n\n          // Notify parent component\n          onConversationStart(newConversation);\n\n          // Log the new conversation\n          console.log(\"New autonomous conversation created:\", {\n            id: newConversation.id,\n            participants: newConversation.participants,\n            trigger,\n            topic,\n          });\n        } else {\n          console.error(\"Failed to create autonomous conversation\");\n        }\n      }\n    }, checkInterval);\n\n    return () => clearInterval(intervalId);\n  }, [\n    agents,\n    activeConversation,\n    isEnabled,\n    checkInterval,\n    onConversationStart,\n  ]);\n\n  // Handle ending autonomous conversations\n  useEffect(() => {\n    // Only apply to autonomous conversations\n    if (!activeConversation?.isAutonomous) return;\n\n    // Check for maximum message count\n    const checkMessageCount = () => {\n      if (\n        activeConversation &&\n        autonomousSystemRef.current.shouldEndConversation(activeConversation)\n      ) {\n        console.log(\n          `Ending autonomous conversation ${activeConversation.id} due to reaching maximum message count`,\n        );\n        if (onConversationEnd) {\n          onConversationEnd(activeConversation);\n        }\n        return true;\n      }\n      return false;\n    };\n\n    // First check if we should end immediately due to message count\n    if (checkMessageCount()) return;\n\n    // Set a timeout to end the conversation after maxConversationDuration\n    // This only applies to autonomous conversations\n    // Use default timeout of 5 minutes (300000ms) since options is private\n    const defaultMaxConversationDuration = 300000; // 5 minutes\n    const timeout = setTimeout(() => {\n      if (!checkMessageCount() && onConversationEnd) {\n        console.log(\n          `Ending autonomous conversation ${activeConversation.id} due to reaching maximum duration`,\n        );\n        onConversationEnd(activeConversation);\n      }\n    }, defaultMaxConversationDuration);\n\n    return () => clearTimeout(timeout);\n  }, [activeConversation, onConversationEnd]);\n\n  // Function to manually trigger an autonomous conversation\n  const triggerConversation = (\n    participantIds: string[],\n    triggerType: TriggerType = \"user_initiated\",\n    topic?: string,\n  ): Conversation | null => {\n    // Find the agent objects for the given IDs\n    const participants = agents.filter((agent) =>\n      participantIds.includes(agent.id),\n    );\n\n    if (participants.length < 2) {\n      console.error(\n        \"Cannot trigger conversation: Need at least 2 participants\",\n      );\n      return null;\n    }\n\n    // Create the conversation\n    const newConversation = autonomousSystemRef.current.initiateConversation(\n      participants,\n      triggerType,\n      topic,\n    );\n\n    if (newConversation && onConversationStart) {\n      // Record the trigger\n      setLastTrigger({\n        type: triggerType,\n        time: new Date(),\n        participants: participants.map((a) => a.id),\n        topic,\n      });\n\n      // Notify parent component\n      onConversationStart(newConversation);\n    }\n\n    return newConversation;\n  };\n\n  // Function to update autonomous system options\n  const updateOptions = (\n    newOptions: Partial<AutonomousConversationOptions>,\n  ) => {\n    autonomousSystemRef.current.updateOptions(newOptions);\n  };\n\n  return {\n    isEnabled,\n    setIsEnabled,\n    lastTrigger,\n    triggerConversation,\n    updateOptions,\n    autonomousSystem: autonomousSystemRef.current,\n  };\n}\n"],"names":["useAutonomousConversations","agents","activeConversation","options","checkInterval","onConversationStart","onConversationEnd","isEnabled","setIsEnabled","useState","lastTrigger","setLastTrigger","autonomousSystemRef","useRef","AutonomousConversationSystem","useEffect","console","log","length","autonomousAgents","filter","agent","autonomyEnabled","map","a","name","intervalId","setInterval","shouldTrigger","participants","trigger","topic","current","checkAllTriggers","newConversation","initiateConversation","type","time","Date","id","error","clearInterval","isAutonomous","checkMessageCount","shouldEndConversation","defaultMaxConversationDuration","timeout","setTimeout","clearTimeout","triggerConversation","participantIds","triggerType","includes","updateOptions","newOptions","autonomousSystem"],"mappings":"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"}