12c50f0b86965cb9adf788cb2b393d4c
/**
 * Phase 1: lib/api-key-service-server.ts Comprehensive Test Suite
 * Target: Complete server-side API key storage functionality
 * Goal: 100% statement coverage for server-side crypto and cookie operations
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock Next.js cookies before importing the module
const mockSet = _globals.jest.fn();
const mockGet = _globals.jest.fn();
const mockDelete = _globals.jest.fn();
const mockCookieStore = {
    set: mockSet,
    get: mockGet,
    delete: mockDelete
};
_globals.jest.mock("next/headers", ()=>({
        cookies: _globals.jest.fn(()=>Promise.resolve(mockCookieStore))
    }));
// Mock crypto module
const mockRandomBytes = _globals.jest.fn();
const mockRandomUUID = _globals.jest.fn();
const mockCreateCipheriv = _globals.jest.fn();
const mockCreateDecipheriv = _globals.jest.fn();
const mockCipherUpdate = _globals.jest.fn();
const mockCipherFinal = _globals.jest.fn();
const mockDecipherUpdate = _globals.jest.fn();
const mockDecipherFinal = _globals.jest.fn();
_globals.jest.mock("crypto", ()=>({
        randomBytes: mockRandomBytes,
        randomUUID: mockRandomUUID,
        createCipheriv: mockCreateCipheriv,
        createDecipheriv: mockCreateDecipheriv
    }));
// Mock Buffer methods
const originalBuffer = global.Buffer;
describe("lib/api-key-service-server.ts - Complete Coverage", ()=>{
    const originalEnv = process.env;
    const originalConsole = {
        log: console.log,
        error: console.error
    };
    let mockConsoleLog;
    let mockConsoleError;
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        // Set up environment variable
        process.env = {
            ...originalEnv,
            ENCRYPTION_KEY: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
            NODE_ENV: "test"
        };
        // Mock console methods
        mockConsoleLog = _globals.jest.fn();
        mockConsoleError = _globals.jest.fn();
        console.log = mockConsoleLog;
        console.error = mockConsoleError;
        // Set up crypto mocks with realistic behavior
        mockRandomBytes.mockReturnValue(Buffer.from("1234567890123456", "hex"));
        mockRandomUUID.mockReturnValue("test-session-id-123");
        // Reset crypto mocks to default successful behavior
        mockCipherUpdate.mockReturnValue(Buffer.from("encrypted_part1", "hex"));
        mockCipherFinal.mockReturnValue(Buffer.from("encrypted_part2", "hex"));
        mockDecipherUpdate.mockReturnValue(Buffer.from("decrypted_data"));
        mockDecipherFinal.mockReturnValue(Buffer.from(""));
        // Mock cipher object
        const mockCipher = {
            update: mockCipherUpdate,
            final: mockCipherFinal
        };
        mockCreateCipheriv.mockReturnValue(mockCipher);
        // Mock decipher object
        const mockDecipher = {
            update: mockDecipherUpdate,
            final: mockDecipherFinal
        };
        mockCreateDecipheriv.mockReturnValue(mockDecipher);
        // Mock Buffer operations more carefully to avoid infinite recursion
        _globals.jest.spyOn(Buffer, "concat").mockImplementation((buffers)=>{
            // Return a simple buffer that represents the concatenated result
            if (buffers.length === 2 && buffers[0].toString() === "decrypted_data") {
                return originalBuffer.from("decrypted_data", "utf8");
            }
            return originalBuffer.from("encrypted_result", "utf8");
        });
    });
    afterEach(()=>{
        process.env = originalEnv;
        console.log = originalConsole.log;
        console.error = originalConsole.error;
        _globals.jest.restoreAllMocks();
    });
    describe("Environment validation", ()=>{
        test("should validate ENCRYPTION_KEY exists during module load", ()=>{
            // This test validates that the environment check exists
            // Since the module is already loaded with the correct env var,
            // we can verify the encryption key is being used
            expect(process.env.ENCRYPTION_KEY).toBeDefined();
            expect(process.env.ENCRYPTION_KEY).toHaveLength(64); // 256-bit key in hex
        });
    });
    describe("storeApiKey", ()=>{
        let storeApiKey;
        beforeEach(async ()=>{
            const module = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/api-key-service-server")));
            storeApiKey = module.storeApiKey;
        });
        test("successfully stores API key with correct encryption", async ()=>{
            const testApiKey = "sk-test-api-key-123";
            const testProvider = "openai";
            const sessionId = await storeApiKey(testProvider, testApiKey);
            // Verify session ID generation
            expect(mockRandomUUID).toHaveBeenCalled();
            expect(sessionId).toBe("test-session-id-123");
            // Verify encryption process
            expect(mockRandomBytes).toHaveBeenCalledWith(16);
            expect(mockCreateCipheriv).toHaveBeenCalledWith("aes-256-cbc", expect.any(Buffer), expect.any(Buffer));
            expect(mockCipherUpdate).toHaveBeenCalledWith(testApiKey);
            expect(mockCipherFinal).toHaveBeenCalled();
            // Verify cookie setting
            expect(mockSet).toHaveBeenCalledWith(`api_key_${testProvider}_${sessionId}`, expect.any(String), {
                httpOnly: true,
                secure: false,
                sameSite: "strict",
                maxAge: 60 * 60 * 24
            });
            // Verify logging
            expect(mockConsoleLog).toHaveBeenCalledWith(`[API-KEY-SERVICE] API key stored with session ID: ${sessionId}`);
        });
        test("sets secure cookie in production environment", async ()=>{
            process.env.NODE_ENV = "production";
            await storeApiKey("anthropic", "test-key");
            expect(mockSet).toHaveBeenCalledWith(expect.any(String), expect.any(String), expect.objectContaining({
                secure: true
            }));
        });
        test("handles storage errors gracefully", async ()=>{
            mockSet.mockImplementation(()=>{
                throw new Error("Cookie storage failed");
            });
            await expect(storeApiKey("openai", "test-key")).rejects.toThrow("Failed to store API key securely");
            expect(mockConsoleError).toHaveBeenCalledWith("[API-KEY-SERVICE] Error storing API key:", expect.any(Error));
        });
        test("handles encryption errors", async ()=>{
            mockCipherUpdate.mockImplementation(()=>{
                throw new Error("Encryption failed");
            });
            await expect(storeApiKey("openai", "test-key")).rejects.toThrow("Failed to store API key securely");
            expect(mockConsoleError).toHaveBeenCalledWith("[API-KEY-SERVICE] Error storing API key:", expect.any(Error));
        });
        test("handles different provider names", async ()=>{
            const providers = [
                "openai",
                "anthropic",
                "openrouter"
            ];
            for (const provider of providers){
                // Reset mocks to ensure clean state for each provider
                mockSet.mockClear();
                await storeApiKey(provider, "test-key");
                expect(mockSet).toHaveBeenCalledWith(expect.stringContaining(`api_key_${provider}_`), expect.any(String), expect.any(Object));
            }
        });
    });
    describe("retrieveApiKey", ()=>{
        let retrieveApiKey;
        beforeEach(async ()=>{
            const module = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/api-key-service-server")));
            retrieveApiKey = module.retrieveApiKey;
        });
        test("successfully retrieves and decrypts API key", async ()=>{
            const testProvider = "openai";
            const testSessionId = "session-123";
            const encryptedValue = "1234567890123456:encrypted_data";
            mockGet.mockReturnValue({
                value: encryptedValue
            });
            // The actual decryption will use our mocked decipher functions
            const result = await retrieveApiKey(testProvider, testSessionId);
            // Verify cookie retrieval
            expect(mockGet).toHaveBeenCalledWith(`api_key_${testProvider}_${testSessionId}`);
            // Verify decryption process
            expect(mockCreateDecipheriv).toHaveBeenCalledWith("aes-256-cbc", expect.any(Buffer), expect.any(Buffer));
            expect(mockDecipherUpdate).toHaveBeenCalled();
            expect(mockDecipherFinal).toHaveBeenCalled();
            // Verify logging
            expect(mockConsoleLog).toHaveBeenCalledWith(`[API-KEY-SERVICE] Retrieved API key for provider: ${testProvider}`);
            // Result should be the decrypted data
            expect(result).toBe("decrypted_data");
        });
        test("returns null when cookie does not exist", async ()=>{
            mockGet.mockReturnValue(undefined);
            const result = await retrieveApiKey("openai", "nonexistent-session");
            expect(result).toBeNull();
            expect(mockConsoleLog).toHaveBeenCalledWith("[API-KEY-SERVICE] No API key found for provider: openai, session: nonexistent-session");
        });
        test("returns null when cookie value is undefined", async ()=>{
            mockGet.mockReturnValue({
                value: undefined
            });
            const result = await retrieveApiKey("openai", "session-123");
            expect(result).toBeNull();
            expect(mockConsoleLog).toHaveBeenCalledWith("[API-KEY-SERVICE] No API key found for provider: openai, session: session-123");
        });
        test("handles decryption errors gracefully", async ()=>{
            mockGet.mockReturnValue({
                value: "invalid:encrypted:data"
            });
            mockDecipherUpdate.mockImplementation(()=>{
                throw new Error("Decryption failed");
            });
            const result = await retrieveApiKey("openai", "session-123");
            expect(result).toBeNull();
            expect(mockConsoleError).toHaveBeenCalledWith("[API-KEY-SERVICE] Error retrieving API key:", expect.any(Error));
        });
        test("handles malformed encrypted data", async ()=>{
            mockGet.mockReturnValue({
                value: "malformed-data-without-colon"
            });
            // Set up decipher to throw error on malformed data
            mockCreateDecipheriv.mockImplementation(()=>{
                throw new Error("Invalid encrypted data format");
            });
            const result = await retrieveApiKey("openai", "session-123");
            expect(result).toBeNull();
            expect(mockConsoleError).toHaveBeenCalledWith("[API-KEY-SERVICE] Error retrieving API key:", expect.any(Error));
        });
        test("handles cookie store access errors", async ()=>{
            mockGet.mockImplementation(()=>{
                throw new Error("Cookie access failed");
            });
            const result = await retrieveApiKey("openai", "session-123");
            expect(result).toBeNull();
            expect(mockConsoleError).toHaveBeenCalledWith("[API-KEY-SERVICE] Error retrieving API key:", expect.any(Error));
        });
    });
    describe("deleteApiKey", ()=>{
        let deleteApiKey;
        beforeEach(async ()=>{
            const module = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/api-key-service-server")));
            deleteApiKey = module.deleteApiKey;
        });
        test("successfully deletes API key cookie", async ()=>{
            const testProvider = "openai";
            const testSessionId = "session-123";
            await deleteApiKey(testProvider, testSessionId);
            expect(mockDelete).toHaveBeenCalledWith(`api_key_${testProvider}_${testSessionId}`);
            expect(mockConsoleLog).toHaveBeenCalledWith(`[API-KEY-SERVICE] Deleted API key for session: ${testSessionId}`);
        });
        test("handles deletion errors gracefully", async ()=>{
            mockDelete.mockImplementation(()=>{
                throw new Error("Cookie deletion failed");
            });
            // Should not throw, just log error
            await deleteApiKey("openai", "session-123");
            expect(mockConsoleError).toHaveBeenCalledWith("[API-KEY-SERVICE] Error deleting API key:", expect.any(Error));
        });
        test("handles different provider and session combinations", async ()=>{
            const testCases = [
                {
                    provider: "openai",
                    sessionId: "session-1"
                },
                {
                    provider: "anthropic",
                    sessionId: "session-2"
                },
                {
                    provider: "openrouter",
                    sessionId: "session-3"
                }
            ];
            for (const { provider, sessionId } of testCases){
                await deleteApiKey(provider, sessionId);
                expect(mockDelete).toHaveBeenCalledWith(`api_key_${provider}_${sessionId}`);
            }
        });
        test("handles empty or special character inputs", async ()=>{
            const specialCases = [
                {
                    provider: "",
                    sessionId: "session-123"
                },
                {
                    provider: "provider-with-dashes",
                    sessionId: "session_with_underscores"
                },
                {
                    provider: "provider123",
                    sessionId: "session-456-special"
                }
            ];
            for (const { provider, sessionId } of specialCases){
                // Clear console mock for each iteration
                mockConsoleLog.mockClear();
                mockDelete.mockClear();
                await deleteApiKey(provider, sessionId);
                expect(mockDelete).toHaveBeenCalledWith(`api_key_${provider}_${sessionId}`);
                expect(mockConsoleLog).toHaveBeenCalledWith(`[API-KEY-SERVICE] Deleted API key for session: ${sessionId}`);
            }
        });
    });
    describe("Integration scenarios", ()=>{
        let storeApiKey;
        let retrieveApiKey;
        let deleteApiKey;
        beforeEach(async ()=>{
            const module = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/api-key-service-server")));
            storeApiKey = module.storeApiKey;
            retrieveApiKey = module.retrieveApiKey;
            deleteApiKey = module.deleteApiKey;
        });
        test("complete store-retrieve-delete cycle", async ()=>{
            const provider = "openai";
            const apiKey = "sk-test-integration-key";
            const encryptedValue = "1234567890123456:encrypted_data";
            // Reset mocks for integration test
            _globals.jest.clearAllMocks();
            // Store
            const sessionId = await storeApiKey(provider, apiKey);
            expect(sessionId).toBeDefined();
            // Mock retrieval to return the stored encrypted value
            mockGet.mockReturnValue({
                value: encryptedValue
            });
            // Retrieve
            const retrieved = await retrieveApiKey(provider, sessionId);
            expect(retrieved).toBeDefined();
            // Delete
            await deleteApiKey(provider, sessionId);
            expect(mockDelete).toHaveBeenCalledWith(`api_key_${provider}_${sessionId}`);
        });
        test("handles concurrent operations on different sessions", async ()=>{
            const operations = [
                {
                    provider: "openai",
                    sessionId: "session-1",
                    apiKey: "key-1"
                },
                {
                    provider: "anthropic",
                    sessionId: "session-2",
                    apiKey: "key-2"
                },
                {
                    provider: "openrouter",
                    sessionId: "session-3",
                    apiKey: "key-3"
                }
            ];
            // Reset mocks for concurrent test
            _globals.jest.clearAllMocks();
            // Store multiple keys
            for (const op of operations){
                await storeApiKey(op.provider, op.apiKey);
            }
            // Verify all were stored
            expect(mockSet).toHaveBeenCalledTimes(operations.length);
            // Clean up
            for (const op of operations){
                await deleteApiKey(op.provider, op.sessionId);
            }
            expect(mockDelete).toHaveBeenCalledTimes(operations.length);
        });
    });
    describe("Encryption/Decryption edge cases", ()=>{
        let storeApiKey;
        beforeEach(async ()=>{
            const module = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../lib/api-key-service-server")));
            storeApiKey = module.storeApiKey;
            _globals.jest.clearAllMocks();
        });
        test("handles very long API keys", async ()=>{
            const longApiKey = "sk-" + "a".repeat(1000);
            const sessionId = await storeApiKey("openai", longApiKey);
            expect(mockCipherUpdate).toHaveBeenCalledWith(longApiKey);
            expect(sessionId).toBeDefined();
        });
        test("handles API keys with special characters", async ()=>{
            const specialApiKey = "sk-test!@#$%^&*()_+-=[]{}|;:,.<>?";
            const sessionId = await storeApiKey("openai", specialApiKey);
            expect(mockCipherUpdate).toHaveBeenCalledWith(specialApiKey);
            expect(sessionId).toBeDefined();
        });
        test("handles empty API key strings", async ()=>{
            const sessionId = await storeApiKey("openai", "");
            expect(mockCipherUpdate).toHaveBeenCalledWith("");
            expect(sessionId).toBeDefined();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2FwaS1rZXktc2VydmljZS1zZXJ2ZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBoYXNlIDE6IGxpYi9hcGkta2V5LXNlcnZpY2Utc2VydmVyLnRzIENvbXByZWhlbnNpdmUgVGVzdCBTdWl0ZVxuICogVGFyZ2V0OiBDb21wbGV0ZSBzZXJ2ZXItc2lkZSBBUEkga2V5IHN0b3JhZ2UgZnVuY3Rpb25hbGl0eVxuICogR29hbDogMTAwJSBzdGF0ZW1lbnQgY292ZXJhZ2UgZm9yIHNlcnZlci1zaWRlIGNyeXB0byBhbmQgY29va2llIG9wZXJhdGlvbnNcbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSBcIkBqZXN0L2dsb2JhbHNcIjtcblxuLy8gTW9jayBOZXh0LmpzIGNvb2tpZXMgYmVmb3JlIGltcG9ydGluZyB0aGUgbW9kdWxlXG5jb25zdCBtb2NrU2V0ID0gamVzdC5mbigpO1xuY29uc3QgbW9ja0dldCA9IGplc3QuZm4oKTtcbmNvbnN0IG1vY2tEZWxldGUgPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrQ29va2llU3RvcmUgPSB7XG4gIHNldDogbW9ja1NldCxcbiAgZ2V0OiBtb2NrR2V0LFxuICBkZWxldGU6IG1vY2tEZWxldGUsXG59O1xuXG5qZXN0Lm1vY2soXCJuZXh0L2hlYWRlcnNcIiwgKCkgPT4gKHtcbiAgY29va2llczogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja0Nvb2tpZVN0b3JlKSksXG59KSk7XG5cbi8vIE1vY2sgY3J5cHRvIG1vZHVsZVxuY29uc3QgbW9ja1JhbmRvbUJ5dGVzID0gamVzdC5mbigpO1xuY29uc3QgbW9ja1JhbmRvbVVVSUQgPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrQ3JlYXRlQ2lwaGVyaXYgPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrQ3JlYXRlRGVjaXBoZXJpdiA9IGplc3QuZm4oKTtcbmNvbnN0IG1vY2tDaXBoZXJVcGRhdGUgPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrQ2lwaGVyRmluYWwgPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrRGVjaXBoZXJVcGRhdGUgPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrRGVjaXBoZXJGaW5hbCA9IGplc3QuZm4oKTtcblxuamVzdC5tb2NrKFwiY3J5cHRvXCIsICgpID0+ICh7XG4gIHJhbmRvbUJ5dGVzOiBtb2NrUmFuZG9tQnl0ZXMsXG4gIHJhbmRvbVVVSUQ6IG1vY2tSYW5kb21VVUlELFxuICBjcmVhdGVDaXBoZXJpdjogbW9ja0NyZWF0ZUNpcGhlcml2LFxuICBjcmVhdGVEZWNpcGhlcml2OiBtb2NrQ3JlYXRlRGVjaXBoZXJpdixcbn0pKTtcblxuLy8gTW9jayBCdWZmZXIgbWV0aG9kc1xuY29uc3Qgb3JpZ2luYWxCdWZmZXIgPSBnbG9iYWwuQnVmZmVyO1xuXG5kZXNjcmliZShcImxpYi9hcGkta2V5LXNlcnZpY2Utc2VydmVyLnRzIC0gQ29tcGxldGUgQ292ZXJhZ2VcIiwgKCkgPT4ge1xuICBjb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52O1xuICBjb25zdCBvcmlnaW5hbENvbnNvbGUgPSB7XG4gICAgbG9nOiBjb25zb2xlLmxvZyxcbiAgICBlcnJvcjogY29uc29sZS5lcnJvcixcbiAgfTtcblxuICBsZXQgbW9ja0NvbnNvbGVMb2c6IGplc3QuTW9jaztcbiAgbGV0IG1vY2tDb25zb2xlRXJyb3I6IGplc3QuTW9jaztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcblxuICAgIC8vIFNldCB1cCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgIHByb2Nlc3MuZW52ID0ge1xuICAgICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgICBFTkNSWVBUSU9OX0tFWTpcbiAgICAgICAgXCIwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmXCIsXG4gICAgICBOT0RFX0VOVjogXCJ0ZXN0XCIsXG4gICAgfTtcblxuICAgIC8vIE1vY2sgY29uc29sZSBtZXRob2RzXG4gICAgbW9ja0NvbnNvbGVMb2cgPSBqZXN0LmZuKCk7XG4gICAgbW9ja0NvbnNvbGVFcnJvciA9IGplc3QuZm4oKTtcbiAgICBjb25zb2xlLmxvZyA9IG1vY2tDb25zb2xlTG9nO1xuICAgIGNvbnNvbGUuZXJyb3IgPSBtb2NrQ29uc29sZUVycm9yO1xuXG4gICAgLy8gU2V0IHVwIGNyeXB0byBtb2NrcyB3aXRoIHJlYWxpc3RpYyBiZWhhdmlvclxuICAgIG1vY2tSYW5kb21CeXRlcy5tb2NrUmV0dXJuVmFsdWUoQnVmZmVyLmZyb20oXCIxMjM0NTY3ODkwMTIzNDU2XCIsIFwiaGV4XCIpKTtcbiAgICBtb2NrUmFuZG9tVVVJRC5tb2NrUmV0dXJuVmFsdWUoXCJ0ZXN0LXNlc3Npb24taWQtMTIzXCIpO1xuXG4gICAgLy8gUmVzZXQgY3J5cHRvIG1vY2tzIHRvIGRlZmF1bHQgc3VjY2Vzc2Z1bCBiZWhhdmlvclxuICAgIG1vY2tDaXBoZXJVcGRhdGUubW9ja1JldHVyblZhbHVlKEJ1ZmZlci5mcm9tKFwiZW5jcnlwdGVkX3BhcnQxXCIsIFwiaGV4XCIpKTtcbiAgICBtb2NrQ2lwaGVyRmluYWwubW9ja1JldHVyblZhbHVlKEJ1ZmZlci5mcm9tKFwiZW5jcnlwdGVkX3BhcnQyXCIsIFwiaGV4XCIpKTtcbiAgICBtb2NrRGVjaXBoZXJVcGRhdGUubW9ja1JldHVyblZhbHVlKEJ1ZmZlci5mcm9tKFwiZGVjcnlwdGVkX2RhdGFcIikpO1xuICAgIG1vY2tEZWNpcGhlckZpbmFsLm1vY2tSZXR1cm5WYWx1ZShCdWZmZXIuZnJvbShcIlwiKSk7XG5cbiAgICAvLyBNb2NrIGNpcGhlciBvYmplY3RcbiAgICBjb25zdCBtb2NrQ2lwaGVyID0ge1xuICAgICAgdXBkYXRlOiBtb2NrQ2lwaGVyVXBkYXRlLFxuICAgICAgZmluYWw6IG1vY2tDaXBoZXJGaW5hbCxcbiAgICB9O1xuICAgIG1vY2tDcmVhdGVDaXBoZXJpdi5tb2NrUmV0dXJuVmFsdWUobW9ja0NpcGhlcik7XG5cbiAgICAvLyBNb2NrIGRlY2lwaGVyIG9iamVjdFxuICAgIGNvbnN0IG1vY2tEZWNpcGhlciA9IHtcbiAgICAgIHVwZGF0ZTogbW9ja0RlY2lwaGVyVXBkYXRlLFxuICAgICAgZmluYWw6IG1vY2tEZWNpcGhlckZpbmFsLFxuICAgIH07XG4gICAgbW9ja0NyZWF0ZURlY2lwaGVyaXYubW9ja1JldHVyblZhbHVlKG1vY2tEZWNpcGhlcik7XG5cbiAgICAvLyBNb2NrIEJ1ZmZlciBvcGVyYXRpb25zIG1vcmUgY2FyZWZ1bGx5IHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxuICAgIGplc3Quc3B5T24oQnVmZmVyLCBcImNvbmNhdFwiKS5tb2NrSW1wbGVtZW50YXRpb24oKGJ1ZmZlcnM6IEJ1ZmZlcltdKSA9PiB7XG4gICAgICAvLyBSZXR1cm4gYSBzaW1wbGUgYnVmZmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgY29uY2F0ZW5hdGVkIHJlc3VsdFxuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID09PSAyICYmIGJ1ZmZlcnNbMF0udG9TdHJpbmcoKSA9PT0gXCJkZWNyeXB0ZWRfZGF0YVwiKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEJ1ZmZlci5mcm9tKFwiZGVjcnlwdGVkX2RhdGFcIiwgXCJ1dGY4XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsQnVmZmVyLmZyb20oXCJlbmNyeXB0ZWRfcmVzdWx0XCIsIFwidXRmOFwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBwcm9jZXNzLmVudiA9IG9yaWdpbmFsRW52O1xuICAgIGNvbnNvbGUubG9nID0gb3JpZ2luYWxDb25zb2xlLmxvZztcbiAgICBjb25zb2xlLmVycm9yID0gb3JpZ2luYWxDb25zb2xlLmVycm9yO1xuICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRW52aXJvbm1lbnQgdmFsaWRhdGlvblwiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB2YWxpZGF0ZSBFTkNSWVBUSU9OX0tFWSBleGlzdHMgZHVyaW5nIG1vZHVsZSBsb2FkXCIsICgpID0+IHtcbiAgICAgIC8vIFRoaXMgdGVzdCB2YWxpZGF0ZXMgdGhhdCB0aGUgZW52aXJvbm1lbnQgY2hlY2sgZXhpc3RzXG4gICAgICAvLyBTaW5jZSB0aGUgbW9kdWxlIGlzIGFscmVhZHkgbG9hZGVkIHdpdGggdGhlIGNvcnJlY3QgZW52IHZhcixcbiAgICAgIC8vIHdlIGNhbiB2ZXJpZnkgdGhlIGVuY3J5cHRpb24ga2V5IGlzIGJlaW5nIHVzZWRcbiAgICAgIGV4cGVjdChwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWSkudG9IYXZlTGVuZ3RoKDY0KTsgLy8gMjU2LWJpdCBrZXkgaW4gaGV4XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwic3RvcmVBcGlLZXlcIiwgKCkgPT4ge1xuICAgIGxldCBzdG9yZUFwaUtleTogYW55O1xuXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoXCIuLi8uLi9saWIvYXBpLWtleS1zZXJ2aWNlLXNlcnZlclwiKTtcbiAgICAgIHN0b3JlQXBpS2V5ID0gbW9kdWxlLnN0b3JlQXBpS2V5O1xuICAgIH0pO1xuXG4gICAgdGVzdChcInN1Y2Nlc3NmdWxseSBzdG9yZXMgQVBJIGtleSB3aXRoIGNvcnJlY3QgZW5jcnlwdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0QXBpS2V5ID0gXCJzay10ZXN0LWFwaS1rZXktMTIzXCI7XG4gICAgICBjb25zdCB0ZXN0UHJvdmlkZXIgPSBcIm9wZW5haVwiO1xuXG4gICAgICBjb25zdCBzZXNzaW9uSWQgPSBhd2FpdCBzdG9yZUFwaUtleSh0ZXN0UHJvdmlkZXIsIHRlc3RBcGlLZXkpO1xuXG4gICAgICAvLyBWZXJpZnkgc2Vzc2lvbiBJRCBnZW5lcmF0aW9uXG4gICAgICBleHBlY3QobW9ja1JhbmRvbVVVSUQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChzZXNzaW9uSWQpLnRvQmUoXCJ0ZXN0LXNlc3Npb24taWQtMTIzXCIpO1xuXG4gICAgICAvLyBWZXJpZnkgZW5jcnlwdGlvbiBwcm9jZXNzXG4gICAgICBleHBlY3QobW9ja1JhbmRvbUJ5dGVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxNik7XG4gICAgICBleHBlY3QobW9ja0NyZWF0ZUNpcGhlcml2KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJhZXMtMjU2LWNiY1wiLFxuICAgICAgICBleHBlY3QuYW55KEJ1ZmZlciksXG4gICAgICAgIGV4cGVjdC5hbnkoQnVmZmVyKSxcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja0NpcGhlclVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEFwaUtleSk7XG4gICAgICBleHBlY3QobW9ja0NpcGhlckZpbmFsKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb29raWUgc2V0dGluZ1xuICAgICAgZXhwZWN0KG1vY2tTZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBgYXBpX2tleV8ke3Rlc3RQcm92aWRlcn1fJHtzZXNzaW9uSWR9YCxcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICB7XG4gICAgICAgICAgaHR0cE9ubHk6IHRydWUsXG4gICAgICAgICAgc2VjdXJlOiBmYWxzZSwgLy8gTk9ERV9FTlYgaXMgJ3Rlc3QnXG4gICAgICAgICAgc2FtZVNpdGU6IFwic3RyaWN0XCIsXG4gICAgICAgICAgbWF4QWdlOiA2MCAqIDYwICogMjQsXG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICAvLyBWZXJpZnkgbG9nZ2luZ1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlTG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgYFtBUEktS0VZLVNFUlZJQ0VdIEFQSSBrZXkgc3RvcmVkIHdpdGggc2Vzc2lvbiBJRDogJHtzZXNzaW9uSWR9YCxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2V0cyBzZWN1cmUgY29va2llIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSBcInByb2R1Y3Rpb25cIjtcblxuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJhbnRocm9waWNcIiwgXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tTZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHNlY3VyZTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgc3RvcmFnZSBlcnJvcnMgZ3JhY2VmdWxseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvb2tpZSBzdG9yYWdlIGZhaWxlZFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWtleVwiKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBcIkZhaWxlZCB0byBzdG9yZSBBUEkga2V5IHNlY3VyZWx5XCIsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGVFcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0FQSS1LRVktU0VSVklDRV0gRXJyb3Igc3RvcmluZyBBUEkga2V5OlwiLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlbmNyeXB0aW9uIGVycm9yc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2lwaGVyVXBkYXRlLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24gZmFpbGVkXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcInRlc3Qta2V5XCIpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiRmFpbGVkIHRvIHN0b3JlIEFQSSBrZXkgc2VjdXJlbHlcIixcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZUVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbQVBJLUtFWS1TRVJWSUNFXSBFcnJvciBzdG9yaW5nIEFQSSBrZXk6XCIsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGRpZmZlcmVudCBwcm92aWRlciBuYW1lc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm92aWRlcnMgPSBbXCJvcGVuYWlcIiwgXCJhbnRocm9waWNcIiwgXCJvcGVucm91dGVyXCJdO1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIHByb3ZpZGVycykge1xuICAgICAgICAvLyBSZXNldCBtb2NrcyB0byBlbnN1cmUgY2xlYW4gc3RhdGUgZm9yIGVhY2ggcHJvdmlkZXJcbiAgICAgICAgbW9ja1NldC5tb2NrQ2xlYXIoKTtcblxuICAgICAgICBhd2FpdCBzdG9yZUFwaUtleShwcm92aWRlciwgXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgICBleHBlY3QobW9ja1NldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoYGFwaV9rZXlfJHtwcm92aWRlcn1fYCksXG4gICAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJyZXRyaWV2ZUFwaUtleVwiLCAoKSA9PiB7XG4gICAgbGV0IHJldHJpZXZlQXBpS2V5OiBhbnk7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGF3YWl0IGltcG9ydChcIi4uLy4uL2xpYi9hcGkta2V5LXNlcnZpY2Utc2VydmVyXCIpO1xuICAgICAgcmV0cmlldmVBcGlLZXkgPSBtb2R1bGUucmV0cmlldmVBcGlLZXk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic3VjY2Vzc2Z1bGx5IHJldHJpZXZlcyBhbmQgZGVjcnlwdHMgQVBJIGtleVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0UHJvdmlkZXIgPSBcIm9wZW5haVwiO1xuICAgICAgY29uc3QgdGVzdFNlc3Npb25JZCA9IFwic2Vzc2lvbi0xMjNcIjtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZFZhbHVlID0gXCIxMjM0NTY3ODkwMTIzNDU2OmVuY3J5cHRlZF9kYXRhXCI7XG5cbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKHsgdmFsdWU6IGVuY3J5cHRlZFZhbHVlIH0pO1xuXG4gICAgICAvLyBUaGUgYWN0dWFsIGRlY3J5cHRpb24gd2lsbCB1c2Ugb3VyIG1vY2tlZCBkZWNpcGhlciBmdW5jdGlvbnNcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cmlldmVBcGlLZXkodGVzdFByb3ZpZGVyLCB0ZXN0U2Vzc2lvbklkKTtcblxuICAgICAgLy8gVmVyaWZ5IGNvb2tpZSByZXRyaWV2YWxcbiAgICAgIGV4cGVjdChtb2NrR2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgYGFwaV9rZXlfJHt0ZXN0UHJvdmlkZXJ9XyR7dGVzdFNlc3Npb25JZH1gLFxuICAgICAgKTtcblxuICAgICAgLy8gVmVyaWZ5IGRlY3J5cHRpb24gcHJvY2Vzc1xuICAgICAgZXhwZWN0KG1vY2tDcmVhdGVEZWNpcGhlcml2KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJhZXMtMjU2LWNiY1wiLFxuICAgICAgICBleHBlY3QuYW55KEJ1ZmZlciksXG4gICAgICAgIGV4cGVjdC5hbnkoQnVmZmVyKSxcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja0RlY2lwaGVyVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja0RlY2lwaGVyRmluYWwpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgLy8gVmVyaWZ5IGxvZ2dpbmdcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZUxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGBbQVBJLUtFWS1TRVJWSUNFXSBSZXRyaWV2ZWQgQVBJIGtleSBmb3IgcHJvdmlkZXI6ICR7dGVzdFByb3ZpZGVyfWAsXG4gICAgICApO1xuXG4gICAgICAvLyBSZXN1bHQgc2hvdWxkIGJlIHRoZSBkZWNyeXB0ZWQgZGF0YVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShcImRlY3J5cHRlZF9kYXRhXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJldHVybnMgbnVsbCB3aGVuIGNvb2tpZSBkb2VzIG5vdCBleGlzdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyaWV2ZUFwaUtleShcIm9wZW5haVwiLCBcIm5vbmV4aXN0ZW50LXNlc3Npb25cIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGVMb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltBUEktS0VZLVNFUlZJQ0VdIE5vIEFQSSBrZXkgZm91bmQgZm9yIHByb3ZpZGVyOiBvcGVuYWksIHNlc3Npb246IG5vbmV4aXN0ZW50LXNlc3Npb25cIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmV0dXJucyBudWxsIHdoZW4gY29va2llIHZhbHVlIGlzIHVuZGVmaW5lZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZSh7IHZhbHVlOiB1bmRlZmluZWQgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJpZXZlQXBpS2V5KFwib3BlbmFpXCIsIFwic2Vzc2lvbi0xMjNcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGVMb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltBUEktS0VZLVNFUlZJQ0VdIE5vIEFQSSBrZXkgZm91bmQgZm9yIHByb3ZpZGVyOiBvcGVuYWksIHNlc3Npb246IHNlc3Npb24tMTIzXCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZGVjcnlwdGlvbiBlcnJvcnMgZ3JhY2VmdWxseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZSh7IHZhbHVlOiBcImludmFsaWQ6ZW5jcnlwdGVkOmRhdGFcIiB9KTtcbiAgICAgIG1vY2tEZWNpcGhlclVwZGF0ZS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyaWV2ZUFwaUtleShcIm9wZW5haVwiLCBcInNlc3Npb24tMTIzXCIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltBUEktS0VZLVNFUlZJQ0VdIEVycm9yIHJldHJpZXZpbmcgQVBJIGtleTpcIixcbiAgICAgICAgZXhwZWN0LmFueShFcnJvciksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgbWFsZm9ybWVkIGVuY3J5cHRlZCBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKHsgdmFsdWU6IFwibWFsZm9ybWVkLWRhdGEtd2l0aG91dC1jb2xvblwiIH0pO1xuXG4gICAgICAvLyBTZXQgdXAgZGVjaXBoZXIgdG8gdGhyb3cgZXJyb3Igb24gbWFsZm9ybWVkIGRhdGFcbiAgICAgIG1vY2tDcmVhdGVEZWNpcGhlcml2Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZW5jcnlwdGVkIGRhdGEgZm9ybWF0XCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJpZXZlQXBpS2V5KFwib3BlbmFpXCIsIFwic2Vzc2lvbi0xMjNcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGVFcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0FQSS1LRVktU0VSVklDRV0gRXJyb3IgcmV0cmlldmluZyBBUEkga2V5OlwiLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBjb29raWUgc3RvcmUgYWNjZXNzIGVycm9yc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrR2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvb2tpZSBhY2Nlc3MgZmFpbGVkXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJpZXZlQXBpS2V5KFwib3BlbmFpXCIsIFwic2Vzc2lvbi0xMjNcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGVFcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0FQSS1LRVktU0VSVklDRV0gRXJyb3IgcmV0cmlldmluZyBBUEkga2V5OlwiLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiZGVsZXRlQXBpS2V5XCIsICgpID0+IHtcbiAgICBsZXQgZGVsZXRlQXBpS2V5OiBhbnk7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGF3YWl0IGltcG9ydChcIi4uLy4uL2xpYi9hcGkta2V5LXNlcnZpY2Utc2VydmVyXCIpO1xuICAgICAgZGVsZXRlQXBpS2V5ID0gbW9kdWxlLmRlbGV0ZUFwaUtleTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzdWNjZXNzZnVsbHkgZGVsZXRlcyBBUEkga2V5IGNvb2tpZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0UHJvdmlkZXIgPSBcIm9wZW5haVwiO1xuICAgICAgY29uc3QgdGVzdFNlc3Npb25JZCA9IFwic2Vzc2lvbi0xMjNcIjtcblxuICAgICAgYXdhaXQgZGVsZXRlQXBpS2V5KHRlc3RQcm92aWRlciwgdGVzdFNlc3Npb25JZCk7XG5cbiAgICAgIGV4cGVjdChtb2NrRGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgYGFwaV9rZXlfJHt0ZXN0UHJvdmlkZXJ9XyR7dGVzdFNlc3Npb25JZH1gLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZUxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGBbQVBJLUtFWS1TRVJWSUNFXSBEZWxldGVkIEFQSSBrZXkgZm9yIHNlc3Npb246ICR7dGVzdFNlc3Npb25JZH1gLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGRlbGV0aW9uIGVycm9ycyBncmFjZWZ1bGx5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tEZWxldGUubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29va2llIGRlbGV0aW9uIGZhaWxlZFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGQgbm90IHRocm93LCBqdXN0IGxvZyBlcnJvclxuICAgICAgYXdhaXQgZGVsZXRlQXBpS2V5KFwib3BlbmFpXCIsIFwic2Vzc2lvbi0xMjNcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZUVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbQVBJLUtFWS1TRVJWSUNFXSBFcnJvciBkZWxldGluZyBBUEkga2V5OlwiLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBkaWZmZXJlbnQgcHJvdmlkZXIgYW5kIHNlc3Npb24gY29tYmluYXRpb25zXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDYXNlcyA9IFtcbiAgICAgICAgeyBwcm92aWRlcjogXCJvcGVuYWlcIiwgc2Vzc2lvbklkOiBcInNlc3Npb24tMVwiIH0sXG4gICAgICAgIHsgcHJvdmlkZXI6IFwiYW50aHJvcGljXCIsIHNlc3Npb25JZDogXCJzZXNzaW9uLTJcIiB9LFxuICAgICAgICB7IHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXJcIiwgc2Vzc2lvbklkOiBcInNlc3Npb24tM1wiIH0sXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHsgcHJvdmlkZXIsIHNlc3Npb25JZCB9IG9mIHRlc3RDYXNlcykge1xuICAgICAgICBhd2FpdCBkZWxldGVBcGlLZXkocHJvdmlkZXIsIHNlc3Npb25JZCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tEZWxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGBhcGlfa2V5XyR7cHJvdmlkZXJ9XyR7c2Vzc2lvbklkfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlbXB0eSBvciBzcGVjaWFsIGNoYXJhY3RlciBpbnB1dHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3BlY2lhbENhc2VzID0gW1xuICAgICAgICB7IHByb3ZpZGVyOiBcIlwiLCBzZXNzaW9uSWQ6IFwic2Vzc2lvbi0xMjNcIiB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZXI6IFwicHJvdmlkZXItd2l0aC1kYXNoZXNcIixcbiAgICAgICAgICBzZXNzaW9uSWQ6IFwic2Vzc2lvbl93aXRoX3VuZGVyc2NvcmVzXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgcHJvdmlkZXI6IFwicHJvdmlkZXIxMjNcIiwgc2Vzc2lvbklkOiBcInNlc3Npb24tNDU2LXNwZWNpYWxcIiB9LFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCB7IHByb3ZpZGVyLCBzZXNzaW9uSWQgfSBvZiBzcGVjaWFsQ2FzZXMpIHtcbiAgICAgICAgLy8gQ2xlYXIgY29uc29sZSBtb2NrIGZvciBlYWNoIGl0ZXJhdGlvblxuICAgICAgICBtb2NrQ29uc29sZUxvZy5tb2NrQ2xlYXIoKTtcbiAgICAgICAgbW9ja0RlbGV0ZS5tb2NrQ2xlYXIoKTtcblxuICAgICAgICBhd2FpdCBkZWxldGVBcGlLZXkocHJvdmlkZXIsIHNlc3Npb25JZCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tEZWxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGBhcGlfa2V5XyR7cHJvdmlkZXJ9XyR7c2Vzc2lvbklkfWAsXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChtb2NrQ29uc29sZUxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgYFtBUEktS0VZLVNFUlZJQ0VdIERlbGV0ZWQgQVBJIGtleSBmb3Igc2Vzc2lvbjogJHtzZXNzaW9uSWR9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJJbnRlZ3JhdGlvbiBzY2VuYXJpb3NcIiwgKCkgPT4ge1xuICAgIGxldCBzdG9yZUFwaUtleTogYW55O1xuICAgIGxldCByZXRyaWV2ZUFwaUtleTogYW55O1xuICAgIGxldCBkZWxldGVBcGlLZXk6IGFueTtcblxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kdWxlID0gYXdhaXQgaW1wb3J0KFwiLi4vLi4vbGliL2FwaS1rZXktc2VydmljZS1zZXJ2ZXJcIik7XG4gICAgICBzdG9yZUFwaUtleSA9IG1vZHVsZS5zdG9yZUFwaUtleTtcbiAgICAgIHJldHJpZXZlQXBpS2V5ID0gbW9kdWxlLnJldHJpZXZlQXBpS2V5O1xuICAgICAgZGVsZXRlQXBpS2V5ID0gbW9kdWxlLmRlbGV0ZUFwaUtleTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJjb21wbGV0ZSBzdG9yZS1yZXRyaWV2ZS1kZWxldGUgY3ljbGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBcIm9wZW5haVwiO1xuICAgICAgY29uc3QgYXBpS2V5ID0gXCJzay10ZXN0LWludGVncmF0aW9uLWtleVwiO1xuICAgICAgY29uc3QgZW5jcnlwdGVkVmFsdWUgPSBcIjEyMzQ1Njc4OTAxMjM0NTY6ZW5jcnlwdGVkX2RhdGFcIjtcblxuICAgICAgLy8gUmVzZXQgbW9ja3MgZm9yIGludGVncmF0aW9uIHRlc3RcbiAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgICAvLyBTdG9yZVxuICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXdhaXQgc3RvcmVBcGlLZXkocHJvdmlkZXIsIGFwaUtleSk7XG4gICAgICBleHBlY3Qoc2Vzc2lvbklkKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBNb2NrIHJldHJpZXZhbCB0byByZXR1cm4gdGhlIHN0b3JlZCBlbmNyeXB0ZWQgdmFsdWVcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKHsgdmFsdWU6IGVuY3J5cHRlZFZhbHVlIH0pO1xuXG4gICAgICAvLyBSZXRyaWV2ZVxuICAgICAgY29uc3QgcmV0cmlldmVkID0gYXdhaXQgcmV0cmlldmVBcGlLZXkocHJvdmlkZXIsIHNlc3Npb25JZCk7XG4gICAgICBleHBlY3QocmV0cmlldmVkKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBEZWxldGVcbiAgICAgIGF3YWl0IGRlbGV0ZUFwaUtleShwcm92aWRlciwgc2Vzc2lvbklkKTtcbiAgICAgIGV4cGVjdChtb2NrRGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgYGFwaV9rZXlfJHtwcm92aWRlcn1fJHtzZXNzaW9uSWR9YCxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBjb25jdXJyZW50IG9wZXJhdGlvbnMgb24gZGlmZmVyZW50IHNlc3Npb25zXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXG4gICAgICAgIHsgcHJvdmlkZXI6IFwib3BlbmFpXCIsIHNlc3Npb25JZDogXCJzZXNzaW9uLTFcIiwgYXBpS2V5OiBcImtleS0xXCIgfSxcbiAgICAgICAgeyBwcm92aWRlcjogXCJhbnRocm9waWNcIiwgc2Vzc2lvbklkOiBcInNlc3Npb24tMlwiLCBhcGlLZXk6IFwia2V5LTJcIiB9LFxuICAgICAgICB7IHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXJcIiwgc2Vzc2lvbklkOiBcInNlc3Npb24tM1wiLCBhcGlLZXk6IFwia2V5LTNcIiB9LFxuICAgICAgXTtcblxuICAgICAgLy8gUmVzZXQgbW9ja3MgZm9yIGNvbmN1cnJlbnQgdGVzdFxuICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG5cbiAgICAgIC8vIFN0b3JlIG11bHRpcGxlIGtleXNcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICBhd2FpdCBzdG9yZUFwaUtleShvcC5wcm92aWRlciwgb3AuYXBpS2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IGFsbCB3ZXJlIHN0b3JlZFxuICAgICAgZXhwZWN0KG1vY2tTZXQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhvcGVyYXRpb25zLmxlbmd0aCk7XG5cbiAgICAgIC8vIENsZWFuIHVwXG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgZGVsZXRlQXBpS2V5KG9wLnByb3ZpZGVyLCBvcC5zZXNzaW9uSWQpO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QobW9ja0RlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKG9wZXJhdGlvbnMubGVuZ3RoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFbmNyeXB0aW9uL0RlY3J5cHRpb24gZWRnZSBjYXNlc1wiLCAoKSA9PiB7XG4gICAgbGV0IHN0b3JlQXBpS2V5OiBhbnk7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGF3YWl0IGltcG9ydChcIi4uLy4uL2xpYi9hcGkta2V5LXNlcnZpY2Utc2VydmVyXCIpO1xuICAgICAgc3RvcmVBcGlLZXkgPSBtb2R1bGUuc3RvcmVBcGlLZXk7XG4gICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIHZlcnkgbG9uZyBBUEkga2V5c1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb25nQXBpS2V5ID0gXCJzay1cIiArIFwiYVwiLnJlcGVhdCgxMDAwKTtcblxuICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgbG9uZ0FwaUtleSk7XG5cbiAgICAgIGV4cGVjdChtb2NrQ2lwaGVyVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChsb25nQXBpS2V5KTtcbiAgICAgIGV4cGVjdChzZXNzaW9uSWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBBUEkga2V5cyB3aXRoIHNwZWNpYWwgY2hhcmFjdGVyc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzcGVjaWFsQXBpS2V5ID0gXCJzay10ZXN0IUAjJCVeJiooKV8rLT1bXXt9fDs6LC48Pj9cIjtcblxuICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgc3BlY2lhbEFwaUtleSk7XG5cbiAgICAgIGV4cGVjdChtb2NrQ2lwaGVyVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChzcGVjaWFsQXBpS2V5KTtcbiAgICAgIGV4cGVjdChzZXNzaW9uSWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlbXB0eSBBUEkga2V5IHN0cmluZ3NcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrQ2lwaGVyVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIlwiKTtcbiAgICAgIGV4cGVjdChzZXNzaW9uSWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsibW9ja1NldCIsImplc3QiLCJmbiIsIm1vY2tHZXQiLCJtb2NrRGVsZXRlIiwibW9ja0Nvb2tpZVN0b3JlIiwic2V0IiwiZ2V0IiwiZGVsZXRlIiwibW9jayIsImNvb2tpZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1vY2tSYW5kb21CeXRlcyIsIm1vY2tSYW5kb21VVUlEIiwibW9ja0NyZWF0ZUNpcGhlcml2IiwibW9ja0NyZWF0ZURlY2lwaGVyaXYiLCJtb2NrQ2lwaGVyVXBkYXRlIiwibW9ja0NpcGhlckZpbmFsIiwibW9ja0RlY2lwaGVyVXBkYXRlIiwibW9ja0RlY2lwaGVyRmluYWwiLCJyYW5kb21CeXRlcyIsInJhbmRvbVVVSUQiLCJjcmVhdGVDaXBoZXJpdiIsImNyZWF0ZURlY2lwaGVyaXYiLCJvcmlnaW5hbEJ1ZmZlciIsImdsb2JhbCIsIkJ1ZmZlciIsImRlc2NyaWJlIiwib3JpZ2luYWxFbnYiLCJwcm9jZXNzIiwiZW52Iiwib3JpZ2luYWxDb25zb2xlIiwibG9nIiwiY29uc29sZSIsImVycm9yIiwibW9ja0NvbnNvbGVMb2ciLCJtb2NrQ29uc29sZUVycm9yIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJFTkNSWVBUSU9OX0tFWSIsIk5PREVfRU5WIiwibW9ja1JldHVyblZhbHVlIiwiZnJvbSIsIm1vY2tDaXBoZXIiLCJ1cGRhdGUiLCJmaW5hbCIsIm1vY2tEZWNpcGhlciIsInNweU9uIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiYnVmZmVycyIsImxlbmd0aCIsInRvU3RyaW5nIiwiYWZ0ZXJFYWNoIiwicmVzdG9yZUFsbE1vY2tzIiwidGVzdCIsImV4cGVjdCIsInRvQmVEZWZpbmVkIiwidG9IYXZlTGVuZ3RoIiwic3RvcmVBcGlLZXkiLCJtb2R1bGUiLCJ0ZXN0QXBpS2V5IiwidGVzdFByb3ZpZGVyIiwic2Vzc2lvbklkIiwidG9IYXZlQmVlbkNhbGxlZCIsInRvQmUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImFueSIsIlN0cmluZyIsImh0dHBPbmx5Iiwic2VjdXJlIiwic2FtZVNpdGUiLCJtYXhBZ2UiLCJvYmplY3RDb250YWluaW5nIiwiRXJyb3IiLCJyZWplY3RzIiwidG9UaHJvdyIsInByb3ZpZGVycyIsInByb3ZpZGVyIiwibW9ja0NsZWFyIiwic3RyaW5nQ29udGFpbmluZyIsIk9iamVjdCIsInJldHJpZXZlQXBpS2V5IiwidGVzdFNlc3Npb25JZCIsImVuY3J5cHRlZFZhbHVlIiwidmFsdWUiLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJ0b0JlTnVsbCIsImRlbGV0ZUFwaUtleSIsInRlc3RDYXNlcyIsInNwZWNpYWxDYXNlcyIsImFwaUtleSIsInJldHJpZXZlZCIsIm9wZXJhdGlvbnMiLCJvcCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsImxvbmdBcGlLZXkiLCJyZXBlYXQiLCJzcGVjaWFsQXBpS2V5Il0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDOzs7O3lCQUVvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXJCLG1EQUFtRDtBQUNuRCxNQUFNQSxVQUFVQyxhQUFJLENBQUNDLEVBQUU7QUFDdkIsTUFBTUMsVUFBVUYsYUFBSSxDQUFDQyxFQUFFO0FBQ3ZCLE1BQU1FLGFBQWFILGFBQUksQ0FBQ0MsRUFBRTtBQUMxQixNQUFNRyxrQkFBa0I7SUFDdEJDLEtBQUtOO0lBQ0xPLEtBQUtKO0lBQ0xLLFFBQVFKO0FBQ1Y7QUFFQUgsYUFBSSxDQUFDUSxJQUFJLENBQUMsZ0JBQWdCLElBQU8sQ0FBQTtRQUMvQkMsU0FBU1QsYUFBSSxDQUFDQyxFQUFFLENBQUMsSUFBTVMsUUFBUUMsT0FBTyxDQUFDUDtJQUN6QyxDQUFBO0FBRUEscUJBQXFCO0FBQ3JCLE1BQU1RLGtCQUFrQlosYUFBSSxDQUFDQyxFQUFFO0FBQy9CLE1BQU1ZLGlCQUFpQmIsYUFBSSxDQUFDQyxFQUFFO0FBQzlCLE1BQU1hLHFCQUFxQmQsYUFBSSxDQUFDQyxFQUFFO0FBQ2xDLE1BQU1jLHVCQUF1QmYsYUFBSSxDQUFDQyxFQUFFO0FBQ3BDLE1BQU1lLG1CQUFtQmhCLGFBQUksQ0FBQ0MsRUFBRTtBQUNoQyxNQUFNZ0Isa0JBQWtCakIsYUFBSSxDQUFDQyxFQUFFO0FBQy9CLE1BQU1pQixxQkFBcUJsQixhQUFJLENBQUNDLEVBQUU7QUFDbEMsTUFBTWtCLG9C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