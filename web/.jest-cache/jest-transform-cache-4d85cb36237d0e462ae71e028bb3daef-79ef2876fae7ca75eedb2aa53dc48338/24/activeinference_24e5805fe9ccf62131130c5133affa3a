3bcace81aeb37a2f5bbcedd40e8fc2fc
/**
 * Active Inference Implementation
 *
 * Core implementation for active inference, free energy minimization,
 * and belief updating based on the Free Energy Principle.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    calculateEpistemic: function() {
        return calculateEpistemic;
    },
    calculateExpectedFreeEnergy: function() {
        return calculateExpectedFreeEnergy;
    },
    calculatePragmatic: function() {
        return calculatePragmatic;
    },
    createActiveInferenceEngine: function() {
        return createActiveInferenceEngine;
    },
    evaluateActionPolicy: function() {
        return evaluateActionPolicy;
    },
    minimizeVariationalFreeEnergy: function() {
        return minimizeVariationalFreeEnergy;
    },
    performInference: function() {
        return performInference;
    },
    predictSensoryOutcomes: function() {
        return predictSensoryOutcomes;
    },
    selectAction: function() {
        return selectAction;
    },
    updateBeliefs: function() {
        return updateBeliefs;
    }
});
const EPSILON = 1e-10;
function createActiveInferenceEngine(config) {
    // Validate model
    if (!config.model.states.length || !config.model.observations.length || !config.model.actions.length) {
        throw new Error("Invalid generative model: missing states, observations, or actions");
    }
    if (Object.keys(config.model.transitionModel).length === 0) {
        throw new Error("Invalid generative model: empty transition model");
    }
    // Initialize uniform beliefs
    const uniformProb = 1.0 / config.model.states.length;
    const initialBeliefs = {
        states: {},
        uncertainty: 1.0
    };
    config.model.states.forEach((state)=>{
        initialBeliefs.states[state] = uniformProb;
    });
    const engine = {
        model: config.model,
        precision: config.precision || 1.0,
        learningRate: config.learningRate || 0.1,
        planningHorizon: config.planningHorizon || 3,
        actionConstraints: config.actionConstraints,
        beliefs: initialBeliefs,
        actionHistory: [],
        getCurrentBeliefs: function() {
            return {
                ...this.beliefs
            };
        },
        setBeliefs: function(beliefs) {
            this.beliefs = {
                ...beliefs
            };
        },
        calculateFreeEnergy: function(beliefs, observation) {
            // Accuracy term (expected log likelihood)
            let accuracy = 0;
            Object.entries(beliefs.states).forEach(([state, prob])=>{
                const likelihood = this.model.observationModel[state]?.[observation] || EPSILON;
                accuracy += prob * Math.log(likelihood + EPSILON);
            });
            // Complexity term (KL divergence from prior)
            let complexity = 0;
            const prior = 1.0 / this.model.states.length;
            Object.values(beliefs.states).forEach((prob)=>{
                if (prob > 0) {
                    complexity += prob * Math.log((prob + EPSILON) / prior);
                }
            });
            // Convert preference to a positive cost term
            // Negative preferences (rewards) become positive costs
            const preference = this.model.preferences[observation] || 0;
            const cost = -preference; // Convert reward to cost
            // Add uncertainty term
            const uncertaintyPenalty = beliefs.uncertainty * 2.0;
            // Free energy = -log likelihood + complexity + cost + uncertainty
            const freeEnergy = -accuracy + complexity + cost + uncertaintyPenalty;
            // Ensure free energy is positive by adding a constant if needed
            return Math.max(0.01, freeEnergy);
        }
    };
    return engine;
}
function updateBeliefs(engine, observation) {
    const currentBeliefs = engine.getCurrentBeliefs();
    const updatedBeliefs = {
        states: {},
        uncertainty: currentBeliefs.uncertainty
    };
    // Standard Bayesian belief update
    let totalPosterior = 0;
    engine.model.states.forEach((state)=>{
        const prior = currentBeliefs.states[state];
        const likelihood = engine.model.observationModel[state]?.[observation.value] || EPSILON;
        const posterior = prior * likelihood;
        updatedBeliefs.states[state] = posterior;
        totalPosterior += posterior;
    });
    // Normalize to get standard Bayesian posterior
    Object.keys(updatedBeliefs.states).forEach((state)=>{
        updatedBeliefs.states[state] /= totalPosterior;
    });
    // Apply confidence weighting by interpolating between prior and posterior
    Object.keys(updatedBeliefs.states).forEach((state)=>{
        const prior = currentBeliefs.states[state];
        const posterior = updatedBeliefs.states[state];
        // High confidence = use more of posterior, low confidence = use more of prior
        updatedBeliefs.states[state] = observation.confidence * posterior + (1 - observation.confidence) * prior;
    });
    // Update uncertainty based on observation confidence and belief entropy
    const entropy = Object.values(updatedBeliefs.states).reduce((h, p)=>{
        return p > 0 ? h - p * Math.log(p + EPSILON) : h;
    }, 0);
    updatedBeliefs.uncertainty = (1 - observation.confidence) * 0.3 + entropy * 0.7;
    // Don't modify engine state, just return the updated beliefs
    return updatedBeliefs;
}
function selectAction(engine, beliefs) {
    let bestAction = "";
    let minExpectedFE = Infinity;
    const actionScores = {};
    // Check action constraints
    const actionCounts = {};
    engine.actionHistory.forEach((action)=>{
        actionCounts[action] = (actionCounts[action] || 0) + 1;
    });
    engine.model.actions.forEach((action)=>{
        // Check constraints
        if (engine.actionConstraints?.[action]) {
            const frequency = (actionCounts[action] || 0) / Math.max(engine.actionHistory.length, 1);
            if (frequency >= engine.actionConstraints[action].maxFrequency) {
                actionScores[action] = Infinity;
                return;
            }
        }
        // Calculate expected free energy for this action
        let expectedFE = 0;
        // Epistemic value (information gain)
        const epistemic = calculateEpistemic(engine, beliefs, action);
        // Pragmatic value (goal achievement)
        const pragmatic = calculatePragmatic(engine, beliefs, action);
        // Combine with precision weighting
        expectedFE = engine.precision * pragmatic - epistemic;
        // Add exploration bonus under high uncertainty
        if (beliefs.uncertainty > 0.5 && action !== "wait") {
            expectedFE -= beliefs.uncertainty * 0.5;
        }
        // Add action variety bonus to prevent getting stuck
        const recentActions = engine.actionHistory.slice(-5);
        const actionFrequency = recentActions.filter((a)=>a === action).length / Math.max(recentActions.length, 1);
        const varietyPenalty = actionFrequency * 2.0; // Penalize repetitive actions
        expectedFE += varietyPenalty;
        actionScores[action] = expectedFE;
        if (expectedFE < minExpectedFE) {
            minExpectedFE = expectedFE;
            bestAction = action;
        }
    });
    // Calculate action confidence based on score differences
    const scores = Object.values(actionScores).filter((s)=>s !== Infinity);
    const avgScore = scores.reduce((a, b)=>a + b, 0) / scores.length;
    const confidence = Math.exp(-Math.abs(minExpectedFE - avgScore));
    engine.actionHistory.push(bestAction);
    return {
        type: bestAction,
        confidence: Math.min(Math.max(confidence, 0.1), 1.0)
    };
}
async function performInference(engine, observation) {
    // Update beliefs based on observation
    const updatedBeliefs = updateBeliefs(engine, observation);
    // Update the engine's beliefs for persistence across inferences
    engine.setBeliefs(updatedBeliefs);
    // Calculate current free energy
    const freeEnergy = engine.calculateFreeEnergy(updatedBeliefs, observation.value);
    // Select action that minimizes expected free energy
    const selectedAction = selectAction(engine, updatedBeliefs);
    // Overall confidence based on belief certainty and action confidence
    const beliefCertainty = Math.max(...Object.values(updatedBeliefs.states));
    const overallConfidence = (beliefCertainty + selectedAction.confidence) / 2;
    return {
        beliefs: updatedBeliefs,
        selectedAction,
        freeEnergy,
        confidence: overallConfidence
    };
}
function calculateExpectedFreeEnergy(engine, policy) {
    let totalEFE = 0;
    let totalEpistemic = 0;
    let totalPragmatic = 0;
    // Start with current beliefs
    let beliefs = engine.getCurrentBeliefs();
    policy.forEach((step)=>{
        const epistemic = calculateEpistemic(engine, beliefs, step.action);
        const pragmatic = calculatePragmatic(engine, beliefs, step.action);
        // Ensure finite values
        const finiteEpistemic = Number.isFinite(epistemic) ? epistemic : 0;
        const finitePragmatic = Number.isFinite(pragmatic) ? pragmatic : 0;
        totalEpistemic += finiteEpistemic * Math.pow(0.9, step.timestep); // Discount future
        totalPragmatic += finitePragmatic * Math.pow(0.9, step.timestep);
        // Predict belief evolution
        beliefs = predictBeliefEvolution(engine, beliefs, step.action);
    });
    totalEFE = engine.precision * totalPragmatic - totalEpistemic;
    // Ensure all values are finite
    return {
        total: Number.isFinite(totalEFE) ? totalEFE : 0,
        epistemic: Number.isFinite(totalEpistemic) ? totalEpistemic : 0,
        pragmatic: Number.isFinite(totalPragmatic) ? totalPragmatic : 0
    };
}
function calculateEpistemic(engine, beliefs, action) {
    // Information gain: reduction in uncertainty about states
    let informationGain = 0;
    // Current entropy
    const currentEntropy = Object.values(beliefs.states).reduce((h, p)=>{
        return p > 0 ? h - p * Math.log(p + EPSILON) : h;
    }, 0);
    // Expected entropy after action
    let expectedEntropy = 0;
    const predictedBeliefs = predictBeliefEvolution(engine, beliefs, action);
    expectedEntropy = Object.values(predictedBeliefs.states).reduce((h, p)=>{
        return p > 0 ? h - p * Math.log(p + EPSILON) : h;
    }, 0);
    informationGain = currentEntropy - expectedEntropy;
    // Add exploration bonus for uncertain states
    const explorationBonus = beliefs.uncertainty * 0.3;
    const result = Math.max(0, informationGain + explorationBonus);
    // Ensure finite result
    return Number.isFinite(result) ? result : 0;
}
function calculatePragmatic(engine, beliefs, action) {
    // Expected preference satisfaction
    let expectedPreference = 0;
    // Predict outcomes for this action
    const predictions = predictSensoryOutcomes(engine, beliefs, action);
    Object.entries(predictions).forEach(([outcome, prob])=>{
        const preference = engine.model.preferences[outcome] || 0;
        const contribution = prob * preference;
        // Only add finite contributions
        if (Number.isFinite(contribution)) {
            expectedPreference += contribution;
        }
    });
    // Ensure finite result
    return Number.isFinite(expectedPreference) ? expectedPreference : 0;
}
async function minimizeVariationalFreeEnergy(engine, initialBeliefs, observation, options) {
    const maxIter = options?.maxIterations || 100;
    const tolerance = options?.tolerance || 0.001;
    let beliefs = {
        ...initialBeliefs
    };
    let prevFE = engine.calculateFreeEnergy(beliefs, observation);
    let converged = false;
    let iterations = 0;
    while(iterations < maxIter && !converged){
        // Gradient descent on beliefs
        const gradient = {};
        const delta = 0.001;
        engine.model.states.forEach((state)=>{
            // Finite difference approximation
            const beliefsCopy = {
                ...beliefs
            };
            beliefsCopy.states[state] = Math.min(beliefs.states[state] + delta, 1);
            // Renormalize
            const sum = Object.values(beliefsCopy.states).reduce((s, p)=>s + p, 0);
            Object.keys(beliefsCopy.states).forEach((s)=>{
                beliefsCopy.states[s] /= sum;
            });
            const fePlus = engine.calculateFreeEnergy(beliefsCopy, observation);
            gradient[state] = (fePlus - prevFE) / delta;
        });
        // Update beliefs
        let changed = false;
        engine.model.states.forEach((state)=>{
            const update = -gradient[state] * engine.learningRate;
            const newBelief = Math.max(0, Math.min(1, beliefs.states[state] + update));
            if (Math.abs(newBelief - beliefs.states[state]) > tolerance) {
                changed = true;
            }
            beliefs.states[state] = newBelief;
        });
        // Renormalize
        const sum = Object.values(beliefs.states).reduce((s, p)=>s + p, 0);
        Object.keys(beliefs.states).forEach((state)=>{
            beliefs.states[state] /= sum;
        });
        // Check convergence
        const currentFE = engine.calculateFreeEnergy(beliefs, observation);
        if (!changed || Math.abs(currentFE - prevFE) < tolerance) {
            converged = true;
        }
        prevFE = currentFE;
        iterations++;
    }
    return {
        ...beliefs,
        converged,
        iterations
    };
}
function predictSensoryOutcomes(engine, beliefs, action) {
    const predictions = {};
    // Initialize predictions
    engine.model.observations.forEach((obs)=>{
        predictions[obs] = 0;
    });
    // For each current state
    Object.entries(beliefs.states).forEach(([currentState, stateProb])=>{
        // Get transition probabilities for this action
        const transitions = engine.model.transitionModel[currentState]?.[action] || {};
        // For each possible next state
        Object.entries(transitions).forEach(([nextState, transProb])=>{
            // Get observation probabilities for next state
            const observations = engine.model.observationModel[nextState] || {};
            // Accumulate prediction
            Object.entries(observations).forEach(([obs, obsProb])=>{
                predictions[obs] += stateProb * transProb * obsProb;
            });
        });
    });
    return predictions;
}
function evaluateActionPolicy(engine, policy) {
    let expectedReturn = 0;
    let totalUncertainty = 0;
    let feasibility = 1.0;
    let beliefs = engine.getCurrentBeliefs();
    policy.forEach((step, t)=>{
        // Expected immediate reward
        const predictions = predictSensoryOutcomes(engine, beliefs, step.action);
        const immediateReturn = Object.entries(predictions).reduce((sum, [outcome, prob])=>{
            const preference = engine.model.preferences[outcome] || 0;
            return sum - prob * preference; // Negative because lower is better
        }, 0);
        expectedReturn += immediateReturn * Math.pow(0.9, t);
        // Accumulate uncertainty
        totalUncertainty += beliefs.uncertainty * Math.pow(0.9, t);
        // Check action feasibility
        if (!engine.model.actions.includes(step.action)) {
            feasibility *= 0.1;
        }
        // Evolve beliefs
        beliefs = predictBeliefEvolution(engine, beliefs, step.action);
    });
    return {
        expectedReturn,
        uncertainty: totalUncertainty / policy.length,
        feasibility
    };
}
// Helper function to predict belief evolution
function predictBeliefEvolution(engine, beliefs, action) {
    const evolved = {
        states: {},
        uncertainty: beliefs.uncertainty
    };
    // Initialize
    engine.model.states.forEach((state)=>{
        evolved.states[state] = 0;
    });
    // Predict state evolution
    Object.entries(beliefs.states).forEach(([currentState, prob])=>{
        const transitions = engine.model.transitionModel[currentState]?.[action] || {};
        Object.entries(transitions).forEach(([nextState, transProb])=>{
            evolved.states[nextState] += prob * transProb;
        });
    });
    // Calculate uncertainty based on belief entropy and action effects
    const entropy = Object.values(evolved.states).reduce((h, p)=>{
        return p > 0 ? h - p * Math.log(p + EPSILON) : h;
    }, 0);
    // Different actions affect uncertainty differently
    let actionUncertaintyEffect = 1.0;
    switch(action){
        case "wait":
            actionUncertaintyEffect = 1.2; // Waiting increases uncertainty
            break;
        case "move_forward":
            actionUncertaintyEffect = 0.9; // Moving reduces uncertainty through exploration
            break;
        case "turn":
            actionUncertaintyEffect = 0.8; // Turning provides more information
            break;
        default:
            actionUncertaintyEffect = 1.1;
    }
    // Update uncertainty based on entropy and action effects
    evolved.uncertainty = Math.min(1.0, Math.max(0.1, beliefs.uncertainty * actionUncertaintyEffect + entropy * 0.1));
    return evolved;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvYWN0aXZlLWluZmVyZW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFjdGl2ZSBJbmZlcmVuY2UgSW1wbGVtZW50YXRpb25cbiAqXG4gKiBDb3JlIGltcGxlbWVudGF0aW9uIGZvciBhY3RpdmUgaW5mZXJlbmNlLCBmcmVlIGVuZXJneSBtaW5pbWl6YXRpb24sXG4gKiBhbmQgYmVsaWVmIHVwZGF0aW5nIGJhc2VkIG9uIHRoZSBGcmVlIEVuZXJneSBQcmluY2lwbGUuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0aXZlTW9kZWwge1xuICBzdGF0ZXM6IHN0cmluZ1tdO1xuICBvYnNlcnZhdGlvbnM6IHN0cmluZ1tdO1xuICBhY3Rpb25zOiBzdHJpbmdbXTtcbiAgdHJhbnNpdGlvbk1vZGVsOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+Pj47XG4gIG9ic2VydmF0aW9uTW9kZWw6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlcj4+O1xuICBwcmVmZXJlbmNlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCZWxpZWZzIHtcbiAgc3RhdGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICB1bmNlcnRhaW50eTogbnVtYmVyO1xuICBjb252ZXJnZWQ/OiBib29sZWFuO1xuICBpdGVyYXRpb25zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbnNvcnlJbnB1dCB7XG4gIHR5cGU6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbiB7XG4gIHR5cGU6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xuICBleHBlY3RlZE91dGNvbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIFBvbGljeSA9IEFycmF5PHtcbiAgYWN0aW9uOiBzdHJpbmc7XG4gIHRpbWVzdGVwOiBudW1iZXI7XG59PjtcblxuZXhwb3J0IGludGVyZmFjZSBBY3RpdmVJbmZlcmVuY2VDb25maWcge1xuICBtb2RlbDogR2VuZXJhdGl2ZU1vZGVsO1xuICBwcmVjaXNpb24/OiBudW1iZXI7XG4gIGxlYXJuaW5nUmF0ZT86IG51bWJlcjtcbiAgcGxhbm5pbmdIb3Jpem9uPzogbnVtYmVyO1xuICBhY3Rpb25Db25zdHJhaW50cz86IFJlY29yZDxzdHJpbmcsIHsgbWF4RnJlcXVlbmN5OiBudW1iZXIgfT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZlSW5mZXJlbmNlRW5naW5lIHtcbiAgbW9kZWw6IEdlbmVyYXRpdmVNb2RlbDtcbiAgcHJlY2lzaW9uOiBudW1iZXI7XG4gIGxlYXJuaW5nUmF0ZTogbnVtYmVyO1xuICBwbGFubmluZ0hvcml6b246IG51bWJlcjtcbiAgYWN0aW9uQ29uc3RyYWludHM/OiBSZWNvcmQ8c3RyaW5nLCB7IG1heEZyZXF1ZW5jeTogbnVtYmVyIH0+O1xuICBiZWxpZWZzOiBCZWxpZWZzO1xuICBhY3Rpb25IaXN0b3J5OiBzdHJpbmdbXTtcbiAgZ2V0Q3VycmVudEJlbGllZnM6ICgpID0+IEJlbGllZnM7XG4gIHNldEJlbGllZnM6IChiZWxpZWZzOiBCZWxpZWZzKSA9PiB2b2lkO1xuICBjYWxjdWxhdGVGcmVlRW5lcmd5OiAoYmVsaWVmczogQmVsaWVmcywgb2JzZXJ2YXRpb246IHN0cmluZykgPT4gbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVJlc3VsdCB7XG4gIGJlbGllZnM6IEJlbGllZnM7XG4gIHNlbGVjdGVkQWN0aW9uOiBBY3Rpb247XG4gIGZyZWVFbmVyZ3k6IG51bWJlcjtcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGVjdGVkRnJlZUVuZXJneSB7XG4gIHRvdGFsOiBudW1iZXI7XG4gIGVwaXN0ZW1pYzogbnVtYmVyO1xuICBwcmFnbWF0aWM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb2xpY3lFdmFsdWF0aW9uIHtcbiAgZXhwZWN0ZWRSZXR1cm46IG51bWJlcjtcbiAgdW5jZXJ0YWludHk6IG51bWJlcjtcbiAgZmVhc2liaWxpdHk6IG51bWJlcjtcbn1cblxuY29uc3QgRVBTSUxPTiA9IDFlLTEwO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWN0aXZlSW5mZXJlbmNlRW5naW5lKFxuICBjb25maWc6IEFjdGl2ZUluZmVyZW5jZUNvbmZpZyxcbik6IEFjdGl2ZUluZmVyZW5jZUVuZ2luZSB7XG4gIC8vIFZhbGlkYXRlIG1vZGVsXG4gIGlmIChcbiAgICAhY29uZmlnLm1vZGVsLnN0YXRlcy5sZW5ndGggfHxcbiAgICAhY29uZmlnLm1vZGVsLm9ic2VydmF0aW9ucy5sZW5ndGggfHxcbiAgICAhY29uZmlnLm1vZGVsLmFjdGlvbnMubGVuZ3RoXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBnZW5lcmF0aXZlIG1vZGVsOiBtaXNzaW5nIHN0YXRlcywgb2JzZXJ2YXRpb25zLCBvciBhY3Rpb25zXCIsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhjb25maWcubW9kZWwudHJhbnNpdGlvbk1vZGVsKS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdlbmVyYXRpdmUgbW9kZWw6IGVtcHR5IHRyYW5zaXRpb24gbW9kZWxcIik7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHVuaWZvcm0gYmVsaWVmc1xuICBjb25zdCB1bmlmb3JtUHJvYiA9IDEuMCAvIGNvbmZpZy5tb2RlbC5zdGF0ZXMubGVuZ3RoO1xuICBjb25zdCBpbml0aWFsQmVsaWVmczogQmVsaWVmcyA9IHtcbiAgICBzdGF0ZXM6IHt9LFxuICAgIHVuY2VydGFpbnR5OiAxLjAsXG4gIH07XG5cbiAgY29uZmlnLm1vZGVsLnN0YXRlcy5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgIGluaXRpYWxCZWxpZWZzLnN0YXRlc1tzdGF0ZV0gPSB1bmlmb3JtUHJvYjtcbiAgfSk7XG5cbiAgY29uc3QgZW5naW5lOiBBY3RpdmVJbmZlcmVuY2VFbmdpbmUgPSB7XG4gICAgbW9kZWw6IGNvbmZpZy5tb2RlbCxcbiAgICBwcmVjaXNpb246IGNvbmZpZy5wcmVjaXNpb24gfHwgMS4wLFxuICAgIGxlYXJuaW5nUmF0ZTogY29uZmlnLmxlYXJuaW5nUmF0ZSB8fCAwLjEsXG4gICAgcGxhbm5pbmdIb3Jpem9uOiBjb25maWcucGxhbm5pbmdIb3Jpem9uIHx8IDMsXG4gICAgYWN0aW9uQ29uc3RyYWludHM6IGNvbmZpZy5hY3Rpb25Db25zdHJhaW50cyxcbiAgICBiZWxpZWZzOiBpbml0aWFsQmVsaWVmcyxcbiAgICBhY3Rpb25IaXN0b3J5OiBbXSxcblxuICAgIGdldEN1cnJlbnRCZWxpZWZzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyAuLi50aGlzLmJlbGllZnMgfTtcbiAgICB9LFxuXG4gICAgc2V0QmVsaWVmczogZnVuY3Rpb24gKGJlbGllZnM6IEJlbGllZnMpIHtcbiAgICAgIHRoaXMuYmVsaWVmcyA9IHsgLi4uYmVsaWVmcyB9O1xuICAgIH0sXG5cbiAgICBjYWxjdWxhdGVGcmVlRW5lcmd5OiBmdW5jdGlvbiAoYmVsaWVmczogQmVsaWVmcywgb2JzZXJ2YXRpb246IHN0cmluZykge1xuICAgICAgLy8gQWNjdXJhY3kgdGVybSAoZXhwZWN0ZWQgbG9nIGxpa2VsaWhvb2QpXG4gICAgICBsZXQgYWNjdXJhY3kgPSAwO1xuICAgICAgT2JqZWN0LmVudHJpZXMoYmVsaWVmcy5zdGF0ZXMpLmZvckVhY2goKFtzdGF0ZSwgcHJvYl0pID0+IHtcbiAgICAgICAgY29uc3QgbGlrZWxpaG9vZCA9XG4gICAgICAgICAgdGhpcy5tb2RlbC5vYnNlcnZhdGlvbk1vZGVsW3N0YXRlXT8uW29ic2VydmF0aW9uXSB8fCBFUFNJTE9OO1xuICAgICAgICBhY2N1cmFjeSArPSBwcm9iICogTWF0aC5sb2cobGlrZWxpaG9vZCArIEVQU0lMT04pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENvbXBsZXhpdHkgdGVybSAoS0wgZGl2ZXJnZW5jZSBmcm9tIHByaW9yKVxuICAgICAgbGV0IGNvbXBsZXhpdHkgPSAwO1xuICAgICAgY29uc3QgcHJpb3IgPSAxLjAgLyB0aGlzLm1vZGVsLnN0YXRlcy5sZW5ndGg7XG4gICAgICBPYmplY3QudmFsdWVzKGJlbGllZnMuc3RhdGVzKS5mb3JFYWNoKChwcm9iKSA9PiB7XG4gICAgICAgIGlmIChwcm9iID4gMCkge1xuICAgICAgICAgIGNvbXBsZXhpdHkgKz0gcHJvYiAqIE1hdGgubG9nKChwcm9iICsgRVBTSUxPTikgLyBwcmlvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDb252ZXJ0IHByZWZlcmVuY2UgdG8gYSBwb3NpdGl2ZSBjb3N0IHRlcm1cbiAgICAgIC8vIE5lZ2F0aXZlIHByZWZlcmVuY2VzIChyZXdhcmRzKSBiZWNvbWUgcG9zaXRpdmUgY29zdHNcbiAgICAgIGNvbnN0IHByZWZlcmVuY2UgPSB0aGlzLm1vZGVsLnByZWZlcmVuY2VzW29ic2VydmF0aW9uXSB8fCAwO1xuICAgICAgY29uc3QgY29zdCA9IC1wcmVmZXJlbmNlOyAvLyBDb252ZXJ0IHJld2FyZCB0byBjb3N0XG5cbiAgICAgIC8vIEFkZCB1bmNlcnRhaW50eSB0ZXJtXG4gICAgICBjb25zdCB1bmNlcnRhaW50eVBlbmFsdHkgPSBiZWxpZWZzLnVuY2VydGFpbnR5ICogMi4wO1xuXG4gICAgICAvLyBGcmVlIGVuZXJneSA9IC1sb2cgbGlrZWxpaG9vZCArIGNvbXBsZXhpdHkgKyBjb3N0ICsgdW5jZXJ0YWludHlcbiAgICAgIGNvbnN0IGZyZWVFbmVyZ3kgPSAtYWNjdXJhY3kgKyBjb21wbGV4aXR5ICsgY29zdCArIHVuY2VydGFpbnR5UGVuYWx0eTtcblxuICAgICAgLy8gRW5zdXJlIGZyZWUgZW5lcmd5IGlzIHBvc2l0aXZlIGJ5IGFkZGluZyBhIGNvbnN0YW50IGlmIG5lZWRlZFxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAuMDEsIGZyZWVFbmVyZ3kpO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIGVuZ2luZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUJlbGllZnMoXG4gIGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBvYnNlcnZhdGlvbjogU2Vuc29yeUlucHV0LFxuKTogQmVsaWVmcyB7XG4gIGNvbnN0IGN1cnJlbnRCZWxpZWZzID0gZW5naW5lLmdldEN1cnJlbnRCZWxpZWZzKCk7XG4gIGNvbnN0IHVwZGF0ZWRCZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgIHN0YXRlczoge30sXG4gICAgdW5jZXJ0YWludHk6IGN1cnJlbnRCZWxpZWZzLnVuY2VydGFpbnR5LFxuICB9O1xuXG4gIC8vIFN0YW5kYXJkIEJheWVzaWFuIGJlbGllZiB1cGRhdGVcbiAgbGV0IHRvdGFsUG9zdGVyaW9yID0gMDtcblxuICBlbmdpbmUubW9kZWwuc3RhdGVzLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgcHJpb3IgPSBjdXJyZW50QmVsaWVmcy5zdGF0ZXNbc3RhdGVdO1xuICAgIGNvbnN0IGxpa2VsaWhvb2QgPVxuICAgICAgZW5naW5lLm1vZGVsLm9ic2VydmF0aW9uTW9kZWxbc3RhdGVdPy5bb2JzZXJ2YXRpb24udmFsdWVdIHx8IEVQU0lMT047XG5cbiAgICBjb25zdCBwb3N0ZXJpb3IgPSBwcmlvciAqIGxpa2VsaWhvb2Q7XG4gICAgdXBkYXRlZEJlbGllZnMuc3RhdGVzW3N0YXRlXSA9IHBvc3RlcmlvcjtcbiAgICB0b3RhbFBvc3RlcmlvciArPSBwb3N0ZXJpb3I7XG4gIH0pO1xuXG4gIC8vIE5vcm1hbGl6ZSB0byBnZXQgc3RhbmRhcmQgQmF5ZXNpYW4gcG9zdGVyaW9yXG4gIE9iamVjdC5rZXlzKHVwZGF0ZWRCZWxpZWZzLnN0YXRlcykuZm9yRWFjaCgoc3RhdGUpID0+IHtcbiAgICB1cGRhdGVkQmVsaWVmcy5zdGF0ZXNbc3RhdGVdIC89IHRvdGFsUG9zdGVyaW9yO1xuICB9KTtcblxuICAvLyBBcHBseSBjb25maWRlbmNlIHdlaWdodGluZyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcHJpb3IgYW5kIHBvc3RlcmlvclxuICBPYmplY3Qua2V5cyh1cGRhdGVkQmVsaWVmcy5zdGF0ZXMpLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgcHJpb3IgPSBjdXJyZW50QmVsaWVmcy5zdGF0ZXNbc3RhdGVdO1xuICAgIGNvbnN0IHBvc3RlcmlvciA9IHVwZGF0ZWRCZWxpZWZzLnN0YXRlc1tzdGF0ZV07XG4gICAgXG4gICAgLy8gSGlnaCBjb25maWRlbmNlID0gdXNlIG1vcmUgb2YgcG9zdGVyaW9yLCBsb3cgY29uZmlkZW5jZSA9IHVzZSBtb3JlIG9mIHByaW9yXG4gICAgdXBkYXRlZEJlbGllZnMuc3RhdGVzW3N0YXRlXSA9IFxuICAgICAgb2JzZXJ2YXRpb24uY29uZmlkZW5jZSAqIHBvc3RlcmlvciArIFxuICAgICAgKDEgLSBvYnNlcnZhdGlvbi5jb25maWRlbmNlKSAqIHByaW9yO1xuICB9KTtcblxuICAvLyBVcGRhdGUgdW5jZXJ0YWludHkgYmFzZWQgb24gb2JzZXJ2YXRpb24gY29uZmlkZW5jZSBhbmQgYmVsaWVmIGVudHJvcHlcbiAgY29uc3QgZW50cm9weSA9IE9iamVjdC52YWx1ZXModXBkYXRlZEJlbGllZnMuc3RhdGVzKS5yZWR1Y2UoKGgsIHApID0+IHtcbiAgICByZXR1cm4gcCA+IDAgPyBoIC0gcCAqIE1hdGgubG9nKHAgKyBFUFNJTE9OKSA6IGg7XG4gIH0sIDApO1xuXG4gIHVwZGF0ZWRCZWxpZWZzLnVuY2VydGFpbnR5ID1cbiAgICAoMSAtIG9ic2VydmF0aW9uLmNvbmZpZGVuY2UpICogMC4zICsgZW50cm9weSAqIDAuNztcblxuICAvLyBEb24ndCBtb2RpZnkgZW5naW5lIHN0YXRlLCBqdXN0IHJldHVybiB0aGUgdXBkYXRlZCBiZWxpZWZzXG4gIHJldHVybiB1cGRhdGVkQmVsaWVmcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdEFjdGlvbihcbiAgZW5naW5lOiBBY3RpdmVJbmZlcmVuY2VFbmdpbmUsXG4gIGJlbGllZnM6IEJlbGllZnMsXG4pOiBBY3Rpb24ge1xuICBsZXQgYmVzdEFjdGlvbiA9IFwiXCI7XG4gIGxldCBtaW5FeHBlY3RlZEZFID0gSW5maW5pdHk7XG4gIGNvbnN0IGFjdGlvblNjb3JlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuXG4gIC8vIENoZWNrIGFjdGlvbiBjb25zdHJhaW50c1xuICBjb25zdCBhY3Rpb25Db3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgZW5naW5lLmFjdGlvbkhpc3RvcnkuZm9yRWFjaCgoYWN0aW9uKSA9PiB7XG4gICAgYWN0aW9uQ291bnRzW2FjdGlvbl0gPSAoYWN0aW9uQ291bnRzW2FjdGlvbl0gfHwgMCkgKyAxO1xuICB9KTtcblxuICBlbmdpbmUubW9kZWwuYWN0aW9ucy5mb3JFYWNoKChhY3Rpb24pID0+IHtcbiAgICAvLyBDaGVjayBjb25zdHJhaW50c1xuICAgIGlmIChlbmdpbmUuYWN0aW9uQ29uc3RyYWludHM/LlthY3Rpb25dKSB7XG4gICAgICBjb25zdCBmcmVxdWVuY3kgPVxuICAgICAgICAoYWN0aW9uQ291bnRzW2FjdGlvbl0gfHwgMCkgLyBNYXRoLm1heChlbmdpbmUuYWN0aW9uSGlzdG9yeS5sZW5ndGgsIDEpO1xuICAgICAgaWYgKGZyZXF1ZW5jeSA+PSBlbmdpbmUuYWN0aW9uQ29uc3RyYWludHNbYWN0aW9uXS5tYXhGcmVxdWVuY3kpIHtcbiAgICAgICAgYWN0aW9uU2NvcmVzW2FjdGlvbl0gPSBJbmZpbml0eTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBleHBlY3RlZCBmcmVlIGVuZXJneSBmb3IgdGhpcyBhY3Rpb25cbiAgICBsZXQgZXhwZWN0ZWRGRSA9IDA7XG5cbiAgICAvLyBFcGlzdGVtaWMgdmFsdWUgKGluZm9ybWF0aW9uIGdhaW4pXG4gICAgY29uc3QgZXBpc3RlbWljID0gY2FsY3VsYXRlRXBpc3RlbWljKGVuZ2luZSwgYmVsaWVmcywgYWN0aW9uKTtcblxuICAgIC8vIFByYWdtYXRpYyB2YWx1ZSAoZ29hbCBhY2hpZXZlbWVudClcbiAgICBjb25zdCBwcmFnbWF0aWMgPSBjYWxjdWxhdGVQcmFnbWF0aWMoZW5naW5lLCBiZWxpZWZzLCBhY3Rpb24pO1xuXG4gICAgLy8gQ29tYmluZSB3aXRoIHByZWNpc2lvbiB3ZWlnaHRpbmdcbiAgICBleHBlY3RlZEZFID0gZW5naW5lLnByZWNpc2lvbiAqIHByYWdtYXRpYyAtIGVwaXN0ZW1pYztcblxuICAgIC8vIEFkZCBleHBsb3JhdGlvbiBib251cyB1bmRlciBoaWdoIHVuY2VydGFpbnR5XG4gICAgaWYgKGJlbGllZnMudW5jZXJ0YWludHkgPiAwLjUgJiYgYWN0aW9uICE9PSBcIndhaXRcIikge1xuICAgICAgZXhwZWN0ZWRGRSAtPSBiZWxpZWZzLnVuY2VydGFpbnR5ICogMC41O1xuICAgIH1cblxuICAgIC8vIEFkZCBhY3Rpb24gdmFyaWV0eSBib251cyB0byBwcmV2ZW50IGdldHRpbmcgc3R1Y2tcbiAgICBjb25zdCByZWNlbnRBY3Rpb25zID0gZW5naW5lLmFjdGlvbkhpc3Rvcnkuc2xpY2UoLTUpO1xuICAgIGNvbnN0IGFjdGlvbkZyZXF1ZW5jeSA9IHJlY2VudEFjdGlvbnMuZmlsdGVyKGEgPT4gYSA9PT0gYWN0aW9uKS5sZW5ndGggLyBNYXRoLm1heChyZWNlbnRBY3Rpb25zLmxlbmd0aCwgMSk7XG4gICAgY29uc3QgdmFyaWV0eVBlbmFsdHkgPSBhY3Rpb25GcmVxdWVuY3kgKiAyLjA7IC8vIFBlbmFsaXplIHJlcGV0aXRpdmUgYWN0aW9uc1xuICAgIGV4cGVjdGVkRkUgKz0gdmFyaWV0eVBlbmFsdHk7XG5cbiAgICBhY3Rpb25TY29yZXNbYWN0aW9uXSA9IGV4cGVjdGVkRkU7XG5cbiAgICBpZiAoZXhwZWN0ZWRGRSA8IG1pbkV4cGVjdGVkRkUpIHtcbiAgICAgIG1pbkV4cGVjdGVkRkUgPSBleHBlY3RlZEZFO1xuICAgICAgYmVzdEFjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENhbGN1bGF0ZSBhY3Rpb24gY29uZmlkZW5jZSBiYXNlZCBvbiBzY29yZSBkaWZmZXJlbmNlc1xuICBjb25zdCBzY29yZXMgPSBPYmplY3QudmFsdWVzKGFjdGlvblNjb3JlcykuZmlsdGVyKChzKSA9PiBzICE9PSBJbmZpbml0eSk7XG4gIGNvbnN0IGF2Z1Njb3JlID0gc2NvcmVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gc2NvcmVzLmxlbmd0aDtcbiAgY29uc3QgY29uZmlkZW5jZSA9IE1hdGguZXhwKC1NYXRoLmFicyhtaW5FeHBlY3RlZEZFIC0gYXZnU2NvcmUpKTtcblxuICBlbmdpbmUuYWN0aW9uSGlzdG9yeS5wdXNoKGJlc3RBY3Rpb24pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogYmVzdEFjdGlvbixcbiAgICBjb25maWRlbmNlOiBNYXRoLm1pbihNYXRoLm1heChjb25maWRlbmNlLCAwLjEpLCAxLjApLFxuICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGVyZm9ybUluZmVyZW5jZShcbiAgZW5naW5lOiBBY3RpdmVJbmZlcmVuY2VFbmdpbmUsXG4gIG9ic2VydmF0aW9uOiBTZW5zb3J5SW5wdXQsXG4pOiBQcm9taXNlPEluZmVyZW5jZVJlc3VsdD4ge1xuICAvLyBVcGRhdGUgYmVsaWVmcyBiYXNlZCBvbiBvYnNlcnZhdGlvblxuICBjb25zdCB1cGRhdGVkQmVsaWVmcyA9IHVwZGF0ZUJlbGllZnMoZW5naW5lLCBvYnNlcnZhdGlvbik7XG5cbiAgLy8gVXBkYXRlIHRoZSBlbmdpbmUncyBiZWxpZWZzIGZvciBwZXJzaXN0ZW5jZSBhY3Jvc3MgaW5mZXJlbmNlc1xuICBlbmdpbmUuc2V0QmVsaWVmcyh1cGRhdGVkQmVsaWVmcyk7XG5cbiAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgZnJlZSBlbmVyZ3lcbiAgY29uc3QgZnJlZUVuZXJneSA9IGVuZ2luZS5jYWxjdWxhdGVGcmVlRW5lcmd5KFxuICAgIHVwZGF0ZWRCZWxpZWZzLFxuICAgIG9ic2VydmF0aW9uLnZhbHVlLFxuICApO1xuXG4gIC8vIFNlbGVjdCBhY3Rpb24gdGhhdCBtaW5pbWl6ZXMgZXhwZWN0ZWQgZnJlZSBlbmVyZ3lcbiAgY29uc3Qgc2VsZWN0ZWRBY3Rpb24gPSBzZWxlY3RBY3Rpb24oZW5naW5lLCB1cGRhdGVkQmVsaWVmcyk7XG5cbiAgLy8gT3ZlcmFsbCBjb25maWRlbmNlIGJhc2VkIG9uIGJlbGllZiBjZXJ0YWludHkgYW5kIGFjdGlvbiBjb25maWRlbmNlXG4gIGNvbnN0IGJlbGllZkNlcnRhaW50eSA9IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXModXBkYXRlZEJlbGllZnMuc3RhdGVzKSk7XG4gIGNvbnN0IG92ZXJhbGxDb25maWRlbmNlID0gKGJlbGllZkNlcnRhaW50eSArIHNlbGVjdGVkQWN0aW9uLmNvbmZpZGVuY2UpIC8gMjtcblxuICByZXR1cm4ge1xuICAgIGJlbGllZnM6IHVwZGF0ZWRCZWxpZWZzLFxuICAgIHNlbGVjdGVkQWN0aW9uLFxuICAgIGZyZWVFbmVyZ3ksXG4gICAgY29uZmlkZW5jZTogb3ZlcmFsbENvbmZpZGVuY2UsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFeHBlY3RlZEZyZWVFbmVyZ3koXG4gIGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBwb2xpY3k6IFBvbGljeSxcbik6IEV4cGVjdGVkRnJlZUVuZXJneSB7XG4gIGxldCB0b3RhbEVGRSA9IDA7XG4gIGxldCB0b3RhbEVwaXN0ZW1pYyA9IDA7XG4gIGxldCB0b3RhbFByYWdtYXRpYyA9IDA7XG5cbiAgLy8gU3RhcnQgd2l0aCBjdXJyZW50IGJlbGllZnNcbiAgbGV0IGJlbGllZnMgPSBlbmdpbmUuZ2V0Q3VycmVudEJlbGllZnMoKTtcblxuICBwb2xpY3kuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgIGNvbnN0IGVwaXN0ZW1pYyA9IGNhbGN1bGF0ZUVwaXN0ZW1pYyhlbmdpbmUsIGJlbGllZnMsIHN0ZXAuYWN0aW9uKTtcbiAgICBjb25zdCBwcmFnbWF0aWMgPSBjYWxjdWxhdGVQcmFnbWF0aWMoZW5naW5lLCBiZWxpZWZzLCBzdGVwLmFjdGlvbik7XG5cbiAgICAvLyBFbnN1cmUgZmluaXRlIHZhbHVlc1xuICAgIGNvbnN0IGZpbml0ZUVwaXN0ZW1pYyA9IE51bWJlci5pc0Zpbml0ZShlcGlzdGVtaWMpID8gZXBpc3RlbWljIDogMDtcbiAgICBjb25zdCBmaW5pdGVQcmFnbWF0aWMgPSBOdW1iZXIuaXNGaW5pdGUocHJhZ21hdGljKSA/IHByYWdtYXRpYyA6IDA7XG5cbiAgICB0b3RhbEVwaXN0ZW1pYyArPSBmaW5pdGVFcGlzdGVtaWMgKiBNYXRoLnBvdygwLjksIHN0ZXAudGltZXN0ZXApOyAvLyBEaXNjb3VudCBmdXR1cmVcbiAgICB0b3RhbFByYWdtYXRpYyArPSBmaW5pdGVQcmFnbWF0aWMgKiBNYXRoLnBvdygwLjksIHN0ZXAudGltZXN0ZXApO1xuXG4gICAgLy8gUHJlZGljdCBiZWxpZWYgZXZvbHV0aW9uXG4gICAgYmVsaWVmcyA9IHByZWRpY3RCZWxpZWZFdm9sdXRpb24oZW5naW5lLCBiZWxpZWZzLCBzdGVwLmFjdGlvbik7XG4gIH0pO1xuXG4gIHRvdGFsRUZFID0gZW5naW5lLnByZWNpc2lvbiAqIHRvdGFsUHJhZ21hdGljIC0gdG90YWxFcGlzdGVtaWM7XG5cbiAgLy8gRW5zdXJlIGFsbCB2YWx1ZXMgYXJlIGZpbml0ZVxuICByZXR1cm4ge1xuICAgIHRvdGFsOiBOdW1iZXIuaXNGaW5pdGUodG90YWxFRkUpID8gdG90YWxFRkUgOiAwLFxuICAgIGVwaXN0ZW1pYzogTnVtYmVyLmlzRmluaXRlKHRvdGFsRXBpc3RlbWljKSA/IHRvdGFsRXBpc3RlbWljIDogMCxcbiAgICBwcmFnbWF0aWM6IE51bWJlci5pc0Zpbml0ZSh0b3RhbFByYWdtYXRpYykgPyB0b3RhbFByYWdtYXRpYyA6IDAsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFcGlzdGVtaWMoXG4gIGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBiZWxpZWZzOiBCZWxpZWZzLFxuICBhY3Rpb246IHN0cmluZyxcbik6IG51bWJlciB7XG4gIC8vIEluZm9ybWF0aW9uIGdhaW46IHJlZHVjdGlvbiBpbiB1bmNlcnRhaW50eSBhYm91dCBzdGF0ZXNcbiAgbGV0IGluZm9ybWF0aW9uR2FpbiA9IDA7XG5cbiAgLy8gQ3VycmVudCBlbnRyb3B5XG4gIGNvbnN0IGN1cnJlbnRFbnRyb3B5ID0gT2JqZWN0LnZhbHVlcyhiZWxpZWZzLnN0YXRlcykucmVkdWNlKChoLCBwKSA9PiB7XG4gICAgcmV0dXJuIHAgPiAwID8gaCAtIHAgKiBNYXRoLmxvZyhwICsgRVBTSUxPTikgOiBoO1xuICB9LCAwKTtcblxuICAvLyBFeHBlY3RlZCBlbnRyb3B5IGFmdGVyIGFjdGlvblxuICBsZXQgZXhwZWN0ZWRFbnRyb3B5ID0gMDtcbiAgY29uc3QgcHJlZGljdGVkQmVsaWVmcyA9IHByZWRpY3RCZWxpZWZFdm9sdXRpb24oZW5naW5lLCBiZWxpZWZzLCBhY3Rpb24pO1xuXG4gIGV4cGVjdGVkRW50cm9weSA9IE9iamVjdC52YWx1ZXMocHJlZGljdGVkQmVsaWVmcy5zdGF0ZXMpLnJlZHVjZSgoaCwgcCkgPT4ge1xuICAgIHJldHVybiBwID4gMCA/IGggLSBwICogTWF0aC5sb2cocCArIEVQU0lMT04pIDogaDtcbiAgfSwgMCk7XG5cbiAgaW5mb3JtYXRpb25HYWluID0gY3VycmVudEVudHJvcHkgLSBleHBlY3RlZEVudHJvcHk7XG5cbiAgLy8gQWRkIGV4cGxvcmF0aW9uIGJvbnVzIGZvciB1bmNlcnRhaW4gc3RhdGVzXG4gIGNvbnN0IGV4cGxvcmF0aW9uQm9udXMgPSBiZWxpZWZzLnVuY2VydGFpbnR5ICogMC4zO1xuXG4gIGNvbnN0IHJlc3VsdCA9IE1hdGgubWF4KDAsIGluZm9ybWF0aW9uR2FpbiArIGV4cGxvcmF0aW9uQm9udXMpO1xuICBcbiAgLy8gRW5zdXJlIGZpbml0ZSByZXN1bHRcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShyZXN1bHQpID8gcmVzdWx0IDogMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVByYWdtYXRpYyhcbiAgZW5naW5lOiBBY3RpdmVJbmZlcmVuY2VFbmdpbmUsXG4gIGJlbGllZnM6IEJlbGllZnMsXG4gIGFjdGlvbjogc3RyaW5nLFxuKTogbnVtYmVyIHtcbiAgLy8gRXhwZWN0ZWQgcHJlZmVyZW5jZSBzYXRpc2ZhY3Rpb25cbiAgbGV0IGV4cGVjdGVkUHJlZmVyZW5jZSA9IDA7XG5cbiAgLy8gUHJlZGljdCBvdXRjb21lcyBmb3IgdGhpcyBhY3Rpb25cbiAgY29uc3QgcHJlZGljdGlvbnMgPSBwcmVkaWN0U2Vuc29yeU91dGNvbWVzKGVuZ2luZSwgYmVsaWVmcywgYWN0aW9uKTtcblxuICBPYmplY3QuZW50cmllcyhwcmVkaWN0aW9ucykuZm9yRWFjaCgoW291dGNvbWUsIHByb2JdKSA9PiB7XG4gICAgY29uc3QgcHJlZmVyZW5jZSA9IGVuZ2luZS5tb2RlbC5wcmVmZXJlbmNlc1tvdXRjb21lXSB8fCAwO1xuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbiA9IHByb2IgKiBwcmVmZXJlbmNlO1xuICAgIFxuICAgIC8vIE9ubHkgYWRkIGZpbml0ZSBjb250cmlidXRpb25zXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShjb250cmlidXRpb24pKSB7XG4gICAgICBleHBlY3RlZFByZWZlcmVuY2UgKz0gY29udHJpYnV0aW9uO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRW5zdXJlIGZpbml0ZSByZXN1bHRcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShleHBlY3RlZFByZWZlcmVuY2UpID8gZXhwZWN0ZWRQcmVmZXJlbmNlIDogMDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pbmltaXplVmFyaWF0aW9uYWxGcmVlRW5lcmd5KFxuICBlbmdpbmU6IEFjdGl2ZUluZmVyZW5jZUVuZ2luZSxcbiAgaW5pdGlhbEJlbGllZnM6IEJlbGllZnMsXG4gIG9ic2VydmF0aW9uOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiB7IG1heEl0ZXJhdGlvbnM/OiBudW1iZXI7IHRvbGVyYW5jZT86IG51bWJlciB9LFxuKTogUHJvbWlzZTxCZWxpZWZzPiB7XG4gIGNvbnN0IG1heEl0ZXIgPSBvcHRpb25zPy5tYXhJdGVyYXRpb25zIHx8IDEwMDtcbiAgY29uc3QgdG9sZXJhbmNlID0gb3B0aW9ucz8udG9sZXJhbmNlIHx8IDAuMDAxO1xuXG4gIGxldCBiZWxpZWZzID0geyAuLi5pbml0aWFsQmVsaWVmcyB9O1xuICBsZXQgcHJldkZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koYmVsaWVmcywgb2JzZXJ2YXRpb24pO1xuICBsZXQgY29udmVyZ2VkID0gZmFsc2U7XG4gIGxldCBpdGVyYXRpb25zID0gMDtcblxuICB3aGlsZSAoaXRlcmF0aW9ucyA8IG1heEl0ZXIgJiYgIWNvbnZlcmdlZCkge1xuICAgIC8vIEdyYWRpZW50IGRlc2NlbnQgb24gYmVsaWVmc1xuICAgIGNvbnN0IGdyYWRpZW50OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgY29uc3QgZGVsdGEgPSAwLjAwMTtcblxuICAgIGVuZ2luZS5tb2RlbC5zdGF0ZXMuZm9yRWFjaCgoc3RhdGUpID0+IHtcbiAgICAgIC8vIEZpbml0ZSBkaWZmZXJlbmNlIGFwcHJveGltYXRpb25cbiAgICAgIGNvbnN0IGJlbGllZnNDb3B5ID0geyAuLi5iZWxpZWZzIH07XG4gICAgICBiZWxpZWZzQ29weS5zdGF0ZXNbc3RhdGVdID0gTWF0aC5taW4oYmVsaWVmcy5zdGF0ZXNbc3RhdGVdICsgZGVsdGEsIDEpO1xuXG4gICAgICAvLyBSZW5vcm1hbGl6ZVxuICAgICAgY29uc3Qgc3VtID0gT2JqZWN0LnZhbHVlcyhiZWxpZWZzQ29weS5zdGF0ZXMpLnJlZHVjZSgocywgcCkgPT4gcyArIHAsIDApO1xuICAgICAgT2JqZWN0LmtleXMoYmVsaWVmc0NvcHkuc3RhdGVzKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIGJlbGllZnNDb3B5LnN0YXRlc1tzXSAvPSBzdW07XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZmVQbHVzID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koYmVsaWVmc0NvcHksIG9ic2VydmF0aW9uKTtcbiAgICAgIGdyYWRpZW50W3N0YXRlXSA9IChmZVBsdXMgLSBwcmV2RkUpIC8gZGVsdGE7XG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgYmVsaWVmc1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZW5naW5lLm1vZGVsLnN0YXRlcy5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlID0gLWdyYWRpZW50W3N0YXRlXSAqIGVuZ2luZS5sZWFybmluZ1JhdGU7XG4gICAgICBjb25zdCBuZXdCZWxpZWYgPSBNYXRoLm1heChcbiAgICAgICAgMCxcbiAgICAgICAgTWF0aC5taW4oMSwgYmVsaWVmcy5zdGF0ZXNbc3RhdGVdICsgdXBkYXRlKSxcbiAgICAgICk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhuZXdCZWxpZWYgLSBiZWxpZWZzLnN0YXRlc1tzdGF0ZV0pID4gdG9sZXJhbmNlKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBiZWxpZWZzLnN0YXRlc1tzdGF0ZV0gPSBuZXdCZWxpZWY7XG4gICAgfSk7XG5cbiAgICAvLyBSZW5vcm1hbGl6ZVxuICAgIGNvbnN0IHN1bSA9IE9iamVjdC52YWx1ZXMoYmVsaWVmcy5zdGF0ZXMpLnJlZHVjZSgocywgcCkgPT4gcyArIHAsIDApO1xuICAgIE9iamVjdC5rZXlzKGJlbGllZnMuc3RhdGVzKS5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgICAgYmVsaWVmcy5zdGF0ZXNbc3RhdGVdIC89IHN1bTtcbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGNvbnZlcmdlbmNlXG4gICAgY29uc3QgY3VycmVudEZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koYmVsaWVmcywgb2JzZXJ2YXRpb24pO1xuICAgIGlmICghY2hhbmdlZCB8fCBNYXRoLmFicyhjdXJyZW50RkUgLSBwcmV2RkUpIDwgdG9sZXJhbmNlKSB7XG4gICAgICBjb252ZXJnZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHByZXZGRSA9IGN1cnJlbnRGRTtcbiAgICBpdGVyYXRpb25zKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLmJlbGllZnMsXG4gICAgY29udmVyZ2VkLFxuICAgIGl0ZXJhdGlvbnMsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVkaWN0U2Vuc29yeU91dGNvbWVzKFxuICBlbmdpbmU6IEFjdGl2ZUluZmVyZW5jZUVuZ2luZSxcbiAgYmVsaWVmczogQmVsaWVmcyxcbiAgYWN0aW9uOiBzdHJpbmcsXG4pOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHtcbiAgY29uc3QgcHJlZGljdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcblxuICAvLyBJbml0aWFsaXplIHByZWRpY3Rpb25zXG4gIGVuZ2luZS5tb2RlbC5vYnNlcnZhdGlvbnMuZm9yRWFjaCgob2JzKSA9PiB7XG4gICAgcHJlZGljdGlvbnNbb2JzXSA9IDA7XG4gIH0pO1xuXG4gIC8vIEZvciBlYWNoIGN1cnJlbnQgc3RhdGVcbiAgT2JqZWN0LmVudHJpZXMoYmVsaWVmcy5zdGF0ZXMpLmZvckVhY2goKFtjdXJyZW50U3RhdGUsIHN0YXRlUHJvYl0pID0+IHtcbiAgICAvLyBHZXQgdHJhbnNpdGlvbiBwcm9iYWJpbGl0aWVzIGZvciB0aGlzIGFjdGlvblxuICAgIGNvbnN0IHRyYW5zaXRpb25zID1cbiAgICAgIGVuZ2luZS5tb2RlbC50cmFuc2l0aW9uTW9kZWxbY3VycmVudFN0YXRlXT8uW2FjdGlvbl0gfHwge307XG5cbiAgICAvLyBGb3IgZWFjaCBwb3NzaWJsZSBuZXh0IHN0YXRlXG4gICAgT2JqZWN0LmVudHJpZXModHJhbnNpdGlvbnMpLmZvckVhY2goKFtuZXh0U3RhdGUsIHRyYW5zUHJvYl0pID0+IHtcbiAgICAgIC8vIEdldCBvYnNlcnZhdGlvbiBwcm9iYWJpbGl0aWVzIGZvciBuZXh0IHN0YXRlXG4gICAgICBjb25zdCBvYnNlcnZhdGlvbnMgPSBlbmdpbmUubW9kZWwub2JzZXJ2YXRpb25Nb2RlbFtuZXh0U3RhdGVdIHx8IHt9O1xuXG4gICAgICAvLyBBY2N1bXVsYXRlIHByZWRpY3Rpb25cbiAgICAgIE9iamVjdC5lbnRyaWVzKG9ic2VydmF0aW9ucykuZm9yRWFjaCgoW29icywgb2JzUHJvYl0pID0+IHtcbiAgICAgICAgcHJlZGljdGlvbnNbb2JzXSArPSBzdGF0ZVByb2IgKiB0cmFuc1Byb2IgKiBvYnNQcm9iO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBwcmVkaWN0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlQWN0aW9uUG9saWN5KFxuICBlbmdpbmU6IEFjdGl2ZUluZmVyZW5jZUVuZ2luZSxcbiAgcG9saWN5OiBQb2xpY3ksXG4pOiBQb2xpY3lFdmFsdWF0aW9uIHtcbiAgbGV0IGV4cGVjdGVkUmV0dXJuID0gMDtcbiAgbGV0IHRvdGFsVW5jZXJ0YWludHkgPSAwO1xuICBsZXQgZmVhc2liaWxpdHkgPSAxLjA7XG5cbiAgbGV0IGJlbGllZnMgPSBlbmdpbmUuZ2V0Q3VycmVudEJlbGllZnMoKTtcblxuICBwb2xpY3kuZm9yRWFjaCgoc3RlcCwgdCkgPT4ge1xuICAgIC8vIEV4cGVjdGVkIGltbWVkaWF0ZSByZXdhcmRcbiAgICBjb25zdCBwcmVkaWN0aW9ucyA9IHByZWRpY3RTZW5zb3J5T3V0Y29tZXMoZW5naW5lLCBiZWxpZWZzLCBzdGVwLmFjdGlvbik7XG4gICAgY29uc3QgaW1tZWRpYXRlUmV0dXJuID0gT2JqZWN0LmVudHJpZXMocHJlZGljdGlvbnMpLnJlZHVjZShcbiAgICAgIChzdW0sIFtvdXRjb21lLCBwcm9iXSkgPT4ge1xuICAgICAgICBjb25zdCBwcmVmZXJlbmNlID0gZW5naW5lLm1vZGVsLnByZWZlcmVuY2VzW291dGNvbWVdIHx8IDA7XG4gICAgICAgIHJldHVybiBzdW0gLSBwcm9iICogcHJlZmVyZW5jZTsgLy8gTmVnYXRpdmUgYmVjYXVzZSBsb3dlciBpcyBiZXR0ZXJcbiAgICAgIH0sXG4gICAgICAwLFxuICAgICk7XG5cbiAgICBleHBlY3RlZFJldHVybiArPSBpbW1lZGlhdGVSZXR1cm4gKiBNYXRoLnBvdygwLjksIHQpO1xuXG4gICAgLy8gQWNjdW11bGF0ZSB1bmNlcnRhaW50eVxuICAgIHRvdGFsVW5jZXJ0YWludHkgKz0gYmVsaWVmcy51bmNlcnRhaW50eSAqIE1hdGgucG93KDAuOSwgdCk7XG5cbiAgICAvLyBDaGVjayBhY3Rpb24gZmVhc2liaWxpdHlcbiAgICBpZiAoIWVuZ2luZS5tb2RlbC5hY3Rpb25zLmluY2x1ZGVzKHN0ZXAuYWN0aW9uKSkge1xuICAgICAgZmVhc2liaWxpdHkgKj0gMC4xO1xuICAgIH1cblxuICAgIC8vIEV2b2x2ZSBiZWxpZWZzXG4gICAgYmVsaWVmcyA9IHByZWRpY3RCZWxpZWZFdm9sdXRpb24oZW5naW5lLCBiZWxpZWZzLCBzdGVwLmFjdGlvbik7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgZXhwZWN0ZWRSZXR1cm4sXG4gICAgdW5jZXJ0YWludHk6IHRvdGFsVW5jZXJ0YWludHkgLyBwb2xpY3kubGVuZ3RoLFxuICAgIGZlYXNpYmlsaXR5LFxuICB9O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcHJlZGljdCBiZWxpZWYgZXZvbHV0aW9uXG5mdW5jdGlvbiBwcmVkaWN0QmVsaWVmRXZvbHV0aW9uKFxuICBlbmdpbmU6IEFjdGl2ZUluZmVyZW5jZUVuZ2luZSxcbiAgYmVsaWVmczogQmVsaWVmcyxcbiAgYWN0aW9uOiBzdHJpbmcsXG4pOiBCZWxpZWZzIHtcbiAgY29uc3QgZXZvbHZlZDogQmVsaWVmcyA9IHtcbiAgICBzdGF0ZXM6IHt9LFxuICAgIHVuY2VydGFpbnR5OiBiZWxpZWZzLnVuY2VydGFpbnR5LFxuICB9O1xuXG4gIC8vIEluaXRpYWxpemVcbiAgZW5naW5lLm1vZGVsLnN0YXRlcy5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgIGV2b2x2ZWQuc3RhdGVzW3N0YXRlXSA9IDA7XG4gIH0pO1xuXG4gIC8vIFByZWRpY3Qgc3RhdGUgZXZvbHV0aW9uXG4gIE9iamVjdC5lbnRyaWVzKGJlbGllZnMuc3RhdGVzKS5mb3JFYWNoKChbY3VycmVudFN0YXRlLCBwcm9iXSkgPT4ge1xuICAgIGNvbnN0IHRyYW5zaXRpb25zID1cbiAgICAgIGVuZ2luZS5tb2RlbC50cmFuc2l0aW9uTW9kZWxbY3VycmVudFN0YXRlXT8uW2FjdGlvbl0gfHwge307XG5cbiAgICBPYmplY3QuZW50cmllcyh0cmFuc2l0aW9ucykuZm9yRWFjaCgoW25leHRTdGF0ZSwgdHJhbnNQcm9iXSkgPT4ge1xuICAgICAgZXZvbHZlZC5zdGF0ZXNbbmV4dFN0YXRlXSArPSBwcm9iICogdHJhbnNQcm9iO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDYWxjdWxhdGUgdW5jZXJ0YWludHkgYmFzZWQgb24gYmVsaWVmIGVudHJvcHkgYW5kIGFjdGlvbiBlZmZlY3RzXG4gIGNvbnN0IGVudHJvcHkgPSBPYmplY3QudmFsdWVzKGV2b2x2ZWQuc3RhdGVzKS5yZWR1Y2UoKGgsIHApID0+IHtcbiAgICByZXR1cm4gcCA+IDAgPyBoIC0gcCAqIE1hdGgubG9nKHAgKyBFUFNJTE9OKSA6IGg7XG4gIH0sIDApO1xuXG4gIC8vIERpZmZlcmVudCBhY3Rpb25zIGFmZmVjdCB1bmNlcnRhaW50eSBkaWZmZXJlbnRseVxuICBsZXQgYWN0aW9uVW5jZXJ0YWludHlFZmZlY3QgPSAxLjA7XG4gIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgY2FzZSBcIndhaXRcIjpcbiAgICAgIGFjdGlvblVuY2VydGFpbnR5RWZmZWN0ID0gMS4yOyAvLyBXYWl0aW5nIGluY3JlYXNlcyB1bmNlcnRhaW50eVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1vdmVfZm9yd2FyZFwiOlxuICAgICAgYWN0aW9uVW5jZXJ0YWludHlFZmZlY3QgPSAwLjk7IC8vIE1vdmluZyByZWR1Y2VzIHVuY2VydGFpbnR5IHRocm91Z2ggZXhwbG9yYXRpb25cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0dXJuXCI6XG4gICAgICBhY3Rpb25VbmNlcnRhaW50eUVmZmVjdCA9IDAuODsgLy8gVHVybmluZyBwcm92aWRlcyBtb3JlIGluZm9ybWF0aW9uXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYWN0aW9uVW5jZXJ0YWludHlFZmZlY3QgPSAxLjE7XG4gIH1cblxuICAvLyBVcGRhdGUgdW5jZXJ0YWludHkgYmFzZWQgb24gZW50cm9weSBhbmQgYWN0aW9uIGVmZmVjdHNcbiAgZXZvbHZlZC51bmNlcnRhaW50eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4xLCBcbiAgICBiZWxpZWZzLnVuY2VydGFpbnR5ICogYWN0aW9uVW5jZXJ0YWludHlFZmZlY3QgKyBlbnRyb3B5ICogMC4xXG4gICkpO1xuXG4gIHJldHVybiBldm9sdmVkO1xufVxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZUVwaXN0ZW1pYyIsImNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneSIsImNhbGN1bGF0ZVByYWdtYXRpYyIsImNyZWF0ZUFjdGl2ZUluZmVyZW5jZUVuZ2luZSIsImV2YWx1YXRlQWN0aW9uUG9saWN5IiwibWluaW1pemVWYXJpYXRpb25hbEZyZWVFbmVyZ3kiLCJwZXJmb3JtSW5mZXJlbmNlIiwicHJlZGljdFNlbnNvcnlPdXRjb21lcyIsInNlbGVjdEFjdGlvbiIsInVwZGF0ZUJlbGllZnMiLCJFUFNJTE9OIiwiY29uZmlnIiwibW9kZWwiLCJzdGF0ZXMiLCJsZW5ndGgiLCJvYnNlcnZhdGlvbnMiLCJhY3Rpb25zIiwiRXJyb3IiLCJPYmplY3QiLCJrZXlzIiwidHJhbnNpdGlvbk1vZGVsIiwidW5pZm9ybVByb2IiLCJpbml0aWFsQmVsaWVmcyIsInVuY2VydGFpbnR5IiwiZm9yRWFjaCIsInN0YXRlIiwiZW5naW5lIiwicHJlY2lzaW9uIiwibGVhcm5pbmdSYXRlIiwicGxhbm5pbmdIb3Jpem9uIiwiYWN0aW9uQ29uc3RyYWludHMiLCJiZWxpZWZzIiwiYWN0aW9uSGlzdG9yeSIsImdldEN1cnJlbnRCZWxpZWZzIiwic2V0QmVsaWVmcyIsImNhbGN1bGF0ZUZyZWVFbmVyZ3kiLCJvYnNlcnZhdGlvbiIsImFjY3VyYWN5IiwiZW50cmllcyIsInByb2IiLCJsaWtlbGlob29kIiwib2JzZXJ2YXRpb25Nb2RlbCIsIk1hdGgiLCJsb2ciLCJjb21wbGV4aXR5IiwicHJpb3IiLCJ2YWx1ZXMiLCJwcmVmZXJlbmNlIiwicHJlZmVyZW5jZXMiLCJjb3N0IiwidW5jZXJ0YWludHlQZW5hbHR5IiwiZnJlZUVuZXJneSIsIm1heCIsImN1cnJlbnRCZWxpZWZzIiwidXBkYXRlZEJlbGllZnMiLCJ0b3RhbFBvc3RlcmlvciIsInZhbHVlIiwicG9zdGVyaW9yIiwiY29uZmlkZW5jZSIsImVudHJvcHkiLCJyZWR1Y2UiLCJoIiwicCIsImJlc3RBY3Rpb24iLCJtaW5FeHBlY3RlZEZFIiwiSW5maW5pdHkiLCJhY3Rpb25TY29yZXMiLCJhY3Rpb25Db3VudHMiLCJhY3Rpb24iLCJmcmVxdWVuY3kiLCJtYXhGcmVxdWVuY3kiLCJleHBlY3RlZEZFIiwiZXBpc3RlbWljIiwicHJhZ21hdGljIiwicmVjZW50QWN0aW9ucyIsInNsaWNlIiwiYWN0aW9uRnJlcXVlbmN5IiwiZmlsdGVyIiwiYSIsInZhcmlldHlQZW5hbHR5Iiwic2NvcmVzIiwicyIsImF2Z1Njb3JlIiwiYiIsImV4cCIsImFicyIsInB1c2giLCJ0eXBlIiwibWluIiwic2VsZWN0ZWRBY3Rpb24iLCJiZWxpZWZDZXJ0YWludHkiLCJvdmVyYWxsQ29uZmlkZW5jZSIsInBvbGljeSIsInRvdGFsRUZFIiwidG90YWxFcGlzdGVtaWMiLCJ0b3RhbFByYWdtYXRpYyIsInN0ZXAiLCJmaW5pdGVFcGlzdGVtaWMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpbml0ZVByYWdtYXRpYyIsInBvdyIsInRpbWVzdGVwIiwicHJlZGljdEJlbGllZkV2b2x1dGlvbiIsInRvdGFsIiwiaW5mb3JtYXRpb25HYWluIiwiY3VycmVudEVudHJvcHkiLCJleHBlY3RlZEVudHJvcHkiLCJwcmVkaWN0ZWRCZWxpZWZzIiwiZXhwbG9yYXRpb25Cb251cyIsInJlc3VsdCIsImV4cGVjdGVkUHJlZmVyZW5jZSIsInByZWRpY3Rpb25zIiwib3V0Y29tZSIsImNvbnRyaWJ1dGlvbiIsIm9wdGlvbnMiLCJtYXhJdGVyIiwibWF4SXRlcmF0aW9ucyIsInRvbGVyYW5jZSIsInByZXZGRSIsImNvbnZlcmdlZCIsIml0ZXJhdGlvbnMiLCJncmFkaWVudCIsImRlbHRhIiwiYmVsaWVmc0NvcHkiLCJzdW0iLCJmZVBsdXMiLCJjaGFuZ2VkIiwidXBkYXRlIiwibmV3QmVsaWVmIiwiY3VycmVudEZFIiwib2JzIiwiY3VycmVudFN0YXRlIiwic3RhdGVQcm9iIiwidHJhbnNpdGlvbnMiLCJuZXh0U3RhdGUiLCJ0cmFuc1Byb2IiLCJvYnNQcm9iIiwiZXhwZWN0ZWRSZXR1cm4iLCJ0b3RhbFVuY2VydGFpbnR5IiwiZmVhc2liaWxpdHkiLCJ0IiwiaW1tZWRpYXRlUmV0dXJuIiwiaW5jbHVkZXMiLCJldm9sdmVkIiwiYWN0aW9uVW5jZXJ0YWludHlFZmZlY3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDOzs7Ozs7Ozs7OztJQTJWZUEsa0JBQWtCO2VBQWxCQTs7SUFwQ0FDLDJCQUEyQjtlQUEzQkE7O0lBb0VBQyxrQkFBa0I7ZUFBbEJBOztJQTlTQUMsMkJBQTJCO2VBQTNCQTs7SUFpYkFDLG9CQUFvQjtlQUFwQkE7O0lBMUdNQyw2QkFBNkI7ZUFBN0JBOztJQTVIQUMsZ0JBQWdCO2VBQWhCQTs7SUFxTU5DLHNCQUFzQjtlQUF0QkE7O0lBMVFBQyxZQUFZO2VBQVpB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