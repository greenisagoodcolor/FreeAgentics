{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/knowledge-graph-management.ts"],"sourcesContent":["/**\n * Knowledge Graph Management Module\n * ADR-007 Compliant - Knowledge Management\n */\n\nexport interface KnowledgeNode {\n  id: string;\n  label: string;\n  type: \"concept\" | \"fact\" | \"entity\" | \"relationship\";\n  properties?: Record<string, any>;\n\n  // Visual properties for rendering\n  x?: number;\n  y?: number;\n  radius?: number;\n  color?: string;\n  ownerType?: \"individual\" | \"collective\" | \"shared\";\n  confidence?: number;\n  importance?: number;\n  lastUpdated?: Date;\n  createdAt?: Date;\n}\n\nexport interface KnowledgeEdge {\n  id: string;\n  source: string;\n  target: string;\n  type: string;\n  weight?: number;\n  strength?: number;\n  confidence?: number;\n  color?: string;\n  createdAt?: Date;\n  lastUpdated?: Date;\n  properties?: Record<string, any>;\n}\n\nexport interface KnowledgeGraph {\n  id: string;\n  nodes: KnowledgeNode[];\n  edges: KnowledgeEdge[];\n  metadata: {\n    created: number;\n    modified: number;\n    version: string;\n    [key: string]: any;\n  };\n}\n\nexport interface GraphMetrics {\n  nodeCount: number;\n  edgeCount: number;\n  density: number;\n  avgDegree: number;\n  diameter: number;\n  clustering: number;\n  modularity: number;\n  importantNodes?: Array<{ id: string; score: number }>;\n  communities?: string[][];\n}\n\nexport interface GraphQuery {\n  startNode?: string;\n  traverse?: {\n    direction: \"incoming\" | \"outgoing\" | \"both\";\n    edgeTypes?: string[];\n    maxDepth?: number;\n  };\n  filter?: {\n    nodeTypes?: string[];\n    properties?: Record<string, any>;\n  };\n}\n\nexport interface GraphDiff {\n  addedNodes: KnowledgeNode[];\n  removedNodes: KnowledgeNode[];\n  modifiedNodes: Array<{\n    id: string;\n    changes: Record<string, { old: any; new: any }>;\n  }>;\n  addedEdges: KnowledgeEdge[];\n  removedEdges: KnowledgeEdge[];\n}\n\nlet graphCounter = 0;\n\nexport function createKnowledgeGraph(id?: string): KnowledgeGraph {\n  return {\n    id: id || `graph-${++graphCounter}`,\n    nodes: [],\n    edges: [],\n    metadata: {\n      created: Date.now(),\n      modified: Date.now(),\n      version: \"1.0\",\n    },\n  };\n}\n\nexport function addNode(\n  graph: KnowledgeGraph,\n  node: KnowledgeNode,\n): KnowledgeGraph {\n  if (graph.nodes.some((n) => n.id === node.id)) {\n    throw new Error(`Node with ID ${node.id} already exists`);\n  }\n\n  return {\n    ...graph,\n    nodes: [...graph.nodes, node],\n    metadata: { ...graph.metadata, modified: Date.now() },\n  };\n}\n\nexport function addEdge(\n  graph: KnowledgeGraph,\n  edge: KnowledgeEdge,\n): KnowledgeGraph {\n  // Validate edge endpoints\n  const sourceExists = graph.nodes.some((n) => n.id === edge.source);\n  const targetExists = graph.nodes.some((n) => n.id === edge.target);\n\n  if (!sourceExists) {\n    throw new Error(`Source node ${edge.source} does not exist`);\n  }\n  if (!targetExists) {\n    throw new Error(`Target node ${edge.target} does not exist`);\n  }\n\n  return {\n    ...graph,\n    edges: [...graph.edges, edge],\n    metadata: { ...graph.metadata, modified: Date.now() },\n  };\n}\n\nexport function updateNode(\n  graph: KnowledgeGraph,\n  nodeId: string,\n  updates: Partial<KnowledgeNode>,\n): KnowledgeGraph {\n  const nodeIndex = graph.nodes.findIndex((n) => n.id === nodeId);\n\n  if (nodeIndex === -1) {\n    throw new Error(`Node ${nodeId} not found`);\n  }\n\n  const updatedNodes = [...graph.nodes];\n  updatedNodes[nodeIndex] = {\n    ...updatedNodes[nodeIndex],\n    ...updates,\n    id: nodeId, // Prevent ID changes\n  };\n\n  return {\n    ...graph,\n    nodes: updatedNodes,\n    metadata: { ...graph.metadata, modified: Date.now() },\n  };\n}\n\nexport function removeNode(\n  graph: KnowledgeGraph,\n  nodeId: string,\n): KnowledgeGraph {\n  return {\n    ...graph,\n    nodes: graph.nodes.filter((n) => n.id !== nodeId),\n    edges: graph.edges.filter(\n      (e) => e.source !== nodeId && e.target !== nodeId,\n    ),\n    metadata: { ...graph.metadata, modified: Date.now() },\n  };\n}\n\nexport function findPath(\n  graph: KnowledgeGraph,\n  startId: string,\n  endId: string,\n): string[] | null {\n  if (\n    !graph.nodes.some((n) => n.id === startId) ||\n    !graph.nodes.some((n) => n.id === endId)\n  ) {\n    return null;\n  }\n\n  // BFS to find shortest path\n  const queue: Array<{ node: string; path: string[] }> = [\n    { node: startId, path: [startId] },\n  ];\n  const visited = new Set<string>();\n\n  while (queue.length > 0) {\n    const { node, path } = queue.shift()!;\n\n    if (node === endId) {\n      return path;\n    }\n\n    if (visited.has(node)) continue;\n    visited.add(node);\n\n    // Find neighbors\n    const neighbors = graph.edges\n      .filter((e) => e.source === node || e.target === node)\n      .map((e) => (e.source === node ? e.target : e.source))\n      .filter((n) => !visited.has(n));\n\n    for (const neighbor of neighbors) {\n      queue.push({ node: neighbor, path: [...path, neighbor] });\n    }\n  }\n\n  return null;\n}\n\nexport function mergeGraphs(\n  graph1: KnowledgeGraph,\n  graph2: KnowledgeGraph,\n  options: {\n    conflictResolution?: \"keep-first\" | \"keep-second\" | \"newer\";\n    reportConflicts?: boolean;\n  } = {},\n): KnowledgeGraph & { conflicts?: any[] } {\n  const conflicts: any[] = [];\n  const mergedNodes = new Map<string, KnowledgeNode>();\n  const mergedEdges = new Map<string, KnowledgeEdge>();\n\n  // Merge nodes\n  for (const node of graph1.nodes) {\n    mergedNodes.set(node.id, node);\n  }\n\n  for (const node of graph2.nodes) {\n    const existing = mergedNodes.get(node.id);\n    if (existing) {\n      // Conflict detected\n      if (options.reportConflicts) {\n        conflicts.push({\n          nodeId: node.id,\n          graph1Value: existing.label,\n          graph2Value: node.label,\n        });\n      }\n\n      if (\n        options.conflictResolution === \"newer\" ||\n        options.conflictResolution === \"keep-second\"\n      ) {\n        mergedNodes.set(node.id, node);\n      }\n      // Otherwise keep existing (keep-first or default)\n    } else {\n      mergedNodes.set(node.id, node);\n    }\n  }\n\n  // Merge edges\n  for (const edge of graph1.edges) {\n    mergedEdges.set(edge.id, edge);\n  }\n\n  for (const edge of graph2.edges) {\n    if (!mergedEdges.has(edge.id)) {\n      // Only add if both endpoints exist in merged graph\n      if (mergedNodes.has(edge.source) && mergedNodes.has(edge.target)) {\n        mergedEdges.set(edge.id, edge);\n      }\n    }\n  }\n\n  const result: KnowledgeGraph & { conflicts?: any[] } = {\n    id: `merged-${graph1.id}-${graph2.id}`,\n    nodes: Array.from(mergedNodes.values()),\n    edges: Array.from(mergedEdges.values()),\n    metadata: {\n      created: Math.min(graph1.metadata.created, graph2.metadata.created),\n      modified: Date.now(),\n      version: \"1.0\",\n      mergedFrom: [graph1.id, graph2.id],\n    },\n  };\n\n  if (options.reportConflicts) {\n    result.conflicts = conflicts;\n  }\n\n  return result;\n}\n\nexport function exportGraph(\n  graph: KnowledgeGraph,\n  format: \"json\" | \"graphml\",\n): string {\n  if (format === \"json\") {\n    return JSON.stringify(graph, null, 2);\n  }\n\n  // GraphML format\n  let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n  xml += '<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\">\\n';\n  xml += '  <graph id=\"' + graph.id + '\" edgedefault=\"directed\">\\n';\n\n  // Add nodes\n  for (const node of graph.nodes) {\n    xml += `    <node id=\"${node.id}\">\\n`;\n    xml += `      <data key=\"label\">${node.label}</data>\\n`;\n    xml += `      <data key=\"type\">${node.type}</data>\\n`;\n    xml += \"    </node>\\n\";\n  }\n\n  // Add edges\n  for (const edge of graph.edges) {\n    xml += `    <edge id=\"${edge.id}\" source=\"${edge.source}\" target=\"${edge.target}\">\\n`;\n    xml += `      <data key=\"type\">${edge.type}</data>\\n`;\n    if (edge.weight !== undefined) {\n      xml += `      <data key=\"weight\">${edge.weight}</data>\\n`;\n    }\n    xml += \"    </edge>\\n\";\n  }\n\n  xml += \"  </graph>\\n\";\n  xml += \"</graphml>\";\n\n  return xml;\n}\n\nexport function importGraph(\n  data: string,\n  format: \"json\" | \"graphml\",\n): KnowledgeGraph {\n  if (format === \"json\") {\n    const parsed = JSON.parse(data);\n\n    // Validate structure\n    if (!parsed.nodes || !parsed.edges) {\n      throw new Error(\"Invalid graph structure\");\n    }\n\n    // Validate nodes\n    for (const node of parsed.nodes) {\n      if (!node.id || !node.label || !node.type) {\n        throw new Error(\"Invalid graph structure\");\n      }\n    }\n\n    // Validate edges reference existing nodes\n    const nodeIds = new Set(parsed.nodes.map((n: KnowledgeNode) => n.id));\n    for (const edge of parsed.edges) {\n      if (!nodeIds.has(edge.source) || !nodeIds.has(edge.target)) {\n        throw new Error(\"Invalid graph structure\");\n      }\n    }\n\n    return {\n      id: parsed.id || createKnowledgeGraph().id,\n      nodes: parsed.nodes,\n      edges: parsed.edges,\n      metadata: parsed.metadata || {\n        created: Date.now(),\n        modified: Date.now(),\n        version: \"1.0\",\n      },\n    };\n  }\n\n  throw new Error(\"GraphML import not implemented\");\n}\n\nexport function analyzeGraph(\n  graph: KnowledgeGraph,\n  options: {\n    includeNodeImportance?: boolean;\n    detectCommunities?: boolean;\n  } = {},\n): GraphMetrics {\n  const nodeCount = graph.nodes.length;\n  const edgeCount = graph.edges.length;\n  const maxPossibleEdges = (nodeCount * (nodeCount - 1)) / 2;\n  const density = nodeCount > 1 ? edgeCount / maxPossibleEdges : 0;\n\n  // Calculate average degree\n  const degrees = new Map<string, number>();\n  for (const edge of graph.edges) {\n    degrees.set(edge.source, (degrees.get(edge.source) || 0) + 1);\n    degrees.set(edge.target, (degrees.get(edge.target) || 0) + 1);\n  }\n  const avgDegree =\n    nodeCount > 0\n      ? Array.from(degrees.values()).reduce((a, b) => a + b, 0) / nodeCount\n      : 0;\n\n  const metrics: GraphMetrics = {\n    nodeCount,\n    edgeCount,\n    density,\n    avgDegree,\n    diameter: calculateDiameter(graph),\n    clustering: calculateClustering(graph),\n    modularity: 0.5, // Mock value\n  };\n\n  if (options.includeNodeImportance) {\n    metrics.importantNodes = Array.from(degrees.entries())\n      .map(([id, degree]) => ({ id, score: degree }))\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 3);\n  }\n\n  if (options.detectCommunities) {\n    metrics.communities = detectCommunities(graph);\n  }\n\n  return metrics;\n}\n\nexport function optimizeGraph(\n  graph: KnowledgeGraph,\n  options: {\n    removeRedundant?: boolean;\n    consolidateSimilar?: boolean;\n    similarityThreshold?: number;\n    pruneThreshold?: number;\n  } = {},\n): KnowledgeGraph {\n  let optimized = { ...graph };\n\n  if (options.removeRedundant) {\n    // Remove transitive edges\n    const edgesToRemove = new Set<string>();\n\n    for (const edge of graph.edges) {\n      if (edge.type === \"implies\") {\n        // Check if there's an indirect path\n        const pathWithoutEdge = findPathExcludingEdge(\n          graph,\n          edge.source,\n          edge.target,\n          edge.id,\n        );\n\n        if (pathWithoutEdge && pathWithoutEdge.length <= 3) {\n          edgesToRemove.add(edge.id);\n        }\n      }\n    }\n\n    optimized.edges = optimized.edges.filter((e) => !edgesToRemove.has(e.id));\n  }\n\n  if (options.consolidateSimilar) {\n    // Simple consolidation based on label similarity\n    const threshold = options.similarityThreshold || 0.8;\n    const nodeGroups: KnowledgeNode[][] = [];\n    const processed = new Set<string>();\n\n    for (const node of graph.nodes) {\n      if (processed.has(node.id)) continue;\n\n      const group = [node];\n      processed.add(node.id);\n\n      for (const other of graph.nodes) {\n        if (processed.has(other.id)) continue;\n\n        const similarity = calculateSimilarity(node.label, other.label);\n        if (similarity >= threshold) {\n          group.push(other);\n          processed.add(other.id);\n        }\n      }\n\n      if (group.length > 1) {\n        nodeGroups.push(group);\n      }\n    }\n\n    // Merge similar nodes\n    const mergedNodes: KnowledgeNode[] = [];\n    const nodeMapping = new Map<string, string>();\n\n    for (const group of nodeGroups) {\n      const merged = group[0]; // Keep first as representative\n      mergedNodes.push(merged);\n\n      for (const node of group) {\n        nodeMapping.set(node.id, merged.id);\n      }\n    }\n\n    // Add non-grouped nodes\n    for (const node of graph.nodes) {\n      if (!nodeMapping.has(node.id) || nodeMapping.get(node.id) === node.id) {\n        if (!mergedNodes.some((n) => n.id === node.id)) {\n          mergedNodes.push(node);\n        }\n      }\n    }\n\n    optimized.nodes = mergedNodes;\n\n    // Update edges with merged node IDs\n    optimized.edges = optimized.edges\n      .map((edge) => ({\n        ...edge,\n        source: nodeMapping.get(edge.source) || edge.source,\n        target: nodeMapping.get(edge.target) || edge.target,\n      }))\n      .filter((edge) => edge.source !== edge.target); // Remove self-loops\n  }\n\n  if (options.pruneThreshold !== undefined) {\n    optimized.edges = optimized.edges.filter(\n      (edge) => (edge.weight || 1) >= options.pruneThreshold!,\n    );\n  }\n\n  return optimized;\n}\n\nexport function validateGraph(\n  graph: KnowledgeGraph,\n  options: { allowOrphans?: boolean } = {},\n): { isValid: boolean; errors: any[] } {\n  const errors: any[] = [];\n\n  // Check for orphaned nodes\n  if (!options.allowOrphans) {\n    const connectedNodes = new Set<string>();\n\n    for (const edge of graph.edges) {\n      connectedNodes.add(edge.source);\n      connectedNodes.add(edge.target);\n    }\n\n    for (const node of graph.nodes) {\n      if (!connectedNodes.has(node.id)) {\n        errors.push({\n          type: \"orphaned-node\",\n          nodeId: node.id,\n          message: `Node ${node.id} has no connections`,\n        });\n      }\n    }\n  }\n\n  // Check for invalid edges\n  const nodeIds = new Set(graph.nodes.map((n) => n.id));\n\n  for (const edge of graph.edges) {\n    if (!nodeIds.has(edge.source)) {\n      errors.push({\n        type: \"invalid-edge\",\n        edgeId: edge.id,\n        reason: `Source node ${edge.source} does not exist`,\n      });\n    }\n    if (!nodeIds.has(edge.target)) {\n      errors.push({\n        type: \"invalid-edge\",\n        edgeId: edge.id,\n        reason: `Target node ${edge.target} does not exist`,\n      });\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n\n// Helper functions\nfunction calculateDiameter(graph: KnowledgeGraph): number {\n  let maxDistance = 0;\n\n  for (const start of graph.nodes) {\n    for (const end of graph.nodes) {\n      if (start.id !== end.id) {\n        const path = findPath(graph, start.id, end.id);\n        if (path) {\n          maxDistance = Math.max(maxDistance, path.length - 1);\n        }\n      }\n    }\n  }\n\n  return maxDistance;\n}\n\nfunction calculateClustering(graph: KnowledgeGraph): number {\n  // Simplified clustering coefficient\n  let totalClustering = 0;\n  let nodeCount = 0;\n\n  for (const node of graph.nodes) {\n    const neighbors = graph.edges\n      .filter((e) => e.source === node.id || e.target === node.id)\n      .map((e) => (e.source === node.id ? e.target : e.source));\n\n    if (neighbors.length >= 2) {\n      let connections = 0;\n\n      for (let i = 0; i < neighbors.length; i++) {\n        for (let j = i + 1; j < neighbors.length; j++) {\n          const hasEdge = graph.edges.some(\n            (e) =>\n              (e.source === neighbors[i] && e.target === neighbors[j]) ||\n              (e.source === neighbors[j] && e.target === neighbors[i]),\n          );\n          if (hasEdge) connections++;\n        }\n      }\n\n      const maxConnections = (neighbors.length * (neighbors.length - 1)) / 2;\n      totalClustering += connections / maxConnections;\n      nodeCount++;\n    }\n  }\n\n  return nodeCount > 0 ? totalClustering / nodeCount : 0;\n}\n\nfunction detectCommunities(graph: KnowledgeGraph): string[][] {\n  // Simple community detection using connected components\n  const visited = new Set<string>();\n  const communities: string[][] = [];\n\n  function dfs(nodeId: string, community: string[]) {\n    if (visited.has(nodeId)) return;\n    visited.add(nodeId);\n    community.push(nodeId);\n\n    const neighbors = graph.edges\n      .filter((e) => e.source === nodeId || e.target === nodeId)\n      .map((e) => (e.source === nodeId ? e.target : e.source));\n\n    for (const neighbor of neighbors) {\n      dfs(neighbor, community);\n    }\n  }\n\n  for (const node of graph.nodes) {\n    if (!visited.has(node.id)) {\n      const community: string[] = [];\n      dfs(node.id, community);\n      communities.push(community);\n    }\n  }\n\n  return communities;\n}\n\nfunction findPathExcludingEdge(\n  graph: KnowledgeGraph,\n  start: string,\n  end: string,\n  excludeEdgeId: string,\n): string[] | null {\n  const filteredGraph = {\n    ...graph,\n    edges: graph.edges.filter((e) => e.id !== excludeEdgeId),\n  };\n  return findPath(filteredGraph, start, end);\n}\n\nfunction calculateSimilarity(label1: string, label2: string): number {\n  // Simple case-insensitive comparison\n  const normalized1 = label1.toLowerCase().trim();\n  const normalized2 = label2.toLowerCase().trim();\n\n  if (normalized1 === normalized2) return 1;\n\n  // Check for common abbreviations\n  const abbreviations: Record<string, string> = {\n    ml: \"machine learning\",\n    ai: \"artificial intelligence\",\n    dl: \"deep learning\",\n  };\n\n  const expanded1 = abbreviations[normalized1] || normalized1;\n  const expanded2 = abbreviations[normalized2] || normalized2;\n\n  if (expanded1 === expanded2) return 0.9;\n  if (expanded1.includes(expanded2) || expanded2.includes(expanded1))\n    return 0.8;\n\n  return 0;\n}\n"],"names":["addEdge","addNode","analyzeGraph","createKnowledgeGraph","exportGraph","findPath","importGraph","mergeGraphs","optimizeGraph","removeNode","updateNode","validateGraph","graphCounter","id","nodes","edges","metadata","created","Date","now","modified","version","graph","node","some","n","Error","edge","sourceExists","source","targetExists","target","nodeId","updates","nodeIndex","findIndex","updatedNodes","filter","e","startId","endId","queue","path","visited","Set","length","shift","has","add","neighbors","map","neighbor","push","graph1","graph2","options","conflicts","mergedNodes","Map","mergedEdges","set","existing","get","reportConflicts","graph1Value","label","graph2Value","conflictResolution","result","Array","from","values","Math","min","mergedFrom","format","JSON","stringify","xml","type","weight","undefined","data","parsed","parse","nodeIds","nodeCount","edgeCount","maxPossibleEdges","density","degrees","avgDegree","reduce","a","b","metrics","diameter","calculateDiameter","clustering","calculateClustering","modularity","includeNodeImportance","importantNodes","entries","degree","score","sort","slice","detectCommunities","communities","optimized","removeRedundant","edgesToRemove","pathWithoutEdge","findPathExcludingEdge","consolidateSimilar","threshold","similarityThreshold","nodeGroups","processed","group","other","similarity","calculateSimilarity","nodeMapping","merged","pruneThreshold","errors","allowOrphans","connectedNodes","message","edgeId","reason","isValid","maxDistance","start","end","max","totalClustering","connections","i","j","hasEdge","maxConnections","dfs","community","excludeEdgeId","filteredGraph","label1","label2","normalized1","toLowerCase","trim","normalized2","abbreviations","ml","ai","dl","expanded1","expanded2","includes"],"mappings":"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"}