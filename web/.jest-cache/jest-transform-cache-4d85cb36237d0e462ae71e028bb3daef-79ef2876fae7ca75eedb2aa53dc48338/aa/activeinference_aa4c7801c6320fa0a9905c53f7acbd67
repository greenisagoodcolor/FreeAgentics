c0bca0be83db6114ec593ee3346a24e0
/**
 * Active Inference Implementation
 *
 * Core implementation for active inference, free energy minimization,
 * and belief updating based on the Free Energy Principle.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    calculateEpistemic: function() {
        return calculateEpistemic;
    },
    calculateExpectedFreeEnergy: function() {
        return calculateExpectedFreeEnergy;
    },
    calculatePragmatic: function() {
        return calculatePragmatic;
    },
    createActiveInferenceEngine: function() {
        return createActiveInferenceEngine;
    },
    evaluateActionPolicy: function() {
        return evaluateActionPolicy;
    },
    minimizeVariationalFreeEnergy: function() {
        return minimizeVariationalFreeEnergy;
    },
    performInference: function() {
        return performInference;
    },
    predictSensoryOutcomes: function() {
        return predictSensoryOutcomes;
    },
    selectAction: function() {
        return selectAction;
    },
    updateBeliefs: function() {
        return updateBeliefs;
    }
});
const EPSILON = 1e-10;
function createActiveInferenceEngine(config) {
    // Validate model
    if (!config.model.states.length || !config.model.observations.length || !config.model.actions.length) {
        throw new Error("Invalid generative model: missing states, observations, or actions");
    }
    if (Object.keys(config.model.transitionModel).length === 0) {
        throw new Error("Invalid generative model: empty transition model");
    }
    // Initialize uniform beliefs
    const uniformProb = 1.0 / config.model.states.length;
    const initialBeliefs = {
        states: {},
        uncertainty: 1.0
    };
    config.model.states.forEach((state)=>{
        initialBeliefs.states[state] = uniformProb;
    });
    const engine = {
        model: config.model,
        precision: config.precision || 1.0,
        learningRate: config.learningRate || 0.1,
        planningHorizon: config.planningHorizon || 3,
        actionConstraints: config.actionConstraints,
        beliefs: initialBeliefs,
        actionHistory: [],
        getCurrentBeliefs: function() {
            return {
                ...this.beliefs
            };
        },
        setBeliefs: function(beliefs) {
            this.beliefs = {
                ...beliefs
            };
        },
        calculateFreeEnergy: function(beliefs, observation) {
            // Accuracy term (expected log likelihood)
            let accuracy = 0;
            Object.entries(beliefs.states).forEach(([state, prob])=>{
                const likelihood = this.model.observationModel[state]?.[observation] || EPSILON;
                accuracy += prob * Math.log(likelihood + EPSILON);
            });
            // Complexity term (KL divergence from prior)
            let complexity = 0;
            const prior = 1.0 / this.model.states.length;
            Object.values(beliefs.states).forEach((prob)=>{
                if (prob > 0) {
                    complexity += prob * Math.log((prob + EPSILON) / prior);
                }
            });
            // Convert preference to a positive cost term
            // Negative preferences (rewards) become positive costs
            const preference = this.model.preferences[observation] || 0;
            const cost = -preference; // Convert reward to cost
            // Add uncertainty term
            const uncertaintyPenalty = beliefs.uncertainty * 2.0;
            // Free energy = -log likelihood + complexity + cost + uncertainty
            const freeEnergy = -accuracy + complexity + cost + uncertaintyPenalty;
            // Ensure free energy is positive by adding a constant if needed
            return Math.max(0.01, freeEnergy);
        }
    };
    return engine;
}
function updateBeliefs(engine, observation) {
    const currentBeliefs = engine.getCurrentBeliefs();
    const updatedBeliefs = {
        states: {},
        uncertainty: currentBeliefs.uncertainty
    };
    // Standard Bayesian belief update
    let totalPosterior = 0;
    engine.model.states.forEach((state)=>{
        const prior = currentBeliefs.states[state];
        const likelihood = engine.model.observationModel[state]?.[observation.value] || EPSILON;
        const posterior = prior * likelihood;
        updatedBeliefs.states[state] = posterior;
        totalPosterior += posterior;
    });
    // Normalize to get standard Bayesian posterior
    Object.keys(updatedBeliefs.states).forEach((state)=>{
        updatedBeliefs.states[state] /= totalPosterior;
    });
    // Apply confidence weighting by interpolating between prior and posterior
    Object.keys(updatedBeliefs.states).forEach((state)=>{
        const prior = currentBeliefs.states[state];
        const posterior = updatedBeliefs.states[state];
        // High confidence = use more of posterior, low confidence = use more of prior
        updatedBeliefs.states[state] = observation.confidence * posterior + (1 - observation.confidence) * prior;
    });
    // Update uncertainty based on observation confidence and belief entropy
    const entropy = Object.values(updatedBeliefs.states).reduce((h, p)=>{
        return p > 0 ? h - p * Math.log(p + EPSILON) : h;
    }, 0);
    updatedBeliefs.uncertainty = (1 - observation.confidence) * 0.3 + entropy * 0.7;
    // Don't modify engine state, just return the updated beliefs
    return updatedBeliefs;
}
function selectAction(engine, beliefs) {
    let bestAction = "";
    let minExpectedFE = Infinity;
    const actionScores = {};
    // Check action constraints
    const actionCounts = {};
    engine.actionHistory.forEach((action)=>{
        actionCounts[action] = (actionCounts[action] || 0) + 1;
    });
    engine.model.actions.forEach((action)=>{
        // Check constraints
        if (engine.actionConstraints?.[action]) {
            const frequency = (actionCounts[action] || 0) / Math.max(engine.actionHistory.length, 1);
            if (frequency >= engine.actionConstraints[action].maxFrequency) {
                actionScores[action] = Infinity;
                return;
            }
        }
        // Calculate expected free energy for this action
        let expectedFE = 0;
        // Epistemic value (information gain)
        const epistemic = calculateEpistemic(engine, beliefs, action);
        // Pragmatic value (goal achievement)
        const pragmatic = calculatePragmatic(engine, beliefs, action);
        // Combine with precision weighting
        expectedFE = engine.precision * pragmatic - epistemic;
        // Add exploration bonus under high uncertainty
        if (beliefs.uncertainty > 0.5 && action !== "wait") {
            expectedFE -= beliefs.uncertainty * 0.5;
        }
        // Add action variety bonus to prevent getting stuck
        const recentActions = engine.actionHistory.slice(-5);
        const actionFrequency = recentActions.filter((a)=>a === action).length / Math.max(recentActions.length, 1);
        const varietyPenalty = actionFrequency * 2.0; // Penalize repetitive actions
        expectedFE += varietyPenalty;
        actionScores[action] = expectedFE;
        // Debug output for adaptation test
        if (action === "move_forward" || action === "turn" || action === "wait") {
            console.log(`Action ${action}: epistemic=${epistemic.toFixed(3)}, pragmatic=${pragmatic.toFixed(3)}, expectedFE=${expectedFE.toFixed(3)}, variety_penalty=${varietyPenalty.toFixed(3)}`);
        }
        if (expectedFE < minExpectedFE) {
            minExpectedFE = expectedFE;
            bestAction = action;
        }
    });
    // Calculate action confidence based on score differences
    const scores = Object.values(actionScores).filter((s)=>s !== Infinity);
    const avgScore = scores.reduce((a, b)=>a + b, 0) / scores.length;
    const confidence = Math.exp(-Math.abs(minExpectedFE - avgScore));
    engine.actionHistory.push(bestAction);
    return {
        type: bestAction,
        confidence: Math.min(Math.max(confidence, 0.1), 1.0)
    };
}
async function performInference(engine, observation) {
    // Update beliefs based on observation
    const updatedBeliefs = updateBeliefs(engine, observation);
    // Calculate current free energy
    const freeEnergy = engine.calculateFreeEnergy(updatedBeliefs, observation.value);
    // Select action that minimizes expected free energy
    const selectedAction = selectAction(engine, updatedBeliefs);
    // Overall confidence based on belief certainty and action confidence
    const beliefCertainty = Math.max(...Object.values(updatedBeliefs.states));
    const overallConfidence = (beliefCertainty + selectedAction.confidence) / 2;
    return {
        beliefs: updatedBeliefs,
        selectedAction,
        freeEnergy,
        confidence: overallConfidence
    };
}
function calculateExpectedFreeEnergy(engine, policy) {
    let totalEFE = 0;
    let totalEpistemic = 0;
    let totalPragmatic = 0;
    // Start with current beliefs
    let beliefs = engine.getCurrentBeliefs();
    policy.forEach((step)=>{
        const epistemic = calculateEpistemic(engine, beliefs, step.action);
        const pragmatic = calculatePragmatic(engine, beliefs, step.action);
        // Ensure finite values
        const finiteEpistemic = Number.isFinite(epistemic) ? epistemic : 0;
        const finitePragmatic = Number.isFinite(pragmatic) ? pragmatic : 0;
        totalEpistemic += finiteEpistemic * Math.pow(0.9, step.timestep); // Discount future
        totalPragmatic += finitePragmatic * Math.pow(0.9, step.timestep);
        // Predict belief evolution
        beliefs = predictBeliefEvolution(engine, beliefs, step.action);
    });
    totalEFE = engine.precision * totalPragmatic - totalEpistemic;
    // Ensure all values are finite
    return {
        total: Number.isFinite(totalEFE) ? totalEFE : 0,
        epistemic: Number.isFinite(totalEpistemic) ? totalEpistemic : 0,
        pragmatic: Number.isFinite(totalPragmatic) ? totalPragmatic : 0
    };
}
function calculateEpistemic(engine, beliefs, action) {
    // Information gain: reduction in uncertainty about states
    let informationGain = 0;
    // Current entropy
    const currentEntropy = Object.values(beliefs.states).reduce((h, p)=>{
        return p > 0 ? h - p * Math.log(p + EPSILON) : h;
    }, 0);
    // Expected entropy after action
    let expectedEntropy = 0;
    const predictedBeliefs = predictBeliefEvolution(engine, beliefs, action);
    expectedEntropy = Object.values(predictedBeliefs.states).reduce((h, p)=>{
        return p > 0 ? h - p * Math.log(p + EPSILON) : h;
    }, 0);
    informationGain = currentEntropy - expectedEntropy;
    // Add exploration bonus for uncertain states
    const explorationBonus = beliefs.uncertainty * 0.3;
    const result = Math.max(0, informationGain + explorationBonus);
    // Ensure finite result
    return Number.isFinite(result) ? result : 0;
}
function calculatePragmatic(engine, beliefs, action) {
    // Expected preference satisfaction
    let expectedPreference = 0;
    // Predict outcomes for this action
    const predictions = predictSensoryOutcomes(engine, beliefs, action);
    Object.entries(predictions).forEach(([outcome, prob])=>{
        const preference = engine.model.preferences[outcome] || 0;
        const contribution = prob * preference;
        // Only add finite contributions
        if (Number.isFinite(contribution)) {
            expectedPreference += contribution;
        }
    });
    // Ensure finite result
    return Number.isFinite(expectedPreference) ? expectedPreference : 0;
}
async function minimizeVariationalFreeEnergy(engine, initialBeliefs, observation, options) {
    const maxIter = options?.maxIterations || 100;
    const tolerance = options?.tolerance || 0.001;
    let beliefs = {
        ...initialBeliefs
    };
    let prevFE = engine.calculateFreeEnergy(beliefs, observation);
    let converged = false;
    let iterations = 0;
    while(iterations < maxIter && !converged){
        // Gradient descent on beliefs
        const gradient = {};
        const delta = 0.001;
        engine.model.states.forEach((state)=>{
            // Finite difference approximation
            const beliefsCopy = {
                ...beliefs
            };
            beliefsCopy.states[state] = Math.min(beliefs.states[state] + delta, 1);
            // Renormalize
            const sum = Object.values(beliefsCopy.states).reduce((s, p)=>s + p, 0);
            Object.keys(beliefsCopy.states).forEach((s)=>{
                beliefsCopy.states[s] /= sum;
            });
            const fePlus = engine.calculateFreeEnergy(beliefsCopy, observation);
            gradient[state] = (fePlus - prevFE) / delta;
        });
        // Update beliefs
        let changed = false;
        engine.model.states.forEach((state)=>{
            const update = -gradient[state] * engine.learningRate;
            const newBelief = Math.max(0, Math.min(1, beliefs.states[state] + update));
            if (Math.abs(newBelief - beliefs.states[state]) > tolerance) {
                changed = true;
            }
            beliefs.states[state] = newBelief;
        });
        // Renormalize
        const sum = Object.values(beliefs.states).reduce((s, p)=>s + p, 0);
        Object.keys(beliefs.states).forEach((state)=>{
            beliefs.states[state] /= sum;
        });
        // Check convergence
        const currentFE = engine.calculateFreeEnergy(beliefs, observation);
        if (!changed || Math.abs(currentFE - prevFE) < tolerance) {
            converged = true;
        }
        prevFE = currentFE;
        iterations++;
    }
    return {
        ...beliefs,
        converged,
        iterations
    };
}
function predictSensoryOutcomes(engine, beliefs, action) {
    const predictions = {};
    // Initialize predictions
    engine.model.observations.forEach((obs)=>{
        predictions[obs] = 0;
    });
    // For each current state
    Object.entries(beliefs.states).forEach(([currentState, stateProb])=>{
        // Get transition probabilities for this action
        const transitions = engine.model.transitionModel[currentState]?.[action] || {};
        // For each possible next state
        Object.entries(transitions).forEach(([nextState, transProb])=>{
            // Get observation probabilities for next state
            const observations = engine.model.observationModel[nextState] || {};
            // Accumulate prediction
            Object.entries(observations).forEach(([obs, obsProb])=>{
                predictions[obs] += stateProb * transProb * obsProb;
            });
        });
    });
    return predictions;
}
function evaluateActionPolicy(engine, policy) {
    let expectedReturn = 0;
    let totalUncertainty = 0;
    let feasibility = 1.0;
    let beliefs = engine.getCurrentBeliefs();
    policy.forEach((step, t)=>{
        // Expected immediate reward
        const predictions = predictSensoryOutcomes(engine, beliefs, step.action);
        const immediateReturn = Object.entries(predictions).reduce((sum, [outcome, prob])=>{
            const preference = engine.model.preferences[outcome] || 0;
            return sum - prob * preference; // Negative because lower is better
        }, 0);
        expectedReturn += immediateReturn * Math.pow(0.9, t);
        // Accumulate uncertainty
        totalUncertainty += beliefs.uncertainty * Math.pow(0.9, t);
        // Check action feasibility
        if (!engine.model.actions.includes(step.action)) {
            feasibility *= 0.1;
        }
        // Evolve beliefs
        beliefs = predictBeliefEvolution(engine, beliefs, step.action);
    });
    return {
        expectedReturn,
        uncertainty: totalUncertainty / policy.length,
        feasibility
    };
}
// Helper function to predict belief evolution
function predictBeliefEvolution(engine, beliefs, action) {
    const evolved = {
        states: {},
        uncertainty: beliefs.uncertainty
    };
    // Initialize
    engine.model.states.forEach((state)=>{
        evolved.states[state] = 0;
    });
    // Predict state evolution
    Object.entries(beliefs.states).forEach(([currentState, prob])=>{
        const transitions = engine.model.transitionModel[currentState]?.[action] || {};
        Object.entries(transitions).forEach(([nextState, transProb])=>{
            evolved.states[nextState] += prob * transProb;
        });
    });
    // Update uncertainty (tends to increase without observations)
    evolved.uncertainty = Math.min(1.0, beliefs.uncertainty * 1.1);
    return evolved;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvYWN0aXZlLWluZmVyZW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFjdGl2ZSBJbmZlcmVuY2UgSW1wbGVtZW50YXRpb25cbiAqXG4gKiBDb3JlIGltcGxlbWVudGF0aW9uIGZvciBhY3RpdmUgaW5mZXJlbmNlLCBmcmVlIGVuZXJneSBtaW5pbWl6YXRpb24sXG4gKiBhbmQgYmVsaWVmIHVwZGF0aW5nIGJhc2VkIG9uIHRoZSBGcmVlIEVuZXJneSBQcmluY2lwbGUuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0aXZlTW9kZWwge1xuICBzdGF0ZXM6IHN0cmluZ1tdO1xuICBvYnNlcnZhdGlvbnM6IHN0cmluZ1tdO1xuICBhY3Rpb25zOiBzdHJpbmdbXTtcbiAgdHJhbnNpdGlvbk1vZGVsOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+Pj47XG4gIG9ic2VydmF0aW9uTW9kZWw6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlcj4+O1xuICBwcmVmZXJlbmNlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCZWxpZWZzIHtcbiAgc3RhdGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICB1bmNlcnRhaW50eTogbnVtYmVyO1xuICBjb252ZXJnZWQ/OiBib29sZWFuO1xuICBpdGVyYXRpb25zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbnNvcnlJbnB1dCB7XG4gIHR5cGU6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbiB7XG4gIHR5cGU6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xuICBleHBlY3RlZE91dGNvbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIFBvbGljeSA9IEFycmF5PHtcbiAgYWN0aW9uOiBzdHJpbmc7XG4gIHRpbWVzdGVwOiBudW1iZXI7XG59PjtcblxuZXhwb3J0IGludGVyZmFjZSBBY3RpdmVJbmZlcmVuY2VDb25maWcge1xuICBtb2RlbDogR2VuZXJhdGl2ZU1vZGVsO1xuICBwcmVjaXNpb24/OiBudW1iZXI7XG4gIGxlYXJuaW5nUmF0ZT86IG51bWJlcjtcbiAgcGxhbm5pbmdIb3Jpem9uPzogbnVtYmVyO1xuICBhY3Rpb25Db25zdHJhaW50cz86IFJlY29yZDxzdHJpbmcsIHsgbWF4RnJlcXVlbmN5OiBudW1iZXIgfT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZlSW5mZXJlbmNlRW5naW5lIHtcbiAgbW9kZWw6IEdlbmVyYXRpdmVNb2RlbDtcbiAgcHJlY2lzaW9uOiBudW1iZXI7XG4gIGxlYXJuaW5nUmF0ZTogbnVtYmVyO1xuICBwbGFubmluZ0hvcml6b246IG51bWJlcjtcbiAgYWN0aW9uQ29uc3RyYWludHM/OiBSZWNvcmQ8c3RyaW5nLCB7IG1heEZyZXF1ZW5jeTogbnVtYmVyIH0+O1xuICBiZWxpZWZzOiBCZWxpZWZzO1xuICBhY3Rpb25IaXN0b3J5OiBzdHJpbmdbXTtcbiAgZ2V0Q3VycmVudEJlbGllZnM6ICgpID0+IEJlbGllZnM7XG4gIHNldEJlbGllZnM6IChiZWxpZWZzOiBCZWxpZWZzKSA9PiB2b2lkO1xuICBjYWxjdWxhdGVGcmVlRW5lcmd5OiAoYmVsaWVmczogQmVsaWVmcywgb2JzZXJ2YXRpb246IHN0cmluZykgPT4gbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVJlc3VsdCB7XG4gIGJlbGllZnM6IEJlbGllZnM7XG4gIHNlbGVjdGVkQWN0aW9uOiBBY3Rpb247XG4gIGZyZWVFbmVyZ3k6IG51bWJlcjtcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGVjdGVkRnJlZUVuZXJneSB7XG4gIHRvdGFsOiBudW1iZXI7XG4gIGVwaXN0ZW1pYzogbnVtYmVyO1xuICBwcmFnbWF0aWM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb2xpY3lFdmFsdWF0aW9uIHtcbiAgZXhwZWN0ZWRSZXR1cm46IG51bWJlcjtcbiAgdW5jZXJ0YWludHk6IG51bWJlcjtcbiAgZmVhc2liaWxpdHk6IG51bWJlcjtcbn1cblxuY29uc3QgRVBTSUxPTiA9IDFlLTEwO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWN0aXZlSW5mZXJlbmNlRW5naW5lKFxuICBjb25maWc6IEFjdGl2ZUluZmVyZW5jZUNvbmZpZyxcbik6IEFjdGl2ZUluZmVyZW5jZUVuZ2luZSB7XG4gIC8vIFZhbGlkYXRlIG1vZGVsXG4gIGlmIChcbiAgICAhY29uZmlnLm1vZGVsLnN0YXRlcy5sZW5ndGggfHxcbiAgICAhY29uZmlnLm1vZGVsLm9ic2VydmF0aW9ucy5sZW5ndGggfHxcbiAgICAhY29uZmlnLm1vZGVsLmFjdGlvbnMubGVuZ3RoXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBnZW5lcmF0aXZlIG1vZGVsOiBtaXNzaW5nIHN0YXRlcywgb2JzZXJ2YXRpb25zLCBvciBhY3Rpb25zXCIsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhjb25maWcubW9kZWwudHJhbnNpdGlvbk1vZGVsKS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdlbmVyYXRpdmUgbW9kZWw6IGVtcHR5IHRyYW5zaXRpb24gbW9kZWxcIik7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHVuaWZvcm0gYmVsaWVmc1xuICBjb25zdCB1bmlmb3JtUHJvYiA9IDEuMCAvIGNvbmZpZy5tb2RlbC5zdGF0ZXMubGVuZ3RoO1xuICBjb25zdCBpbml0aWFsQmVsaWVmczogQmVsaWVmcyA9IHtcbiAgICBzdGF0ZXM6IHt9LFxuICAgIHVuY2VydGFpbnR5OiAxLjAsXG4gIH07XG5cbiAgY29uZmlnLm1vZGVsLnN0YXRlcy5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgIGluaXRpYWxCZWxpZWZzLnN0YXRlc1tzdGF0ZV0gPSB1bmlmb3JtUHJvYjtcbiAgfSk7XG5cbiAgY29uc3QgZW5naW5lOiBBY3RpdmVJbmZlcmVuY2VFbmdpbmUgPSB7XG4gICAgbW9kZWw6IGNvbmZpZy5tb2RlbCxcbiAgICBwcmVjaXNpb246IGNvbmZpZy5wcmVjaXNpb24gfHwgMS4wLFxuICAgIGxlYXJuaW5nUmF0ZTogY29uZmlnLmxlYXJuaW5nUmF0ZSB8fCAwLjEsXG4gICAgcGxhbm5pbmdIb3Jpem9uOiBjb25maWcucGxhbm5pbmdIb3Jpem9uIHx8IDMsXG4gICAgYWN0aW9uQ29uc3RyYWludHM6IGNvbmZpZy5hY3Rpb25Db25zdHJhaW50cyxcbiAgICBiZWxpZWZzOiBpbml0aWFsQmVsaWVmcyxcbiAgICBhY3Rpb25IaXN0b3J5OiBbXSxcblxuICAgIGdldEN1cnJlbnRCZWxpZWZzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyAuLi50aGlzLmJlbGllZnMgfTtcbiAgICB9LFxuXG4gICAgc2V0QmVsaWVmczogZnVuY3Rpb24gKGJlbGllZnM6IEJlbGllZnMpIHtcbiAgICAgIHRoaXMuYmVsaWVmcyA9IHsgLi4uYmVsaWVmcyB9O1xuICAgIH0sXG5cbiAgICBjYWxjdWxhdGVGcmVlRW5lcmd5OiBmdW5jdGlvbiAoYmVsaWVmczogQmVsaWVmcywgb2JzZXJ2YXRpb246IHN0cmluZykge1xuICAgICAgLy8gQWNjdXJhY3kgdGVybSAoZXhwZWN0ZWQgbG9nIGxpa2VsaWhvb2QpXG4gICAgICBsZXQgYWNjdXJhY3kgPSAwO1xuICAgICAgT2JqZWN0LmVudHJpZXMoYmVsaWVmcy5zdGF0ZXMpLmZvckVhY2goKFtzdGF0ZSwgcHJvYl0pID0+IHtcbiAgICAgICAgY29uc3QgbGlrZWxpaG9vZCA9XG4gICAgICAgICAgdGhpcy5tb2RlbC5vYnNlcnZhdGlvbk1vZGVsW3N0YXRlXT8uW29ic2VydmF0aW9uXSB8fCBFUFNJTE9OO1xuICAgICAgICBhY2N1cmFjeSArPSBwcm9iICogTWF0aC5sb2cobGlrZWxpaG9vZCArIEVQU0lMT04pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENvbXBsZXhpdHkgdGVybSAoS0wgZGl2ZXJnZW5jZSBmcm9tIHByaW9yKVxuICAgICAgbGV0IGNvbXBsZXhpdHkgPSAwO1xuICAgICAgY29uc3QgcHJpb3IgPSAxLjAgLyB0aGlzLm1vZGVsLnN0YXRlcy5sZW5ndGg7XG4gICAgICBPYmplY3QudmFsdWVzKGJlbGllZnMuc3RhdGVzKS5mb3JFYWNoKChwcm9iKSA9PiB7XG4gICAgICAgIGlmIChwcm9iID4gMCkge1xuICAgICAgICAgIGNvbXBsZXhpdHkgKz0gcHJvYiAqIE1hdGgubG9nKChwcm9iICsgRVBTSUxPTikgLyBwcmlvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDb252ZXJ0IHByZWZlcmVuY2UgdG8gYSBwb3NpdGl2ZSBjb3N0IHRlcm1cbiAgICAgIC8vIE5lZ2F0aXZlIHByZWZlcmVuY2VzIChyZXdhcmRzKSBiZWNvbWUgcG9zaXRpdmUgY29zdHNcbiAgICAgIGNvbnN0IHByZWZlcmVuY2UgPSB0aGlzLm1vZGVsLnByZWZlcmVuY2VzW29ic2VydmF0aW9uXSB8fCAwO1xuICAgICAgY29uc3QgY29zdCA9IC1wcmVmZXJlbmNlOyAvLyBDb252ZXJ0IHJld2FyZCB0byBjb3N0XG5cbiAgICAgIC8vIEFkZCB1bmNlcnRhaW50eSB0ZXJtXG4gICAgICBjb25zdCB1bmNlcnRhaW50eVBlbmFsdHkgPSBiZWxpZWZzLnVuY2VydGFpbnR5ICogMi4wO1xuXG4gICAgICAvLyBGcmVlIGVuZXJneSA9IC1sb2cgbGlrZWxpaG9vZCArIGNvbXBsZXhpdHkgKyBjb3N0ICsgdW5jZXJ0YWludHlcbiAgICAgIGNvbnN0IGZyZWVFbmVyZ3kgPSAtYWNjdXJhY3kgKyBjb21wbGV4aXR5ICsgY29zdCArIHVuY2VydGFpbnR5UGVuYWx0eTtcblxuICAgICAgLy8gRW5zdXJlIGZyZWUgZW5lcmd5IGlzIHBvc2l0aXZlIGJ5IGFkZGluZyBhIGNvbnN0YW50IGlmIG5lZWRlZFxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAuMDEsIGZyZWVFbmVyZ3kpO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIGVuZ2luZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUJlbGllZnMoXG4gIGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBvYnNlcnZhdGlvbjogU2Vuc29yeUlucHV0LFxuKTogQmVsaWVmcyB7XG4gIGNvbnN0IGN1cnJlbnRCZWxpZWZzID0gZW5naW5lLmdldEN1cnJlbnRCZWxpZWZzKCk7XG4gIGNvbnN0IHVwZGF0ZWRCZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgIHN0YXRlczoge30sXG4gICAgdW5jZXJ0YWludHk6IGN1cnJlbnRCZWxpZWZzLnVuY2VydGFpbnR5LFxuICB9O1xuXG4gIC8vIFN0YW5kYXJkIEJheWVzaWFuIGJlbGllZiB1cGRhdGVcbiAgbGV0IHRvdGFsUG9zdGVyaW9yID0gMDtcblxuICBlbmdpbmUubW9kZWwuc3RhdGVzLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgcHJpb3IgPSBjdXJyZW50QmVsaWVmcy5zdGF0ZXNbc3RhdGVdO1xuICAgIGNvbnN0IGxpa2VsaWhvb2QgPVxuICAgICAgZW5naW5lLm1vZGVsLm9ic2VydmF0aW9uTW9kZWxbc3RhdGVdPy5bb2JzZXJ2YXRpb24udmFsdWVdIHx8IEVQU0lMT047XG5cbiAgICBjb25zdCBwb3N0ZXJpb3IgPSBwcmlvciAqIGxpa2VsaWhvb2Q7XG4gICAgdXBkYXRlZEJlbGllZnMuc3RhdGVzW3N0YXRlXSA9IHBvc3RlcmlvcjtcbiAgICB0b3RhbFBvc3RlcmlvciArPSBwb3N0ZXJpb3I7XG4gIH0pO1xuXG4gIC8vIE5vcm1hbGl6ZSB0byBnZXQgc3RhbmRhcmQgQmF5ZXNpYW4gcG9zdGVyaW9yXG4gIE9iamVjdC5rZXlzKHVwZGF0ZWRCZWxpZWZzLnN0YXRlcykuZm9yRWFjaCgoc3RhdGUpID0+IHtcbiAgICB1cGRhdGVkQmVsaWVmcy5zdGF0ZXNbc3RhdGVdIC89IHRvdGFsUG9zdGVyaW9yO1xuICB9KTtcblxuICAvLyBBcHBseSBjb25maWRlbmNlIHdlaWdodGluZyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcHJpb3IgYW5kIHBvc3RlcmlvclxuICBPYmplY3Qua2V5cyh1cGRhdGVkQmVsaWVmcy5zdGF0ZXMpLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgcHJpb3IgPSBjdXJyZW50QmVsaWVmcy5zdGF0ZXNbc3RhdGVdO1xuICAgIGNvbnN0IHBvc3RlcmlvciA9IHVwZGF0ZWRCZWxpZWZzLnN0YXRlc1tzdGF0ZV07XG4gICAgXG4gICAgLy8gSGlnaCBjb25maWRlbmNlID0gdXNlIG1vcmUgb2YgcG9zdGVyaW9yLCBsb3cgY29uZmlkZW5jZSA9IHVzZSBtb3JlIG9mIHByaW9yXG4gICAgdXBkYXRlZEJlbGllZnMuc3RhdGVzW3N0YXRlXSA9IFxuICAgICAgb2JzZXJ2YXRpb24uY29uZmlkZW5jZSAqIHBvc3RlcmlvciArIFxuICAgICAgKDEgLSBvYnNlcnZhdGlvbi5jb25maWRlbmNlKSAqIHByaW9yO1xuICB9KTtcblxuICAvLyBVcGRhdGUgdW5jZXJ0YWludHkgYmFzZWQgb24gb2JzZXJ2YXRpb24gY29uZmlkZW5jZSBhbmQgYmVsaWVmIGVudHJvcHlcbiAgY29uc3QgZW50cm9weSA9IE9iamVjdC52YWx1ZXModXBkYXRlZEJlbGllZnMuc3RhdGVzKS5yZWR1Y2UoKGgsIHApID0+IHtcbiAgICByZXR1cm4gcCA+IDAgPyBoIC0gcCAqIE1hdGgubG9nKHAgKyBFUFNJTE9OKSA6IGg7XG4gIH0sIDApO1xuXG4gIHVwZGF0ZWRCZWxpZWZzLnVuY2VydGFpbnR5ID1cbiAgICAoMSAtIG9ic2VydmF0aW9uLmNvbmZpZGVuY2UpICogMC4zICsgZW50cm9weSAqIDAuNztcblxuICAvLyBEb24ndCBtb2RpZnkgZW5naW5lIHN0YXRlLCBqdXN0IHJldHVybiB0aGUgdXBkYXRlZCBiZWxpZWZzXG4gIHJldHVybiB1cGRhdGVkQmVsaWVmcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdEFjdGlvbihcbiAgZW5naW5lOiBBY3RpdmVJbmZlcmVuY2VFbmdpbmUsXG4gIGJlbGllZnM6IEJlbGllZnMsXG4pOiBBY3Rpb24ge1xuICBsZXQgYmVzdEFjdGlvbiA9IFwiXCI7XG4gIGxldCBtaW5FeHBlY3RlZEZFID0gSW5maW5pdHk7XG4gIGNvbnN0IGFjdGlvblNjb3JlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuXG4gIC8vIENoZWNrIGFjdGlvbiBjb25zdHJhaW50c1xuICBjb25zdCBhY3Rpb25Db3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgZW5naW5lLmFjdGlvbkhpc3RvcnkuZm9yRWFjaCgoYWN0aW9uKSA9PiB7XG4gICAgYWN0aW9uQ291bnRzW2FjdGlvbl0gPSAoYWN0aW9uQ291bnRzW2FjdGlvbl0gfHwgMCkgKyAxO1xuICB9KTtcblxuICBlbmdpbmUubW9kZWwuYWN0aW9ucy5mb3JFYWNoKChhY3Rpb24pID0+IHtcbiAgICAvLyBDaGVjayBjb25zdHJhaW50c1xuICAgIGlmIChlbmdpbmUuYWN0aW9uQ29uc3RyYWludHM/LlthY3Rpb25dKSB7XG4gICAgICBjb25zdCBmcmVxdWVuY3kgPVxuICAgICAgICAoYWN0aW9uQ291bnRzW2FjdGlvbl0gfHwgMCkgLyBNYXRoLm1heChlbmdpbmUuYWN0aW9uSGlzdG9yeS5sZW5ndGgsIDEpO1xuICAgICAgaWYgKGZyZXF1ZW5jeSA+PSBlbmdpbmUuYWN0aW9uQ29uc3RyYWludHNbYWN0aW9uXS5tYXhGcmVxdWVuY3kpIHtcbiAgICAgICAgYWN0aW9uU2NvcmVzW2FjdGlvbl0gPSBJbmZpbml0eTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBleHBlY3RlZCBmcmVlIGVuZXJneSBmb3IgdGhpcyBhY3Rpb25cbiAgICBsZXQgZXhwZWN0ZWRGRSA9IDA7XG5cbiAgICAvLyBFcGlzdGVtaWMgdmFsdWUgKGluZm9ybWF0aW9uIGdhaW4pXG4gICAgY29uc3QgZXBpc3RlbWljID0gY2FsY3VsYXRlRXBpc3RlbWljKGVuZ2luZSwgYmVsaWVmcywgYWN0aW9uKTtcblxuICAgIC8vIFByYWdtYXRpYyB2YWx1ZSAoZ29hbCBhY2hpZXZlbWVudClcbiAgICBjb25zdCBwcmFnbWF0aWMgPSBjYWxjdWxhdGVQcmFnbWF0aWMoZW5naW5lLCBiZWxpZWZzLCBhY3Rpb24pO1xuXG4gICAgLy8gQ29tYmluZSB3aXRoIHByZWNpc2lvbiB3ZWlnaHRpbmdcbiAgICBleHBlY3RlZEZFID0gZW5naW5lLnByZWNpc2lvbiAqIHByYWdtYXRpYyAtIGVwaXN0ZW1pYztcblxuICAgIC8vIEFkZCBleHBsb3JhdGlvbiBib251cyB1bmRlciBoaWdoIHVuY2VydGFpbnR5XG4gICAgaWYgKGJlbGllZnMudW5jZXJ0YWludHkgPiAwLjUgJiYgYWN0aW9uICE9PSBcIndhaXRcIikge1xuICAgICAgZXhwZWN0ZWRGRSAtPSBiZWxpZWZzLnVuY2VydGFpbnR5ICogMC41O1xuICAgIH1cblxuICAgIC8vIEFkZCBhY3Rpb24gdmFyaWV0eSBib251cyB0byBwcmV2ZW50IGdldHRpbmcgc3R1Y2tcbiAgICBjb25zdCByZWNlbnRBY3Rpb25zID0gZW5naW5lLmFjdGlvbkhpc3Rvcnkuc2xpY2UoLTUpO1xuICAgIGNvbnN0IGFjdGlvbkZyZXF1ZW5jeSA9IHJlY2VudEFjdGlvbnMuZmlsdGVyKGEgPT4gYSA9PT0gYWN0aW9uKS5sZW5ndGggLyBNYXRoLm1heChyZWNlbnRBY3Rpb25zLmxlbmd0aCwgMSk7XG4gICAgY29uc3QgdmFyaWV0eVBlbmFsdHkgPSBhY3Rpb25GcmVxdWVuY3kgKiAyLjA7IC8vIFBlbmFsaXplIHJlcGV0aXRpdmUgYWN0aW9uc1xuICAgIGV4cGVjdGVkRkUgKz0gdmFyaWV0eVBlbmFsdHk7XG5cbiAgICBhY3Rpb25TY29yZXNbYWN0aW9uXSA9IGV4cGVjdGVkRkU7XG5cbiAgICAvLyBEZWJ1ZyBvdXRwdXQgZm9yIGFkYXB0YXRpb24gdGVzdFxuICAgIGlmIChhY3Rpb24gPT09IFwibW92ZV9mb3J3YXJkXCIgfHwgYWN0aW9uID09PSBcInR1cm5cIiB8fCBhY3Rpb24gPT09IFwid2FpdFwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhgQWN0aW9uICR7YWN0aW9ufTogZXBpc3RlbWljPSR7ZXBpc3RlbWljLnRvRml4ZWQoMyl9LCBwcmFnbWF0aWM9JHtwcmFnbWF0aWMudG9GaXhlZCgzKX0sIGV4cGVjdGVkRkU9JHtleHBlY3RlZEZFLnRvRml4ZWQoMyl9LCB2YXJpZXR5X3BlbmFsdHk9JHt2YXJpZXR5UGVuYWx0eS50b0ZpeGVkKDMpfWApO1xuICAgIH1cblxuICAgIGlmIChleHBlY3RlZEZFIDwgbWluRXhwZWN0ZWRGRSkge1xuICAgICAgbWluRXhwZWN0ZWRGRSA9IGV4cGVjdGVkRkU7XG4gICAgICBiZXN0QWN0aW9uID0gYWN0aW9uO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIGFjdGlvbiBjb25maWRlbmNlIGJhc2VkIG9uIHNjb3JlIGRpZmZlcmVuY2VzXG4gIGNvbnN0IHNjb3JlcyA9IE9iamVjdC52YWx1ZXMoYWN0aW9uU2NvcmVzKS5maWx0ZXIoKHMpID0+IHMgIT09IEluZmluaXR5KTtcbiAgY29uc3QgYXZnU2NvcmUgPSBzY29yZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBzY29yZXMubGVuZ3RoO1xuICBjb25zdCBjb25maWRlbmNlID0gTWF0aC5leHAoLU1hdGguYWJzKG1pbkV4cGVjdGVkRkUgLSBhdmdTY29yZSkpO1xuXG4gIGVuZ2luZS5hY3Rpb25IaXN0b3J5LnB1c2goYmVzdEFjdGlvbik7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBiZXN0QWN0aW9uLFxuICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKE1hdGgubWF4KGNvbmZpZGVuY2UsIDAuMSksIDEuMCksXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwZXJmb3JtSW5mZXJlbmNlKFxuICBlbmdpbmU6IEFjdGl2ZUluZmVyZW5jZUVuZ2luZSxcbiAgb2JzZXJ2YXRpb246IFNlbnNvcnlJbnB1dCxcbik6IFByb21pc2U8SW5mZXJlbmNlUmVzdWx0PiB7XG4gIC8vIFVwZGF0ZSBiZWxpZWZzIGJhc2VkIG9uIG9ic2VydmF0aW9uXG4gIGNvbnN0IHVwZGF0ZWRCZWxpZWZzID0gdXBkYXRlQmVsaWVmcyhlbmdpbmUsIG9ic2VydmF0aW9uKTtcblxuICAvLyBDYWxjdWxhdGUgY3VycmVudCBmcmVlIGVuZXJneVxuICBjb25zdCBmcmVlRW5lcmd5ID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koXG4gICAgdXBkYXRlZEJlbGllZnMsXG4gICAgb2JzZXJ2YXRpb24udmFsdWUsXG4gICk7XG5cbiAgLy8gU2VsZWN0IGFjdGlvbiB0aGF0IG1pbmltaXplcyBleHBlY3RlZCBmcmVlIGVuZXJneVxuICBjb25zdCBzZWxlY3RlZEFjdGlvbiA9IHNlbGVjdEFjdGlvbihlbmdpbmUsIHVwZGF0ZWRCZWxpZWZzKTtcblxuICAvLyBPdmVyYWxsIGNvbmZpZGVuY2UgYmFzZWQgb24gYmVsaWVmIGNlcnRhaW50eSBhbmQgYWN0aW9uIGNvbmZpZGVuY2VcbiAgY29uc3QgYmVsaWVmQ2VydGFpbnR5ID0gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyh1cGRhdGVkQmVsaWVmcy5zdGF0ZXMpKTtcbiAgY29uc3Qgb3ZlcmFsbENvbmZpZGVuY2UgPSAoYmVsaWVmQ2VydGFpbnR5ICsgc2VsZWN0ZWRBY3Rpb24uY29uZmlkZW5jZSkgLyAyO1xuXG4gIHJldHVybiB7XG4gICAgYmVsaWVmczogdXBkYXRlZEJlbGllZnMsXG4gICAgc2VsZWN0ZWRBY3Rpb24sXG4gICAgZnJlZUVuZXJneSxcbiAgICBjb25maWRlbmNlOiBvdmVyYWxsQ29uZmlkZW5jZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneShcbiAgZW5naW5lOiBBY3RpdmVJbmZlcmVuY2VFbmdpbmUsXG4gIHBvbGljeTogUG9saWN5LFxuKTogRXhwZWN0ZWRGcmVlRW5lcmd5IHtcbiAgbGV0IHRvdGFsRUZFID0gMDtcbiAgbGV0IHRvdGFsRXBpc3RlbWljID0gMDtcbiAgbGV0IHRvdGFsUHJhZ21hdGljID0gMDtcblxuICAvLyBTdGFydCB3aXRoIGN1cnJlbnQgYmVsaWVmc1xuICBsZXQgYmVsaWVmcyA9IGVuZ2luZS5nZXRDdXJyZW50QmVsaWVmcygpO1xuXG4gIHBvbGljeS5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgY29uc3QgZXBpc3RlbWljID0gY2FsY3VsYXRlRXBpc3RlbWljKGVuZ2luZSwgYmVsaWVmcywgc3RlcC5hY3Rpb24pO1xuICAgIGNvbnN0IHByYWdtYXRpYyA9IGNhbGN1bGF0ZVByYWdtYXRpYyhlbmdpbmUsIGJlbGllZnMsIHN0ZXAuYWN0aW9uKTtcblxuICAgIC8vIEVuc3VyZSBmaW5pdGUgdmFsdWVzXG4gICAgY29uc3QgZmluaXRlRXBpc3RlbWljID0gTnVtYmVyLmlzRmluaXRlKGVwaXN0ZW1pYykgPyBlcGlzdGVtaWMgOiAwO1xuICAgIGNvbnN0IGZpbml0ZVByYWdtYXRpYyA9IE51bWJlci5pc0Zpbml0ZShwcmFnbWF0aWMpID8gcHJhZ21hdGljIDogMDtcblxuICAgIHRvdGFsRXBpc3RlbWljICs9IGZpbml0ZUVwaXN0ZW1pYyAqIE1hdGgucG93KDAuOSwgc3RlcC50aW1lc3RlcCk7IC8vIERpc2NvdW50IGZ1dHVyZVxuICAgIHRvdGFsUHJhZ21hdGljICs9IGZpbml0ZVByYWdtYXRpYyAqIE1hdGgucG93KDAuOSwgc3RlcC50aW1lc3RlcCk7XG5cbiAgICAvLyBQcmVkaWN0IGJlbGllZiBldm9sdXRpb25cbiAgICBiZWxpZWZzID0gcHJlZGljdEJlbGllZkV2b2x1dGlvbihlbmdpbmUsIGJlbGllZnMsIHN0ZXAuYWN0aW9uKTtcbiAgfSk7XG5cbiAgdG90YWxFRkUgPSBlbmdpbmUucHJlY2lzaW9uICogdG90YWxQcmFnbWF0aWMgLSB0b3RhbEVwaXN0ZW1pYztcblxuICAvLyBFbnN1cmUgYWxsIHZhbHVlcyBhcmUgZmluaXRlXG4gIHJldHVybiB7XG4gICAgdG90YWw6IE51bWJlci5pc0Zpbml0ZSh0b3RhbEVGRSkgPyB0b3RhbEVGRSA6IDAsXG4gICAgZXBpc3RlbWljOiBOdW1iZXIuaXNGaW5pdGUodG90YWxFcGlzdGVtaWMpID8gdG90YWxFcGlzdGVtaWMgOiAwLFxuICAgIHByYWdtYXRpYzogTnVtYmVyLmlzRmluaXRlKHRvdGFsUHJhZ21hdGljKSA/IHRvdGFsUHJhZ21hdGljIDogMCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUVwaXN0ZW1pYyhcbiAgZW5naW5lOiBBY3RpdmVJbmZlcmVuY2VFbmdpbmUsXG4gIGJlbGllZnM6IEJlbGllZnMsXG4gIGFjdGlvbjogc3RyaW5nLFxuKTogbnVtYmVyIHtcbiAgLy8gSW5mb3JtYXRpb24gZ2FpbjogcmVkdWN0aW9uIGluIHVuY2VydGFpbnR5IGFib3V0IHN0YXRlc1xuICBsZXQgaW5mb3JtYXRpb25HYWluID0gMDtcblxuICAvLyBDdXJyZW50IGVudHJvcHlcbiAgY29uc3QgY3VycmVudEVudHJvcHkgPSBPYmplY3QudmFsdWVzKGJlbGllZnMuc3RhdGVzKS5yZWR1Y2UoKGgsIHApID0+IHtcbiAgICByZXR1cm4gcCA+IDAgPyBoIC0gcCAqIE1hdGgubG9nKHAgKyBFUFNJTE9OKSA6IGg7XG4gIH0sIDApO1xuXG4gIC8vIEV4cGVjdGVkIGVudHJvcHkgYWZ0ZXIgYWN0aW9uXG4gIGxldCBleHBlY3RlZEVudHJvcHkgPSAwO1xuICBjb25zdCBwcmVkaWN0ZWRCZWxpZWZzID0gcHJlZGljdEJlbGllZkV2b2x1dGlvbihlbmdpbmUsIGJlbGllZnMsIGFjdGlvbik7XG5cbiAgZXhwZWN0ZWRFbnRyb3B5ID0gT2JqZWN0LnZhbHVlcyhwcmVkaWN0ZWRCZWxpZWZzLnN0YXRlcykucmVkdWNlKChoLCBwKSA9PiB7XG4gICAgcmV0dXJuIHAgPiAwID8gaCAtIHAgKiBNYXRoLmxvZyhwICsgRVBTSUxPTikgOiBoO1xuICB9LCAwKTtcblxuICBpbmZvcm1hdGlvbkdhaW4gPSBjdXJyZW50RW50cm9weSAtIGV4cGVjdGVkRW50cm9weTtcblxuICAvLyBBZGQgZXhwbG9yYXRpb24gYm9udXMgZm9yIHVuY2VydGFpbiBzdGF0ZXNcbiAgY29uc3QgZXhwbG9yYXRpb25Cb251cyA9IGJlbGllZnMudW5jZXJ0YWludHkgKiAwLjM7XG5cbiAgY29uc3QgcmVzdWx0ID0gTWF0aC5tYXgoMCwgaW5mb3JtYXRpb25HYWluICsgZXhwbG9yYXRpb25Cb251cyk7XG4gIFxuICAvLyBFbnN1cmUgZmluaXRlIHJlc3VsdFxuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHJlc3VsdCkgPyByZXN1bHQgOiAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUHJhZ21hdGljKFxuICBlbmdpbmU6IEFjdGl2ZUluZmVyZW5jZUVuZ2luZSxcbiAgYmVsaWVmczogQmVsaWVmcyxcbiAgYWN0aW9uOiBzdHJpbmcsXG4pOiBudW1iZXIge1xuICAvLyBFeHBlY3RlZCBwcmVmZXJlbmNlIHNhdGlzZmFjdGlvblxuICBsZXQgZXhwZWN0ZWRQcmVmZXJlbmNlID0gMDtcblxuICAvLyBQcmVkaWN0IG91dGNvbWVzIGZvciB0aGlzIGFjdGlvblxuICBjb25zdCBwcmVkaWN0aW9ucyA9IHByZWRpY3RTZW5zb3J5T3V0Y29tZXMoZW5naW5lLCBiZWxpZWZzLCBhY3Rpb24pO1xuXG4gIE9iamVjdC5lbnRyaWVzKHByZWRpY3Rpb25zKS5mb3JFYWNoKChbb3V0Y29tZSwgcHJvYl0pID0+IHtcbiAgICBjb25zdCBwcmVmZXJlbmNlID0gZW5naW5lLm1vZGVsLnByZWZlcmVuY2VzW291dGNvbWVdIHx8IDA7XG4gICAgY29uc3QgY29udHJpYnV0aW9uID0gcHJvYiAqIHByZWZlcmVuY2U7XG4gICAgXG4gICAgLy8gT25seSBhZGQgZmluaXRlIGNvbnRyaWJ1dGlvbnNcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGNvbnRyaWJ1dGlvbikpIHtcbiAgICAgIGV4cGVjdGVkUHJlZmVyZW5jZSArPSBjb250cmlidXRpb247XG4gICAgfVxuICB9KTtcblxuICAvLyBFbnN1cmUgZmluaXRlIHJlc3VsdFxuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKGV4cGVjdGVkUHJlZmVyZW5jZSkgPyBleHBlY3RlZFByZWZlcmVuY2UgOiAwO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWluaW1pemVWYXJpYXRpb25hbEZyZWVFbmVyZ3koXG4gIGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBpbml0aWFsQmVsaWVmczogQmVsaWVmcyxcbiAgb2JzZXJ2YXRpb246IHN0cmluZyxcbiAgb3B0aW9ucz86IHsgbWF4SXRlcmF0aW9ucz86IG51bWJlcjsgdG9sZXJhbmNlPzogbnVtYmVyIH0sXG4pOiBQcm9taXNlPEJlbGllZnM+IHtcbiAgY29uc3QgbWF4SXRlciA9IG9wdGlvbnM/Lm1heEl0ZXJhdGlvbnMgfHwgMTAwO1xuICBjb25zdCB0b2xlcmFuY2UgPSBvcHRpb25zPy50b2xlcmFuY2UgfHwgMC4wMDE7XG5cbiAgbGV0IGJlbGllZnMgPSB7IC4uLmluaXRpYWxCZWxpZWZzIH07XG4gIGxldCBwcmV2RkUgPSBlbmdpbmUuY2FsY3VsYXRlRnJlZUVuZXJneShiZWxpZWZzLCBvYnNlcnZhdGlvbik7XG4gIGxldCBjb252ZXJnZWQgPSBmYWxzZTtcbiAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuXG4gIHdoaWxlIChpdGVyYXRpb25zIDwgbWF4SXRlciAmJiAhY29udmVyZ2VkKSB7XG4gICAgLy8gR3JhZGllbnQgZGVzY2VudCBvbiBiZWxpZWZzXG4gICAgY29uc3QgZ3JhZGllbnQ6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICBjb25zdCBkZWx0YSA9IDAuMDAxO1xuXG4gICAgZW5naW5lLm1vZGVsLnN0YXRlcy5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgICAgLy8gRmluaXRlIGRpZmZlcmVuY2UgYXBwcm94aW1hdGlvblxuICAgICAgY29uc3QgYmVsaWVmc0NvcHkgPSB7IC4uLmJlbGllZnMgfTtcbiAgICAgIGJlbGllZnNDb3B5LnN0YXRlc1tzdGF0ZV0gPSBNYXRoLm1pbihiZWxpZWZzLnN0YXRlc1tzdGF0ZV0gKyBkZWx0YSwgMSk7XG5cbiAgICAgIC8vIFJlbm9ybWFsaXplXG4gICAgICBjb25zdCBzdW0gPSBPYmplY3QudmFsdWVzKGJlbGllZnNDb3B5LnN0YXRlcykucmVkdWNlKChzLCBwKSA9PiBzICsgcCwgMCk7XG4gICAgICBPYmplY3Qua2V5cyhiZWxpZWZzQ29weS5zdGF0ZXMpLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgYmVsaWVmc0NvcHkuc3RhdGVzW3NdIC89IHN1bTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmZVBsdXMgPSBlbmdpbmUuY2FsY3VsYXRlRnJlZUVuZXJneShiZWxpZWZzQ29weSwgb2JzZXJ2YXRpb24pO1xuICAgICAgZ3JhZGllbnRbc3RhdGVdID0gKGZlUGx1cyAtIHByZXZGRSkgLyBkZWx0YTtcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBiZWxpZWZzXG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBlbmdpbmUubW9kZWwuc3RhdGVzLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGUgPSAtZ3JhZGllbnRbc3RhdGVdICogZW5naW5lLmxlYXJuaW5nUmF0ZTtcbiAgICAgIGNvbnN0IG5ld0JlbGllZiA9IE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICBNYXRoLm1pbigxLCBiZWxpZWZzLnN0YXRlc1tzdGF0ZV0gKyB1cGRhdGUpLFxuICAgICAgKTtcblxuICAgICAgaWYgKE1hdGguYWJzKG5ld0JlbGllZiAtIGJlbGllZnMuc3RhdGVzW3N0YXRlXSkgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGJlbGllZnMuc3RhdGVzW3N0YXRlXSA9IG5ld0JlbGllZjtcbiAgICB9KTtcblxuICAgIC8vIFJlbm9ybWFsaXplXG4gICAgY29uc3Qgc3VtID0gT2JqZWN0LnZhbHVlcyhiZWxpZWZzLnN0YXRlcykucmVkdWNlKChzLCBwKSA9PiBzICsgcCwgMCk7XG4gICAgT2JqZWN0LmtleXMoYmVsaWVmcy5zdGF0ZXMpLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgICBiZWxpZWZzLnN0YXRlc1tzdGF0ZV0gLz0gc3VtO1xuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgY29udmVyZ2VuY2VcbiAgICBjb25zdCBjdXJyZW50RkUgPSBlbmdpbmUuY2FsY3VsYXRlRnJlZUVuZXJneShiZWxpZWZzLCBvYnNlcnZhdGlvbik7XG4gICAgaWYgKCFjaGFuZ2VkIHx8IE1hdGguYWJzKGN1cnJlbnRGRSAtIHByZXZGRSkgPCB0b2xlcmFuY2UpIHtcbiAgICAgIGNvbnZlcmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHJldkZFID0gY3VycmVudEZFO1xuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uYmVsaWVmcyxcbiAgICBjb252ZXJnZWQsXG4gICAgaXRlcmF0aW9ucyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZWRpY3RTZW5zb3J5T3V0Y29tZXMoXG4gIGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBiZWxpZWZzOiBCZWxpZWZzLFxuICBhY3Rpb246IHN0cmluZyxcbik6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICBjb25zdCBwcmVkaWN0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuXG4gIC8vIEluaXRpYWxpemUgcHJlZGljdGlvbnNcbiAgZW5naW5lLm1vZGVsLm9ic2VydmF0aW9ucy5mb3JFYWNoKChvYnMpID0+IHtcbiAgICBwcmVkaWN0aW9uc1tvYnNdID0gMDtcbiAgfSk7XG5cbiAgLy8gRm9yIGVhY2ggY3VycmVudCBzdGF0ZVxuICBPYmplY3QuZW50cmllcyhiZWxpZWZzLnN0YXRlcykuZm9yRWFjaCgoW2N1cnJlbnRTdGF0ZSwgc3RhdGVQcm9iXSkgPT4ge1xuICAgIC8vIEdldCB0cmFuc2l0aW9uIHByb2JhYmlsaXRpZXMgZm9yIHRoaXMgYWN0aW9uXG4gICAgY29uc3QgdHJhbnNpdGlvbnMgPVxuICAgICAgZW5naW5lLm1vZGVsLnRyYW5zaXRpb25Nb2RlbFtjdXJyZW50U3RhdGVdPy5bYWN0aW9uXSB8fCB7fTtcblxuICAgIC8vIEZvciBlYWNoIHBvc3NpYmxlIG5leHQgc3RhdGVcbiAgICBPYmplY3QuZW50cmllcyh0cmFuc2l0aW9ucykuZm9yRWFjaCgoW25leHRTdGF0ZSwgdHJhbnNQcm9iXSkgPT4ge1xuICAgICAgLy8gR2V0IG9ic2VydmF0aW9uIHByb2JhYmlsaXRpZXMgZm9yIG5leHQgc3RhdGVcbiAgICAgIGNvbnN0IG9ic2VydmF0aW9ucyA9IGVuZ2luZS5tb2RlbC5vYnNlcnZhdGlvbk1vZGVsW25leHRTdGF0ZV0gfHwge307XG5cbiAgICAgIC8vIEFjY3VtdWxhdGUgcHJlZGljdGlvblxuICAgICAgT2JqZWN0LmVudHJpZXMob2JzZXJ2YXRpb25zKS5mb3JFYWNoKChbb2JzLCBvYnNQcm9iXSkgPT4ge1xuICAgICAgICBwcmVkaWN0aW9uc1tvYnNdICs9IHN0YXRlUHJvYiAqIHRyYW5zUHJvYiAqIG9ic1Byb2I7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByZWRpY3Rpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVBY3Rpb25Qb2xpY3koXG4gIGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBwb2xpY3k6IFBvbGljeSxcbik6IFBvbGljeUV2YWx1YXRpb24ge1xuICBsZXQgZXhwZWN0ZWRSZXR1cm4gPSAwO1xuICBsZXQgdG90YWxVbmNlcnRhaW50eSA9IDA7XG4gIGxldCBmZWFzaWJpbGl0eSA9IDEuMDtcblxuICBsZXQgYmVsaWVmcyA9IGVuZ2luZS5nZXRDdXJyZW50QmVsaWVmcygpO1xuXG4gIHBvbGljeS5mb3JFYWNoKChzdGVwLCB0KSA9PiB7XG4gICAgLy8gRXhwZWN0ZWQgaW1tZWRpYXRlIHJld2FyZFxuICAgIGNvbnN0IHByZWRpY3Rpb25zID0gcHJlZGljdFNlbnNvcnlPdXRjb21lcyhlbmdpbmUsIGJlbGllZnMsIHN0ZXAuYWN0aW9uKTtcbiAgICBjb25zdCBpbW1lZGlhdGVSZXR1cm4gPSBPYmplY3QuZW50cmllcyhwcmVkaWN0aW9ucykucmVkdWNlKFxuICAgICAgKHN1bSwgW291dGNvbWUsIHByb2JdKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZWZlcmVuY2UgPSBlbmdpbmUubW9kZWwucHJlZmVyZW5jZXNbb3V0Y29tZV0gfHwgMDtcbiAgICAgICAgcmV0dXJuIHN1bSAtIHByb2IgKiBwcmVmZXJlbmNlOyAvLyBOZWdhdGl2ZSBiZWNhdXNlIGxvd2VyIGlzIGJldHRlclxuICAgICAgfSxcbiAgICAgIDAsXG4gICAgKTtcblxuICAgIGV4cGVjdGVkUmV0dXJuICs9IGltbWVkaWF0ZVJldHVybiAqIE1hdGgucG93KDAuOSwgdCk7XG5cbiAgICAvLyBBY2N1bXVsYXRlIHVuY2VydGFpbnR5XG4gICAgdG90YWxVbmNlcnRhaW50eSArPSBiZWxpZWZzLnVuY2VydGFpbnR5ICogTWF0aC5wb3coMC45LCB0KTtcblxuICAgIC8vIENoZWNrIGFjdGlvbiBmZWFzaWJpbGl0eVxuICAgIGlmICghZW5naW5lLm1vZGVsLmFjdGlvbnMuaW5jbHVkZXMoc3RlcC5hY3Rpb24pKSB7XG4gICAgICBmZWFzaWJpbGl0eSAqPSAwLjE7XG4gICAgfVxuXG4gICAgLy8gRXZvbHZlIGJlbGllZnNcbiAgICBiZWxpZWZzID0gcHJlZGljdEJlbGllZkV2b2x1dGlvbihlbmdpbmUsIGJlbGllZnMsIHN0ZXAuYWN0aW9uKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBleHBlY3RlZFJldHVybixcbiAgICB1bmNlcnRhaW50eTogdG90YWxVbmNlcnRhaW50eSAvIHBvbGljeS5sZW5ndGgsXG4gICAgZmVhc2liaWxpdHksXG4gIH07XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwcmVkaWN0IGJlbGllZiBldm9sdXRpb25cbmZ1bmN0aW9uIHByZWRpY3RCZWxpZWZFdm9sdXRpb24oXG4gIGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBiZWxpZWZzOiBCZWxpZWZzLFxuICBhY3Rpb246IHN0cmluZyxcbik6IEJlbGllZnMge1xuICBjb25zdCBldm9sdmVkOiBCZWxpZWZzID0ge1xuICAgIHN0YXRlczoge30sXG4gICAgdW5jZXJ0YWludHk6IGJlbGllZnMudW5jZXJ0YWludHksXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZVxuICBlbmdpbmUubW9kZWwuc3RhdGVzLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgZXZvbHZlZC5zdGF0ZXNbc3RhdGVdID0gMDtcbiAgfSk7XG5cbiAgLy8gUHJlZGljdCBzdGF0ZSBldm9sdXRpb25cbiAgT2JqZWN0LmVudHJpZXMoYmVsaWVmcy5zdGF0ZXMpLmZvckVhY2goKFtjdXJyZW50U3RhdGUsIHByb2JdKSA9PiB7XG4gICAgY29uc3QgdHJhbnNpdGlvbnMgPVxuICAgICAgZW5naW5lLm1vZGVsLnRyYW5zaXRpb25Nb2RlbFtjdXJyZW50U3RhdGVdPy5bYWN0aW9uXSB8fCB7fTtcblxuICAgIE9iamVjdC5lbnRyaWVzKHRyYW5zaXRpb25zKS5mb3JFYWNoKChbbmV4dFN0YXRlLCB0cmFuc1Byb2JdKSA9PiB7XG4gICAgICBldm9sdmVkLnN0YXRlc1tuZXh0U3RhdGVdICs9IHByb2IgKiB0cmFuc1Byb2I7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFVwZGF0ZSB1bmNlcnRhaW50eSAodGVuZHMgdG8gaW5jcmVhc2Ugd2l0aG91dCBvYnNlcnZhdGlvbnMpXG4gIGV2b2x2ZWQudW5jZXJ0YWludHkgPSBNYXRoLm1pbigxLjAsIGJlbGllZnMudW5jZXJ0YWludHkgKiAxLjEpO1xuXG4gIHJldHVybiBldm9sdmVkO1xufVxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZUVwaXN0ZW1pYyIsImNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneSIsImNhbGN1bGF0ZVByYWdtYXRpYyIsImNyZWF0ZUFjdGl2ZUluZmVyZW5jZUVuZ2luZSIsImV2YWx1YXRlQWN0aW9uUG9saWN5IiwibWluaW1pemVWYXJpYXRpb25hbEZyZWVFbmVyZ3kiLCJwZXJmb3JtSW5mZXJlbmNlIiwicHJlZGljdFNlbnNvcnlPdXRjb21lcyIsInNlbGVjdEFjdGlvbiIsInVwZGF0ZUJlbGllZnMiLCJFUFNJTE9OIiwiY29uZmlnIiwibW9kZWwiLCJzdGF0ZXMiLCJsZW5ndGgiLCJvYnNlcnZhdGlvbnMiLCJhY3Rpb25zIiwiRXJyb3IiLCJPYmplY3QiLCJrZXlzIiwidHJhbnNpdGlvbk1vZGVsIiwidW5pZm9ybVByb2IiLCJpbml0aWFsQmVsaWVmcyIsInVuY2VydGFpbnR5IiwiZm9yRWFjaCIsInN0YXRlIiwiZW5naW5lIiwicHJlY2lzaW9uIiwibGVhcm5pbmdSYXRlIiwicGxhbm5pbmdIb3Jpem9uIiwiYWN0aW9uQ29uc3RyYWludHMiLCJiZWxpZWZzIiwiYWN0aW9uSGlzdG9yeSIsImdldEN1cnJlbnRCZWxpZWZzIiwic2V0QmVsaWVmcyIsImNhbGN1bGF0ZUZyZWVFbmVyZ3kiLCJvYnNlcnZhdGlvbiIsImFjY3VyYWN5IiwiZW50cmllcyIsInByb2IiLCJsaWtlbGlob29kIiwib2JzZXJ2YXRpb25Nb2RlbCIsIk1hdGgiLCJsb2ciLCJjb21wbGV4aXR5IiwicHJpb3IiLCJ2YWx1ZXMiLCJwcmVmZXJlbmNlIiwicHJlZmVyZW5jZXMiLCJjb3N0IiwidW5jZXJ0YWludHlQZW5hbHR5IiwiZnJlZUVuZXJneSIsIm1heCIsImN1cnJlbnRCZWxpZWZzIiwidXBkYXRlZEJlbGllZnMiLCJ0b3RhbFBvc3RlcmlvciIsInZhbHVlIiwicG9zdGVyaW9yIiwiY29uZmlkZW5jZSIsImVudHJvcHkiLCJyZWR1Y2UiLCJoIiwicCIsImJlc3RBY3Rpb24iLCJtaW5FeHBlY3RlZEZFIiwiSW5maW5pdHkiLCJhY3Rpb25TY29yZXMiLCJhY3Rpb25Db3VudHMiLCJhY3Rpb24iLCJmcmVxdWVuY3kiLCJtYXhGcmVxdWVuY3kiLCJleHBlY3RlZEZFIiwiZXBpc3RlbWljIiwicHJhZ21hdGljIiwicmVjZW50QWN0aW9ucyIsInNsaWNlIiwiYWN0aW9uRnJlcXVlbmN5IiwiZmlsdGVyIiwiYSIsInZhcmlldHlQZW5hbHR5IiwiY29uc29sZSIsInRvRml4ZWQiLCJzY29yZXMiLCJzIiwiYXZnU2NvcmUiLCJiIiwiZXhwIiwiYWJzIiwicHVzaCIsInR5cGUiLCJtaW4iLCJzZWxlY3RlZEFjdGlvbiIsImJlbGllZkNlcnRhaW50eSIsIm92ZXJhbGxDb25maWRlbmNlIiwicG9saWN5IiwidG90YWxFRkUiLCJ0b3RhbEVwaXN0ZW1pYyIsInRvdGFsUHJhZ21hdGljIiwic3RlcCIsImZpbml0ZUVwaXN0ZW1pYyIsIk51bWJlciIsImlzRmluaXRlIiwiZmluaXRlUHJhZ21hdGljIiwicG93IiwidGltZXN0ZXAiLCJwcmVkaWN0QmVsaWVmRXZvbHV0aW9uIiwidG90YWwiLCJpbmZvcm1hdGlvbkdhaW4iLCJjdXJyZW50RW50cm9weSIsImV4cGVjdGVkRW50cm9weSIsInByZWRpY3RlZEJlbGllZnMiLCJleHBsb3JhdGlvbkJvbnVzIiwicmVzdWx0IiwiZXhwZWN0ZWRQcmVmZXJlbmNlIiwicHJlZGljdGlvbnMiLCJvdXRjb21lIiwiY29udHJpYnV0aW9uIiwib3B0aW9ucyIsIm1heEl0ZXIiLCJtYXhJdGVyYXRpb25zIiwidG9sZXJhbmNlIiwicHJldkZFIiwiY29udmVyZ2VkIiwiaXRlcmF0aW9ucyIsImdyYWRpZW50IiwiZGVsdGEiLCJiZWxpZWZzQ29weSIsInN1bSIsImZlUGx1cyIsImNoYW5nZWQiLCJ1cGRhdGUiLCJuZXdCZWxpZWYiLCJjdXJyZW50RkUiLCJvYnMiLCJjdXJyZW50U3RhdGUiLCJzdGF0ZVByb2IiLCJ0cmFuc2l0aW9ucyIsIm5leHRTdGF0ZSIsInRyYW5zUHJvYiIsIm9ic1Byb2IiLCJleHBlY3RlZFJldHVybiIsInRvdGFsVW5jZXJ0YWludHkiLCJmZWFzaWJpbGl0eSIsInQiLCJpbW1lZGlhdGVSZXR1cm4iLCJpbmNsdWRlcyIsImV2b2x2ZWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDOzs7Ozs7Ozs7OztJQTZWZUEsa0JBQWtCO2VBQWxCQTs7SUFwQ0FDLDJCQUEyQjtlQUEzQkE7O0lBb0VBQyxrQkFBa0I7ZUFBbEJBOztJQWhUQUMsMkJBQTJCO2VBQTNCQTs7SUFtYkFDLG9CQUFvQjtlQUFwQkE7O0lBMUdNQyw2QkFBNkI7ZUFBN0JBOztJQXpIQUMsZ0JBQWdCO2VBQWhCQTs7SUFrTU5DLHNCQUFzQjtlQUF0QkE7O0lBNVFBQyxZQUFZO2VBQVpBOztJQW5EQUMsYUFBYTtlQUFiQTs7O0FBckZoQixNQUFNQyxVQUFVO0FBRVQsU0FBU1AsNEJBQ2RRLE1BQTZCO0lBRTdCLGlCQUFpQjtJQUNqQixJQUNFLENBQUNBLE9BQU9DLEtBQUssQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNLElBQzNCLENBQUNILE9BQU9DLEtBQUssQ0FBQ0csWUFBWSxDQUFDRCxNQUFNLElBQ2pDLENBQUNILE9BQU9DLEtBQUssQ0FBQ0ksT0FBTyxDQUFDRixNQUFNLEVBQzVCO1FBQ0EsTUFBTSxJQUFJRyxNQUNSO0lBRUo7SUFFQSxJQUFJQyxPQUFPQyxJQUFJLENBQUNSLE9BQU9DLEtBQUssQ0FBQ1EsZUFBZSxFQUFFTixNQUFNLEtBQUssR0FBRztRQUMxRCxNQUFNLElBQUlHLE1BQU07SUFDbEI7SUFFQSw2QkFBNkI7SUFDN0IsTUFBTUksY0FBYyxNQUFNVixPQUFPQyxLQUFLLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTTtJQUNwRCxNQUFNUSxpQkFBMEI7UUFDOUJULFFBQVEsQ0FBQztRQUNUVSxhQUFhO0lBQ2Y7SUFFQVosT0FBT0MsS0FBSyxDQUFDQyxNQUFNLENBQUNXLE9BQU8sQ0FBQyxDQUFDQztRQUMzQkgsZUFBZVQsTUFBTSxDQUFDWSxNQUFNLEdBQUdKO0lBQ2pDO0lBRUEs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