55a1ef8f6e47ca9a1daf58870106a7a4
/**
 * Specialized Services Tests
 *
 * Tests for compression workers, provider monitoring, knowledge graph utilities,
 * and other specialized service components following ADR-007 requirements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Mock Worker for compression service
global.Worker = _globals.jest.fn(()=>({
        postMessage: _globals.jest.fn(),
        terminate: _globals.jest.fn(),
        onmessage: null,
        onerror: null
    }));
// Mock IndexedDB for storage services
global.indexedDB = {
    open: _globals.jest.fn(()=>({
            onsuccess: null,
            onerror: null,
            onupgradeneeded: null,
            result: {
                createObjectStore: _globals.jest.fn(()=>({
                        createIndex: _globals.jest.fn()
                    })),
                transaction: _globals.jest.fn(()=>({
                        objectStore: _globals.jest.fn(()=>({
                                add: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                get: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                delete: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                put: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                getAll: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    })),
                                clear: _globals.jest.fn(()=>({
                                        onsuccess: null,
                                        onerror: null
                                    }))
                            }))
                    }))
            }
        })),
    deleteDatabase: _globals.jest.fn()
};
class CompressionWorker {
    constructor(){
        this.pendingJobs = new Map();
        this.worker = new Worker("/workers/compression.js");
        this.worker.onmessage = this.handleMessage.bind(this);
        this.worker.onerror = this.handleError.bind(this);
    }
    handleMessage(event) {
        const { id, result, error } = event.data;
        const job = this.pendingJobs.get(id);
        if (job) {
            if (error) {
                job.reject(new Error(error));
            } else {
                job.resolve(result);
            }
            this.pendingJobs.delete(id);
        }
    }
    handleError(error) {
        console.error("Compression worker error:", error);
        // Reject all pending jobs
        this.pendingJobs.forEach(({ reject })=>reject(error));
        this.pendingJobs.clear();
    }
    async compress(data, options) {
        const id = Math.random().toString(36);
        return new Promise((resolve, reject)=>{
            this.pendingJobs.set(id, {
                resolve,
                reject
            });
            this.worker.postMessage({
                id,
                action: "compress",
                data,
                options
            });
        });
    }
    async decompress(data, algorithm) {
        const id = Math.random().toString(36);
        return new Promise((resolve, reject)=>{
            this.pendingJobs.set(id, {
                resolve,
                reject
            });
            this.worker.postMessage({
                id,
                action: "decompress",
                data,
                algorithm
            });
        });
    }
    terminate() {
        this.worker.terminate();
        this.pendingJobs.clear();
    }
}
class ProviderMonitoringService {
    recordMetric(providerId, metric) {
        if (!this.metrics.has(providerId)) {
            this.metrics.set(providerId, []);
        }
        const providerMetrics = this.metrics.get(providerId);
        providerMetrics.push(metric);
        // Keep only last 100 metrics
        if (providerMetrics.length > 100) {
            providerMetrics.shift();
        }
        this.checkThresholds(providerId, metric);
    }
    checkThresholds(providerId, metric) {
        const alerts = [];
        if (metric.responseTime > this.thresholds.responseTime) {
            alerts.push({
                id: Math.random().toString(36),
                providerId,
                severity: "warning",
                message: `High response time: ${metric.responseTime}ms`,
                timestamp: new Date(),
                resolved: false
            });
        }
        if (metric.errorRate > this.thresholds.errorRate) {
            alerts.push({
                id: Math.random().toString(36),
                providerId,
                severity: "error",
                message: `High error rate: ${(metric.errorRate * 100).toFixed(2)}%`,
                timestamp: new Date(),
                resolved: false
            });
        }
        if (metric.availability < this.thresholds.availability) {
            alerts.push({
                id: Math.random().toString(36),
                providerId,
                severity: "critical",
                message: `Low availability: ${(metric.availability * 100).toFixed(2)}%`,
                timestamp: new Date(),
                resolved: false
            });
        }
        this.alerts.push(...alerts);
    }
    getMetrics(providerId) {
        return this.metrics.get(providerId) || [];
    }
    getAggregatedMetrics(providerId) {
        const metrics = this.getMetrics(providerId);
        if (metrics.length === 0) return {};
        return {
            responseTime: metrics.reduce((sum, m)=>sum + m.responseTime, 0) / metrics.length,
            successRate: metrics.reduce((sum, m)=>sum + m.successRate, 0) / metrics.length,
            errorRate: metrics.reduce((sum, m)=>sum + m.errorRate, 0) / metrics.length,
            throughput: metrics.reduce((sum, m)=>sum + m.throughput, 0) / metrics.length,
            availability: metrics.reduce((sum, m)=>sum + m.availability, 0) / metrics.length,
            cost: metrics.reduce((sum, m)=>sum + m.cost, 0)
        };
    }
    getAlerts(providerId) {
        return providerId ? this.alerts.filter((alert)=>alert.providerId === providerId) : this.alerts;
    }
    resolveAlert(alertId) {
        const alert = this.alerts.find((a)=>a.id === alertId);
        if (alert) {
            alert.resolved = true;
            return true;
        }
        return false;
    }
    clearResolvedAlerts() {
        this.alerts = this.alerts.filter((alert)=>!alert.resolved);
    }
    constructor(){
        this.metrics = new Map();
        this.alerts = [];
        this.thresholds = {
            responseTime: 1000,
            errorRate: 0.05,
            availability: 0.95
        };
    }
}
class KnowledgeGraphExportService {
    constructor(){
        this.compressionWorker = new CompressionWorker();
    }
    async exportGraph(nodes, edges, options) {
        // Filter nodes and edges
        let filteredNodes = this.filterNodes(nodes, options);
        let filteredEdges = this.filterEdges(edges, options);
        // Generate export data based on format
        let exportData;
        switch(options.format){
            case "json":
                exportData = this.exportToJSON(filteredNodes, filteredEdges, options);
                break;
            case "csv":
                exportData = this.exportToCSV(filteredNodes, filteredEdges, options);
                break;
            case "gexf":
                exportData = this.exportToGEXF(filteredNodes, filteredEdges, options);
                break;
            case "graphml":
                exportData = this.exportToGraphML(filteredNodes, filteredEdges, options);
                break;
            default:
                throw new Error(`Unsupported export format: ${options.format}`);
        }
        // Compress if requested
        if (options.compressed && this.compressionWorker) {
            return await this.compressionWorker.compress(exportData, {
                algorithm: "gzip",
                level: 6,
                chunkSize: 1024 * 1024
            });
        }
        return exportData;
    }
    filterNodes(nodes, options) {
        let filtered = nodes;
        if (options.filterByType) {
            filtered = filtered.filter((node)=>options.filterByType.includes(node.type));
        }
        if (options.filterByConfidence !== undefined) {
            filtered = filtered.filter((node)=>node.metadata.confidence >= options.filterByConfidence);
        }
        return filtered;
    }
    filterEdges(edges, options) {
        return edges; // Simple implementation
    }
    exportToJSON(nodes, edges, options) {
        const data = {
            nodes: options.includeMetadata ? nodes : nodes.map(({ metadata, ...node })=>node),
            edges: edges,
            exportInfo: {
                timestamp: new Date().toISOString(),
                nodeCount: nodes.length,
                edgeCount: edges.length,
                options
            }
        };
        return JSON.stringify(data, null, 2);
    }
    exportToCSV(nodes, edges, options) {
        const nodeHeaders = [
            "id",
            "type",
            "properties"
        ];
        if (options.includeMetadata) {
            nodeHeaders.push("created", "updated", "confidence");
        }
        const edgeHeaders = [
            "id",
            "source",
            "target",
            "type",
            "weight",
            "properties"
        ];
        let csv = "NODES\n";
        csv += nodeHeaders.join(",") + "\n";
        nodes.forEach((node)=>{
            const row = [
                node.id,
                node.type,
                JSON.stringify(node.properties).replace(/"/g, '""')
            ];
            if (options.includeMetadata) {
                row.push(node.metadata.created.toISOString(), node.metadata.updated.toISOString(), node.metadata.confidence.toString());
            }
            csv += row.join(",") + "\n";
        });
        csv += "\nEDGES\n";
        csv += edgeHeaders.join(",") + "\n";
        edges.forEach((edge)=>{
            const row = [
                edge.id,
                edge.source,
                edge.target,
                edge.type,
                edge.weight.toString(),
                JSON.stringify(edge.properties).replace(/"/g, '""')
            ];
            csv += row.join(",") + "\n";
        });
        return csv;
    }
    exportToGEXF(nodes, edges, options) {
        let gexf = '<?xml version="1.0" encoding="UTF-8"?>\n';
        gexf += '<gexf xmlns="http://www.gexf.net/1.2draft" version="1.2">\n';
        gexf += '  <graph mode="static" defaultedgetype="directed">\n';
        // Nodes
        gexf += "    <nodes>\n";
        nodes.forEach((node)=>{
            gexf += `      <node id="${node.id}" label="${node.type}"/>\n`;
        });
        gexf += "    </nodes>\n";
        // Edges
        gexf += "    <edges>\n";
        edges.forEach((edge)=>{
            gexf += `      <edge id="${edge.id}" source="${edge.source}" target="${edge.target}" weight="${edge.weight}"/>\n`;
        });
        gexf += "    </edges>\n";
        gexf += "  </graph>\n";
        gexf += "</gexf>";
        return gexf;
    }
    exportToGraphML(nodes, edges, options) {
        let graphml = '<?xml version="1.0" encoding="UTF-8"?>\n';
        graphml += '<graphml xmlns="http://graphml.graphdrawing.org/xmlns">\n';
        graphml += '  <graph id="knowledge-graph" edgedefault="directed">\n';
        // Nodes
        nodes.forEach((node)=>{
            graphml += `    <node id="${node.id}"/>\n`;
        });
        // Edges
        edges.forEach((edge)=>{
            graphml += `    <edge source="${edge.source}" target="${edge.target}"/>\n`;
        });
        graphml += "  </graph>\n";
        graphml += "</graphml>";
        return graphml;
    }
    terminate() {
        if (this.compressionWorker) {
            this.compressionWorker.terminate();
        }
    }
}
// Storage Service with IndexedDB
class AdvancedStorageService {
    async initialize() {
        return new Promise((resolve, reject)=>{
            const request = indexedDB.open(this.dbName, this.version);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>{
                this.db = request.result;
                resolve();
            };
            request.onupgradeneeded = (event)=>{
                const db = event.target.result;
                // Create object stores
                if (!db.objectStoreNames.contains("agents")) {
                    const agentsStore = db.createObjectStore("agents", {
                        keyPath: "id"
                    });
                    agentsStore.createIndex("type", "type", {
                        unique: false
                    });
                }
                if (!db.objectStoreNames.contains("conversations")) {
                    const conversationsStore = db.createObjectStore("conversations", {
                        keyPath: "id"
                    });
                    conversationsStore.createIndex("timestamp", "timestamp", {
                        unique: false
                    });
                }
                if (!db.objectStoreNames.contains("knowledge")) {
                    const knowledgeStore = db.createObjectStore("knowledge", {
                        keyPath: "id"
                    });
                    knowledgeStore.createIndex("type", "type", {
                        unique: false
                    });
                }
            };
        });
    }
    async store(storeName, data) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.add(data);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve();
        });
    }
    async retrieve(storeName, id) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readonly");
            const store = transaction.objectStore(storeName);
            const request = store.get(id);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve(request.result);
        });
    }
    async retrieveAll(storeName) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readonly");
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve(request.result);
        });
    }
    async update(storeName, data) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.put(data);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve();
        });
    }
    async delete(storeName, id) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.delete(id);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve();
        });
    }
    async clear(storeName) {
        if (!this.db) throw new Error("Database not initialized");
        return new Promise((resolve, reject)=>{
            const transaction = this.db.transaction([
                storeName
            ], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.clear();
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve();
        });
    }
    constructor(){
        this.dbName = "FreeAgenticsDB";
        this.version = 1;
    }
}
// Tests
describe("Specialized Services", ()=>{
    describe("CompressionWorker", ()=>{
        let compressionWorker;
        beforeEach(()=>{
            compressionWorker = new CompressionWorker();
        });
        afterEach(()=>{
            compressionWorker.terminate();
        });
        test("should create worker instance", ()=>{
            expect(compressionWorker).toBeDefined();
            expect(Worker).toHaveBeenCalledWith("/workers/compression.js");
        });
        test("should compress data", async ()=>{
            const testData = "Hello, World!";
            const options = {
                algorithm: "gzip",
                level: 6,
                chunkSize: 1024
            };
            // Mock successful compression
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: new ArrayBuffer(8)
                    }
                });
            }, 10);
            const result = await compressionWorker.compress(testData, options);
            expect(result).toBeInstanceOf(ArrayBuffer);
        });
        test("should decompress data", async ()=>{
            const testData = new ArrayBuffer(8);
            const algorithm = "gzip";
            // Mock successful decompression
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: "Hello, World!"
                    }
                });
            }, 10);
            const result = await compressionWorker.decompress(testData, algorithm);
            expect(result).toBe("Hello, World!");
        });
        test("should handle compression errors", async ()=>{
            const testData = "Hello, World!";
            const options = {
                algorithm: "gzip",
                level: 6,
                chunkSize: 1024
            };
            // Mock compression error
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        error: "Compression failed"
                    }
                });
            }, 10);
            await expect(compressionWorker.compress(testData, options)).rejects.toThrow("Compression failed");
        });
        test("should handle worker errors", ()=>{
            const mockWorker = Worker.mock.results[0].value;
            const errorEvent = new ErrorEvent("error", {
                message: "Worker crashed"
            });
            expect(()=>{
                mockWorker.onerror(errorEvent);
            }).not.toThrow();
        });
    });
    describe("ProviderMonitoringService", ()=>{
        let monitoringService;
        beforeEach(()=>{
            monitoringService = new ProviderMonitoringService();
        });
        test("should record metrics", ()=>{
            const metric = {
                responseTime: 500,
                successRate: 0.95,
                errorRate: 0.05,
                throughput: 100,
                availability: 0.99,
                cost: 0.001
            };
            monitoringService.recordMetric("provider1", metric);
            const metrics = monitoringService.getMetrics("provider1");
            expect(metrics).toHaveLength(1);
            expect(metrics[0]).toEqual(metric);
        });
        test("should generate alerts for threshold violations", ()=>{
            const highLatencyMetric = {
                responseTime: 2000,
                successRate: 0.95,
                errorRate: 0.05,
                throughput: 100,
                availability: 0.99,
                cost: 0.001
            };
            monitoringService.recordMetric("provider1", highLatencyMetric);
            const alerts = monitoringService.getAlerts("provider1");
            expect(alerts).toHaveLength(1);
            expect(alerts[0].severity).toBe("warning");
            expect(alerts[0].message).toContain("High response time");
        });
        test("should calculate aggregated metrics", ()=>{
            const metrics = [
                {
                    responseTime: 400,
                    successRate: 0.95,
                    errorRate: 0.05,
                    throughput: 100,
                    availability: 0.99,
                    cost: 0.001
                },
                {
                    responseTime: 600,
                    successRate: 0.98,
                    errorRate: 0.02,
                    throughput: 120,
                    availability: 0.97,
                    cost: 0.002
                }
            ];
            metrics.forEach((metric)=>{
                monitoringService.recordMetric("provider1", metric);
            });
            const aggregated = monitoringService.getAggregatedMetrics("provider1");
            expect(aggregated.responseTime).toBe(500); // Average
            expect(aggregated.successRate).toBeCloseTo(0.965, 3);
            expect(aggregated.cost).toBe(0.003); // Sum
        });
        test("should resolve alerts", ()=>{
            const metric = {
                responseTime: 2000,
                successRate: 0.95,
                errorRate: 0.1,
                throughput: 100,
                availability: 0.9,
                cost: 0.001
            };
            monitoringService.recordMetric("provider1", metric);
            const alerts = monitoringService.getAlerts("provider1");
            expect(alerts.length).toBeGreaterThan(0);
            const alertId = alerts[0].id;
            const resolved = monitoringService.resolveAlert(alertId);
            expect(resolved).toBe(true);
            expect(alerts[0].resolved).toBe(true);
        });
        test("should clear resolved alerts", ()=>{
            const metric = {
                responseTime: 2000,
                successRate: 0.95,
                errorRate: 0.1,
                throughput: 100,
                availability: 0.9,
                cost: 0.001
            };
            monitoringService.recordMetric("provider1", metric);
            const alerts = monitoringService.getAlerts();
            // Resolve all alerts
            alerts.forEach((alert)=>{
                monitoringService.resolveAlert(alert.id);
            });
            monitoringService.clearResolvedAlerts();
            const remainingAlerts = monitoringService.getAlerts();
            expect(remainingAlerts).toHaveLength(0);
        });
    });
    describe("KnowledgeGraphExportService", ()=>{
        let exportService;
        let mockNodes;
        let mockEdges;
        beforeEach(()=>{
            exportService = new KnowledgeGraphExportService();
            mockNodes = [
                {
                    id: "node1",
                    type: "agent",
                    properties: {
                        name: "Agent 1"
                    },
                    metadata: {
                        created: new Date("2023-01-01"),
                        updated: new Date("2023-01-02"),
                        confidence: 0.9
                    }
                },
                {
                    id: "node2",
                    type: "concept",
                    properties: {
                        name: "Concept 1"
                    },
                    metadata: {
                        created: new Date("2023-01-01"),
                        updated: new Date("2023-01-02"),
                        confidence: 0.8
                    }
                }
            ];
            mockEdges = [
                {
                    id: "edge1",
                    source: "node1",
                    target: "node2",
                    type: "knows",
                    weight: 0.7,
                    properties: {
                        strength: "strong"
                    }
                }
            ];
        });
        afterEach(()=>{
            exportService.terminate();
        });
        test("should export to JSON format", async ()=>{
            const options = {
                format: "json",
                includeMetadata: true
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(typeof result).toBe("string");
            const parsed = JSON.parse(result);
            expect(parsed.nodes).toHaveLength(2);
            expect(parsed.edges).toHaveLength(1);
            expect(parsed.nodes[0].metadata).toBeDefined();
        });
        test("should export to CSV format", async ()=>{
            const options = {
                format: "csv",
                includeMetadata: false
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(typeof result).toBe("string");
            expect(result).toContain("NODES");
            expect(result).toContain("EDGES");
            expect(result).toContain("node1,agent");
        });
        test("should export to GEXF format", async ()=>{
            const options = {
                format: "gexf",
                includeMetadata: false
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(typeof result).toBe("string");
            expect(result).toContain('<?xml version="1.0"');
            expect(result).toContain("<gexf xmlns=");
            expect(result).toContain('<node id="node1"');
        });
        test("should export to GraphML format", async ()=>{
            const options = {
                format: "graphml",
                includeMetadata: false
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(typeof result).toBe("string");
            expect(result).toContain('<?xml version="1.0"');
            expect(result).toContain("<graphml xmlns=");
            expect(result).toContain('<node id="node1"');
        });
        test("should filter by node type", async ()=>{
            const options = {
                format: "json",
                includeMetadata: false,
                filterByType: [
                    "agent"
                ]
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            const parsed = JSON.parse(result);
            expect(parsed.nodes).toHaveLength(1);
            expect(parsed.nodes[0].type).toBe("agent");
        });
        test("should filter by confidence", async ()=>{
            const options = {
                format: "json",
                includeMetadata: true,
                filterByConfidence: 0.85
            };
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            const parsed = JSON.parse(result);
            expect(parsed.nodes).toHaveLength(1);
            expect(parsed.nodes[0].metadata.confidence).toBeGreaterThanOrEqual(0.85);
        });
        test("should handle compression", async ()=>{
            const options = {
                format: "json",
                includeMetadata: true,
                compressed: true
            };
            // Mock compression worker
            const mockWorker = Worker.mock.results[0].value;
            setTimeout(()=>{
                mockWorker.onmessage({
                    data: {
                        id: expect.any(String),
                        result: new ArrayBuffer(100)
                    }
                });
            }, 10);
            const result = await exportService.exportGraph(mockNodes, mockEdges, options);
            expect(result).toBeInstanceOf(ArrayBuffer);
        });
        test("should handle unsupported format", async ()=>{
            const options = {
                format: "unsupported",
                includeMetadata: false
            };
            await expect(exportService.exportGraph(mockNodes, mockEdges, options)).rejects.toThrow("Unsupported export format");
        });
    });
    describe("AdvancedStorageService", ()=>{
        let storageService;
        beforeEach(async ()=>{
            storageService = new AdvancedStorageService();
            // Mock successful initialization
            const mockRequest = {
                onsuccess: null,
                onerror: null,
                onupgradeneeded: null,
                result: {
                    objectStoreNames: {
                        contains: _globals.jest.fn(()=>false)
                    },
                    createObjectStore: _globals.jest.fn(()=>({
                            createIndex: _globals.jest.fn()
                        })),
                    transaction: _globals.jest.fn(()=>({
                            objectStore: _globals.jest.fn(()=>({
                                    add: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    get: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    getAll: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    put: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    delete: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        })),
                                    clear: _globals.jest.fn(()=>({
                                            onsuccess: null,
                                            onerror: null
                                        }))
                                }))
                        }))
                }
            };
            global.indexedDB.open.mockReturnValue(mockRequest);
            // Simulate successful initialization
            setTimeout(()=>{
                if (mockRequest.onsuccess) {
                    mockRequest.onsuccess();
                }
            }, 0);
            await storageService.initialize();
        });
        test("should initialize database", async ()=>{
            expect(global.indexedDB.open).toHaveBeenCalledWith("FreeAgenticsDB", 1);
        });
        test("should store data", async ()=>{
            const testData = {
                id: "test1",
                name: "Test Agent"
            };
            // Mock successful store operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        add: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            await expect(storageService.store("agents", testData)).resolves.toBeUndefined();
        });
        test("should retrieve data", async ()=>{
            const testId = "test1";
            const expectedData = {
                id: "test1",
                name: "Test Agent"
            };
            // Mock successful retrieve operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        get: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null,
                                result: expectedData
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            const result = await storageService.retrieve("agents", testId);
            expect(result).toEqual(expectedData);
        });
        test("should retrieve all data", async ()=>{
            const expectedData = [
                {
                    id: "test1",
                    name: "Test Agent 1"
                },
                {
                    id: "test2",
                    name: "Test Agent 2"
                }
            ];
            // Mock successful retrieveAll operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        getAll: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null,
                                result: expectedData
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            const result = await storageService.retrieveAll("agents");
            expect(result).toEqual(expectedData);
        });
        test("should update data", async ()=>{
            const testData = {
                id: "test1",
                name: "Updated Agent"
            };
            // Mock successful update operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        put: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            await expect(storageService.update("agents", testData)).resolves.toBeUndefined();
        });
        test("should delete data", async ()=>{
            const testId = "test1";
            // Mock successful delete operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        delete: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            await expect(storageService.delete("agents", testId)).resolves.toBeUndefined();
        });
        test("should clear store", async ()=>{
            // Mock successful clear operation
            const mockTransaction = {
                objectStore: _globals.jest.fn(()=>({
                        clear: _globals.jest.fn(()=>{
                            const request = {
                                onsuccess: null,
                                onerror: null
                            };
                            setTimeout(()=>{
                                if (request.onsuccess) request.onsuccess();
                            }, 0);
                            return request;
                        })
                    }))
            };
            storageService.db = {
                transaction: _globals.jest.fn(()=>mockTransaction)
            };
            await expect(storageService.clear("agents")).resolves.toBeUndefined();
        });
        test("should handle database not initialized error", async ()=>{
            const uninitializedService = new AdvancedStorageService();
            await expect(uninitializedService.store("agents", {})).rejects.toThrow("Database not initialized");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vc2VydmljZXMvc3BlY2lhbGl6ZWQtc2VydmljZXMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNwZWNpYWxpemVkIFNlcnZpY2VzIFRlc3RzXG4gKlxuICogVGVzdHMgZm9yIGNvbXByZXNzaW9uIHdvcmtlcnMsIHByb3ZpZGVyIG1vbml0b3JpbmcsIGtub3dsZWRnZSBncmFwaCB1dGlsaXRpZXMsXG4gKiBhbmQgb3RoZXIgc3BlY2lhbGl6ZWQgc2VydmljZSBjb21wb25lbnRzIGZvbGxvd2luZyBBRFItMDA3IHJlcXVpcmVtZW50cy5cbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSBcIkBqZXN0L2dsb2JhbHNcIjtcblxuLy8gTW9jayBXb3JrZXIgZm9yIGNvbXByZXNzaW9uIHNlcnZpY2Vcbmdsb2JhbC5Xb3JrZXIgPSBqZXN0LmZuKCgpID0+ICh7XG4gIHBvc3RNZXNzYWdlOiBqZXN0LmZuKCksXG4gIHRlcm1pbmF0ZTogamVzdC5mbigpLFxuICBvbm1lc3NhZ2U6IG51bGwsXG4gIG9uZXJyb3I6IG51bGwsXG59KSkgYXMgYW55O1xuXG4vLyBNb2NrIEluZGV4ZWREQiBmb3Igc3RvcmFnZSBzZXJ2aWNlc1xuZ2xvYmFsLmluZGV4ZWREQiA9IHtcbiAgb3BlbjogamVzdC5mbigoKSA9PiAoe1xuICAgIG9uc3VjY2VzczogbnVsbCxcbiAgICBvbmVycm9yOiBudWxsLFxuICAgIG9udXBncmFkZW5lZWRlZDogbnVsbCxcbiAgICByZXN1bHQ6IHtcbiAgICAgIGNyZWF0ZU9iamVjdFN0b3JlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIGNyZWF0ZUluZGV4OiBqZXN0LmZuKCksXG4gICAgICB9KSksXG4gICAgICB0cmFuc2FjdGlvbjogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGFkZDogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgIGdldDogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgIGRlbGV0ZTogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgIHB1dDogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgIGdldEFsbDogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgIGNsZWFyOiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgIH0pKSxcbiAgICAgIH0pKSxcbiAgICB9LFxuICB9KSksXG4gIGRlbGV0ZURhdGFiYXNlOiBqZXN0LmZuKCksXG59IGFzIGFueTtcblxuLy8gQ29tcHJlc3Npb24gV29ya2VyIFNlcnZpY2VcbmludGVyZmFjZSBDb21wcmVzc2lvbk9wdGlvbnMge1xuICBhbGdvcml0aG06IFwiZ3ppcFwiIHwgXCJkZWZsYXRlXCIgfCBcImJyb3RsaVwiO1xuICBsZXZlbDogbnVtYmVyO1xuICBjaHVua1NpemU6IG51bWJlcjtcbn1cblxuY2xhc3MgQ29tcHJlc3Npb25Xb3JrZXIge1xuICBwcml2YXRlIHdvcmtlcjogV29ya2VyO1xuICBwcml2YXRlIHBlbmRpbmdKb2JzOiBNYXA8c3RyaW5nLCB7IHJlc29sdmU6IEZ1bmN0aW9uOyByZWplY3Q6IEZ1bmN0aW9uIH0+ID1cbiAgICBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKFwiL3dvcmtlcnMvY29tcHJlc3Npb24uanNcIik7XG4gICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy53b3JrZXIub25lcnJvciA9IHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTWVzc2FnZShldmVudDogTWVzc2FnZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgeyBpZCwgcmVzdWx0LCBlcnJvciB9ID0gZXZlbnQuZGF0YTtcbiAgICBjb25zdCBqb2IgPSB0aGlzLnBlbmRpbmdKb2JzLmdldChpZCk7XG5cbiAgICBpZiAoam9iKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgam9iLnJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvYi5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdKb2JzLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogRXJyb3JFdmVudCk6IHZvaWQge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJDb21wcmVzc2lvbiB3b3JrZXIgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAvLyBSZWplY3QgYWxsIHBlbmRpbmcgam9ic1xuICAgIHRoaXMucGVuZGluZ0pvYnMuZm9yRWFjaCgoeyByZWplY3QgfSkgPT4gcmVqZWN0KGVycm9yKSk7XG4gICAgdGhpcy5wZW5kaW5nSm9icy5jbGVhcigpO1xuICB9XG5cbiAgYXN5bmMgY29tcHJlc3MoXG4gICAgZGF0YTogc3RyaW5nIHwgQXJyYXlCdWZmZXIsXG4gICAgb3B0aW9uczogQ29tcHJlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgY29uc3QgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdKb2JzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkLFxuICAgICAgICBhY3Rpb246IFwiY29tcHJlc3NcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZGVjb21wcmVzcyhkYXRhOiBBcnJheUJ1ZmZlciwgYWxnb3JpdGhtOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nSm9icy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZCxcbiAgICAgICAgYWN0aW9uOiBcImRlY29tcHJlc3NcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgYWxnb3JpdGhtLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB0ZXJtaW5hdGUoKTogdm9pZCB7XG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy5wZW5kaW5nSm9icy5jbGVhcigpO1xuICB9XG59XG5cbi8vIFByb3ZpZGVyIE1vbml0b3JpbmcgU2VydmljZVxuaW50ZXJmYWNlIFByb3ZpZGVyTWV0cmljcyB7XG4gIHJlc3BvbnNlVGltZTogbnVtYmVyO1xuICBzdWNjZXNzUmF0ZTogbnVtYmVyO1xuICBlcnJvclJhdGU6IG51bWJlcjtcbiAgdGhyb3VnaHB1dDogbnVtYmVyO1xuICBhdmFpbGFiaWxpdHk6IG51bWJlcjtcbiAgY29zdDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgUHJvdmlkZXJBbGVydCB7XG4gIGlkOiBzdHJpbmc7XG4gIHByb3ZpZGVySWQ6IHN0cmluZztcbiAgc2V2ZXJpdHk6IFwiaW5mb1wiIHwgXCJ3YXJuaW5nXCIgfCBcImVycm9yXCIgfCBcImNyaXRpY2FsXCI7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgdGltZXN0YW1wOiBEYXRlO1xuICByZXNvbHZlZDogYm9vbGVhbjtcbn1cblxuY2xhc3MgUHJvdmlkZXJNb25pdG9yaW5nU2VydmljZSB7XG4gIHByaXZhdGUgbWV0cmljczogTWFwPHN0cmluZywgUHJvdmlkZXJNZXRyaWNzW10+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGFsZXJ0czogUHJvdmlkZXJBbGVydFtdID0gW107XG4gIHByaXZhdGUgdGhyZXNob2xkcyA9IHtcbiAgICByZXNwb25zZVRpbWU6IDEwMDAsXG4gICAgZXJyb3JSYXRlOiAwLjA1LFxuICAgIGF2YWlsYWJpbGl0eTogMC45NSxcbiAgfTtcblxuICByZWNvcmRNZXRyaWMocHJvdmlkZXJJZDogc3RyaW5nLCBtZXRyaWM6IFByb3ZpZGVyTWV0cmljcyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5tZXRyaWNzLmhhcyhwcm92aWRlcklkKSkge1xuICAgICAgdGhpcy5tZXRyaWNzLnNldChwcm92aWRlcklkLCBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdmlkZXJNZXRyaWNzID0gdGhpcy5tZXRyaWNzLmdldChwcm92aWRlcklkKSE7XG4gICAgcHJvdmlkZXJNZXRyaWNzLnB1c2gobWV0cmljKTtcblxuICAgIC8vIEtlZXAgb25seSBsYXN0IDEwMCBtZXRyaWNzXG4gICAgaWYgKHByb3ZpZGVyTWV0cmljcy5sZW5ndGggPiAxMDApIHtcbiAgICAgIHByb3ZpZGVyTWV0cmljcy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tUaHJlc2hvbGRzKHByb3ZpZGVySWQsIG1ldHJpYyk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrVGhyZXNob2xkcyhwcm92aWRlcklkOiBzdHJpbmcsIG1ldHJpYzogUHJvdmlkZXJNZXRyaWNzKTogdm9pZCB7XG4gICAgY29uc3QgYWxlcnRzOiBQcm92aWRlckFsZXJ0W10gPSBbXTtcblxuICAgIGlmIChtZXRyaWMucmVzcG9uc2VUaW1lID4gdGhpcy50aHJlc2hvbGRzLnJlc3BvbnNlVGltZSkge1xuICAgICAgYWxlcnRzLnB1c2goe1xuICAgICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNiksXG4gICAgICAgIHByb3ZpZGVySWQsXG4gICAgICAgIHNldmVyaXR5OiBcIndhcm5pbmdcIixcbiAgICAgICAgbWVzc2FnZTogYEhpZ2ggcmVzcG9uc2UgdGltZTogJHttZXRyaWMucmVzcG9uc2VUaW1lfW1zYCxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICByZXNvbHZlZDogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWV0cmljLmVycm9yUmF0ZSA+IHRoaXMudGhyZXNob2xkcy5lcnJvclJhdGUpIHtcbiAgICAgIGFsZXJ0cy5wdXNoKHtcbiAgICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLFxuICAgICAgICBwcm92aWRlcklkLFxuICAgICAgICBzZXZlcml0eTogXCJlcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBgSGlnaCBlcnJvciByYXRlOiAkeyhtZXRyaWMuZXJyb3JSYXRlICogMTAwKS50b0ZpeGVkKDIpfSVgLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXRyaWMuYXZhaWxhYmlsaXR5IDwgdGhpcy50aHJlc2hvbGRzLmF2YWlsYWJpbGl0eSkge1xuICAgICAgYWxlcnRzLnB1c2goe1xuICAgICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNiksXG4gICAgICAgIHByb3ZpZGVySWQsXG4gICAgICAgIHNldmVyaXR5OiBcImNyaXRpY2FsXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBMb3cgYXZhaWxhYmlsaXR5OiAkeyhtZXRyaWMuYXZhaWxhYmlsaXR5ICogMTAwKS50b0ZpeGVkKDIpfSVgLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYWxlcnRzLnB1c2goLi4uYWxlcnRzKTtcbiAgfVxuXG4gIGdldE1ldHJpY3MocHJvdmlkZXJJZDogc3RyaW5nKTogUHJvdmlkZXJNZXRyaWNzW10ge1xuICAgIHJldHVybiB0aGlzLm1ldHJpY3MuZ2V0KHByb3ZpZGVySWQpIHx8IFtdO1xuICB9XG5cbiAgZ2V0QWdncmVnYXRlZE1ldHJpY3MocHJvdmlkZXJJZDogc3RyaW5nKTogUGFydGlhbDxQcm92aWRlck1ldHJpY3M+IHtcbiAgICBjb25zdCBtZXRyaWNzID0gdGhpcy5nZXRNZXRyaWNzKHByb3ZpZGVySWQpO1xuICAgIGlmIChtZXRyaWNzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlVGltZTpcbiAgICAgICAgbWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5yZXNwb25zZVRpbWUsIDApIC8gbWV0cmljcy5sZW5ndGgsXG4gICAgICBzdWNjZXNzUmF0ZTpcbiAgICAgICAgbWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5zdWNjZXNzUmF0ZSwgMCkgLyBtZXRyaWNzLmxlbmd0aCxcbiAgICAgIGVycm9yUmF0ZTpcbiAgICAgICAgbWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5lcnJvclJhdGUsIDApIC8gbWV0cmljcy5sZW5ndGgsXG4gICAgICB0aHJvdWdocHV0OlxuICAgICAgICBtZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLnRocm91Z2hwdXQsIDApIC8gbWV0cmljcy5sZW5ndGgsXG4gICAgICBhdmFpbGFiaWxpdHk6XG4gICAgICAgIG1ldHJpY3MucmVkdWNlKChzdW0sIG0pID0+IHN1bSArIG0uYXZhaWxhYmlsaXR5LCAwKSAvIG1ldHJpY3MubGVuZ3RoLFxuICAgICAgY29zdDogbWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5jb3N0LCAwKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0QWxlcnRzKHByb3ZpZGVySWQ/OiBzdHJpbmcpOiBQcm92aWRlckFsZXJ0W10ge1xuICAgIHJldHVybiBwcm92aWRlcklkXG4gICAgICA/IHRoaXMuYWxlcnRzLmZpbHRlcigoYWxlcnQpID0+IGFsZXJ0LnByb3ZpZGVySWQgPT09IHByb3ZpZGVySWQpXG4gICAgICA6IHRoaXMuYWxlcnRzO1xuICB9XG5cbiAgcmVzb2x2ZUFsZXJ0KGFsZXJ0SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGFsZXJ0ID0gdGhpcy5hbGVydHMuZmluZCgoYSkgPT4gYS5pZCA9PT0gYWxlcnRJZCk7XG4gICAgaWYgKGFsZXJ0KSB7XG4gICAgICBhbGVydC5yZXNvbHZlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2xlYXJSZXNvbHZlZEFsZXJ0cygpOiB2b2lkIHtcbiAgICB0aGlzLmFsZXJ0cyA9IHRoaXMuYWxlcnRzLmZpbHRlcigoYWxlcnQpID0+ICFhbGVydC5yZXNvbHZlZCk7XG4gIH1cbn1cblxuLy8gS25vd2xlZGdlIEdyYXBoIEV4cG9ydCBTZXJ2aWNlXG5pbnRlcmZhY2UgS25vd2xlZGdlTm9kZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgbWV0YWRhdGE6IHtcbiAgICBjcmVhdGVkOiBEYXRlO1xuICAgIHVwZGF0ZWQ6IERhdGU7XG4gICAgY29uZmlkZW5jZTogbnVtYmVyO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgS25vd2xlZGdlRWRnZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHNvdXJjZTogc3RyaW5nO1xuICB0YXJnZXQ6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICB3ZWlnaHQ6IG51bWJlcjtcbiAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuaW50ZXJmYWNlIEV4cG9ydE9wdGlvbnMge1xuICBmb3JtYXQ6IFwianNvblwiIHwgXCJjc3ZcIiB8IFwiZ2V4ZlwiIHwgXCJncmFwaG1sXCI7XG4gIGluY2x1ZGVNZXRhZGF0YTogYm9vbGVhbjtcbiAgZmlsdGVyQnlUeXBlPzogc3RyaW5nW107XG4gIGZpbHRlckJ5Q29uZmlkZW5jZT86IG51bWJlcjtcbiAgY29tcHJlc3NlZD86IGJvb2xlYW47XG59XG5cbmNsYXNzIEtub3dsZWRnZUdyYXBoRXhwb3J0U2VydmljZSB7XG4gIHByaXZhdGUgY29tcHJlc3Npb25Xb3JrZXI/OiBDb21wcmVzc2lvbldvcmtlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbXByZXNzaW9uV29ya2VyID0gbmV3IENvbXByZXNzaW9uV29ya2VyKCk7XG4gIH1cblxuICBhc3luYyBleHBvcnRHcmFwaChcbiAgICBub2RlczogS25vd2xlZGdlTm9kZVtdLFxuICAgIGVkZ2VzOiBLbm93bGVkZ2VFZGdlW10sXG4gICAgb3B0aW9uczogRXhwb3J0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxzdHJpbmcgfCBBcnJheUJ1ZmZlcj4ge1xuICAgIC8vIEZpbHRlciBub2RlcyBhbmQgZWRnZXNcbiAgICBsZXQgZmlsdGVyZWROb2RlcyA9IHRoaXMuZmlsdGVyTm9kZXMobm9kZXMsIG9wdGlvbnMpO1xuICAgIGxldCBmaWx0ZXJlZEVkZ2VzID0gdGhpcy5maWx0ZXJFZGdlcyhlZGdlcywgb3B0aW9ucyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBleHBvcnQgZGF0YSBiYXNlZCBvbiBmb3JtYXRcbiAgICBsZXQgZXhwb3J0RGF0YTogc3RyaW5nO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLmZvcm1hdCkge1xuICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgZXhwb3J0RGF0YSA9IHRoaXMuZXhwb3J0VG9KU09OKGZpbHRlcmVkTm9kZXMsIGZpbHRlcmVkRWRnZXMsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjc3ZcIjpcbiAgICAgICAgZXhwb3J0RGF0YSA9IHRoaXMuZXhwb3J0VG9DU1YoZmlsdGVyZWROb2RlcywgZmlsdGVyZWRFZGdlcywgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImdleGZcIjpcbiAgICAgICAgZXhwb3J0RGF0YSA9IHRoaXMuZXhwb3J0VG9HRVhGKGZpbHRlcmVkTm9kZXMsIGZpbHRlcmVkRWRnZXMsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJncmFwaG1sXCI6XG4gICAgICAgIGV4cG9ydERhdGEgPSB0aGlzLmV4cG9ydFRvR3JhcGhNTChcbiAgICAgICAgICBmaWx0ZXJlZE5vZGVzLFxuICAgICAgICAgIGZpbHRlcmVkRWRnZXMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGV4cG9ydCBmb3JtYXQ6ICR7b3B0aW9ucy5mb3JtYXR9YCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHJlc3MgaWYgcmVxdWVzdGVkXG4gICAgaWYgKG9wdGlvbnMuY29tcHJlc3NlZCAmJiB0aGlzLmNvbXByZXNzaW9uV29ya2VyKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb21wcmVzc2lvbldvcmtlci5jb21wcmVzcyhleHBvcnREYXRhLCB7XG4gICAgICAgIGFsZ29yaXRobTogXCJnemlwXCIsXG4gICAgICAgIGxldmVsOiA2LFxuICAgICAgICBjaHVua1NpemU6IDEwMjQgKiAxMDI0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydERhdGE7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlck5vZGVzKFxuICAgIG5vZGVzOiBLbm93bGVkZ2VOb2RlW10sXG4gICAgb3B0aW9uczogRXhwb3J0T3B0aW9ucyxcbiAgKTogS25vd2xlZGdlTm9kZVtdIHtcbiAgICBsZXQgZmlsdGVyZWQgPSBub2RlcztcblxuICAgIGlmIChvcHRpb25zLmZpbHRlckJ5VHlwZSkge1xuICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKG5vZGUpID0+XG4gICAgICAgIG9wdGlvbnMuZmlsdGVyQnlUeXBlIS5pbmNsdWRlcyhub2RlLnR5cGUpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maWx0ZXJCeUNvbmZpZGVuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoXG4gICAgICAgIChub2RlKSA9PiBub2RlLm1ldGFkYXRhLmNvbmZpZGVuY2UgPj0gb3B0aW9ucy5maWx0ZXJCeUNvbmZpZGVuY2UhLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVyZWQ7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlckVkZ2VzKFxuICAgIGVkZ2VzOiBLbm93bGVkZ2VFZGdlW10sXG4gICAgb3B0aW9uczogRXhwb3J0T3B0aW9ucyxcbiAgKTogS25vd2xlZGdlRWRnZVtdIHtcbiAgICByZXR1cm4gZWRnZXM7IC8vIFNpbXBsZSBpbXBsZW1lbnRhdGlvblxuICB9XG5cbiAgcHJpdmF0ZSBleHBvcnRUb0pTT04oXG4gICAgbm9kZXM6IEtub3dsZWRnZU5vZGVbXSxcbiAgICBlZGdlczogS25vd2xlZGdlRWRnZVtdLFxuICAgIG9wdGlvbnM6IEV4cG9ydE9wdGlvbnMsXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG5vZGVzOiBvcHRpb25zLmluY2x1ZGVNZXRhZGF0YVxuICAgICAgICA/IG5vZGVzXG4gICAgICAgIDogbm9kZXMubWFwKCh7IG1ldGFkYXRhLCAuLi5ub2RlIH0pID0+IG5vZGUpLFxuICAgICAgZWRnZXM6IGVkZ2VzLFxuICAgICAgZXhwb3J0SW5mbzoge1xuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbm9kZUNvdW50OiBub2Rlcy5sZW5ndGgsXG4gICAgICAgIGVkZ2VDb3VudDogZWRnZXMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICB9XG5cbiAgcHJpdmF0ZSBleHBvcnRUb0NTVihcbiAgICBub2RlczogS25vd2xlZGdlTm9kZVtdLFxuICAgIGVkZ2VzOiBLbm93bGVkZ2VFZGdlW10sXG4gICAgb3B0aW9uczogRXhwb3J0T3B0aW9ucyxcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCBub2RlSGVhZGVycyA9IFtcImlkXCIsIFwidHlwZVwiLCBcInByb3BlcnRpZXNcIl07XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhKSB7XG4gICAgICBub2RlSGVhZGVycy5wdXNoKFwiY3JlYXRlZFwiLCBcInVwZGF0ZWRcIiwgXCJjb25maWRlbmNlXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGVkZ2VIZWFkZXJzID0gW1xuICAgICAgXCJpZFwiLFxuICAgICAgXCJzb3VyY2VcIixcbiAgICAgIFwidGFyZ2V0XCIsXG4gICAgICBcInR5cGVcIixcbiAgICAgIFwid2VpZ2h0XCIsXG4gICAgICBcInByb3BlcnRpZXNcIixcbiAgICBdO1xuXG4gICAgbGV0IGNzdiA9IFwiTk9ERVNcXG5cIjtcbiAgICBjc3YgKz0gbm9kZUhlYWRlcnMuam9pbihcIixcIikgKyBcIlxcblwiO1xuXG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgY29uc3Qgcm93ID0gW1xuICAgICAgICBub2RlLmlkLFxuICAgICAgICBub2RlLnR5cGUsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KG5vZGUucHJvcGVydGllcykucmVwbGFjZSgvXCIvZywgJ1wiXCInKSxcbiAgICAgIF07XG5cbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVNZXRhZGF0YSkge1xuICAgICAgICByb3cucHVzaChcbiAgICAgICAgICBub2RlLm1ldGFkYXRhLmNyZWF0ZWQudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBub2RlLm1ldGFkYXRhLnVwZGF0ZWQudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBub2RlLm1ldGFkYXRhLmNvbmZpZGVuY2UudG9TdHJpbmcoKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY3N2ICs9IHJvdy5qb2luKFwiLFwiKSArIFwiXFxuXCI7XG4gICAgfSk7XG5cbiAgICBjc3YgKz0gXCJcXG5FREdFU1xcblwiO1xuICAgIGNzdiArPSBlZGdlSGVhZGVycy5qb2luKFwiLFwiKSArIFwiXFxuXCI7XG5cbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICBjb25zdCByb3cgPSBbXG4gICAgICAgIGVkZ2UuaWQsXG4gICAgICAgIGVkZ2Uuc291cmNlLFxuICAgICAgICBlZGdlLnRhcmdldCxcbiAgICAgICAgZWRnZS50eXBlLFxuICAgICAgICBlZGdlLndlaWdodC50b1N0cmluZygpLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShlZGdlLnByb3BlcnRpZXMpLnJlcGxhY2UoL1wiL2csICdcIlwiJyksXG4gICAgICBdO1xuXG4gICAgICBjc3YgKz0gcm93LmpvaW4oXCIsXCIpICsgXCJcXG5cIjtcbiAgICB9KTtcblxuICAgIHJldHVybiBjc3Y7XG4gIH1cblxuICBwcml2YXRlIGV4cG9ydFRvR0VYRihcbiAgICBub2RlczogS25vd2xlZGdlTm9kZVtdLFxuICAgIGVkZ2VzOiBLbm93bGVkZ2VFZGdlW10sXG4gICAgb3B0aW9uczogRXhwb3J0T3B0aW9ucyxcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgZ2V4ZiA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG4nO1xuICAgIGdleGYgKz0gJzxnZXhmIHhtbG5zPVwiaHR0cDovL3d3dy5nZXhmLm5ldC8xLjJkcmFmdFwiIHZlcnNpb249XCIxLjJcIj5cXG4nO1xuICAgIGdleGYgKz0gJyAgPGdyYXBoIG1vZGU9XCJzdGF0aWNcIiBkZWZhdWx0ZWRnZXR5cGU9XCJkaXJlY3RlZFwiPlxcbic7XG5cbiAgICAvLyBOb2Rlc1xuICAgIGdleGYgKz0gXCIgICAgPG5vZGVzPlxcblwiO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGdleGYgKz0gYCAgICAgIDxub2RlIGlkPVwiJHtub2RlLmlkfVwiIGxhYmVsPVwiJHtub2RlLnR5cGV9XCIvPlxcbmA7XG4gICAgfSk7XG4gICAgZ2V4ZiArPSBcIiAgICA8L25vZGVzPlxcblwiO1xuXG4gICAgLy8gRWRnZXNcbiAgICBnZXhmICs9IFwiICAgIDxlZGdlcz5cXG5cIjtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICBnZXhmICs9IGAgICAgICA8ZWRnZSBpZD1cIiR7ZWRnZS5pZH1cIiBzb3VyY2U9XCIke2VkZ2Uuc291cmNlfVwiIHRhcmdldD1cIiR7ZWRnZS50YXJnZXR9XCIgd2VpZ2h0PVwiJHtlZGdlLndlaWdodH1cIi8+XFxuYDtcbiAgICB9KTtcbiAgICBnZXhmICs9IFwiICAgIDwvZWRnZXM+XFxuXCI7XG5cbiAgICBnZXhmICs9IFwiICA8L2dyYXBoPlxcblwiO1xuICAgIGdleGYgKz0gXCI8L2dleGY+XCI7XG5cbiAgICByZXR1cm4gZ2V4ZjtcbiAgfVxuXG4gIHByaXZhdGUgZXhwb3J0VG9HcmFwaE1MKFxuICAgIG5vZGVzOiBLbm93bGVkZ2VOb2RlW10sXG4gICAgZWRnZXM6IEtub3dsZWRnZUVkZ2VbXSxcbiAgICBvcHRpb25zOiBFeHBvcnRPcHRpb25zLFxuICApOiBzdHJpbmcge1xuICAgIGxldCBncmFwaG1sID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/Plxcbic7XG4gICAgZ3JhcGhtbCArPSAnPGdyYXBobWwgeG1sbnM9XCJodHRwOi8vZ3JhcGhtbC5ncmFwaGRyYXdpbmcub3JnL3htbG5zXCI+XFxuJztcbiAgICBncmFwaG1sICs9ICcgIDxncmFwaCBpZD1cImtub3dsZWRnZS1ncmFwaFwiIGVkZ2VkZWZhdWx0PVwiZGlyZWN0ZWRcIj5cXG4nO1xuXG4gICAgLy8gTm9kZXNcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBncmFwaG1sICs9IGAgICAgPG5vZGUgaWQ9XCIke25vZGUuaWR9XCIvPlxcbmA7XG4gICAgfSk7XG5cbiAgICAvLyBFZGdlc1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgIGdyYXBobWwgKz0gYCAgICA8ZWRnZSBzb3VyY2U9XCIke2VkZ2Uuc291cmNlfVwiIHRhcmdldD1cIiR7ZWRnZS50YXJnZXR9XCIvPlxcbmA7XG4gICAgfSk7XG5cbiAgICBncmFwaG1sICs9IFwiICA8L2dyYXBoPlxcblwiO1xuICAgIGdyYXBobWwgKz0gXCI8L2dyYXBobWw+XCI7XG5cbiAgICByZXR1cm4gZ3JhcGhtbDtcbiAgfVxuXG4gIHRlcm1pbmF0ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb21wcmVzc2lvbldvcmtlcikge1xuICAgICAgdGhpcy5jb21wcmVzc2lvbldvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gU3RvcmFnZSBTZXJ2aWNlIHdpdGggSW5kZXhlZERCXG5jbGFzcyBBZHZhbmNlZFN0b3JhZ2VTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBkYk5hbWUgPSBcIkZyZWVBZ2VudGljc0RCXCI7XG4gIHByaXZhdGUgdmVyc2lvbiA9IDE7XG4gIHByaXZhdGUgZGI/OiBJREJEYXRhYmFzZTtcblxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUsIHRoaXMudmVyc2lvbik7XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRiID0gKGV2ZW50LnRhcmdldCBhcyBJREJPcGVuREJSZXF1ZXN0KS5yZXN1bHQ7XG5cbiAgICAgICAgLy8gQ3JlYXRlIG9iamVjdCBzdG9yZXNcbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFwiYWdlbnRzXCIpKSB7XG4gICAgICAgICAgY29uc3QgYWdlbnRzU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShcImFnZW50c1wiLCB7IGtleVBhdGg6IFwiaWRcIiB9KTtcbiAgICAgICAgICBhZ2VudHNTdG9yZS5jcmVhdGVJbmRleChcInR5cGVcIiwgXCJ0eXBlXCIsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhcImNvbnZlcnNhdGlvbnNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb25zU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShcImNvbnZlcnNhdGlvbnNcIiwge1xuICAgICAgICAgICAga2V5UGF0aDogXCJpZFwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnZlcnNhdGlvbnNTdG9yZS5jcmVhdGVJbmRleChcInRpbWVzdGFtcFwiLCBcInRpbWVzdGFtcFwiLCB7XG4gICAgICAgICAgICB1bmlxdWU6IGZhbHNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFwia25vd2xlZGdlXCIpKSB7XG4gICAgICAgICAgY29uc3Qga25vd2xlZGdlU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShcImtub3dsZWRnZVwiLCB7XG4gICAgICAgICAgICBrZXlQYXRoOiBcImlkXCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAga25vd2xlZGdlU3RvcmUuY3JlYXRlSW5kZXgoXCJ0eXBlXCIsIFwidHlwZVwiLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBzdG9yZShzdG9yZU5hbWU6IHN0cmluZywgZGF0YTogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuYWRkKGRhdGEpO1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJldHJpZXZlKHN0b3JlTmFtZTogc3RyaW5nLCBpZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCBcInJlYWRvbmx5XCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChpZCk7XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXRyaWV2ZUFsbChzdG9yZU5hbWU6IHN0cmluZyk6IFByb21pc2U8YW55W10+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCBcInJlYWRvbmx5XCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldEFsbCgpO1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUocmVxdWVzdC5yZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlKHN0b3JlTmFtZTogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoZGF0YSk7XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlKHN0b3JlTmFtZTogc3RyaW5nLCBpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKGlkKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjbGVhcihzdG9yZU5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkXCIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sIFwicmVhZHdyaXRlXCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIFRlc3RzXG5kZXNjcmliZShcIlNwZWNpYWxpemVkIFNlcnZpY2VzXCIsICgpID0+IHtcbiAgZGVzY3JpYmUoXCJDb21wcmVzc2lvbldvcmtlclwiLCAoKSA9PiB7XG4gICAgbGV0IGNvbXByZXNzaW9uV29ya2VyOiBDb21wcmVzc2lvbldvcmtlcjtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgY29tcHJlc3Npb25Xb3JrZXIgPSBuZXcgQ29tcHJlc3Npb25Xb3JrZXIoKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBjb21wcmVzc2lvbldvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY3JlYXRlIHdvcmtlciBpbnN0YW5jZVwiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoY29tcHJlc3Npb25Xb3JrZXIpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoV29ya2VyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIi93b3JrZXJzL2NvbXByZXNzaW9uLmpzXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjb21wcmVzcyBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gXCJIZWxsbywgV29ybGQhXCI7XG4gICAgICBjb25zdCBvcHRpb25zOiBDb21wcmVzc2lvbk9wdGlvbnMgPSB7XG4gICAgICAgIGFsZ29yaXRobTogXCJnemlwXCIsXG4gICAgICAgIGxldmVsOiA2LFxuICAgICAgICBjaHVua1NpemU6IDEwMjQsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgY29tcHJlc3Npb25cbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiBuZXcgQXJyYXlCdWZmZXIoOCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXByZXNzaW9uV29ya2VyLmNvbXByZXNzKHRlc3REYXRhLCBvcHRpb25zKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVJbnN0YW5jZU9mKEFycmF5QnVmZmVyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZGVjb21wcmVzcyBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgICAgY29uc3QgYWxnb3JpdGhtID0gXCJnemlwXCI7XG5cbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBkZWNvbXByZXNzaW9uXG4gICAgICBjb25zdCBtb2NrV29ya2VyID0gKFdvcmtlciBhcyBqZXN0Lk1vY2spLm1vY2sucmVzdWx0c1swXS52YWx1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtb2NrV29ya2VyLm9ubWVzc2FnZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaWQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIHJlc3VsdDogXCJIZWxsbywgV29ybGQhXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXByZXNzaW9uV29ya2VyLmRlY29tcHJlc3ModGVzdERhdGEsIGFsZ29yaXRobSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwiSGVsbG8sIFdvcmxkIVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGNvbXByZXNzaW9uIGVycm9yc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IFwiSGVsbG8sIFdvcmxkIVwiO1xuICAgICAgY29uc3Qgb3B0aW9uczogQ29tcHJlc3Npb25PcHRpb25zID0ge1xuICAgICAgICBhbGdvcml0aG06IFwiZ3ppcFwiLFxuICAgICAgICBsZXZlbDogNixcbiAgICAgICAgY2h1bmtTaXplOiAxMDI0LFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb21wcmVzc2lvbiBlcnJvclxuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICBlcnJvcjogXCJDb21wcmVzc2lvbiBmYWlsZWRcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBjb21wcmVzc2lvbldvcmtlci5jb21wcmVzcyh0ZXN0RGF0YSwgb3B0aW9ucyksXG4gICAgICApLnJlamVjdHMudG9UaHJvdyhcIkNvbXByZXNzaW9uIGZhaWxlZFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHdvcmtlciBlcnJvcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1dvcmtlciA9IChXb3JrZXIgYXMgamVzdC5Nb2NrKS5tb2NrLnJlc3VsdHNbMF0udmFsdWU7XG4gICAgICBjb25zdCBlcnJvckV2ZW50ID0gbmV3IEVycm9yRXZlbnQoXCJlcnJvclwiLCB7IG1lc3NhZ2U6IFwiV29ya2VyIGNyYXNoZWRcIiB9KTtcblxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgbW9ja1dvcmtlci5vbmVycm9yKGVycm9yRXZlbnQpO1xuICAgICAgfSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJQcm92aWRlck1vbml0b3JpbmdTZXJ2aWNlXCIsICgpID0+IHtcbiAgICBsZXQgbW9uaXRvcmluZ1NlcnZpY2U6IFByb3ZpZGVyTW9uaXRvcmluZ1NlcnZpY2U7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vbml0b3JpbmdTZXJ2aWNlID0gbmV3IFByb3ZpZGVyTW9uaXRvcmluZ1NlcnZpY2UoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVjb3JkIG1ldHJpY3NcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljOiBQcm92aWRlck1ldHJpY3MgPSB7XG4gICAgICAgIHJlc3BvbnNlVGltZTogNTAwLFxuICAgICAgICBzdWNjZXNzUmF0ZTogMC45NSxcbiAgICAgICAgZXJyb3JSYXRlOiAwLjA1LFxuICAgICAgICB0aHJvdWdocHV0OiAxMDAsXG4gICAgICAgIGF2YWlsYWJpbGl0eTogMC45OSxcbiAgICAgICAgY29zdDogMC4wMDEsXG4gICAgICB9O1xuXG4gICAgICBtb25pdG9yaW5nU2VydmljZS5yZWNvcmRNZXRyaWMoXCJwcm92aWRlcjFcIiwgbWV0cmljKTtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBtb25pdG9yaW5nU2VydmljZS5nZXRNZXRyaWNzKFwicHJvdmlkZXIxXCIpO1xuXG4gICAgICBleHBlY3QobWV0cmljcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KG1ldHJpY3NbMF0pLnRvRXF1YWwobWV0cmljKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZ2VuZXJhdGUgYWxlcnRzIGZvciB0aHJlc2hvbGQgdmlvbGF0aW9uc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBoaWdoTGF0ZW5jeU1ldHJpYzogUHJvdmlkZXJNZXRyaWNzID0ge1xuICAgICAgICByZXNwb25zZVRpbWU6IDIwMDAsIC8vIEFib3ZlIHRocmVzaG9sZFxuICAgICAgICBzdWNjZXNzUmF0ZTogMC45NSxcbiAgICAgICAgZXJyb3JSYXRlOiAwLjA1LFxuICAgICAgICB0aHJvdWdocHV0OiAxMDAsXG4gICAgICAgIGF2YWlsYWJpbGl0eTogMC45OSxcbiAgICAgICAgY29zdDogMC4wMDEsXG4gICAgICB9O1xuXG4gICAgICBtb25pdG9yaW5nU2VydmljZS5yZWNvcmRNZXRyaWMoXCJwcm92aWRlcjFcIiwgaGlnaExhdGVuY3lNZXRyaWMpO1xuICAgICAgY29uc3QgYWxlcnRzID0gbW9uaXRvcmluZ1NlcnZpY2UuZ2V0QWxlcnRzKFwicHJvdmlkZXIxXCIpO1xuXG4gICAgICBleHBlY3QoYWxlcnRzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoYWxlcnRzWzBdLnNldmVyaXR5KS50b0JlKFwid2FybmluZ1wiKTtcbiAgICAgIGV4cGVjdChhbGVydHNbMF0ubWVzc2FnZSkudG9Db250YWluKFwiSGlnaCByZXNwb25zZSB0aW1lXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjYWxjdWxhdGUgYWdncmVnYXRlZCBtZXRyaWNzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1ldHJpY3M6IFByb3ZpZGVyTWV0cmljc1tdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgcmVzcG9uc2VUaW1lOiA0MDAsXG4gICAgICAgICAgc3VjY2Vzc1JhdGU6IDAuOTUsXG4gICAgICAgICAgZXJyb3JSYXRlOiAwLjA1LFxuICAgICAgICAgIHRocm91Z2hwdXQ6IDEwMCxcbiAgICAgICAgICBhdmFpbGFiaWxpdHk6IDAuOTksXG4gICAgICAgICAgY29zdDogMC4wMDEsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByZXNwb25zZVRpbWU6IDYwMCxcbiAgICAgICAgICBzdWNjZXNzUmF0ZTogMC45OCxcbiAgICAgICAgICBlcnJvclJhdGU6IDAuMDIsXG4gICAgICAgICAgdGhyb3VnaHB1dDogMTIwLFxuICAgICAgICAgIGF2YWlsYWJpbGl0eTogMC45NyxcbiAgICAgICAgICBjb3N0OiAwLjAwMixcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIG1ldHJpY3MuZm9yRWFjaCgobWV0cmljKSA9PiB7XG4gICAgICAgIG1vbml0b3JpbmdTZXJ2aWNlLnJlY29yZE1ldHJpYyhcInByb3ZpZGVyMVwiLCBtZXRyaWMpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZWQgPSBtb25pdG9yaW5nU2VydmljZS5nZXRBZ2dyZWdhdGVkTWV0cmljcyhcInByb3ZpZGVyMVwiKTtcblxuICAgICAgZXhwZWN0KGFnZ3JlZ2F0ZWQucmVzcG9uc2VUaW1lKS50b0JlKDUwMCk7IC8vIEF2ZXJhZ2VcbiAgICAgIGV4cGVjdChhZ2dyZWdhdGVkLnN1Y2Nlc3NSYXRlKS50b0JlQ2xvc2VUbygwLjk2NSwgMyk7XG4gICAgICBleHBlY3QoYWdncmVnYXRlZC5jb3N0KS50b0JlKDAuMDAzKTsgLy8gU3VtXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHJlc29sdmUgYWxlcnRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1ldHJpYzogUHJvdmlkZXJNZXRyaWNzID0ge1xuICAgICAgICByZXNwb25zZVRpbWU6IDIwMDAsXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiAwLjk1LFxuICAgICAgICBlcnJvclJhdGU6IDAuMSwgLy8gSGlnaCBlcnJvciByYXRlXG4gICAgICAgIHRocm91Z2hwdXQ6IDEwMCxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiAwLjksIC8vIExvdyBhdmFpbGFiaWxpdHlcbiAgICAgICAgY29zdDogMC4wMDEsXG4gICAgICB9O1xuXG4gICAgICBtb25pdG9yaW5nU2VydmljZS5yZWNvcmRNZXRyaWMoXCJwcm92aWRlcjFcIiwgbWV0cmljKTtcbiAgICAgIGNvbnN0IGFsZXJ0cyA9IG1vbml0b3JpbmdTZXJ2aWNlLmdldEFsZXJ0cyhcInByb3ZpZGVyMVwiKTtcblxuICAgICAgZXhwZWN0KGFsZXJ0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgICAgY29uc3QgYWxlcnRJZCA9IGFsZXJ0c1swXS5pZDtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gbW9uaXRvcmluZ1NlcnZpY2UucmVzb2x2ZUFsZXJ0KGFsZXJ0SWQpO1xuXG4gICAgICBleHBlY3QocmVzb2x2ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoYWxlcnRzWzBdLnJlc29sdmVkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBjbGVhciByZXNvbHZlZCBhbGVydHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljOiBQcm92aWRlck1ldHJpY3MgPSB7XG4gICAgICAgIHJlc3BvbnNlVGltZTogMjAwMCxcbiAgICAgICAgc3VjY2Vzc1JhdGU6IDAuOTUsXG4gICAgICAgIGVycm9yUmF0ZTogMC4xLFxuICAgICAgICB0aHJvdWdocHV0OiAxMDAsXG4gICAgICAgIGF2YWlsYWJpbGl0eTogMC45LFxuICAgICAgICBjb3N0OiAwLjAwMSxcbiAgICAgIH07XG5cbiAgICAgIG1vbml0b3JpbmdTZXJ2aWNlLnJlY29yZE1ldHJpYyhcInByb3ZpZGVyMVwiLCBtZXRyaWMpO1xuICAgICAgY29uc3QgYWxlcnRzID0gbW9uaXRvcmluZ1NlcnZpY2UuZ2V0QWxlcnRzKCk7XG5cbiAgICAgIC8vIFJlc29sdmUgYWxsIGFsZXJ0c1xuICAgICAgYWxlcnRzLmZvckVhY2goKGFsZXJ0KSA9PiB7XG4gICAgICAgIG1vbml0b3JpbmdTZXJ2aWNlLnJlc29sdmVBbGVydChhbGVydC5pZCk7XG4gICAgICB9KTtcblxuICAgICAgbW9uaXRvcmluZ1NlcnZpY2UuY2xlYXJSZXNvbHZlZEFsZXJ0cygpO1xuICAgICAgY29uc3QgcmVtYWluaW5nQWxlcnRzID0gbW9uaXRvcmluZ1NlcnZpY2UuZ2V0QWxlcnRzKCk7XG5cbiAgICAgIGV4cGVjdChyZW1haW5pbmdBbGVydHMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJLbm93bGVkZ2VHcmFwaEV4cG9ydFNlcnZpY2VcIiwgKCkgPT4ge1xuICAgIGxldCBleHBvcnRTZXJ2aWNlOiBLbm93bGVkZ2VHcmFwaEV4cG9ydFNlcnZpY2U7XG4gICAgbGV0IG1vY2tOb2RlczogS25vd2xlZGdlTm9kZVtdO1xuICAgIGxldCBtb2NrRWRnZXM6IEtub3dsZWRnZUVkZ2VbXTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgZXhwb3J0U2VydmljZSA9IG5ldyBLbm93bGVkZ2VHcmFwaEV4cG9ydFNlcnZpY2UoKTtcblxuICAgICAgbW9ja05vZGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibm9kZTFcIixcbiAgICAgICAgICB0eXBlOiBcImFnZW50XCIsXG4gICAgICAgICAgcHJvcGVydGllczogeyBuYW1lOiBcIkFnZW50IDFcIiB9LFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBjcmVhdGVkOiBuZXcgRGF0ZShcIjIwMjMtMDEtMDFcIiksXG4gICAgICAgICAgICB1cGRhdGVkOiBuZXcgRGF0ZShcIjIwMjMtMDEtMDJcIiksXG4gICAgICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcIm5vZGUyXCIsXG4gICAgICAgICAgdHlwZTogXCJjb25jZXB0XCIsXG4gICAgICAgICAgcHJvcGVydGllczogeyBuYW1lOiBcIkNvbmNlcHQgMVwiIH0sXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IG5ldyBEYXRlKFwiMjAyMy0wMS0wMlwiKSxcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgbW9ja0VkZ2VzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwiZWRnZTFcIixcbiAgICAgICAgICBzb3VyY2U6IFwibm9kZTFcIixcbiAgICAgICAgICB0YXJnZXQ6IFwibm9kZTJcIixcbiAgICAgICAgICB0eXBlOiBcImtub3dzXCIsXG4gICAgICAgICAgd2VpZ2h0OiAwLjcsXG4gICAgICAgICAgcHJvcGVydGllczogeyBzdHJlbmd0aDogXCJzdHJvbmdcIiB9LFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBleHBvcnRTZXJ2aWNlLnRlcm1pbmF0ZSgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBleHBvcnQgdG8gSlNPTiBmb3JtYXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogRXhwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgZm9ybWF0OiBcImpzb25cIixcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhwb3J0U2VydmljZS5leHBvcnRHcmFwaChcbiAgICAgICAgbW9ja05vZGVzLFxuICAgICAgICBtb2NrRWRnZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdCkudG9CZShcInN0cmluZ1wiKTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmVzdWx0IGFzIHN0cmluZyk7XG5cbiAgICAgIGV4cGVjdChwYXJzZWQubm9kZXMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChwYXJzZWQuZWRnZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChwYXJzZWQubm9kZXNbMF0ubWV0YWRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGV4cG9ydCB0byBDU1YgZm9ybWF0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IEV4cG9ydE9wdGlvbnMgPSB7XG4gICAgICAgIGZvcm1hdDogXCJjc3ZcIixcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4cG9ydFNlcnZpY2UuZXhwb3J0R3JhcGgoXG4gICAgICAgIG1vY2tOb2RlcyxcbiAgICAgICAgbW9ja0VkZ2VzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHR5cGVvZiByZXN1bHQpLnRvQmUoXCJzdHJpbmdcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJOT0RFU1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcIkVER0VTXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwibm9kZTEsYWdlbnRcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGV4cG9ydCB0byBHRVhGIGZvcm1hdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBFeHBvcnRPcHRpb25zID0ge1xuICAgICAgICBmb3JtYXQ6IFwiZ2V4ZlwiLFxuICAgICAgICBpbmNsdWRlTWV0YWRhdGE6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhwb3J0U2VydmljZS5leHBvcnRHcmFwaChcbiAgICAgICAgbW9ja05vZGVzLFxuICAgICAgICBtb2NrRWRnZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdCkudG9CZShcInN0cmluZ1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbignPD94bWwgdmVyc2lvbj1cIjEuMFwiJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCI8Z2V4ZiB4bWxucz1cIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJzxub2RlIGlkPVwibm9kZTFcIicpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBleHBvcnQgdG8gR3JhcGhNTCBmb3JtYXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogRXhwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgZm9ybWF0OiBcImdyYXBobWxcIixcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4cG9ydFNlcnZpY2UuZXhwb3J0R3JhcGgoXG4gICAgICAgIG1vY2tOb2RlcyxcbiAgICAgICAgbW9ja0VkZ2VzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHR5cGVvZiByZXN1bHQpLnRvQmUoXCJzdHJpbmdcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJzw/eG1sIHZlcnNpb249XCIxLjBcIicpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiPGdyYXBobWwgeG1sbnM9XCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKCc8bm9kZSBpZD1cIm5vZGUxXCInKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZmlsdGVyIGJ5IG5vZGUgdHlwZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBFeHBvcnRPcHRpb25zID0ge1xuICAgICAgICBmb3JtYXQ6IFwianNvblwiLFxuICAgICAgICBpbmNsdWRlTWV0YWRhdGE6IGZhbHNlLFxuICAgICAgICBmaWx0ZXJCeVR5cGU6IFtcImFnZW50XCJdLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhwb3J0U2VydmljZS5leHBvcnRHcmFwaChcbiAgICAgICAgbW9ja05vZGVzLFxuICAgICAgICBtb2NrRWRnZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyZXN1bHQgYXMgc3RyaW5nKTtcblxuICAgICAgZXhwZWN0KHBhcnNlZC5ub2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHBhcnNlZC5ub2Rlc1swXS50eXBlKS50b0JlKFwiYWdlbnRcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGZpbHRlciBieSBjb25maWRlbmNlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IEV4cG9ydE9wdGlvbnMgPSB7XG4gICAgICAgIGZvcm1hdDogXCJqc29uXCIsXG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YTogdHJ1ZSxcbiAgICAgICAgZmlsdGVyQnlDb25maWRlbmNlOiAwLjg1LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhwb3J0U2VydmljZS5leHBvcnRHcmFwaChcbiAgICAgICAgbW9ja05vZGVzLFxuICAgICAgICBtb2NrRWRnZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyZXN1bHQgYXMgc3RyaW5nKTtcblxuICAgICAgZXhwZWN0KHBhcnNlZC5ub2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHBhcnNlZC5ub2Rlc1swXS5tZXRhZGF0YS5jb25maWRlbmNlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDAuODUpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgY29tcHJlc3Npb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogRXhwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgZm9ybWF0OiBcImpzb25cIixcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhOiB0cnVlLFxuICAgICAgICBjb21wcmVzc2VkOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb21wcmVzc2lvbiB3b3JrZXJcbiAgICAgIGNvbnN0IG1vY2tXb3JrZXIgPSAoV29ya2VyIGFzIGplc3QuTW9jaykubW9jay5yZXN1bHRzWzBdLnZhbHVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG1vY2tXb3JrZXIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgcmVzdWx0OiBuZXcgQXJyYXlCdWZmZXIoMTAwKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhwb3J0U2VydmljZS5leHBvcnRHcmFwaChcbiAgICAgICAgbW9ja05vZGVzLFxuICAgICAgICBtb2NrRWRnZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlSW5zdGFuY2VPZihBcnJheUJ1ZmZlcik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSB1bnN1cHBvcnRlZCBmb3JtYXRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczogRXhwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgZm9ybWF0OiBcInVuc3VwcG9ydGVkXCIgYXMgYW55LFxuICAgICAgICBpbmNsdWRlTWV0YWRhdGE6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBleHBvcnRTZXJ2aWNlLmV4cG9ydEdyYXBoKG1vY2tOb2RlcywgbW9ja0VkZ2VzLCBvcHRpb25zKSxcbiAgICAgICkucmVqZWN0cy50b1Rocm93KFwiVW5zdXBwb3J0ZWQgZXhwb3J0IGZvcm1hdFwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJBZHZhbmNlZFN0b3JhZ2VTZXJ2aWNlXCIsICgpID0+IHtcbiAgICBsZXQgc3RvcmFnZVNlcnZpY2U6IEFkdmFuY2VkU3RvcmFnZVNlcnZpY2U7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIHN0b3JhZ2VTZXJ2aWNlID0gbmV3IEFkdmFuY2VkU3RvcmFnZVNlcnZpY2UoKTtcblxuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIGluaXRpYWxpemF0aW9uXG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgb25zdWNjZXNzOiBudWxsLFxuICAgICAgICBvbmVycm9yOiBudWxsLFxuICAgICAgICBvbnVwZ3JhZGVuZWVkZWQ6IG51bGwsXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIG9iamVjdFN0b3JlTmFtZXM6IHtcbiAgICAgICAgICAgIGNvbnRhaW5zOiBqZXN0LmZuKCgpID0+IGZhbHNlKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyZWF0ZU9iamVjdFN0b3JlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICBjcmVhdGVJbmRleDogamVzdC5mbigpLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgb2JqZWN0U3RvcmU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgICAgYWRkOiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgICAgIGdldDogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgICAgICBnZXRBbGw6IGplc3QuZm4oKCkgPT4gKHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH0pKSxcbiAgICAgICAgICAgICAgcHV0OiBqZXN0LmZuKCgpID0+ICh7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgICAgIGRlbGV0ZTogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgICAgICBjbGVhcjogamVzdC5mbigoKSA9PiAoeyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIChnbG9iYWwuaW5kZXhlZERCLm9wZW4gYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUobW9ja1JlcXVlc3QpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBzdWNjZXNzZnVsIGluaXRpYWxpemF0aW9uXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKG1vY2tSZXF1ZXN0Lm9uc3VjY2Vzcykge1xuICAgICAgICAgIG1vY2tSZXF1ZXN0Lm9uc3VjY2VzcygpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcblxuICAgICAgYXdhaXQgc3RvcmFnZVNlcnZpY2UuaW5pdGlhbGl6ZSgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBpbml0aWFsaXplIGRhdGFiYXNlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGV4cGVjdChnbG9iYWwuaW5kZXhlZERCLm9wZW4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiRnJlZUFnZW50aWNzREJcIiwgMSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHN0b3JlIGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiBcInRlc3QxXCIsIG5hbWU6IFwiVGVzdCBBZ2VudFwiIH07XG5cbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBzdG9yZSBvcGVyYXRpb25cbiAgICAgIGNvbnN0IG1vY2tUcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgb2JqZWN0U3RvcmU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBhZGQ6IGplc3QuZm4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH07XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlcXVlc3Qub25zdWNjZXNzKSByZXF1ZXN0Lm9uc3VjY2VzcygpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgKHN0b3JhZ2VTZXJ2aWNlIGFzIGFueSkuZGIgPSB7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBqZXN0LmZuKCgpID0+IG1vY2tUcmFuc2FjdGlvbiksXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHN0b3JhZ2VTZXJ2aWNlLnN0b3JlKFwiYWdlbnRzXCIsIHRlc3REYXRhKSxcbiAgICAgICkucmVzb2x2ZXMudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCByZXRyaWV2ZSBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RJZCA9IFwidGVzdDFcIjtcbiAgICAgIGNvbnN0IGV4cGVjdGVkRGF0YSA9IHsgaWQ6IFwidGVzdDFcIiwgbmFtZTogXCJUZXN0IEFnZW50XCIgfTtcblxuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIHJldHJpZXZlIG9wZXJhdGlvblxuICAgICAgY29uc3QgbW9ja1RyYW5zYWN0aW9uID0ge1xuICAgICAgICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGdldDogamVzdC5mbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICBvbnN1Y2Nlc3M6IG51bGwsXG4gICAgICAgICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgIHJlc3VsdDogZXhwZWN0ZWREYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5vbnN1Y2Nlc3MpIHJlcXVlc3Qub25zdWNjZXNzKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgIH0pLFxuICAgICAgICB9KSksXG4gICAgICB9O1xuXG4gICAgICAoc3RvcmFnZVNlcnZpY2UgYXMgYW55KS5kYiA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb246IGplc3QuZm4oKCkgPT4gbW9ja1RyYW5zYWN0aW9uKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0b3JhZ2VTZXJ2aWNlLnJldHJpZXZlKFwiYWdlbnRzXCIsIHRlc3RJZCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGV4cGVjdGVkRGF0YSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHJldHJpZXZlIGFsbCBkYXRhXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkRGF0YSA9IFtcbiAgICAgICAgeyBpZDogXCJ0ZXN0MVwiLCBuYW1lOiBcIlRlc3QgQWdlbnQgMVwiIH0sXG4gICAgICAgIHsgaWQ6IFwidGVzdDJcIiwgbmFtZTogXCJUZXN0IEFnZW50IDJcIiB9LFxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIHJldHJpZXZlQWxsIG9wZXJhdGlvblxuICAgICAgY29uc3QgbW9ja1RyYW5zYWN0aW9uID0ge1xuICAgICAgICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGdldEFsbDogamVzdC5mbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICBvbnN1Y2Nlc3M6IG51bGwsXG4gICAgICAgICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgIHJlc3VsdDogZXhwZWN0ZWREYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5vbnN1Y2Nlc3MpIHJlcXVlc3Qub25zdWNjZXNzKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgIH0pLFxuICAgICAgICB9KSksXG4gICAgICB9O1xuXG4gICAgICAoc3RvcmFnZVNlcnZpY2UgYXMgYW55KS5kYiA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb246IGplc3QuZm4oKCkgPT4gbW9ja1RyYW5zYWN0aW9uKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0b3JhZ2VTZXJ2aWNlLnJldHJpZXZlQWxsKFwiYWdlbnRzXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChleHBlY3RlZERhdGEpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB1cGRhdGUgZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgaWQ6IFwidGVzdDFcIiwgbmFtZTogXCJVcGRhdGVkIEFnZW50XCIgfTtcblxuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIHVwZGF0ZSBvcGVyYXRpb25cbiAgICAgIGNvbnN0IG1vY2tUcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgb2JqZWN0U3RvcmU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBwdXQ6IGplc3QuZm4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH07XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlcXVlc3Qub25zdWNjZXNzKSByZXF1ZXN0Lm9uc3VjY2VzcygpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgKHN0b3JhZ2VTZXJ2aWNlIGFzIGFueSkuZGIgPSB7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBqZXN0LmZuKCgpID0+IG1vY2tUcmFuc2FjdGlvbiksXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHN0b3JhZ2VTZXJ2aWNlLnVwZGF0ZShcImFnZW50c1wiLCB0ZXN0RGF0YSksXG4gICAgICApLnJlc29sdmVzLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZGVsZXRlIGRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdElkID0gXCJ0ZXN0MVwiO1xuXG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgZGVsZXRlIG9wZXJhdGlvblxuICAgICAgY29uc3QgbW9ja1RyYW5zYWN0aW9uID0ge1xuICAgICAgICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGRlbGV0ZTogamVzdC5mbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5vbnN1Y2Nlc3MpIHJlcXVlc3Qub25zdWNjZXNzKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgIH0pLFxuICAgICAgICB9KSksXG4gICAgICB9O1xuXG4gICAgICAoc3RvcmFnZVNlcnZpY2UgYXMgYW55KS5kYiA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb246IGplc3QuZm4oKCkgPT4gbW9ja1RyYW5zYWN0aW9uKSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgc3RvcmFnZVNlcnZpY2UuZGVsZXRlKFwiYWdlbnRzXCIsIHRlc3RJZCksXG4gICAgICApLnJlc29sdmVzLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY2xlYXIgc3RvcmVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIGNsZWFyIG9wZXJhdGlvblxuICAgICAgY29uc3QgbW9ja1RyYW5zYWN0aW9uID0ge1xuICAgICAgICBvYmplY3RTdG9yZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGNsZWFyOiBqZXN0LmZuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IG9uc3VjY2VzczogbnVsbCwgb25lcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm9uc3VjY2VzcykgcmVxdWVzdC5vbnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pKSxcbiAgICAgIH07XG5cbiAgICAgIChzdG9yYWdlU2VydmljZSBhcyBhbnkpLmRiID0ge1xuICAgICAgICB0cmFuc2FjdGlvbjogamVzdC5mbigoKSA9PiBtb2NrVHJhbnNhY3Rpb24pLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHN0b3JhZ2VTZXJ2aWNlLmNsZWFyKFwiYWdlbnRzXCIpKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQgZXJyb3JcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdW5pbml0aWFsaXplZFNlcnZpY2UgPSBuZXcgQWR2YW5jZWRTdG9yYWdlU2VydmljZSgpO1xuXG4gICAgICBhd2FpdCBleHBlY3QodW5pbml0aWFsaXplZFNlcnZpY2Uuc3RvcmUoXCJhZ2VudHNcIiwge30pKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkXCIsXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsIldvcmtlciIsImplc3QiLCJmbiIsInBvc3RNZXNzYWdlIiwidGVybWluYXRlIiwib25tZXNzYWdlIiwib25lcnJvciIsImluZGV4ZWREQiIsIm9wZW4iLCJvbnN1Y2Nlc3MiLCJvbnVwZ3JhZGVuZWVkZWQiLCJyZXN1bHQiLCJjcmVhdGVPYmplY3RTdG9yZSIsImNyZWF0ZUluZGV4IiwidHJhbnNhY3Rpb24iLCJvYmplY3RTdG9yZSIsImFkZCIsImdldCIsImRlbGV0ZSIsInB1dCIsImdldEFsbCIsImNsZWFyIiwiZGVsZXRlRGF0YWJhc2UiLCJDb21wcmVzc2lvbldvcmtlciIsImNvbnN0cnVjdG9yIiwicGVuZGluZ0pvYnMiLCJNYXAiLCJ3b3JrZXIiLCJoYW5kbGVNZXNzYWdlIiwiYmluZCIsImhhbmRsZUVycm9yIiwiZXZlbnQiLCJpZCIsImVycm9yIiwiZGF0YSIsImpvYiIsInJlamVjdCIsIkVycm9yIiwicmVzb2x2ZSIsImNvbnNvbGUiLCJmb3JFYWNoIiwiY29tcHJlc3MiLCJvcHRpb25zIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwiUHJvbWlzZSIsInNldCIsImFjdGlvbiIsImRlY29tcHJlc3MiLCJhbGdvcml0aG0iLCJQcm92aWRlck1vbml0b3JpbmdTZXJ2aWNlIiwicmVjb3JkTWV0cmljIiwicHJvdmlkZXJJZCIsIm1ldHJpYyIsIm1ldHJpY3MiLCJoYXMiLCJwcm92aWRlck1ldHJpY3MiLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJjaGVja1RocmVzaG9sZHMiLCJhbGVydHMiLCJyZXNwb25zZVRpbWUiLCJ0aHJlc2hvbGRzIiwic2V2ZXJpdHkiLCJtZXNzYWdlIiwidGltZXN0YW1wIiwiRGF0ZSIsInJlc29sdmVkIiwiZXJyb3JSYXRlIiwidG9GaXhlZCIsImF2YWlsYWJpbGl0eSIsImdldE1ldHJpY3MiLCJnZXRBZ2dyZWdhdGVkTWV0cmljcyIsInJlZHVjZSIsInN1bSIsIm0iLCJzdWNjZXNzUmF0ZSIsInRocm91Z2hwdXQiLCJjb3N0IiwiZ2V0QWxlcnRzIiwiZmlsdGVyIiwiYWxlcnQiLCJyZXNvbHZlQWxlcnQiLCJhbGVydElkIiwiZmluZCIsImEiLCJjbGVhclJlc29sdmVkQWxlcnRzIiwiS25vd2xlZGdlR3JhcGhFeHBvcnRTZXJ2aWNlIiwiY29tcHJlc3Npb25Xb3JrZXIiLCJleHBvcnRHcmFwaCIsIm5vZGVzIiwiZWRnZXMiLCJmaWx0ZXJlZE5vZGVzIiwiZmlsdGVyTm9kZXMiLCJmaWx0ZXJlZEVkZ2VzIiwiZmlsdGVyRWRnZXMiLCJleHBvcnREYXRhIiwiZm9ybWF0IiwiZXhwb3J0VG9KU09OIiwiZXhwb3J0VG9DU1YiLCJleHBvcnRUb0dFWEYiLCJleHBvcnRUb0dyYXBoTUwiLCJjb21wcmVzc2VkIiwibGV2ZWwiLCJjaHVua1NpemUiLCJmaWx0ZXJlZCIsImZpbHRlckJ5VHlwZSIsIm5vZGUiLCJpbmNsdWRlcyIsInR5cGUiLCJmaWx0ZXJCeUNvbmZpZGVuY2UiLCJ1bmRlZmluZWQiLCJtZXRhZGF0YSIsImNvbmZpZGVuY2UiLCJpbmNsdWRlTWV0YWRhdGEiLCJtYXAiLCJleHBvcnRJbmZvIiwidG9JU09TdHJpbmciLCJub2RlQ291bnQiLCJlZGdlQ291bnQiLCJKU09OIiwic3RyaW5naWZ5Iiwibm9kZUhlYWRlcnMiLCJlZGdlSGVhZGVycyIsImNzdiIsImpvaW4iLCJyb3ciLCJwcm9wZXJ0aWVzIiwicmVwbGFjZSIsImNyZWF0ZWQiLCJ1cGRhdGVkIiwiZWRnZSIsInNvdXJjZSIsInRhcmdldCIsIndlaWdodCIsImdleGYiLCJncmFwaG1sIiwiQWR2YW5jZWRTdG9yYWdlU2VydmljZSIsImluaXRpYWxpemUiLCJyZXF1ZXN0IiwiZGJOYW1lIiwidmVyc2lvbiIsImRiIiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwiYWdlbnRzU3RvcmUiLCJrZXlQYXRoIiwidW5pcXVlIiwiY29udmVyc2F0aW9uc1N0b3JlIiwia25vd2xlZGdlU3RvcmUiLCJzdG9yZSIsInN0b3JlTmFtZSIsInJldHJpZXZlIiwicmV0cmlldmVBbGwiLCJ1cGRhdGUiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJhZnRlckVhY2giLCJ0ZXN0IiwiZXhwZWN0IiwidG9CZURlZmluZWQiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInRlc3REYXRhIiwibW9ja1dvcmtlciIsIm1vY2siLCJyZXN1bHRzIiwidmFsdWUiLCJzZXRUaW1lb3V0IiwiYW55IiwiU3RyaW5nIiwiQXJyYXlCdWZmZXIiLCJ0b0JlSW5zdGFuY2VPZiIsInRvQmUiLCJyZWplY3RzIiwidG9UaHJvdyIsImVycm9yRXZlbnQiLCJFcnJvckV2ZW50Iiwibm90IiwibW9uaXRvcmluZ1NlcnZpY2UiLCJ0b0hhdmVMZW5ndGgiLCJ0b0VxdWFsIiwiaGlnaExhdGVuY3lNZXRyaWMiLCJ0b0NvbnRhaW4iLCJhZ2dyZWdhdGVkIiwidG9CZUNsb3NlVG8iLCJ0b0JlR3JlYXRlclRoYW4iLCJyZW1haW5pbmdBbGVydHMiLCJleHBvcnRTZXJ2aWNlIiwibW9ja05vZGVzIiwibW9ja0VkZ2VzIiwibmFtZSIsInN0cmVuZ3RoIiwicGFyc2VkIiwicGFyc2UiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwic3RvcmFnZVNlcnZpY2UiLCJtb2NrUmVxdWVzdCIsIm1vY2tSZXR1cm5WYWx1ZSIsIm1vY2tUcmFuc2FjdGlvbiIsInJlc29sdmVzIiwidG9CZVVuZGVmaW5lZCIsInRlc3RJZCIsImV4cGVjdGVkRGF0YSIsInVuaW5pdGlhbGl6ZWRTZXJ2aWNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozt5QkFFb0I7QUFFckIsc0NBQXNDO0FBQ3RDQSxPQUFPQyxNQUFNLEdBQUdDLGFBQUksQ0FBQ0MsRUFBRSxDQUFDLElBQU8sQ0FBQTtRQUM3QkMsYUFBYUYsYUFBSSxDQUFDQyxFQUFFO1FBQ3BCRSxXQUFXSCxhQUFJLENBQUNDLEVBQUU7UUFDbEJHLFdBQVc7UUFDWEMsU0FBUztJQUNYLENBQUE7QUFFQSxzQ0FBc0M7QUFDdENQLE9BQU9RLFNBQVMsR0FBRztJQUNqQkMsTUFBTVAsYUFBSSxDQUFDQyxFQUFFLENBQUMsSUFBTyxDQUFBO1lBQ25CTyxXQUFXO1lBQ1hILFNBQVM7WUFDVEksaUJBQWlCO1lBQ2pCQyxRQUFRO2dCQUNOQyxtQkFBbUJYLGFBQUksQ0FBQ0MsRUFBRSxDQUFDLElBQU8sQ0FBQTt3QkFDaENXLGFBQWFaLGFBQUksQ0FBQ0MsRUFBRTtvQkFDdEIsQ0FBQTtnQkFDQVksYUFBYWIsYUFBSSxDQUFDQyxFQUFFLENBQUMsSUFBTyxDQUFBO3dCQUMxQmEsYUFBYWQsYUFBSSxDQUFDQyxFQUFFLENBQUMsSUFBTyxDQUFBO2dDQUMxQmMsS0FBS2YsYUFBSSxDQUFDQyxFQUFFLENBQUMsSUFBTyxDQUFBO3dDQUFFTyxXQUFXO3dDQUFNSCxTQUFTO29DQUFLLENBQUE7Z0NBQ3JEVyxLQUFLaEIsYUFBSSxDQUFDQyxFQUFFLENBQUMsSUFBTyxDQUFBO3dDQUFFTyxXQUFXO3dDQUFNSCxTQUFTO29DQUFLLENBQUE7Z0NBQ3JEWSxRQUFRakIsYUFBSSxD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