{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/services/provider-monitoring-service.ts"],"sourcesContent":["\"use client\";\n\nimport {\n  ProviderMonitoringData,\n  UsageMetrics,\n  HealthStatus,\n} from \"../../types/llm-providers\";\n\nexport interface MonitoringConfig {\n  healthCheckInterval: number;\n  usageUpdateInterval: number;\n  alertThresholds: {\n    errorRatePercent: number;\n    latencyMs: number;\n    costPerHour: number;\n    consecutiveFailures: number;\n  };\n  retentionPeriod: number; // hours\n}\n\nexport interface AlertEvent {\n  id: string;\n  providerId: string;\n  type: \"error_rate\" | \"latency\" | \"cost\" | \"health\" | \"rate_limit\";\n  severity: \"low\" | \"medium\" | \"high\" | \"critical\";\n  message: string;\n  data: any;\n  timestamp: Date;\n  acknowledged: boolean;\n}\n\n/**\n * Real-time provider monitoring service\n */\nexport class ProviderMonitoringService {\n  private static instance: ProviderMonitoringService;\n  private providers: Map<string, ProviderMonitoringData> = new Map();\n  private alerts: AlertEvent[] = [];\n  private listeners: Set<(data: ProviderMonitoringData[]) => void> = new Set();\n  private alertListeners: Set<(alert: AlertEvent) => void> = new Set();\n  private isRunning = false;\n  private healthCheckTimer?: NodeJS.Timeout;\n  private usageUpdateTimer?: NodeJS.Timeout;\n\n  private config: MonitoringConfig = {\n    healthCheckInterval: 60000, // 1 minute\n    usageUpdateInterval: 30000, // 30 seconds\n    alertThresholds: {\n      errorRatePercent: 5,\n      latencyMs: 5000,\n      costPerHour: 10,\n      consecutiveFailures: 3,\n    },\n    retentionPeriod: 24, // 24 hours\n  };\n\n  private constructor() {}\n\n  static getInstance(): ProviderMonitoringService {\n    if (!ProviderMonitoringService.instance) {\n      ProviderMonitoringService.instance = new ProviderMonitoringService();\n    }\n    return ProviderMonitoringService.instance;\n  }\n\n  /**\n   * Initialize monitoring for providers\n   */\n  async initialize(\n    providers: ProviderMonitoringData[],\n    config?: Partial<MonitoringConfig>,\n  ) {\n    if (config) {\n      this.config = { ...this.config, ...config };\n    }\n\n    // Initialize provider data\n    providers.forEach((provider) => {\n      this.providers.set(provider.providerId, {\n        ...provider,\n        timestamp: new Date(),\n      });\n    });\n\n    console.log(\n      `[MONITORING] Initialized monitoring for ${providers.length} providers`,\n    );\n    return this.start();\n  }\n\n  /**\n   * Start real-time monitoring\n   */\n  async start() {\n    if (this.isRunning) {\n      console.warn(\"[MONITORING] Service already running\");\n      return;\n    }\n\n    this.isRunning = true;\n    console.log(\"[MONITORING] Starting real-time monitoring service\");\n\n    // Start health checks\n    this.healthCheckTimer = setInterval(\n      () => this.performHealthChecks(),\n      this.config.healthCheckInterval,\n    );\n\n    // Start usage updates\n    this.usageUpdateTimer = setInterval(\n      () => this.updateUsageMetrics(),\n      this.config.usageUpdateInterval,\n    );\n\n    // Initial health check\n    await this.performHealthChecks();\n  }\n\n  /**\n   * Stop monitoring service\n   */\n  stop() {\n    if (!this.isRunning) return;\n\n    this.isRunning = false;\n    console.log(\"[MONITORING] Stopping monitoring service\");\n\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n      this.healthCheckTimer = undefined;\n    }\n\n    if (this.usageUpdateTimer) {\n      clearInterval(this.usageUpdateTimer);\n      this.usageUpdateTimer = undefined;\n    }\n  }\n\n  /**\n   * Subscribe to provider data updates\n   */\n  subscribe(listener: (data: ProviderMonitoringData[]) => void) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  /**\n   * Subscribe to alert events\n   */\n  subscribeToAlerts(listener: (alert: AlertEvent) => void) {\n    this.alertListeners.add(listener);\n    return () => this.alertListeners.delete(listener);\n  }\n\n  /**\n   * Get current provider data\n   */\n  getProviderData(): ProviderMonitoringData[] {\n    return Array.from(this.providers.values());\n  }\n\n  /**\n   * Get provider by ID\n   */\n  getProvider(id: string): ProviderMonitoringData | undefined {\n    return this.providers.get(id);\n  }\n\n  /**\n   * Update provider configuration\n   */\n  updateProvider(id: string, updates: Partial<ProviderMonitoringData>) {\n    const provider = this.providers.get(id);\n    if (!provider) return false;\n\n    const updatedProvider = { ...provider, ...updates };\n    this.providers.set(id, updatedProvider);\n    this.notifyListeners();\n    return true;\n  }\n\n  /**\n   * Record a request for usage tracking\n   */\n  recordRequest(\n    providerId: string,\n    success: boolean,\n    inputTokens: number,\n    outputTokens: number,\n    latency: number,\n    cost: number,\n    errorType?: string,\n  ) {\n    const provider = this.providers.get(providerId);\n    if (!provider) return;\n\n    const now = new Date();\n    const metrics = provider.metrics;\n\n    // Update usage metrics\n    metrics.requestCount += 1;\n    metrics.tokenCount += inputTokens + outputTokens;\n    metrics.costEstimate += cost;\n\n    if (success) {\n      metrics.successRate =\n        (metrics.successRate * (metrics.requestCount - 1) + 100) /\n        metrics.requestCount;\n    } else {\n      metrics.successRate =\n        (metrics.successRate * (metrics.requestCount - 1)) /\n        metrics.requestCount;\n    }\n\n    // Update averages\n    metrics.averageLatency =\n      (metrics.averageLatency * (metrics.requestCount - 1) + latency) /\n      metrics.requestCount;\n    metrics.errorRate = 100 - metrics.successRate;\n\n    // Update timestamp\n    provider.timestamp = now;\n\n    if (!success) {\n      // Add an incident for the failure\n      provider.health.incidents.push({\n        id: `incident_${Date.now()}`,\n        type: \"error\",\n        severity: \"medium\",\n        startTime: now,\n        impact: \"Request failed\",\n        duration: 0,\n      });\n    }\n\n    // Clean old incidents data\n    this.cleanIncidentData(provider);\n\n    // Check for alerts\n    this.checkAlerts(provider);\n\n    // Update provider\n    this.providers.set(providerId, provider);\n    this.notifyListeners();\n  }\n\n  /**\n   * Perform health checks on all providers\n   */\n  private async performHealthChecks() {\n    const promises = Array.from(this.providers.values()).map((provider) =>\n      this.performProviderHealthCheck(provider),\n    );\n\n    await Promise.allSettled(promises);\n    this.notifyListeners();\n  }\n\n  /**\n   * Perform health check for a single provider\n   */\n  private async performProviderHealthCheck(provider: ProviderMonitoringData) {\n    const startTime = Date.now();\n\n    try {\n      // Call health check API\n      const response = await fetch(\"/api/llm/health-check\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          providerId: provider.providerId,\n          providerType: \"unknown\",\n        }),\n      });\n\n      const latency = Date.now() - startTime;\n      const isHealthy = response.ok;\n\n      // Update health status\n      provider.health = {\n        status: isHealthy ? \"healthy\" : \"unhealthy\",\n        lastCheck: new Date(),\n        uptime: isHealthy\n          ? Math.min(provider.health.uptime + 0.1, 100)\n          : Math.max(provider.health.uptime - 1, 0),\n        incidents: provider.health.incidents || [],\n      };\n\n      console.log(\n        `[MONITORING] Health check for ${provider.providerId}: ${provider.health.status} (${latency}ms)`,\n      );\n\n      // Check for health alerts\n      this.checkHealthAlerts(provider);\n    } catch (error) {\n      console.error(\n        `[MONITORING] Health check failed for ${provider.providerId}:`,\n        error,\n      );\n\n      provider.health = {\n        status: \"unhealthy\",\n        lastCheck: new Date(),\n        uptime: Math.max(provider.health.uptime - 5, 0),\n        incidents: provider.health.incidents || [],\n      };\n\n      this.createAlert(\n        provider.providerId,\n        \"health\",\n        \"high\",\n        `Provider ${provider.providerId} health check failed`,\n        { error: error.message },\n      );\n    }\n\n    this.providers.set(provider.providerId, provider);\n  }\n\n  /**\n   * Update usage metrics (calculate rates, etc.)\n   */\n  private updateUsageMetrics() {\n    const now = new Date();\n    const oneMinuteAgo = new Date(now.getTime() - 60000);\n    const oneHourAgo = new Date(now.getTime() - 3600000);\n\n    this.providers.forEach((provider, id) => {\n      // Update timestamp\n      provider.timestamp = now;\n      this.providers.set(id, provider);\n    });\n\n    this.notifyListeners();\n  }\n\n  /**\n   * Clean old incident data based on retention period\n   */\n  private cleanIncidentData(provider: ProviderMonitoringData) {\n    const cutoff = new Date(Date.now() - this.config.retentionPeriod * 3600000);\n\n    provider.health.incidents = provider.health.incidents.filter(\n      (incident) => incident.startTime >= cutoff,\n    );\n  }\n\n  /**\n   * Check for usage-based alerts\n   */\n  private checkAlerts(provider: ProviderMonitoringData) {\n    const { alertThresholds } = this.config;\n\n    // Error rate alert\n    if (provider.metrics.errorRate > alertThresholds.errorRatePercent) {\n      this.createAlert(\n        provider.providerId,\n        \"error_rate\",\n        provider.metrics.errorRate > alertThresholds.errorRatePercent * 2\n          ? \"critical\"\n          : \"high\",\n        `High error rate: ${provider.metrics.errorRate.toFixed(1)}%`,\n        {\n          errorRate: provider.metrics.errorRate,\n          threshold: alertThresholds.errorRatePercent,\n        },\n      );\n    }\n\n    // Latency alert\n    if (provider.metrics.averageLatency > alertThresholds.latencyMs) {\n      this.createAlert(\n        provider.providerId,\n        \"latency\",\n        \"medium\",\n        `High latency: ${provider.metrics.averageLatency.toFixed(0)}ms`,\n        {\n          latency: provider.metrics.averageLatency,\n          threshold: alertThresholds.latencyMs,\n        },\n      );\n    }\n\n    // Cost alert\n    if (provider.metrics.costEstimate > alertThresholds.costPerHour) {\n      this.createAlert(\n        provider.providerId,\n        \"cost\",\n        \"medium\",\n        `High cost: $${provider.metrics.costEstimate.toFixed(2)}/hour`,\n        {\n          costPerHour: provider.metrics.costEstimate,\n          threshold: alertThresholds.costPerHour,\n        },\n      );\n    }\n  }\n\n  /**\n   * Check for health-based alerts\n   */\n  private checkHealthAlerts(provider: ProviderMonitoringData) {\n    const { alertThresholds } = this.config;\n\n    // Health status alert\n    if (provider.health.status === \"unhealthy\") {\n      this.createAlert(\n        provider.providerId,\n        \"health\",\n        \"critical\",\n        `Provider is unhealthy`,\n        { status: provider.health.status },\n      );\n    }\n\n    // Low uptime alert\n    if (provider.health.uptime < 95) {\n      this.createAlert(\n        provider.providerId,\n        \"health\",\n        \"high\",\n        `Low uptime: ${provider.health.uptime.toFixed(1)}%`,\n        { uptime: provider.health.uptime },\n      );\n    }\n  }\n\n  /**\n   * Create an alert\n   */\n  private createAlert(\n    providerId: string,\n    type: AlertEvent[\"type\"],\n    severity: AlertEvent[\"severity\"],\n    message: string,\n    data: any,\n  ) {\n    // Check if similar alert already exists (prevent spam)\n    const recentSimilarAlert = this.alerts.find(\n      (alert) =>\n        alert.providerId === providerId &&\n        alert.type === type &&\n        alert.severity === severity &&\n        Date.now() - alert.timestamp.getTime() < 300000, // 5 minutes\n    );\n\n    if (recentSimilarAlert) return;\n\n    const alert: AlertEvent = {\n      id: `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      providerId,\n      type,\n      severity,\n      message,\n      data,\n      timestamp: new Date(),\n      acknowledged: false,\n    };\n\n    this.alerts.push(alert);\n    console.warn(`[MONITORING] Alert created: ${alert.message}`);\n\n    // Notify alert listeners\n    this.alertListeners.forEach((listener) => listener(alert));\n\n    // Clean old alerts (keep last 100)\n    if (this.alerts.length > 100) {\n      this.alerts = this.alerts.slice(-100);\n    }\n  }\n\n  /**\n   * Get all alerts\n   */\n  getAlerts(): AlertEvent[] {\n    return [...this.alerts];\n  }\n\n  /**\n   * Acknowledge an alert\n   */\n  acknowledgeAlert(alertId: string) {\n    const alert = this.alerts.find((a) => a.id === alertId);\n    if (alert) {\n      alert.acknowledged = true;\n    }\n  }\n\n  /**\n   * Get monitoring statistics\n   */\n  getStats() {\n    const providers = Array.from(this.providers.values());\n    const totalRequests = providers.reduce(\n      (sum, p) => sum + p.metrics.requestCount,\n      0,\n    );\n    const totalCost = providers.reduce(\n      (sum, p) => sum + p.metrics.costEstimate,\n      0,\n    );\n    const healthyProviders = providers.filter(\n      (p) => p.health.status === \"healthy\",\n    ).length;\n    const activeAlerts = this.alerts.filter((a) => !a.acknowledged).length;\n\n    return {\n      totalProviders: providers.length,\n      healthyProviders,\n      totalRequests,\n      totalCost,\n      activeAlerts,\n      isRunning: this.isRunning,\n    };\n  }\n\n  /**\n   * Notify all listeners of data changes\n   */\n  private notifyListeners() {\n    const data = this.getProviderData();\n    this.listeners.forEach((listener) => listener(data));\n  }\n\n  /**\n   * Export monitoring data for analysis\n   */\n  exportData(timeRange?: { start: Date; end: Date }) {\n    const providers = this.getProviderData();\n\n    return {\n      providers: providers.filter(\n        (provider) =>\n          !timeRange ||\n          (provider.timestamp >= timeRange.start &&\n            provider.timestamp <= timeRange.end),\n      ),\n      alerts: this.alerts.filter(\n        (alert) =>\n          !timeRange ||\n          (alert.timestamp >= timeRange.start &&\n            alert.timestamp <= timeRange.end),\n      ),\n      exportedAt: new Date(),\n      timeRange,\n    };\n  }\n}\n"],"names":["ProviderMonitoringService","providers","Map","alerts","listeners","Set","alertListeners","isRunning","config","healthCheckInterval","usageUpdateInterval","alertThresholds","errorRatePercent","latencyMs","costPerHour","consecutiveFailures","retentionPeriod","getInstance","instance","initialize","forEach","provider","set","providerId","timestamp","Date","console","log","length","start","warn","healthCheckTimer","setInterval","performHealthChecks","usageUpdateTimer","updateUsageMetrics","stop","clearInterval","undefined","subscribe","listener","add","delete","subscribeToAlerts","getProviderData","Array","from","values","getProvider","id","get","updateProvider","updates","updatedProvider","notifyListeners","recordRequest","success","inputTokens","outputTokens","latency","cost","errorType","now","metrics","requestCount","tokenCount","costEstimate","successRate","averageLatency","errorRate","health","incidents","push","type","severity","startTime","impact","duration","cleanIncidentData","checkAlerts","promises","map","performProviderHealthCheck","Promise","allSettled","response","fetch","method","headers","body","JSON","stringify","providerType","isHealthy","ok","status","lastCheck","uptime","Math","min","max","checkHealthAlerts","error","createAlert","message","oneMinuteAgo","getTime","oneHourAgo","cutoff","filter","incident","toFixed","threshold","data","recentSimilarAlert","find","alert","random","toString","substr","acknowledged","slice","getAlerts","acknowledgeAlert","alertId","a","getStats","totalRequests","reduce","sum","p","totalCost","healthyProviders","activeAlerts","totalProviders","exportData","timeRange","end","exportedAt"],"mappings":"AAAA;;;;;+BAkCaA;;;eAAAA;;;AAAN,MAAMA;IAsBX,aAAsB;aApBdC,YAAiD,IAAIC;aACrDC,SAAuB,EAAE;aACzBC,YAA2D,IAAIC;aAC/DC,iBAAmD,IAAID;aACvDE,YAAY;aAIZC,SAA2B;YACjCC,qBAAqB;YACrBC,qBAAqB;YACrBC,iBAAiB;gBACfC,kBAAkB;gBAClBC,WAAW;gBACXC,aAAa;gBACbC,qBAAqB;YACvB;YACAC,iBAAiB;QACnB;IAEuB;IAEvB,OAAOC,cAAyC;QAC9C,IAAI,CAACjB,0BAA0BkB,QAAQ,EAAE;YACvClB,0BAA0BkB,QAAQ,GAAG,IAAIlB;QAC3C;QACA,OAAOA,0BAA0BkB,QAAQ;IAC3C;IAEA;;GAEC,GACD,MAAMC,WACJlB,SAAmC,EACnCO,MAAkC,EAClC;QACA,IAAIA,QAAQ;YACV,IAAI,CAACA,MAAM,GAAG;gBAAE,GAAG,IAAI,CAACA,MAAM;gBAAE,GAAGA,MAAM;YAAC;QAC5C;QAEA,2BAA2B;QAC3BP,UAAUmB,OAAO,CAAC,CAACC;YACjB,IAAI,CAACpB,SAAS,CAACqB,GAAG,CAACD,SAASE,UAAU,EAAE;gBACtC,GAAGF,QAAQ;gBACXG,WAAW,IAAIC;YACjB;QACF;QAEAC,QAAQC,GAAG,CACT,CAAC,wCAAwC,EAAE1B,UAAU2B,MAAM,CAAC,UAAU,CAAC;QAEzE,OAAO,IAAI,CAACC,KAAK;IACnB;IAEA;;GAEC,GACD,MAAMA,QAAQ;QACZ,IAAI,IAAI,CAACtB,SAAS,EAAE;YAClBmB,QAAQI,IAAI,CAAC;YACb;QACF;QAEA,IAAI,CAACvB,SAAS,GAAG;QACjBmB,QAAQC,GAAG,CAAC;QAEZ,sBAAsB;QACtB,IAAI,CAACI,gBAAgB,GAAGC,YACtB,IAAM,IAAI,CAACC,mBAAmB,IAC9B,IAAI,CAACzB,MAAM,CAACC,mBAAmB;QAGjC,sBAAsB;QACtB,IAAI,CAACyB,gBAAgB,GAAGF,YACtB,IAAM,IAAI,CAACG,kBAAkB,IAC7B,IAAI,CAAC3B,MAAM,CAACE,mBAAmB;QAGjC,uBAAuB;QACvB,MAAM,IAAI,CAACuB,mBAAmB;IAChC;IAEA;;GAEC,GACDG,OAAO;QACL,IAAI,CAAC,IAAI,CAAC7B,SAAS,EAAE;QAErB,IAAI,CAACA,SAAS,GAAG;QACjBmB,QAAQC,GAAG,CAAC;QAEZ,IAAI,IAAI,CAACI,gBAAgB,EAAE;YACzBM,cAAc,IAAI,CAACN,gBAAgB;YACnC,IAAI,CAACA,gBAAgB,GAAGO;QAC1B;QAEA,IAAI,IAAI,CAACJ,gBAAgB,EAAE;YACzBG,cAAc,IAAI,CAACH,gBAAgB;YACnC,IAAI,CAACA,gBAAgB,GAAGI;QAC1B;IACF;IAEA;;GAEC,GACDC,UAAUC,QAAkD,EAAE;QAC5D,IAAI,CAACpC,SAAS,CAACqC,GAAG,CAACD;QACnB,OAAO,IAAM,IAAI,CAACpC,SAAS,CAACsC,MAAM,CAACF;IACrC;IAEA;;GAEC,GACDG,kBAAkBH,QAAqC,EAAE;QACvD,IAAI,CAAClC,cAAc,CAACmC,GAAG,CAACD;QACxB,OAAO,IAAM,IAAI,CAAClC,cAAc,CAACoC,MAAM,CAACF;IAC1C;IAEA;;GAEC,GACDI,kBAA4C;QAC1C,OAAOC,MAAMC,IAAI,CAAC,IAAI,CAAC7C,SAAS,CAAC8C,MAAM;IACzC;IAEA;;GAEC,GACDC,YAAYC,EAAU,EAAsC;QAC1D,OAAO,IAAI,CAAChD,SAAS,CAACiD,GAAG,CAACD;IAC5B;IAEA;;GAEC,GACDE,eAAeF,EAAU,EAAEG,OAAwC,EAAE;QACnE,MAAM/B,WAAW,IAAI,CAACpB,SAAS,CAACiD,GAAG,CAACD;QACpC,IAAI,CAAC5B,UAAU,OAAO;QAEtB,MAAMgC,kBAAkB;YAAE,GAAGhC,QAAQ;YAAE,GAAG+B,OAAO;QAAC;QAClD,IAAI,CAACnD,SAAS,CAACqB,GAAG,CAAC2B,IAAII;QACvB,IAAI,CAACC,eAAe;QACpB,OAAO;IACT;IAEA;;GAEC,GACDC,cACEhC,UAAkB,EAClBiC,OAAgB,EAChBC,WAAmB,EACnBC,YAAoB,EACpBC,OAAe,EACfC,IAAY,EACZC,SAAkB,EAClB;QACA,MAAMxC,WAAW,IAAI,CAACpB,SAAS,CAACiD,GAAG,CAAC3B;QACpC,IAAI,CAACF,UAAU;QAEf,MAAMyC,MAAM,IAAIrC;QAChB,MAAMsC,UAAU1C,SAAS0C,OAAO;QAEhC,uBAAuB;QACvBA,QAAQC,YAAY,IAAI;QACxBD,QAAQE,UAAU,IAAIR,cAAcC;QACpCK,QAAQG,YAAY,IAAIN;QAExB,IAAIJ,SAAS;YACXO,QAAQI,WAAW,GACjB,AAACJ,CAAAA,QAAQI,WAAW,GAAIJ,CAAAA,QAAQC,YAAY,GAAG,CAAA,IAAK,GAAE,IACtDD,QAAQC,YAAY;QACxB,OAAO;YACLD,QAAQI,WAAW,GACjB,AAACJ,QAAQI,WAAW,GAAIJ,CAAAA,QAAQC,YAAY,GAAG,CAAA,IAC/CD,QAAQC,YAAY;QACxB;QAEA,kBAAkB;QAClBD,QAAQK,cAAc,GACpB,AAACL,CAAAA,QAAQK,cAAc,GAAIL,CAAAA,QAAQC,YAAY,GAAG,CAAA,IAAKL,OAAM,IAC7DI,QAAQC,YAAY;QACtBD,QAAQM,SAAS,GAAG,MAAMN,QAAQI,WAAW;QAE7C,mBAAmB;QACnB9C,SAASG,SAAS,GAAGsC;QAErB,IAAI,CAACN,SAAS;YACZ,kCAAkC;YAClCnC,SAASiD,MAAM,CAACC,SAAS,CAACC,IAAI,CAAC;gBAC7BvB,IAAI,CAAC,SAAS,EAAExB,KAAKqC,GAAG,GAAG,CAAC;gBAC5BW,MAAM;gBACNC,UAAU;gBACVC,WAAWb;gBACXc,QAAQ;gBACRC,UAAU;YACZ;QACF;QAEA,2BAA2B;QAC3B,IAAI,CAACC,iBAAiB,CAACzD;QAEvB,mBAAmB;QACnB,IAAI,CAAC0D,WAAW,CAAC1D;QAEjB,kBAAkB;QAClB,IAAI,CAACpB,SAAS,CAACqB,GAAG,CAACC,YAAYF;QAC/B,IAAI,CAACiC,eAAe;IACtB;IAEA;;GAEC,GACD,MAAcrB,sBAAsB;QAClC,MAAM+C,WAAWnC,MAAMC,IAAI,CAAC,IAAI,CAAC7C,SAAS,CAAC8C,MAAM,IAAIkC,GAAG,CAAC,CAAC5D,WACxD,IAAI,CAAC6D,0BAA0B,CAAC7D;QAGlC,MAAM8D,QAAQC,UAAU,CAACJ;QACzB,IAAI,CAAC1B,eAAe;IACtB;IAEA;;GAEC,GACD,MAAc4B,2BAA2B7D,QAAgC,EAAE;QACzE,MAAMsD,YAAYlD,KAAKqC,GAAG;QAE1B,IAAI;YACF,wBAAwB;YACxB,MAAMuB,WAAW,MAAMC,MAAM,yBAAyB;gBACpDC,QAAQ;gBACRC,SAAS;oBAAE,gBAAgB;gBAAmB;gBAC9CC,MAAMC,KAAKC,SAAS,CAAC;oBACnBpE,YAAYF,SAASE,UAAU;oBAC/BqE,cAAc;gBAChB;YACF;YAEA,MAAMjC,UAAUlC,KAAKqC,GAAG,KAAKa;YAC7B,MAAMkB,YAAYR,SAASS,EAAE;YAE7B,uBAAuB;YACvBzE,SAASiD,MAAM,GAAG;gBAChByB,QAAQF,YAAY,YAAY;gBAChCG,WAAW,IAAIvE;gBACfwE,QAAQJ,YACJK,KAAKC,GAAG,CAAC9E,SAASiD,MAAM,CAAC2B,MAAM,GAAG,KAAK,OACvCC,KAAKE,GAAG,CAAC/E,SAASiD,MAAM,CAAC2B,MAAM,GAAG,GAAG;gBACzC1B,WAAWlD,SAASiD,MAAM,CAACC,SAAS,IAAI,EAAE;YAC5C;YAEA7C,QAAQC,GAAG,CACT,CAAC,8BAA8B,EAAEN,SAASE,UAAU,CAAC,EAAE,EAAEF,SAASiD,MAAM,CAACyB,MAAM,CAAC,EAAE,EAAEpC,QAAQ,GAAG,CAAC;YAGlG,0BAA0B;YAC1B,IAAI,CAAC0C,iBAAiB,CAAChF;QACzB,EAAE,OAAOiF,OAAO;YACd5E,QAAQ4E,KAAK,CACX,CAAC,qCAAqC,EAAEjF,SAASE,UAAU,CAAC,CAAC,CAAC,EAC9D+E;YAGFjF,SAASiD,MAAM,GAAG;gBAChByB,QAAQ;gBACRC,WAAW,IAAIvE;gBACfwE,QAAQC,KAAKE,GAAG,CAAC/E,SAASiD,MAAM,CAAC2B,MAAM,GAAG,GAAG;gBAC7C1B,WAAWlD,SAASiD,MAAM,CAACC,SAAS,IAAI,EAAE;YAC5C;YAEA,IAAI,CAACgC,WAAW,CACdlF,SAASE,UAAU,EACnB,UACA,QACA,CAAC,SAAS,EAAEF,SAASE,UAAU,CAAC,oBAAoB,CAAC,EACrD;gBAAE+E,OAAOA,MAAME,OAAO;YAAC;QAE3B;QAEA,IAAI,CAACvG,SAAS,CAACqB,GAAG,CAACD,SAASE,UAAU,EAAEF;IAC1C;IAEA;;GAEC,GACD,AAAQc,qBAAqB;QAC3B,MAAM2B,MAAM,IAAIrC;QAChB,MAAMgF,eAAe,IAAIhF,KAAKqC,IAAI4C,OAAO,KAAK;QAC9C,MAAMC,aAAa,IAAIlF,KAAKqC,IAAI4C,OAAO,KAAK;QAE5C,IAAI,CAACzG,SAAS,CAACmB,OAAO,CAAC,CAACC,UAAU4B;YAChC,mBAAmB;YACnB5B,SAASG,SAAS,GAAGsC;YACrB,IAAI,CAAC7D,SAAS,CAACqB,GAAG,CAAC2B,IAAI5B;QACzB;QAEA,IAAI,CAACiC,eAAe;IACtB;IAEA;;GAEC,GACD,AAAQwB,kBAAkBzD,QAAgC,EAAE;QAC1D,MAAMuF,SAAS,IAAInF,KAAKA,KAAKqC,GAAG,KAAK,IAAI,CAACtD,MAAM,CAACQ,eAAe,GAAG;QAEnEK,SAASiD,MAAM,CAACC,SAAS,GAAGlD,SAASiD,MAAM,CAACC,SAAS,CAACsC,MAAM,CAC1D,CAACC,WAAaA,SAASnC,SAAS,IAAIiC;IAExC;IAEA;;GAEC,GACD,AAAQ7B,YAAY1D,QAAgC,EAAE;QACpD,MAAM,EAAEV,eAAe,EAAE,GAAG,IAAI,CAACH,MAAM;QAEvC,mBAAmB;QACnB,IAAIa,SAAS0C,OAAO,CAACM,SAAS,GAAG1D,gBAAgBC,gBAAgB,EAAE;YACjE,IAAI,CAAC2F,WAAW,CACdlF,SAASE,UAAU,EACnB,cACAF,SAAS0C,OAAO,CAACM,SAAS,GAAG1D,gBAAgBC,gBAAgB,GAAG,IAC5D,aACA,QACJ,CAAC,iBAAiB,EAAES,SAAS0C,OAAO,CAACM,SAAS,CAAC0C,OAAO,CAAC,GAAG,CAAC,CAAC,EAC5D;gBACE1C,WAAWhD,SAAS0C,OAAO,CAACM,SAAS;gBACrC2C,WAAWrG,gBAAgBC,gBAAgB;YAC7C;QAEJ;QAEA,gBAAgB;QAChB,IAAIS,SAAS0C,OAAO,CAACK,cAAc,GAAGzD,gBAAgBE,SAAS,EAAE;YAC/D,IAAI,CAAC0F,WAAW,CACdlF,SAASE,UAAU,EACnB,WACA,UACA,CAAC,cAAc,EAAEF,SAAS0C,OAAO,CAACK,cAAc,CAAC2C,OAAO,CAAC,GAAG,EAAE,CAAC,EAC/D;gBACEpD,SAAStC,SAAS0C,OAAO,CAACK,cAAc;gBACxC4C,WAAWrG,gBAAgBE,SAAS;YACtC;QAEJ;QAEA,aAAa;QACb,IAAIQ,SAAS0C,OAAO,CAACG,YAAY,GAAGvD,gBAAgBG,WAAW,EAAE;YAC/D,IAAI,CAACyF,WAAW,CACdlF,SAASE,UAAU,EACnB,QACA,UACA,CAAC,YAAY,EAAEF,SAAS0C,OAAO,CAACG,YAAY,CAAC6C,OAAO,CAAC,GAAG,KAAK,CAAC,EAC9D;gBACEjG,aAAaO,SAAS0C,OAAO,CAACG,YAAY;gBAC1C8C,WAAWrG,gBAAgBG,WAAW;YACxC;QAEJ;IACF;IAEA;;GAEC,GACD,AAAQuF,kBAAkBhF,QAAgC,EAAE;QAC1D,MAAM,EAAEV,eAAe,EAAE,GAAG,IAAI,CAACH,MAAM;QAEvC,sBAAsB;QACtB,IAAIa,SAASiD,MAAM,CAACyB,MAAM,KAAK,aAAa;YAC1C,IAAI,CAACQ,WAAW,CACdlF,SAASE,UAAU,EACnB,UACA,YACA,CAAC,qBAAqB,CAAC,EACvB;gBAAEwE,QAAQ1E,SAASiD,MAAM,CAACyB,MAAM;YAAC;QAErC;QAEA,mBAAmB;QACnB,IAAI1E,SAASiD,MAAM,CAAC2B,MAAM,GAAG,IAAI;YAC/B,IAAI,CAACM,WAAW,CACdlF,SAASE,UAAU,EACnB,UACA,QACA,CAAC,YAAY,EAAEF,SAASiD,MAAM,CAAC2B,MAAM,CAACc,OAAO,CAAC,GAAG,CAAC,CAAC,EACnD;gBAAEd,QAAQ5E,SAASiD,MAAM,CAAC2B,MAAM;YAAC;QAErC;IACF;IAEA;;GAEC,GACD,AAAQM,YACNhF,UAAkB,EAClBkD,IAAwB,EACxBC,QAAgC,EAChC8B,OAAe,EACfS,IAAS,EACT;QACA,uDAAuD;QACvD,MAAMC,qBAAqB,IAAI,CAAC/G,MAAM,CAACgH,IAAI,CACzC,CAACC,QACCA,MAAM7F,UAAU,KAAKA,cACrB6F,MAAM3C,IAAI,KAAKA,QACf2C,MAAM1C,QAAQ,KAAKA,YACnBjD,KAAKqC,GAAG,KAAKsD,MAAM5F,SAAS,CAACkF,OAAO,KAAK;QAG7C,IAAIQ,oBAAoB;QAExB,MAAME,QAAoB;YACxBnE,IAAI,CAAC,MAAM,EAAExB,KAAKqC,GAAG,GAAG,CAAC,EAAEoC,KAAKmB,MAAM,GAAGC,QAAQ,CAAC,IAAIC,MAAM,CAAC,GAAG,GAAG,CAAC;YACpEhG;YACAkD;YACAC;YACA8B;YACAS;YACAzF,WAAW,IAAIC;YACf+F,cAAc;QAChB;QAEA,IAAI,CAACrH,MAAM,CAACqE,IAAI,CAAC4C;QACjB1F,QAAQI,IAAI,CAAC,CAAC,4BAA4B,EAAEsF,MAAMZ,OAAO,CAAC,CAAC;QAE3D,yBAAyB;QACzB,IAAI,CAAClG,cAAc,CAACc,OAAO,CAAC,CAACoB,WAAaA,SAAS4E;QAEnD,mCAAmC;QACnC,IAAI,IAAI,CAACjH,MAAM,CAACyB,MAAM,GAAG,KAAK;YAC5B,IAAI,CAACzB,MAAM,GAAG,IAAI,CAACA,MAAM,CAACsH,KAAK,CAAC,CAAC;QACnC;IACF;IAEA;;GAEC,GACDC,YAA0B;QACxB,OAAO;eAAI,IAAI,CAACvH,MAAM;SAAC;IACzB;IAEA;;GAEC,GACDwH,iBAAiBC,OAAe,EAAE;QAChC,MAAMR,QAAQ,IAAI,CAACjH,MAAM,CAACgH,IAAI,CAAC,CAACU,IAAMA,EAAE5E,EAAE,KAAK2E;QAC/C,IAAIR,OAAO;YACTA,MAAMI,YAAY,GAAG;QACvB;IACF;IAEA;;GAEC,GACDM,WAAW;QACT,MAAM7H,YAAY4C,MAAMC,IAAI,CAAC,IAAI,CAAC7C,SAAS,CAAC8C,MAAM;QAClD,MAAMgF,gBAAgB9H,UAAU+H,MAAM,CACpC,CAACC,KAAKC,IAAMD,MAAMC,EAAEnE,OAAO,CAACC,YAAY,EACxC;QAEF,MAAMmE,YAAYlI,UAAU+H,MAAM,CAChC,CAACC,KAAKC,IAAMD,MAAMC,EAAEnE,OAAO,CAACG,YAAY,EACxC;QAEF,MAAMkE,mBAAmBnI,UAAU4G,MAAM,CACvC,CAACqB,IAAMA,EAAE5D,MAAM,CAACyB,MAAM,KAAK,WAC3BnE,MAAM;QACR,MAAMyG,eAAe,IAAI,CAAClI,MAAM,CAAC0G,MAAM,CAAC,CAACgB,IAAM,CAACA,EAAEL,YAAY,EAAE5F,MAAM;QAEtE,OAAO;YACL0G,gBAAgBrI,UAAU2B,MAAM;YAChCwG;YACAL;YACAI;YACAE;YACA9H,WAAW,IAAI,CAACA,SAAS;QAC3B;IACF;IAEA;;GAEC,GACD,AAAQ+C,kBAAkB;QACxB,MAAM2D,OAAO,IAAI,CAACrE,eAAe;QACjC,IAAI,CAACxC,SAAS,CAACgB,OAAO,CAAC,CAACoB,WAAaA,SAASyE;IAChD;IAEA;;GAEC,GACDsB,WAAWC,SAAsC,EAAE;QACjD,MAAMvI,YAAY,IAAI,CAAC2C,eAAe;QAEtC,OAAO;YACL3C,WAAWA,UAAU4G,MAAM,CACzB,CAACxF,WACC,CAACmH,aACAnH,SAASG,SAAS,IAAIgH,UAAU3G,KAAK,IACpCR,SAASG,SAAS,IAAIgH,UAAUC,GAAG;YAEzCtI,QAAQ,IAAI,CAACA,MAAM,CAAC0G,MAAM,CACxB,CAACO,QACC,CAACoB,aACApB,MAAM5F,SAAS,IAAIgH,UAAU3G,KAAK,IACjCuF,MAAM5F,SAAS,IAAIgH,UAAUC,GAAG;YAEtCC,YAAY,IAAIjH;YAChB+G;QACF;IACF;AACF"}