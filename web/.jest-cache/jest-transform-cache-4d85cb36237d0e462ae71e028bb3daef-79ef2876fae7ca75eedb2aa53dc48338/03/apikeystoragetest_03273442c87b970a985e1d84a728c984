83ed52ea13cdeb3ef3beeada32f86b3e
/**
 * Phase 1: lib/api-key-storage.ts Comprehensive Test Suite
 * Target: Complete API key storage functionality with server-side encryption
 * Goal: Maximum statement coverage for secure API key management
 */ "use strict";
// Mock dependencies
jest.mock("@/lib/encryption", ()=>({
        encrypt: jest.fn(),
        decrypt: jest.fn()
    }));
jest.mock("next/headers", ()=>({
        cookies: jest.fn()
    }));
jest.mock("node:crypto", ()=>({
        randomBytes: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _apikeystorage = require("../../lib/api-key-storage");
// Mock console methods
const originalConsole = {
    ...console
};
beforeEach(()=>{
    console.log = jest.fn();
    console.warn = jest.fn();
    console.error = jest.fn();
});
afterEach(()=>{
    Object.assign(console, originalConsole);
    jest.clearAllMocks();
    jest.clearAllTimers();
    jest.useRealTimers();
});
describe("lib/api-key-storage.ts - Complete Coverage", ()=>{
    const mockEncrypt = require("@/lib/encryption").encrypt;
    const mockDecrypt = require("@/lib/encryption").decrypt;
    const mockCookies = require("next/headers").cookies;
    const mockCrypto = require("node:crypto");
    let mockCookieStore;
    beforeEach(()=>{
        mockCookieStore = {
            set: jest.fn(),
            get: jest.fn(),
            delete: jest.fn()
        };
        mockCookies.mockResolvedValue(mockCookieStore);
        mockCrypto.randomBytes = jest.fn().mockReturnValue({
            toString: ()=>"mock-session-id"
        });
        mockEncrypt.mockResolvedValue("encrypted-api-key");
        mockDecrypt.mockResolvedValue("decrypted-api-key");
    });
    describe("storeApiKey - all scenarios", ()=>{
        test("stores API key successfully in development", async ()=>{
            process.env.NODE_ENV = "development";
            const result = await (0, _apikeystorage.storeApiKey)("openai", "test-api-key");
            expect(mockEncrypt).toHaveBeenCalledWith("test-api-key");
            expect(mockCookieStore.set).toHaveBeenCalledWith("api_session_openai", "mock-session-id", {
                httpOnly: true,
                secure: false,
                sameSite: "strict",
                maxAge: 86400,
                path: "/"
            });
            expect(result).toBe("mock-session-id");
            expect(console.log).toHaveBeenCalledWith("[API-KEY-STORAGE] Storing API key for provider: openai");
        });
        test("stores API key successfully in production", async ()=>{
            process.env.NODE_ENV = "production";
            const result = await (0, _apikeystorage.storeApiKey)("anthropic", "claude-api-key");
            expect(mockCookieStore.set).toHaveBeenCalledWith("api_session_anthropic", "mock-session-id", expect.objectContaining({
                secure: true
            }));
            expect(result).toBe("mock-session-id");
        });
        test("handles all providers", async ()=>{
            const providers = [
                "openai",
                "anthropic",
                "google",
                "azure"
            ];
            for (const provider of providers){
                const result = await (0, _apikeystorage.storeApiKey)(provider, `${provider}-key`);
                expect(result).toBe("mock-session-id");
                expect(mockCookieStore.set).toHaveBeenCalledWith(`api_session_${provider}`, "mock-session-id", expect.any(Object));
            }
        });
        test("handles encryption failure", async ()=>{
            mockEncrypt.mockRejectedValue(new Error("Encryption failed"));
            await expect((0, _apikeystorage.storeApiKey)("openai", "test-key")).rejects.toThrow("Failed to store API key securely");
            expect(console.error).toHaveBeenCalledWith("[API-KEY-STORAGE] Error storing API key:", expect.any(Error));
        });
        test("handles cookie setting failure", async ()=>{
            mockCookies.mockRejectedValue(new Error("Cookie error"));
            await expect((0, _apikeystorage.storeApiKey)("openai", "test-key")).rejects.toThrow("Failed to store API key securely");
        });
        test("generates unique session IDs", async ()=>{
            mockCrypto.randomBytes.mockReturnValueOnce({
                toString: ()=>"session-1"
            }).mockReturnValueOnce({
                toString: ()=>"session-2"
            });
            const result1 = await (0, _apikeystorage.storeApiKey)("openai", "key1");
            const result2 = await (0, _apikeystorage.storeApiKey)("anthropic", "key2");
            expect(result1).toBe("session-1");
            expect(result2).toBe("session-2");
        });
    });
    describe("getApiKey - all scenarios", ()=>{
        test("retrieves API key with explicit session ID", async ()=>{
            // Store a key first
            await (0, _apikeystorage.storeApiKey)("openai", "test-api-key");
            const result = await (0, _apikeystorage.getApiKey)("openai", "mock-session-id");
            expect(mockDecrypt).toHaveBeenCalledWith("encrypted-api-key");
            expect(result).toBe("decrypted-api-key");
            expect(console.log).toHaveBeenCalledWith("[API-KEY-STORAGE] Retrieving API key for provider: openai, session ID: mock-session-id");
        });
        test("retrieves API key from cookies when no session ID provided", async ()=>{
            mockCookieStore.get.mockReturnValue({
                value: "cookie-session-id"
            });
            await (0, _apikeystorage.storeApiKey)("openai", "test-api-key");
            const result = await (0, _apikeystorage.getApiKey)("openai");
            expect(mockCookieStore.get).toHaveBeenCalledWith("api_session_openai");
            expect(result).toBe("decrypted-api-key");
        });
        test("returns null when no session ID found", async ()=>{
            mockCookieStore.get.mockReturnValue(undefined);
            const result = await (0, _apikeystorage.getApiKey)("openai");
            expect(result).toBeNull();
            expect(console.warn).toHaveBeenCalledWith("[API-KEY-STORAGE] No session ID found for provider: openai");
        });
        test("returns null when session data not found", async ()=>{
            const result = await (0, _apikeystorage.getApiKey)("openai", "non-existent-session");
            expect(result).toBeNull();
            expect(console.warn).toHaveBeenCalledWith("[API-KEY-STORAGE] No session data found for session ID: non-existent-session");
        });
        test("returns null when provider mismatch", async ()=>{
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            const result = await (0, _apikeystorage.getApiKey)("anthropic", "mock-session-id");
            expect(result).toBeNull();
            expect(console.warn).toHaveBeenCalledWith("[API-KEY-STORAGE] Provider mismatch for session ID: mock-session-id");
        });
        test("returns null and cleans up expired session", async ()=>{
            jest.useFakeTimers();
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            // Fast-forward past session lifetime (24 hours)
            jest.advanceTimersByTime(25 * 60 * 60 * 1000);
            const result = await (0, _apikeystorage.getApiKey)("openai", "mock-session-id");
            expect(result).toBeNull();
            expect(console.warn).toHaveBeenCalledWith("[API-KEY-STORAGE] Session expired for session ID: mock-session-id");
        });
        test("handles decryption failure", async ()=>{
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            mockDecrypt.mockRejectedValue(new Error("Decryption failed"));
            const result = await (0, _apikeystorage.getApiKey)("openai", "mock-session-id");
            expect(result).toBeNull();
            expect(console.error).toHaveBeenCalledWith("[API-KEY-STORAGE] Error retrieving API key:", expect.any(Error));
        });
    });
    describe("validateSession - all scenarios", ()=>{
        test("validates active session with explicit session ID", async ()=>{
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            const result = await (0, _apikeystorage.validateSession)("openai", "mock-session-id");
            expect(result).toBe(true);
            expect(console.log).toHaveBeenCalledWith("[API-KEY-STORAGE] Validating session for provider: openai, session ID: mock-session-id");
        });
        test("validates session from cookies", async ()=>{
            mockCookieStore.get.mockReturnValue({
                value: "cookie-session-id"
            });
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            const result = await (0, _apikeystorage.validateSession)("openai");
            expect(mockCookieStore.get).toHaveBeenCalledWith("api_session_openai");
            expect(result).toBe(true);
        });
        test("returns false when no session ID", async ()=>{
            mockCookieStore.get.mockReturnValue(undefined);
            const result = await (0, _apikeystorage.validateSession)("openai");
            expect(result).toBe(false);
        });
        test("returns false when session data not found", async ()=>{
            const result = await (0, _apikeystorage.validateSession)("openai", "non-existent");
            expect(result).toBe(false);
        });
        test("returns false when provider mismatch", async ()=>{
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            const result = await (0, _apikeystorage.validateSession)("anthropic", "mock-session-id");
            expect(result).toBe(false);
        });
        test("returns false and cleans up expired session", async ()=>{
            jest.useFakeTimers();
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            jest.advanceTimersByTime(25 * 60 * 60 * 1000);
            const result = await (0, _apikeystorage.validateSession)("openai", "mock-session-id");
            expect(result).toBe(false);
        });
        test("handles validation errors", async ()=>{
            mockCookies.mockRejectedValue(new Error("Cookie error"));
            const result = await (0, _apikeystorage.validateSession)("openai");
            expect(result).toBe(false);
            expect(console.error).toHaveBeenCalledWith("[API-KEY-STORAGE] Error validating session:", expect.any(Error));
        });
    });
    describe("deleteApiKey - all scenarios", ()=>{
        test("deletes API key with explicit session ID", async ()=>{
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            const result = await (0, _apikeystorage.deleteApiKey)("openai", "mock-session-id");
            expect(result).toBe(true);
            expect(mockCookieStore.delete).toHaveBeenCalledWith("api_session_openai");
            expect(console.log).toHaveBeenCalledWith("[API-KEY-STORAGE] Deleting API key for provider: openai, session ID: mock-session-id");
        });
        test("deletes API key from cookies", async ()=>{
            mockCookieStore.get.mockReturnValue({
                value: "cookie-session-id"
            });
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            const result = await (0, _apikeystorage.deleteApiKey)("openai");
            expect(mockCookieStore.get).toHaveBeenCalledWith("api_session_openai");
            expect(result).toBe(true);
        });
        test("returns false when no session ID", async ()=>{
            mockCookieStore.get.mockReturnValue(undefined);
            const result = await (0, _apikeystorage.deleteApiKey)("openai");
            expect(result).toBe(false);
        });
        test("returns false when session not found", async ()=>{
            const result = await (0, _apikeystorage.deleteApiKey)("openai", "non-existent");
            expect(result).toBe(false);
        });
        test("handles deletion errors", async ()=>{
            mockCookies.mockRejectedValue(new Error("Cookie error"));
            const result = await (0, _apikeystorage.deleteApiKey)("openai");
            expect(result).toBe(false);
            expect(console.error).toHaveBeenCalledWith("[API-KEY-STORAGE] Error deleting API key:", expect.any(Error));
        });
    });
    describe("clearExpiredSessions - cleanup functionality", ()=>{
        test("clears expired sessions", async ()=>{
            jest.useFakeTimers();
            // Store multiple keys
            await (0, _apikeystorage.storeApiKey)("openai", "key1");
            await (0, _apikeystorage.storeApiKey)("anthropic", "key2");
            await (0, _apikeystorage.storeApiKey)("google", "key3");
            // Fast-forward past expiration
            jest.advanceTimersByTime(25 * 60 * 60 * 1000);
            const cleared = await (0, _apikeystorage.clearExpiredSessions)();
            expect(cleared).toBe(3);
            expect(console.log).toHaveBeenCalledWith("[API-KEY-STORAGE] Cleared 3 expired sessions");
        });
        test("does not clear active sessions", async ()=>{
            await (0, _apikeystorage.storeApiKey)("openai", "active-key");
            const cleared = await (0, _apikeystorage.clearExpiredSessions)();
            expect(cleared).toBe(0);
            expect(console.log).toHaveBeenCalledWith("[API-KEY-STORAGE] Cleared 0 expired sessions");
        });
        test("clears mix of expired and active sessions", async ()=>{
            jest.useFakeTimers();
            // Store some keys
            await (0, _apikeystorage.storeApiKey)("openai", "key1");
            await (0, _apikeystorage.storeApiKey)("anthropic", "key2");
            // Advance time partially
            jest.advanceTimersByTime(25 * 60 * 60 * 1000);
            // Store more keys (these should be active)
            await (0, _apikeystorage.storeApiKey)("google", "key3");
            const cleared = await (0, _apikeystorage.clearExpiredSessions)();
            expect(cleared).toBe(2); // Only first two expired
        });
    });
    describe("automatic cleanup timer", ()=>{
        test("starts cleanup timer when storing first key", async ()=>{
            jest.useFakeTimers();
            const setIntervalSpy = jest.spyOn(global, "setInterval");
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            expect(setIntervalSpy).toHaveBeenCalledWith(expect.any(Function), 60 * 60 * 1000);
        });
        test("does not start multiple timers", async ()=>{
            jest.useFakeTimers();
            const setIntervalSpy = jest.spyOn(global, "setInterval");
            await (0, _apikeystorage.storeApiKey)("openai", "key1");
            await (0, _apikeystorage.storeApiKey)("anthropic", "key2");
            expect(setIntervalSpy).toHaveBeenCalledTimes(1);
        });
        test("cleanup timer removes expired sessions", async ()=>{
            jest.useFakeTimers();
            await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            // Fast-forward past session lifetime
            jest.advanceTimersByTime(25 * 60 * 60 * 1000);
            // Trigger cleanup timer
            jest.advanceTimersByTime(60 * 60 * 1000);
            expect(console.log).toHaveBeenCalledWith(expect.stringContaining("Cleaned up expired session"));
        });
    });
    describe("edge cases and error scenarios", ()=>{
        test("handles concurrent operations", async ()=>{
            const promises = [
                (0, _apikeystorage.storeApiKey)("openai", "key1"),
                (0, _apikeystorage.storeApiKey)("anthropic", "key2"),
                (0, _apikeystorage.storeApiKey)("google", "key3")
            ];
            const results = await Promise.all(promises);
            expect(results).toHaveLength(3);
            results.forEach((result)=>{
                expect(typeof result).toBe("string");
            });
        });
        test("handles session ID generation failure", async ()=>{
            mockCrypto.randomBytes.mockImplementation(()=>{
                throw new Error("Crypto failure");
            });
            await expect((0, _apikeystorage.storeApiKey)("openai", "test-key")).rejects.toThrow("Failed to store API key securely");
        });
        test("handles empty and invalid inputs", async ()=>{
            // Empty provider
            await expect((0, _apikeystorage.storeApiKey)("", "test-key")).resolves.toBeDefined();
            // Empty API key
            await expect((0, _apikeystorage.storeApiKey)("openai", "")).resolves.toBeDefined();
            // Special characters in provider
            await expect((0, _apikeystorage.storeApiKey)("test@provider!", "key")).resolves.toBeDefined();
        });
        test("validates session lifetime constants", ()=>{
            // Test that constants are reasonable
            expect(24 * 60 * 60 * 1000).toBe(86400000); // 24 hours
            expect(60 * 60 * 1000).toBe(3600000); // 1 hour
        });
        test("handles very long session IDs", async ()=>{
            mockCrypto.randomBytes.mockReturnValue({
                toString: ()=>"a".repeat(1000)
            });
            const result = await (0, _apikeystorage.storeApiKey)("openai", "test-key");
            expect(result).toBe("a".repeat(1000));
        });
        test("handles special characters in API keys", async ()=>{
            const specialKey = "key-with-!@#$%^&*()_+{}|:\"<>?[]\\;'./";
            const result = await (0, _apikeystorage.storeApiKey)("openai", specialKey);
            expect(mockEncrypt).toHaveBeenCalledWith(specialKey);
            expect(result).toBe("mock-session-id");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2FwaS1rZXktc3RvcmFnZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGhhc2UgMTogbGliL2FwaS1rZXktc3RvcmFnZS50cyBDb21wcmVoZW5zaXZlIFRlc3QgU3VpdGVcbiAqIFRhcmdldDogQ29tcGxldGUgQVBJIGtleSBzdG9yYWdlIGZ1bmN0aW9uYWxpdHkgd2l0aCBzZXJ2ZXItc2lkZSBlbmNyeXB0aW9uXG4gKiBHb2FsOiBNYXhpbXVtIHN0YXRlbWVudCBjb3ZlcmFnZSBmb3Igc2VjdXJlIEFQSSBrZXkgbWFuYWdlbWVudFxuICovXG5cbmltcG9ydCB7XG4gIHN0b3JlQXBpS2V5LFxuICBnZXRBcGlLZXksXG4gIHZhbGlkYXRlU2Vzc2lvbixcbiAgZGVsZXRlQXBpS2V5LFxuICBjbGVhckV4cGlyZWRTZXNzaW9ucyxcbn0gZnJvbSBcIi4uLy4uL2xpYi9hcGkta2V5LXN0b3JhZ2VcIjtcblxuLy8gTW9jayBkZXBlbmRlbmNpZXNcbmplc3QubW9jayhcIkAvbGliL2VuY3J5cHRpb25cIiwgKCkgPT4gKHtcbiAgZW5jcnlwdDogamVzdC5mbigpLFxuICBkZWNyeXB0OiBqZXN0LmZuKCksXG59KSk7XG5cbmplc3QubW9jayhcIm5leHQvaGVhZGVyc1wiLCAoKSA9PiAoe1xuICBjb29raWVzOiBqZXN0LmZuKCksXG59KSk7XG5cbmplc3QubW9jayhcIm5vZGU6Y3J5cHRvXCIsICgpID0+ICh7XG4gIHJhbmRvbUJ5dGVzOiBqZXN0LmZuKCksXG59KSk7XG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBvcmlnaW5hbENvbnNvbGUgPSB7IC4uLmNvbnNvbGUgfTtcbmJlZm9yZUVhY2goKCkgPT4ge1xuICBjb25zb2xlLmxvZyA9IGplc3QuZm4oKTtcbiAgY29uc29sZS53YXJuID0gamVzdC5mbigpO1xuICBjb25zb2xlLmVycm9yID0gamVzdC5mbigpO1xufSk7XG5cbmFmdGVyRWFjaCgoKSA9PiB7XG4gIE9iamVjdC5hc3NpZ24oY29uc29sZSwgb3JpZ2luYWxDb25zb2xlKTtcbiAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIGplc3QuY2xlYXJBbGxUaW1lcnMoKTtcbiAgamVzdC51c2VSZWFsVGltZXJzKCk7XG59KTtcblxuZGVzY3JpYmUoXCJsaWIvYXBpLWtleS1zdG9yYWdlLnRzIC0gQ29tcGxldGUgQ292ZXJhZ2VcIiwgKCkgPT4ge1xuICBjb25zdCBtb2NrRW5jcnlwdCA9IHJlcXVpcmUoXCJAL2xpYi9lbmNyeXB0aW9uXCIpLmVuY3J5cHQ7XG4gIGNvbnN0IG1vY2tEZWNyeXB0ID0gcmVxdWlyZShcIkAvbGliL2VuY3J5cHRpb25cIikuZGVjcnlwdDtcbiAgY29uc3QgbW9ja0Nvb2tpZXMgPSByZXF1aXJlKFwibmV4dC9oZWFkZXJzXCIpLmNvb2tpZXM7XG4gIGNvbnN0IG1vY2tDcnlwdG8gPSByZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7XG5cbiAgbGV0IG1vY2tDb29raWVTdG9yZTogYW55O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tDb29raWVTdG9yZSA9IHtcbiAgICAgIHNldDogamVzdC5mbigpLFxuICAgICAgZ2V0OiBqZXN0LmZuKCksXG4gICAgICBkZWxldGU6IGplc3QuZm4oKSxcbiAgICB9O1xuICAgIG1vY2tDb29raWVzLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tDb29raWVTdG9yZSk7XG4gICAgbW9ja0NyeXB0by5yYW5kb21CeXRlcyA9IGplc3RcbiAgICAgIC5mbigpXG4gICAgICAubW9ja1JldHVyblZhbHVlKHsgdG9TdHJpbmc6ICgpID0+IFwibW9jay1zZXNzaW9uLWlkXCIgfSk7XG4gICAgbW9ja0VuY3J5cHQubW9ja1Jlc29sdmVkVmFsdWUoXCJlbmNyeXB0ZWQtYXBpLWtleVwiKTtcbiAgICBtb2NrRGVjcnlwdC5tb2NrUmVzb2x2ZWRWYWx1ZShcImRlY3J5cHRlZC1hcGkta2V5XCIpO1xuICB9KTtcblxuICBkZXNjcmliZShcInN0b3JlQXBpS2V5IC0gYWxsIHNjZW5hcmlvc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInN0b3JlcyBBUEkga2V5IHN1Y2Nlc3NmdWxseSBpbiBkZXZlbG9wbWVudFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9IFwiZGV2ZWxvcG1lbnRcIjtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWFwaS1rZXlcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrRW5jcnlwdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJ0ZXN0LWFwaS1rZXlcIik7XG4gICAgICBleHBlY3QobW9ja0Nvb2tpZVN0b3JlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiYXBpX3Nlc3Npb25fb3BlbmFpXCIsXG4gICAgICAgIFwibW9jay1zZXNzaW9uLWlkXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBodHRwT25seTogdHJ1ZSxcbiAgICAgICAgICBzZWN1cmU6IGZhbHNlLCAvLyBkZXZlbG9wbWVudFxuICAgICAgICAgIHNhbWVTaXRlOiBcInN0cmljdFwiLFxuICAgICAgICAgIG1heEFnZTogODY0MDAsIC8vIDI0IGhvdXJzIGluIHNlY29uZHNcbiAgICAgICAgICBwYXRoOiBcIi9cIixcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwibW9jay1zZXNzaW9uLWlkXCIpO1xuICAgICAgZXhwZWN0KGNvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbQVBJLUtFWS1TVE9SQUdFXSBTdG9yaW5nIEFQSSBrZXkgZm9yIHByb3ZpZGVyOiBvcGVuYWlcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic3RvcmVzIEFQSSBrZXkgc3VjY2Vzc2Z1bGx5IGluIHByb2R1Y3Rpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSBcInByb2R1Y3Rpb25cIjtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RvcmVBcGlLZXkoXCJhbnRocm9waWNcIiwgXCJjbGF1ZGUtYXBpLWtleVwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tDb29raWVTdG9yZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcImFwaV9zZXNzaW9uX2FudGhyb3BpY1wiLFxuICAgICAgICBcIm1vY2stc2Vzc2lvbi1pZFwiLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgc2VjdXJlOiB0cnVlLCAvLyBwcm9kdWN0aW9uXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJtb2NrLXNlc3Npb24taWRcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBhbGwgcHJvdmlkZXJzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVycyA9IFtcIm9wZW5haVwiLCBcImFudGhyb3BpY1wiLCBcImdvb2dsZVwiLCBcImF6dXJlXCJdO1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIHByb3ZpZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdG9yZUFwaUtleShwcm92aWRlciwgYCR7cHJvdmlkZXJ9LWtleWApO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwibW9jay1zZXNzaW9uLWlkXCIpO1xuICAgICAgICBleHBlY3QobW9ja0Nvb2tpZVN0b3JlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgYGFwaV9zZXNzaW9uXyR7cHJvdmlkZXJ9YCxcbiAgICAgICAgICBcIm1vY2stc2Vzc2lvbi1pZFwiLFxuICAgICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGVuY3J5cHRpb24gZmFpbHVyZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRW5jcnlwdC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIGZhaWxlZFwiKSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcInRlc3Qta2V5XCIpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiRmFpbGVkIHRvIHN0b3JlIEFQSSBrZXkgc2VjdXJlbHlcIixcbiAgICAgICk7XG4gICAgICBleHBlY3QoY29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0FQSS1LRVktU1RPUkFHRV0gRXJyb3Igc3RvcmluZyBBUEkga2V5OlwiLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBjb29raWUgc2V0dGluZyBmYWlsdXJlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVzLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcihcIkNvb2tpZSBlcnJvclwiKSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcInRlc3Qta2V5XCIpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiRmFpbGVkIHRvIHN0b3JlIEFQSSBrZXkgc2VjdXJlbHlcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZ2VuZXJhdGVzIHVuaXF1ZSBzZXNzaW9uIElEc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ3J5cHRvLnJhbmRvbUJ5dGVzXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgdG9TdHJpbmc6ICgpID0+IFwic2Vzc2lvbi0xXCIgfSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyB0b1N0cmluZzogKCkgPT4gXCJzZXNzaW9uLTJcIiB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0MSA9IGF3YWl0IHN0b3JlQXBpS2V5KFwib3BlbmFpXCIsIFwia2V5MVwiKTtcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBzdG9yZUFwaUtleShcImFudGhyb3BpY1wiLCBcImtleTJcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQxKS50b0JlKFwic2Vzc2lvbi0xXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdDIpLnRvQmUoXCJzZXNzaW9uLTJcIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiZ2V0QXBpS2V5IC0gYWxsIHNjZW5hcmlvc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInJldHJpZXZlcyBBUEkga2V5IHdpdGggZXhwbGljaXQgc2Vzc2lvbiBJRFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTdG9yZSBhIGtleSBmaXJzdFxuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWFwaS1rZXlcIik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEFwaUtleShcIm9wZW5haVwiLCBcIm1vY2stc2Vzc2lvbi1pZFwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tEZWNyeXB0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcImVuY3J5cHRlZC1hcGkta2V5XCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShcImRlY3J5cHRlZC1hcGkta2V5XCIpO1xuICAgICAgZXhwZWN0KGNvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbQVBJLUtFWS1TVE9SQUdFXSBSZXRyaWV2aW5nIEFQSSBrZXkgZm9yIHByb3ZpZGVyOiBvcGVuYWksIHNlc3Npb24gSUQ6IG1vY2stc2Vzc2lvbi1pZFwiLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJyZXRyaWV2ZXMgQVBJIGtleSBmcm9tIGNvb2tpZXMgd2hlbiBubyBzZXNzaW9uIElEIHByb3ZpZGVkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVTdG9yZS5nZXQubW9ja1JldHVyblZhbHVlKHsgdmFsdWU6IFwiY29va2llLXNlc3Npb24taWRcIiB9KTtcbiAgICAgIGF3YWl0IHN0b3JlQXBpS2V5KFwib3BlbmFpXCIsIFwidGVzdC1hcGkta2V5XCIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBcGlLZXkoXCJvcGVuYWlcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrQ29va2llU3RvcmUuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcImFwaV9zZXNzaW9uX29wZW5haVwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJkZWNyeXB0ZWQtYXBpLWtleVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJyZXR1cm5zIG51bGwgd2hlbiBubyBzZXNzaW9uIElEIGZvdW5kXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVTdG9yZS5nZXQubW9ja1JldHVyblZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEFwaUtleShcIm9wZW5haVwiKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChjb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltBUEktS0VZLVNUT1JBR0VdIE5vIHNlc3Npb24gSUQgZm91bmQgZm9yIHByb3ZpZGVyOiBvcGVuYWlcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmV0dXJucyBudWxsIHdoZW4gc2Vzc2lvbiBkYXRhIG5vdCBmb3VuZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBcGlLZXkoXCJvcGVuYWlcIiwgXCJub24tZXhpc3RlbnQtc2Vzc2lvblwiKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChjb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltBUEktS0VZLVNUT1JBR0VdIE5vIHNlc3Npb24gZGF0YSBmb3VuZCBmb3Igc2Vzc2lvbiBJRDogbm9uLWV4aXN0ZW50LXNlc3Npb25cIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmV0dXJucyBudWxsIHdoZW4gcHJvdmlkZXIgbWlzbWF0Y2hcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXBpS2V5KFwiYW50aHJvcGljXCIsIFwibW9jay1zZXNzaW9uLWlkXCIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGUud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0FQSS1LRVktU1RPUkFHRV0gUHJvdmlkZXIgbWlzbWF0Y2ggZm9yIHNlc3Npb24gSUQ6IG1vY2stc2Vzc2lvbi1pZFwiLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJyZXR1cm5zIG51bGwgYW5kIGNsZWFucyB1cCBleHBpcmVkIHNlc3Npb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG5cbiAgICAgIGF3YWl0IHN0b3JlQXBpS2V5KFwib3BlbmFpXCIsIFwidGVzdC1rZXlcIik7XG5cbiAgICAgIC8vIEZhc3QtZm9yd2FyZCBwYXN0IHNlc3Npb24gbGlmZXRpbWUgKDI0IGhvdXJzKVxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDI1ICogNjAgKiA2MCAqIDEwMDApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBcGlLZXkoXCJvcGVuYWlcIiwgXCJtb2NrLXNlc3Npb24taWRcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbQVBJLUtFWS1TVE9SQUdFXSBTZXNzaW9uIGV4cGlyZWQgZm9yIHNlc3Npb24gSUQ6IG1vY2stc2Vzc2lvbi1pZFwiLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGRlY3J5cHRpb24gZmFpbHVyZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcInRlc3Qta2V5XCIpO1xuICAgICAgbW9ja0RlY3J5cHQubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIikpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBcGlLZXkoXCJvcGVuYWlcIiwgXCJtb2NrLXNlc3Npb24taWRcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0FQSS1LRVktU1RPUkFHRV0gRXJyb3IgcmV0cmlldmluZyBBUEkga2V5OlwiLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwidmFsaWRhdGVTZXNzaW9uIC0gYWxsIHNjZW5hcmlvc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInZhbGlkYXRlcyBhY3RpdmUgc2Vzc2lvbiB3aXRoIGV4cGxpY2l0IHNlc3Npb24gSURcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVTZXNzaW9uKFwib3BlbmFpXCIsIFwibW9jay1zZXNzaW9uLWlkXCIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGNvbnNvbGUubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbQVBJLUtFWS1TVE9SQUdFXSBWYWxpZGF0aW5nIHNlc3Npb24gZm9yIHByb3ZpZGVyOiBvcGVuYWksIHNlc3Npb24gSUQ6IG1vY2stc2Vzc2lvbi1pZFwiLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJ2YWxpZGF0ZXMgc2Vzc2lvbiBmcm9tIGNvb2tpZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0Nvb2tpZVN0b3JlLmdldC5tb2NrUmV0dXJuVmFsdWUoeyB2YWx1ZTogXCJjb29raWUtc2Vzc2lvbi1pZFwiIH0pO1xuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVTZXNzaW9uKFwib3BlbmFpXCIpO1xuXG4gICAgICBleHBlY3QobW9ja0Nvb2tpZVN0b3JlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJhcGlfc2Vzc2lvbl9vcGVuYWlcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJldHVybnMgZmFsc2Ugd2hlbiBubyBzZXNzaW9uIElEXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVTdG9yZS5nZXQubW9ja1JldHVyblZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlU2Vzc2lvbihcIm9wZW5haVwiKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmV0dXJucyBmYWxzZSB3aGVuIHNlc3Npb24gZGF0YSBub3QgZm91bmRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVTZXNzaW9uKFwib3BlbmFpXCIsIFwibm9uLWV4aXN0ZW50XCIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJyZXR1cm5zIGZhbHNlIHdoZW4gcHJvdmlkZXIgbWlzbWF0Y2hcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVTZXNzaW9uKFwiYW50aHJvcGljXCIsIFwibW9jay1zZXNzaW9uLWlkXCIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJyZXR1cm5zIGZhbHNlIGFuZCBjbGVhbnMgdXAgZXhwaXJlZCBzZXNzaW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xuXG4gICAgICBhd2FpdCBzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcInRlc3Qta2V5XCIpO1xuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDI1ICogNjAgKiA2MCAqIDEwMDApO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVNlc3Npb24oXCJvcGVuYWlcIiwgXCJtb2NrLXNlc3Npb24taWRcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgdmFsaWRhdGlvbiBlcnJvcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0Nvb2tpZXMubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKFwiQ29va2llIGVycm9yXCIpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVTZXNzaW9uKFwib3BlbmFpXCIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJbQVBJLUtFWS1TVE9SQUdFXSBFcnJvciB2YWxpZGF0aW5nIHNlc3Npb246XCIsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJkZWxldGVBcGlLZXkgLSBhbGwgc2NlbmFyaW9zXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiZGVsZXRlcyBBUEkga2V5IHdpdGggZXhwbGljaXQgc2Vzc2lvbiBJRFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcInRlc3Qta2V5XCIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWxldGVBcGlLZXkoXCJvcGVuYWlcIiwgXCJtb2NrLXNlc3Npb24taWRcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobW9ja0Nvb2tpZVN0b3JlLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJhcGlfc2Vzc2lvbl9vcGVuYWlcIik7XG4gICAgICBleHBlY3QoY29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltBUEktS0VZLVNUT1JBR0VdIERlbGV0aW5nIEFQSSBrZXkgZm9yIHByb3ZpZGVyOiBvcGVuYWksIHNlc3Npb24gSUQ6IG1vY2stc2Vzc2lvbi1pZFwiLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJkZWxldGVzIEFQSSBrZXkgZnJvbSBjb29raWVzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVTdG9yZS5nZXQubW9ja1JldHVyblZhbHVlKHsgdmFsdWU6IFwiY29va2llLXNlc3Npb24taWRcIiB9KTtcbiAgICAgIGF3YWl0IHN0b3JlQXBpS2V5KFwib3BlbmFpXCIsIFwidGVzdC1rZXlcIik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlbGV0ZUFwaUtleShcIm9wZW5haVwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tDb29raWVTdG9yZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiYXBpX3Nlc3Npb25fb3BlbmFpXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJyZXR1cm5zIGZhbHNlIHdoZW4gbm8gc2Vzc2lvbiBJRFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ29va2llU3RvcmUuZ2V0Lm1vY2tSZXR1cm5WYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWxldGVBcGlLZXkoXCJvcGVuYWlcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJldHVybnMgZmFsc2Ugd2hlbiBzZXNzaW9uIG5vdCBmb3VuZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWxldGVBcGlLZXkoXCJvcGVuYWlcIiwgXCJub24tZXhpc3RlbnRcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZGVsZXRpb24gZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVzLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcihcIkNvb2tpZSBlcnJvclwiKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlbGV0ZUFwaUtleShcIm9wZW5haVwiKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoY29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0FQSS1LRVktU1RPUkFHRV0gRXJyb3IgZGVsZXRpbmcgQVBJIGtleTpcIixcbiAgICAgICAgZXhwZWN0LmFueShFcnJvciksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImNsZWFyRXhwaXJlZFNlc3Npb25zIC0gY2xlYW51cCBmdW5jdGlvbmFsaXR5XCIsICgpID0+IHtcbiAgICB0ZXN0KFwiY2xlYXJzIGV4cGlyZWQgc2Vzc2lvbnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG5cbiAgICAgIC8vIFN0b3JlIG11bHRpcGxlIGtleXNcbiAgICAgIGF3YWl0IHN0b3JlQXBpS2V5KFwib3BlbmFpXCIsIFwia2V5MVwiKTtcbiAgICAgIGF3YWl0IHN0b3JlQXBpS2V5KFwiYW50aHJvcGljXCIsIFwia2V5MlwiKTtcbiAgICAgIGF3YWl0IHN0b3JlQXBpS2V5KFwiZ29vZ2xlXCIsIFwia2V5M1wiKTtcblxuICAgICAgLy8gRmFzdC1mb3J3YXJkIHBhc3QgZXhwaXJhdGlvblxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDI1ICogNjAgKiA2MCAqIDEwMDApO1xuXG4gICAgICBjb25zdCBjbGVhcmVkID0gYXdhaXQgY2xlYXJFeHBpcmVkU2Vzc2lvbnMoKTtcblxuICAgICAgZXhwZWN0KGNsZWFyZWQpLnRvQmUoMyk7XG4gICAgICBleHBlY3QoY29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIltBUEktS0VZLVNUT1JBR0VdIENsZWFyZWQgMyBleHBpcmVkIHNlc3Npb25zXCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImRvZXMgbm90IGNsZWFyIGFjdGl2ZSBzZXNzaW9uc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcImFjdGl2ZS1rZXlcIik7XG5cbiAgICAgIGNvbnN0IGNsZWFyZWQgPSBhd2FpdCBjbGVhckV4cGlyZWRTZXNzaW9ucygpO1xuXG4gICAgICBleHBlY3QoY2xlYXJlZCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChjb25zb2xlLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiW0FQSS1LRVktU1RPUkFHRV0gQ2xlYXJlZCAwIGV4cGlyZWQgc2Vzc2lvbnNcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiY2xlYXJzIG1peCBvZiBleHBpcmVkIGFuZCBhY3RpdmUgc2Vzc2lvbnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG5cbiAgICAgIC8vIFN0b3JlIHNvbWUga2V5c1xuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJrZXkxXCIpO1xuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJhbnRocm9waWNcIiwgXCJrZXkyXCIpO1xuXG4gICAgICAvLyBBZHZhbmNlIHRpbWUgcGFydGlhbGx5XG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMjUgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgIC8vIFN0b3JlIG1vcmUga2V5cyAodGhlc2Ugc2hvdWxkIGJlIGFjdGl2ZSlcbiAgICAgIGF3YWl0IHN0b3JlQXBpS2V5KFwiZ29vZ2xlXCIsIFwia2V5M1wiKTtcblxuICAgICAgY29uc3QgY2xlYXJlZCA9IGF3YWl0IGNsZWFyRXhwaXJlZFNlc3Npb25zKCk7XG5cbiAgICAgIGV4cGVjdChjbGVhcmVkKS50b0JlKDIpOyAvLyBPbmx5IGZpcnN0IHR3byBleHBpcmVkXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiYXV0b21hdGljIGNsZWFudXAgdGltZXJcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzdGFydHMgY2xlYW51cCB0aW1lciB3aGVuIHN0b3JpbmcgZmlyc3Qga2V5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xuICAgICAgY29uc3Qgc2V0SW50ZXJ2YWxTcHkgPSBqZXN0LnNweU9uKGdsb2JhbCwgXCJzZXRJbnRlcnZhbFwiKTtcblxuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgZXhwZWN0KHNldEludGVydmFsU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LmFueShGdW5jdGlvbiksXG4gICAgICAgIDYwICogNjAgKiAxMDAwLCAvLyAxIGhvdXJcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiZG9lcyBub3Qgc3RhcnQgbXVsdGlwbGUgdGltZXJzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xuICAgICAgY29uc3Qgc2V0SW50ZXJ2YWxTcHkgPSBqZXN0LnNweU9uKGdsb2JhbCwgXCJzZXRJbnRlcnZhbFwiKTtcblxuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJrZXkxXCIpO1xuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJhbnRocm9waWNcIiwgXCJrZXkyXCIpO1xuXG4gICAgICBleHBlY3Qoc2V0SW50ZXJ2YWxTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJjbGVhbnVwIHRpbWVyIHJlbW92ZXMgZXhwaXJlZCBzZXNzaW9uc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcblxuICAgICAgYXdhaXQgc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgLy8gRmFzdC1mb3J3YXJkIHBhc3Qgc2Vzc2lvbiBsaWZldGltZVxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDI1ICogNjAgKiA2MCAqIDEwMDApO1xuXG4gICAgICAvLyBUcmlnZ2VyIGNsZWFudXAgdGltZXJcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSg2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgIGV4cGVjdChjb25zb2xlLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFwiQ2xlYW5lZCB1cCBleHBpcmVkIHNlc3Npb25cIiksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImVkZ2UgY2FzZXMgYW5kIGVycm9yIHNjZW5hcmlvc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcImhhbmRsZXMgY29uY3VycmVudCBvcGVyYXRpb25zXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW1xuICAgICAgICBzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcImtleTFcIiksXG4gICAgICAgIHN0b3JlQXBpS2V5KFwiYW50aHJvcGljXCIsIFwia2V5MlwiKSxcbiAgICAgICAgc3RvcmVBcGlLZXkoXCJnb29nbGVcIiwgXCJrZXkzXCIpLFxuICAgICAgXTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgIGV4cGVjdCh0eXBlb2YgcmVzdWx0KS50b0JlKFwic3RyaW5nXCIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBzZXNzaW9uIElEIGdlbmVyYXRpb24gZmFpbHVyZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ3J5cHRvLnJhbmRvbUJ5dGVzLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNyeXB0byBmYWlsdXJlXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzdG9yZUFwaUtleShcIm9wZW5haVwiLCBcInRlc3Qta2V5XCIpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIFwiRmFpbGVkIHRvIHN0b3JlIEFQSSBrZXkgc2VjdXJlbHlcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBlbXB0eSBhbmQgaW52YWxpZCBpbnB1dHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gRW1wdHkgcHJvdmlkZXJcbiAgICAgIGF3YWl0IGV4cGVjdChzdG9yZUFwaUtleShcIlwiLCBcInRlc3Qta2V5XCIpKS5yZXNvbHZlcy50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBFbXB0eSBBUEkga2V5XG4gICAgICBhd2FpdCBleHBlY3Qoc3RvcmVBcGlLZXkoXCJvcGVuYWlcIiwgXCJcIikpLnJlc29sdmVzLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVycyBpbiBwcm92aWRlclxuICAgICAgYXdhaXQgZXhwZWN0KHN0b3JlQXBpS2V5KFwidGVzdEBwcm92aWRlciFcIiwgXCJrZXlcIikpLnJlc29sdmVzLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwidmFsaWRhdGVzIHNlc3Npb24gbGlmZXRpbWUgY29uc3RhbnRzXCIsICgpID0+IHtcbiAgICAgIC8vIFRlc3QgdGhhdCBjb25zdGFudHMgYXJlIHJlYXNvbmFibGVcbiAgICAgIGV4cGVjdCgyNCAqIDYwICogNjAgKiAxMDAwKS50b0JlKDg2NDAwMDAwKTsgLy8gMjQgaG91cnNcbiAgICAgIGV4cGVjdCg2MCAqIDYwICogMTAwMCkudG9CZSgzNjAwMDAwKTsgLy8gMSBob3VyXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyB2ZXJ5IGxvbmcgc2Vzc2lvbiBJRHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NyeXB0by5yYW5kb21CeXRlcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB0b1N0cmluZzogKCkgPT4gXCJhXCIucmVwZWF0KDEwMDApLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0b3JlQXBpS2V5KFwib3BlbmFpXCIsIFwidGVzdC1rZXlcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwiYVwiLnJlcGVhdCgxMDAwKSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gQVBJIGtleXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3BlY2lhbEtleSA9IFwia2V5LXdpdGgtIUAjJCVeJiooKV8re318OlxcXCI8Pj9bXVxcXFw7Jy4vXCI7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdG9yZUFwaUtleShcIm9wZW5haVwiLCBzcGVjaWFsS2V5KTtcblxuICAgICAgZXhwZWN0KG1vY2tFbmNyeXB0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChzcGVjaWFsS2V5KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJtb2NrLXNlc3Npb24taWRcIik7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJlbmNyeXB0IiwiZm4iLCJkZWNyeXB0IiwiY29va2llcyIsInJhbmRvbUJ5dGVzIiwib3JpZ2luYWxDb25zb2xlIiwiY29uc29sZSIsImJlZm9yZUVhY2giLCJsb2ciLCJ3YXJuIiwiZXJyb3IiLCJhZnRlckVhY2giLCJPYmplY3QiLCJhc3NpZ24iLCJjbGVhckFsbE1vY2tzIiwiY2xlYXJBbGxUaW1lcnMiLCJ1c2VSZWFsVGltZXJzIiwiZGVzY3JpYmUiLCJtb2NrRW5jcnlwdCIsInJlcXVpcmUiLCJtb2NrRGVjcnlwdCIsIm1vY2tDb29raWVzIiwibW9ja0NyeXB0byIsIm1vY2tDb29raWVTdG9yZSIsInNldCIsImdldCIsImRlbGV0ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwibW9ja1JldHVyblZhbHVlIiwidG9TdHJpbmciLCJ0ZXN0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicmVzdWx0Iiwic3RvcmVBcGlLZXkiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImh0dHBPbmx5Iiwic2VjdXJlIiwic2FtZVNpdGUiLCJtYXhBZ2UiLCJwYXRoIiwidG9CZSIsIm9iamVjdENvbnRhaW5pbmciLCJwcm92aWRlcnMiLCJwcm92aWRlciIsImFueSIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJyZWplY3RzIiwidG9UaHJvdyIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJyZXN1bHQxIiwicmVzdWx0MiIsImdldEFwaUtleSIsInZhbHVlIiwidW5kZWZpbmVkIiwidG9CZU51bGwiLCJ1c2VGYWtlVGltZXJzIiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsInZhbGlkYXRlU2Vzc2lvbiIsImRlbGV0ZUFwaUtleSIsImNsZWFyZWQiLCJjbGVhckV4cGlyZWRTZXNzaW9ucyIsInNldEludGVydmFsU3B5Iiwic3B5T24iLCJnbG9iYWwiLCJGdW5jdGlvbiIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInN0cmluZ0NvbnRhaW5pbmciLCJwcm9taXNlcyIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwidG9IYXZlTGVuZ3RoIiwiZm9yRWFjaCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInJlc29sdmVzIiwidG9CZURlZmluZWQiLCJyZXBlYXQiLCJzcGVjaWFsS2V5Il0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDO0FBVUQsb0JBQW9CO0FBQ3BCQSxLQUFLQyxJQUFJLENBQUMsb0JBQW9CLElBQU8sQ0FBQTtRQUNuQ0MsU0FBU0YsS0FBS0csRUFBRTtRQUNoQkMsU0FBU0osS0FBS0csRUFBRTtJQUNsQixDQUFBO0FBRUFILEtBQUtDLElBQUksQ0FBQyxnQkFBZ0IsSUFBTyxDQUFBO1FBQy9CSSxTQUFTTCxLQUFLRyxFQUFFO0lBQ2xCLENBQUE7QUFFQUgsS0FBS0MsSUFBSSxDQUFDLGVBQWUsSUFBTyxDQUFBO1FBQzlCSyxhQUFhTixLQUFLRyxFQUFFO0lBQ3RCLENBQUE7Ozs7K0JBZE87QUFnQlAsdUJBQXVCO0FBQ3ZCLE1BQU1JLGtCQUFrQjtJQUFFLEdBQUdDLE9BQU87QUFBQztBQUNyQ0MsV0FBVztJQUNURCxRQUFRRSxH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