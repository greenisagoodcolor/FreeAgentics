{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/safety/data-validation.ts"],"sourcesContent":["interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  sanitizedData?: any;\n}\n\ninterface SafetyConfig {\n  maxDataSize: number; // bytes\n  maxNestingDepth: number;\n  allowedDataTypes: string[];\n  sanitizeStrings: boolean;\n  validateSchema: boolean;\n}\n\nclass DataValidationService {\n  private readonly defaultConfig: SafetyConfig = {\n    maxDataSize: 100 * 1024 * 1024, // 100MB\n    maxNestingDepth: 10,\n    allowedDataTypes: [\"string\", \"number\", \"boolean\", \"object\", \"array\"],\n    sanitizeStrings: true,\n    validateSchema: true,\n  };\n\n  private config: SafetyConfig;\n\n  constructor(config?: Partial<SafetyConfig>) {\n    this.config = { ...this.defaultConfig, ...config };\n  }\n\n  validateExperimentData(data: any): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    let sanitizedData = data;\n\n    try {\n      // 1. Size validation\n      const sizeResult = this.validateSize(data);\n      if (!sizeResult.isValid) {\n        errors.push(...sizeResult.errors);\n      }\n\n      // 2. Structure validation\n      const structureResult = this.validateStructure(data);\n      if (!structureResult.isValid) {\n        errors.push(...structureResult.errors);\n      }\n      warnings.push(...structureResult.warnings);\n\n      // 3. Content sanitization\n      if (this.config.sanitizeStrings) {\n        const sanitizeResult = this.sanitizeData(data);\n        sanitizedData = sanitizeResult.sanitizedData;\n        warnings.push(...sanitizeResult.warnings);\n      }\n\n      // 4. Schema validation for experiment data\n      if (this.config.validateSchema) {\n        const schemaResult = this.validateExperimentSchema(sanitizedData);\n        if (!schemaResult.isValid) {\n          errors.push(...schemaResult.errors);\n        }\n      }\n\n      // 5. Security validation\n      const securityResult = this.validateSecurity(sanitizedData);\n      if (!securityResult.isValid) {\n        errors.push(...securityResult.errors);\n      }\n      warnings.push(...securityResult.warnings);\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings,\n        sanitizedData: errors.length === 0 ? sanitizedData : undefined,\n      };\n    } catch (error) {\n      return {\n        isValid: false,\n        errors: [\n          `Validation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        ],\n        warnings,\n      };\n    }\n  }\n\n  private validateSize(data: any): ValidationResult {\n    const errors: string[] = [];\n\n    try {\n      const dataSize = new TextEncoder().encode(JSON.stringify(data)).length;\n\n      if (dataSize > this.config.maxDataSize) {\n        errors.push(\n          `Data size (${dataSize} bytes) exceeds maximum allowed size (${this.config.maxDataSize} bytes)`,\n        );\n      }\n\n      return { isValid: errors.length === 0, errors, warnings: [] };\n    } catch (error) {\n      return {\n        isValid: false,\n        errors: [\"Failed to calculate data size\"],\n        warnings: [],\n      };\n    }\n  }\n\n  private validateStructure(data: any, depth = 0): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (depth > this.config.maxNestingDepth) {\n      errors.push(\n        `Maximum nesting depth (${this.config.maxNestingDepth}) exceeded`,\n      );\n      return { isValid: false, errors, warnings };\n    }\n\n    const dataType = Array.isArray(data) ? \"array\" : typeof data;\n\n    if (!this.config.allowedDataTypes.includes(dataType)) {\n      errors.push(`Data type '${dataType}' is not allowed`);\n      return { isValid: false, errors, warnings };\n    }\n\n    // Recursively validate nested objects\n    if (typeof data === \"object\" && data !== null) {\n      if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n          const result = this.validateStructure(data[i], depth + 1);\n          if (!result.isValid) {\n            errors.push(...result.errors.map((err) => `Array[${i}]: ${err}`));\n          }\n          warnings.push(...result.warnings);\n        }\n      } else {\n        const keys = Object.keys(data);\n        if (keys.length > 10000) {\n          warnings.push(\n            `Object has ${keys.length} keys, which may impact performance`,\n          );\n        }\n\n        for (const key of keys) {\n          // Validate key\n          if (typeof key !== \"string\") {\n            errors.push(`Invalid object key type: ${typeof key}`);\n          }\n\n          if (key.length > 1000) {\n            errors.push(`Object key too long: ${key.length} characters`);\n          }\n\n          // Validate value\n          const result = this.validateStructure(data[key], depth + 1);\n          if (!result.isValid) {\n            errors.push(\n              ...result.errors.map((err) => `Object[${key}]: ${err}`),\n            );\n          }\n          warnings.push(...result.warnings);\n        }\n      }\n    }\n\n    return { isValid: errors.length === 0, errors, warnings };\n  }\n\n  private sanitizeData(data: any): { sanitizedData: any; warnings: string[] } {\n    const warnings: string[] = [];\n\n    const sanitize = (obj: any): any => {\n      if (typeof obj === \"string\") {\n        // Remove potentially dangerous HTML/JS\n        const sanitized = obj\n          .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\")\n          .replace(/javascript:/gi, \"\")\n          .replace(/on\\w+\\s*=/gi, \"\")\n          .trim();\n\n        if (sanitized !== obj) {\n          warnings.push(\"Potentially dangerous content removed from string\");\n        }\n\n        return sanitized;\n      }\n\n      if (Array.isArray(obj)) {\n        return obj.map(sanitize);\n      }\n\n      if (typeof obj === \"object\" && obj !== null) {\n        const sanitized: any = {};\n        for (const [key, value] of Object.entries(obj)) {\n          const sanitizedKey = this.sanitizeKey(key);\n          if (sanitizedKey !== key) {\n            warnings.push(\n              `Object key sanitized: '${key}' -> '${sanitizedKey}'`,\n            );\n          }\n          sanitized[sanitizedKey] = sanitize(value);\n        }\n        return sanitized;\n      }\n\n      return obj;\n    };\n\n    return {\n      sanitizedData: sanitize(data),\n      warnings,\n    };\n  }\n\n  private sanitizeKey(key: string): string {\n    // Remove potentially dangerous characters from object keys\n    return key.replace(/[<>\\\"'&]/g, \"\").trim();\n  }\n\n  private validateExperimentSchema(data: any): ValidationResult {\n    const errors: string[] = [];\n\n    // Check for required experiment fields\n    const requiredFields = [\"id\", \"name\", \"createdAt\"];\n    const missingFields = requiredFields.filter((field) => !(field in data));\n\n    if (missingFields.length > 0) {\n      errors.push(`Missing required fields: ${missingFields.join(\", \")}`);\n    }\n\n    // Validate field types\n    if (data.id && typeof data.id !== \"string\") {\n      errors.push('Field \"id\" must be a string');\n    }\n\n    if (data.name && typeof data.name !== \"string\") {\n      errors.push('Field \"name\" must be a string');\n    }\n\n    if (data.createdAt && typeof data.createdAt !== \"string\") {\n      errors.push('Field \"createdAt\" must be a string');\n    }\n\n    // Validate date format\n    if (data.createdAt && !this.isValidISODate(data.createdAt)) {\n      errors.push('Field \"createdAt\" must be a valid ISO date string');\n    }\n\n    // Validate metadata if present\n    if (data.metadata && typeof data.metadata !== \"object\") {\n      errors.push('Field \"metadata\" must be an object');\n    }\n\n    return { isValid: errors.length === 0, errors, warnings: [] };\n  }\n\n  private validateSecurity(data: any): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Check for potentially dangerous patterns\n    const dangerousPatterns = [\n      /eval\\s*\\(/gi,\n      /Function\\s*\\(/gi,\n      /setTimeout\\s*\\(/gi,\n      /setInterval\\s*\\(/gi,\n      /__proto__/gi,\n      /constructor/gi,\n      /prototype/gi,\n    ];\n\n    const checkForPatterns = (obj: any, path = \"\"): void => {\n      if (typeof obj === \"string\") {\n        for (const pattern of dangerousPatterns) {\n          if (pattern.test(obj)) {\n            warnings.push(\n              `Potentially dangerous pattern found at ${path}: ${pattern.source}`,\n            );\n          }\n        }\n      } else if (Array.isArray(obj)) {\n        obj.forEach((item, index) =>\n          checkForPatterns(item, `${path}[${index}]`),\n        );\n      } else if (typeof obj === \"object\" && obj !== null) {\n        for (const [key, value] of Object.entries(obj)) {\n          // Check for prototype pollution attempts\n          if (\n            key === \"__proto__\" ||\n            key === \"constructor\" ||\n            key === \"prototype\"\n          ) {\n            errors.push(`Dangerous property name detected: ${key}`);\n          }\n\n          checkForPatterns(value, path ? `${path}.${key}` : key);\n        }\n      }\n    };\n\n    checkForPatterns(data);\n\n    return { isValid: errors.length === 0, errors, warnings };\n  }\n\n  private isValidISODate(dateString: string): boolean {\n    const date = new Date(dateString);\n    return date.toISOString() === dateString;\n  }\n\n  validateSharedLink(linkData: any): ValidationResult {\n    const errors: string[] = [];\n\n    // Required fields for shared links\n    const requiredFields = [\n      \"id\",\n      \"experimentId\",\n      \"accessLevel\",\n      \"createdAt\",\n      \"createdBy\",\n    ];\n    const missingFields = requiredFields.filter(\n      (field) => !(field in linkData),\n    );\n\n    if (missingFields.length > 0) {\n      errors.push(`Missing required fields: ${missingFields.join(\", \")}`);\n    }\n\n    // Validate access level\n    const validAccessLevels = [\"view\", \"comment\", \"edit\"];\n    if (\n      linkData.accessLevel &&\n      !validAccessLevels.includes(linkData.accessLevel)\n    ) {\n      errors.push(\n        `Invalid access level: ${linkData.accessLevel}. Must be one of: ${validAccessLevels.join(\", \")}`,\n      );\n    }\n\n    // Validate expiration date if present\n    if (linkData.expiresAt && !this.isValidISODate(linkData.expiresAt)) {\n      errors.push('Field \"expiresAt\" must be a valid ISO date string');\n    }\n\n    // Check if expiration date is in the future\n    if (linkData.expiresAt) {\n      const expiryDate = new Date(linkData.expiresAt);\n      if (expiryDate <= new Date()) {\n        errors.push(\"Expiration date must be in the future\");\n      }\n    }\n\n    return { isValid: errors.length === 0, errors, warnings: [] };\n  }\n\n  validateVersionData(versionData: any): ValidationResult {\n    const errors: string[] = [];\n\n    // Basic structure validation\n    if (!versionData || typeof versionData !== \"object\") {\n      errors.push(\"Version data must be an object\");\n      return { isValid: false, errors, warnings: [] };\n    }\n\n    // Validate that it has some meaningful content\n    const keys = Object.keys(versionData);\n    if (keys.length === 0) {\n      errors.push(\"Version data cannot be empty\");\n    }\n\n    // Validate against experiment schema\n    const schemaResult = this.validateExperimentSchema(versionData);\n    errors.push(...schemaResult.errors);\n\n    return { isValid: errors.length === 0, errors, warnings: [] };\n  }\n}\n\n// Singleton instance\nexport const dataValidation = new DataValidationService();\n\n// Export types\nexport type { ValidationResult, SafetyConfig };\n\n// Export individual validation functions for backward compatibility\nexport function validateStorageData(data: any): boolean {\n  const result = dataValidation.validateExperimentData(data);\n  return result.isValid;\n}\n\nexport function sanitizeBeforeStorage(data: any): any {\n  const result = dataValidation.validateExperimentData(data);\n  return result.sanitizedData || data;\n}\n\nexport function validateDataIntegrity(data: any): boolean {\n  // Check if data has required integrity fields and structure\n  if (!data || typeof data !== \"object\") return false;\n  if (!data.checksum) return false;\n\n  // If data has content undefined but checksum exists, it's corrupted\n  if (data.content === undefined) {\n    throw new Error(\"Data corruption detected\");\n  }\n\n  // Simple integrity check - in real implementation would verify checksum\n  return true;\n}\n\nexport async function compressForStorage(data: any): Promise<any> {\n  const jsonString = JSON.stringify(data);\n  // Simulate compression by base64 encoding\n  const encoded = btoa(jsonString);\n\n  return {\n    compressed: true,\n    algorithm: \"gzip\",\n    data: encoded,\n    length: encoded.length,\n  };\n}\n\nexport async function decompressFromStorage(compressed: any): Promise<any> {\n  if (!compressed.compressed) return compressed;\n\n  try {\n    const decoded = atob(compressed.data);\n    return JSON.parse(decoded);\n  } catch (error) {\n    // Return original data on decompression failure\n    return compressed;\n  }\n}\n"],"names":["compressForStorage","dataValidation","decompressFromStorage","sanitizeBeforeStorage","validateDataIntegrity","validateStorageData","DataValidationService","constructor","config","defaultConfig","maxDataSize","maxNestingDepth","allowedDataTypes","sanitizeStrings","validateSchema","validateExperimentData","data","errors","warnings","sanitizedData","sizeResult","validateSize","isValid","push","structureResult","validateStructure","sanitizeResult","sanitizeData","schemaResult","validateExperimentSchema","securityResult","validateSecurity","length","undefined","error","Error","message","dataSize","TextEncoder","encode","JSON","stringify","depth","dataType","Array","isArray","includes","i","result","map","err","keys","Object","key","sanitize","obj","sanitized","replace","trim","value","entries","sanitizedKey","sanitizeKey","requiredFields","missingFields","filter","field","join","id","name","createdAt","isValidISODate","metadata","dangerousPatterns","checkForPatterns","path","pattern","test","source","forEach","item","index","dateString","date","Date","toISOString","validateSharedLink","linkData","validAccessLevels","accessLevel","expiresAt","expiryDate","validateVersionData","versionData","checksum","content","jsonString","encoded","btoa","compressed","algorithm","decoded","atob","parse"],"mappings":"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"}