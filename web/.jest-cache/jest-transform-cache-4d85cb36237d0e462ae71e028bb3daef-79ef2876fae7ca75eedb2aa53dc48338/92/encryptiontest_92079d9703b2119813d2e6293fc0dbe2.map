{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/__tests__/lib/encryption.test.ts"],"sourcesContent":["/**\n * Phase 1: lib/encryption.ts Comprehensive Test Suite\n * Target: Complete encryption and decryption functionality\n * Goal: Maximum statement coverage for security utilities\n */\n\nimport { encrypt, decrypt } from \"../../lib/encryption\";\n\ndescribe(\"lib/encryption.ts - Complete Coverage\", () => {\n  describe(\"encrypt function\", () => {\n    test(\"encrypts plain text strings\", () => {\n      const plainText = \"hello world\";\n      const encrypted = encrypt(plainText);\n\n      expect(encrypted).toBe(\"encrypted_hello world\");\n      expect(typeof encrypted).toBe(\"string\");\n    });\n\n    test(\"encrypts empty string\", () => {\n      const plainText = \"\";\n      const encrypted = encrypt(plainText);\n\n      expect(encrypted).toBe(\"encrypted_\");\n      expect(encrypted.length).toBe(10); // 'encrypted_'.length\n    });\n\n    test(\"encrypts strings with special characters\", () => {\n      const specialTexts = [\n        \"hello@world.com\",\n        \"password123!@#\",\n        \"text with spaces and symbols: {}[]()&*%$#@!\",\n        \"unicode: Ã±Ã¡Ã©Ã­Ã³Ãº ä¸­æ–‡ ðŸš€\",\n        'JSON: {\"key\": \"value\", \"number\": 123}',\n        \"SQL: SELECT * FROM users WHERE id = 1;\",\n        'HTML: <div class=\"test\">content</div>',\n      ];\n\n      specialTexts.forEach((text) => {\n        const encrypted = encrypt(text);\n        expect(encrypted).toBe(`encrypted_${text}`);\n        expect(encrypted.startsWith(\"encrypted_\")).toBe(true);\n      });\n    });\n\n    test(\"encrypts very long strings\", () => {\n      const longText = \"A\".repeat(10000);\n      const encrypted = encrypt(longText);\n\n      expect(encrypted).toBe(`encrypted_${longText}`);\n      expect(encrypted.length).toBe(longText.length + 10);\n    });\n\n    test(\"encrypts strings with newlines and tabs\", () => {\n      const textWithWhitespace = \"line1\\nline2\\tcolumn1\\tcolumn2\\r\\nline3\";\n      const encrypted = encrypt(textWithWhitespace);\n\n      expect(encrypted).toBe(`encrypted_${textWithWhitespace}`);\n    });\n\n    test(\"handles null-like strings\", () => {\n      const nullLikeStrings = [\"null\", \"undefined\", \"NaN\", \"0\", \"false\"];\n\n      nullLikeStrings.forEach((text) => {\n        const encrypted = encrypt(text);\n        expect(encrypted).toBe(`encrypted_${text}`);\n      });\n    });\n\n    test(\"consistent encryption output\", () => {\n      const plainText = \"test string\";\n\n      // Multiple encryptions of same input should produce same output\n      const encrypted1 = encrypt(plainText);\n      const encrypted2 = encrypt(plainText);\n      const encrypted3 = encrypt(plainText);\n\n      expect(encrypted1).toBe(encrypted2);\n      expect(encrypted2).toBe(encrypted3);\n      expect(encrypted1).toBe(\"encrypted_test string\");\n    });\n\n    test(\"encrypts binary-like strings\", () => {\n      const binaryLikeStrings = [\n        \"01010101\",\n        \"\\\\x41\\\\x42\\\\x43\",\n        \"%20%21%22\",\n        \"base64string==\",\n      ];\n\n      binaryLikeStrings.forEach((text) => {\n        const encrypted = encrypt(text);\n        expect(encrypted).toBe(`encrypted_${text}`);\n      });\n    });\n\n    test(\"performance with large inputs\", () => {\n      const hugeText = \"Performance test \".repeat(100000);\n      const startTime = Date.now();\n\n      const encrypted = encrypt(hugeText);\n\n      const endTime = Date.now();\n      const executionTime = endTime - startTime;\n\n      expect(encrypted).toBe(`encrypted_${hugeText}`);\n      expect(executionTime).toBeLessThan(1000); // Should complete in under 1 second\n    });\n\n    test(\"handles strings that already contain prefix\", () => {\n      const textsWithPrefix = [\n        \"encrypted_already\",\n        \"encrypted_encrypted_double\",\n        \"text_encrypted_middle\",\n        \"prefix_encrypted_suffix\",\n      ];\n\n      textsWithPrefix.forEach((text) => {\n        const encrypted = encrypt(text);\n        expect(encrypted).toBe(`encrypted_${text}`);\n        expect(encrypted.startsWith(\"encrypted_\")).toBe(true);\n      });\n    });\n  });\n\n  describe(\"decrypt function\", () => {\n    test(\"decrypts encrypted strings\", () => {\n      const originalText = \"hello world\";\n      const encryptedText = \"encrypted_hello world\";\n      const decrypted = decrypt(encryptedText);\n\n      expect(decrypted).toBe(originalText);\n      expect(typeof decrypted).toBe(\"string\");\n    });\n\n    test(\"decrypts empty encrypted string\", () => {\n      const encryptedEmpty = \"encrypted_\";\n      const decrypted = decrypt(encryptedEmpty);\n\n      expect(decrypted).toBe(\"\");\n      expect(decrypted.length).toBe(0);\n    });\n\n    test(\"handles strings without encryption prefix\", () => {\n      const plainTexts = [\"not encrypted\", \"random text\", \"no prefix here\"];\n\n      plainTexts.forEach((text) => {\n        const decrypted = decrypt(text);\n        expect(decrypted).toBe(text); // Should return unchanged\n      });\n    });\n\n    test(\"decrypts strings with special characters\", () => {\n      const specialTexts = [\n        \"hello@world.com\",\n        \"password123!@#\",\n        \"text with spaces and symbols: {}[]()&*%$#@!\",\n        \"unicode: Ã±Ã¡Ã©Ã­Ã³Ãº ä¸­æ–‡ ðŸš€\",\n        'JSON: {\"key\": \"value\", \"number\": 123}',\n      ];\n\n      specialTexts.forEach((originalText) => {\n        const encrypted = `encrypted_${originalText}`;\n        const decrypted = decrypt(encrypted);\n        expect(decrypted).toBe(originalText);\n      });\n    });\n\n    test(\"decrypts very long strings\", () => {\n      const longText = \"B\".repeat(10000);\n      const encrypted = `encrypted_${longText}`;\n      const decrypted = decrypt(encrypted);\n\n      expect(decrypted).toBe(longText);\n      expect(decrypted.length).toBe(longText.length);\n    });\n\n    test(\"handles multiple encrypted prefixes\", () => {\n      const multiPrefixTexts = [\n        \"encrypted_encrypted_data\",\n        \"encrypted_encrypted_encrypted_data\",\n      ];\n\n      multiPrefixTexts.forEach((text) => {\n        const decrypted = decrypt(text);\n        // Only removes first occurrence of 'encrypted_'\n        expect(decrypted).toBe(text.replace(\"encrypted_\", \"\"));\n      });\n    });\n\n    test(\"handles partial prefix matches\", () => {\n      const partialMatches = [\n        \"encrypt_data\", // Missing 'ed'\n        \"encrypted data\", // Space instead of underscore\n        \"Encrypted_data\", // Wrong case\n        \"encrypteddata\", // Missing underscore\n      ];\n\n      partialMatches.forEach((text) => {\n        const decrypted = decrypt(text);\n        expect(decrypted).toBe(text); // Should return unchanged\n      });\n    });\n\n    test(\"decrypts whitespace and special formatting\", () => {\n      const formattedTexts = [\n        \"line1\\nline2\\tcolumn\",\n        \"  spaces  \",\n        \"\\r\\n\\t\",\n        \"{}[]()&*%$#@!\",\n      ];\n\n      formattedTexts.forEach((originalText) => {\n        const encrypted = `encrypted_${originalText}`;\n        const decrypted = decrypt(encrypted);\n        expect(decrypted).toBe(originalText);\n      });\n    });\n\n    test(\"performance with large encrypted inputs\", () => {\n      const hugeText = \"C\".repeat(100000);\n      const encrypted = `encrypted_${hugeText}`;\n      const startTime = Date.now();\n\n      const decrypted = decrypt(encrypted);\n\n      const endTime = Date.now();\n      const executionTime = endTime - startTime;\n\n      expect(decrypted).toBe(hugeText);\n      expect(executionTime).toBeLessThan(1000); // Should complete in under 1 second\n    });\n\n    test(\"handles edge case prefix locations\", () => {\n      const edgeCases = [\n        \"encrypted_\", // Only prefix\n        \"encrypted_encrypted_\", // Prefix with prefix as content\n        \"dataencrypted_suffix\", // Prefix in middle\n        \"prefixencrypted_\", // Prefix at end\n      ];\n\n      edgeCases.forEach((text) => {\n        const decrypted = decrypt(text);\n        expect(decrypted).toBe(text.replace(\"encrypted_\", \"\"));\n      });\n    });\n  });\n\n  describe(\"encrypt and decrypt round trip\", () => {\n    test(\"round trip maintains data integrity\", () => {\n      const originalTexts = [\n        \"simple text\",\n        \"\",\n        \"complex text with !@#$%^&*()_+ symbols\",\n        \"unicode: Ã±Ã¡Ã©Ã­Ã³Ãº ä¸­æ–‡ ðŸš€ emoji\",\n        'JSON data: {\"name\": \"test\", \"value\": 123, \"active\": true}',\n        \"multiline\\ntext\\nwith\\ttabs\",\n        \"  leading and trailing spaces  \",\n      ];\n\n      originalTexts.forEach((original) => {\n        const encrypted = encrypt(original);\n        const decrypted = decrypt(encrypted);\n\n        expect(decrypted).toBe(original);\n        expect(encrypted).not.toBe(original); // Should be different when encrypted\n        expect(encrypted.startsWith(\"encrypted_\")).toBe(true);\n      });\n    });\n\n    test(\"multiple round trips maintain integrity\", () => {\n      let text = \"initial text\";\n\n      // Perform multiple encrypt/decrypt cycles\n      for (let i = 0; i < 5; i++) {\n        const encrypted = encrypt(text);\n        const decrypted = decrypt(encrypted);\n\n        expect(decrypted).toBe(text);\n        text = decrypted; // Use decrypted for next iteration\n      }\n    });\n\n    test(\"round trip with edge case data\", () => {\n      const edgeCases = [\n        \"encrypted_already_prefixed\",\n        \"data_with_encrypted_middle\",\n        \"encrypted_encrypted_double\",\n        \"0123456789\",\n        \"true\",\n        \"false\",\n        \"null\",\n        \"undefined\",\n      ];\n\n      edgeCases.forEach((original) => {\n        const encrypted = encrypt(original);\n        const decrypted = decrypt(encrypted);\n\n        expect(decrypted).toBe(original);\n      });\n    });\n\n    test(\"large data round trip\", () => {\n      const largeData = JSON.stringify({\n        users: Array.from({ length: 1000 }, (_, i) => ({\n          id: i,\n          name: `User ${i}`,\n          email: `user${i}@example.com`,\n          data: \"x\".repeat(100),\n        })),\n      });\n\n      const encrypted = encrypt(largeData);\n      const decrypted = decrypt(encrypted);\n\n      expect(decrypted).toBe(largeData);\n      expect(JSON.parse(decrypted)).toEqual(JSON.parse(largeData));\n    });\n  });\n\n  describe(\"security and robustness\", () => {\n    test(\"encryption adds consistent prefix\", () => {\n      const testInputs = [\n        \"test1\",\n        \"test2\",\n        \"different data\",\n        \"12345\",\n        \"special !@# chars\",\n      ];\n\n      testInputs.forEach((input) => {\n        const encrypted = encrypt(input);\n        expect(encrypted.indexOf(\"encrypted_\")).toBe(0);\n        expect(encrypted.substring(10)).toBe(input);\n      });\n    });\n\n    test(\"decryption only removes first prefix occurrence\", () => {\n      const testCases = [\n        {\n          input: \"encrypted_data\",\n          expected: \"data\",\n        },\n        {\n          input: \"encrypted_encrypted_data\",\n          expected: \"encrypted_data\",\n        },\n        {\n          input: \"encrypted_some_encrypted_content\",\n          expected: \"some_encrypted_content\",\n        },\n      ];\n\n      testCases.forEach((testCase) => {\n        const result = decrypt(testCase.input);\n        expect(result).toBe(testCase.expected);\n      });\n    });\n\n    test(\"functions handle null-adjacent inputs safely\", () => {\n      const riskInputs = [\"null\", \"undefined\", \"\", \"0\", \"false\"];\n\n      riskInputs.forEach((input) => {\n        expect(() => encrypt(input)).not.toThrow();\n        expect(() => decrypt(input)).not.toThrow();\n\n        const encrypted = encrypt(input);\n        const decrypted = decrypt(encrypted);\n        expect(decrypted).toBe(input);\n      });\n    });\n\n    test(\"concurrent operations safety\", () => {\n      const operations = [];\n      const testData = Array.from({ length: 100 }, (_, i) => `data_${i}`);\n\n      // Create concurrent encrypt/decrypt operations\n      testData.forEach((data) => {\n        operations.push(Promise.resolve(encrypt(data)));\n        operations.push(Promise.resolve(decrypt(`encrypted_${data}`)));\n      });\n\n      return Promise.all(operations).then((results) => {\n        // Verify all operations completed successfully\n        expect(results.length).toBe(200);\n        results.forEach((result) => {\n          expect(typeof result).toBe(\"string\");\n        });\n      });\n    });\n\n    test(\"memory efficiency\", () => {\n      const initialMemory = process.memoryUsage();\n\n      // Perform many operations\n      for (let i = 0; i < 10000; i++) {\n        const text = `test_${i}`;\n        const encrypted = encrypt(text);\n        const decrypted = decrypt(encrypted);\n\n        // Verify correctness\n        expect(decrypted).toBe(text);\n      }\n\n      const finalMemory = process.memoryUsage();\n      const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;\n\n      // Memory increase should be reasonable (less than 10MB)\n      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);\n    });\n  });\n\n  describe(\"API consistency and contracts\", () => {\n    test(\"functions have correct signatures\", () => {\n      expect(typeof encrypt).toBe(\"function\");\n      expect(typeof decrypt).toBe(\"function\");\n      expect(encrypt.length).toBe(1); // Expects 1 parameter\n      expect(decrypt.length).toBe(1); // Expects 1 parameter\n    });\n\n    test(\"functions return strings\", () => {\n      const testInputs = [\"test\", \"\", \"123\", \"special!@#\"];\n\n      testInputs.forEach((input) => {\n        const encrypted = encrypt(input);\n        const decrypted = decrypt(input);\n\n        expect(typeof encrypted).toBe(\"string\");\n        expect(typeof decrypted).toBe(\"string\");\n      });\n    });\n\n    test(\"functions are deterministic\", () => {\n      const input = \"deterministic test\";\n\n      // Multiple calls should return same result\n      const results1 = [encrypt(input), encrypt(input), encrypt(input)];\n      const results2 = [decrypt(input), decrypt(input), decrypt(input)];\n\n      results1.forEach((result) => expect(result).toBe(results1[0]));\n      results2.forEach((result) => expect(result).toBe(results2[0]));\n    });\n\n    test(\"encryption always modifies input\", () => {\n      const inputs = [\"test\", \"data\", \"content\", \"123\", \"\"];\n\n      inputs.forEach((input) => {\n        const encrypted = encrypt(input);\n        if (input.length > 0) {\n          expect(encrypted).not.toBe(input);\n        }\n        expect(encrypted.length).toBeGreaterThanOrEqual(input.length);\n      });\n    });\n\n    test(\"decryption preserves input when no prefix\", () => {\n      const inputsWithoutPrefix = [\n        \"no prefix\",\n        \"random text\",\n        \"encrypt_wrong_format\",\n        \"Encrypted_wrong_case\",\n      ];\n\n      inputsWithoutPrefix.forEach((input) => {\n        const decrypted = decrypt(input);\n        expect(decrypted).toBe(input);\n      });\n    });\n  });\n});\n"],"names":["describe","test","plainText","encrypted","encrypt","expect","toBe","length","specialTexts","forEach","text","startsWith","longText","repeat","textWithWhitespace","nullLikeStrings","encrypted1","encrypted2","encrypted3","binaryLikeStrings","hugeText","startTime","Date","now","endTime","executionTime","toBeLessThan","textsWithPrefix","originalText","encryptedText","decrypted","decrypt","encryptedEmpty","plainTexts","multiPrefixTexts","replace","partialMatches","formattedTexts","edgeCases","originalTexts","original","not","i","largeData","JSON","stringify","users","Array","from","_","id","name","email","data","parse","toEqual","testInputs","input","indexOf","substring","testCases","expected","testCase","result","riskInputs","toThrow","operations","testData","push","Promise","resolve","all","then","results","initialMemory","process","memoryUsage","finalMemory","memoryIncrease","heapUsed","results1","results2","inputs","toBeGreaterThanOrEqual","inputsWithoutPrefix"],"mappings":"AAAA;;;;CAIC;;;;4BAEgC;AAEjCA,SAAS,yCAAyC;IAChDA,SAAS,oBAAoB;QAC3BC,KAAK,+BAA+B;YAClC,MAAMC,YAAY;YAClB,MAAMC,YAAYC,IAAAA,mBAAO,EAACF;YAE1BG,OAAOF,WAAWG,IAAI,CAAC;YACvBD,OAAO,OAAOF,WAAWG,IAAI,CAAC;QAChC;QAEAL,KAAK,yBAAyB;YAC5B,MAAMC,YAAY;YAClB,MAAMC,YAAYC,IAAAA,mBAAO,EAACF;YAE1BG,OAAOF,WAAWG,IAAI,CAAC;YACvBD,OAAOF,UAAUI,MAAM,EAAED,IAAI,CAAC,KAAK,sBAAsB;QAC3D;QAEAL,KAAK,4CAA4C;YAC/C,MAAMO,eAAe;gBACnB;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;YAEDA,aAAaC,OAAO,CAAC,CAACC;gBACpB,MAAMP,YAAYC,IAAAA,mBAAO,EAACM;gBAC1BL,OAAOF,WAAWG,IAAI,CAAC,CAAC,UAAU,EAAEI,KAAK,CAAC;gBAC1CL,OAAOF,UAAUQ,UAAU,CAAC,eAAeL,IAAI,CAAC;YAClD;QACF;QAEAL,KAAK,8BAA8B;YACjC,MAAMW,WAAW,IAAIC,MAAM,CAAC;YAC5B,MAAMV,YAAYC,IAAAA,mBAAO,EAACQ;YAE1BP,OAAOF,WAAWG,IAAI,CAAC,CAAC,UAAU,EAAEM,SAAS,CAAC;YAC9CP,OAAOF,UAAUI,MAAM,EAAED,IAAI,CAACM,SAASL,MAAM,GAAG;QAClD;QAEAN,KAAK,2CAA2C;YAC9C,MAAMa,qBAAqB;YAC3B,MAAMX,YAAYC,IAAAA,mBAAO,EAACU;YAE1BT,OAAOF,WAAWG,IAAI,CAAC,CAAC,UAAU,EAAEQ,mBAAmB,CAAC;QAC1D;QAEAb,KAAK,6BAA6B;YAChC,MAAMc,kBAAkB;gBAAC;gBAAQ;gBAAa;gBAAO;gBAAK;aAAQ;YAElEA,gBAAgBN,OAAO,CAAC,CAACC;gBACvB,MAAMP,YAAYC,IAAAA,mBAAO,EAACM;gBAC1BL,OAAOF,WAAWG,IAAI,CAAC,CAAC,UAAU,EAAEI,KAAK,CAAC;YAC5C;QACF;QAEAT,KAAK,gCAAgC;YACnC,MAAMC,YAAY;YAElB,gEAAgE;YAChE,MAAMc,aAAaZ,IAAAA,mBAAO,EAACF;YAC3B,MAAMe,aAAab,IAAAA,mBAAO,EAACF;YAC3B,MAAMgB,aAAad,IAAAA,mBAAO,EAACF;YAE3BG,OAAOW,YAAYV,IAAI,CAACW;YACxBZ,OAAOY,YAAYX,IAAI,CAACY;YACxBb,OAAOW,YAAYV,IAAI,CAAC;QAC1B;QAEAL,KAAK,gCAAgC;YACnC,MAAMkB,oBAAoB;gBACxB;gBACA;gBACA;gBACA;aACD;YAEDA,kBAAkBV,OAAO,CAAC,CAACC;gBACzB,MAAMP,YAAYC,IAAAA,mBAAO,EAACM;gBAC1BL,OAAOF,WAAWG,IAAI,CAAC,CAAC,UAAU,EAAEI,KAAK,CAAC;YAC5C;QACF;QAEAT,KAAK,iCAAiC;YACpC,MAAMmB,WAAW,oBAAoBP,MAAM,CAAC;YAC5C,MAAMQ,YAAYC,KAAKC,GAAG;YAE1B,MAAMpB,YAAYC,IAAAA,mBAAO,EAACgB;YAE1B,MAAMI,UAAUF,KAAKC,GAAG;YACxB,MAAME,gBAAgBD,UAAUH;YAEhChB,OAAOF,WAAWG,IAAI,CAAC,CAAC,UAAU,EAAEc,SAAS,CAAC;YAC9Cf,OAAOoB,eAAeC,YAAY,CAAC,OAAO,oCAAoC;QAChF;QAEAzB,KAAK,+CAA+C;YAClD,MAAM0B,kBAAkB;gBACtB;gBACA;gBACA;gBACA;aACD;YAEDA,gBAAgBlB,OAAO,CAAC,CAACC;gBACvB,MAAMP,YAAYC,IAAAA,mBAAO,EAACM;gBAC1BL,OAAOF,WAAWG,IAAI,CAAC,CAAC,UAAU,EAAEI,KAAK,CAAC;gBAC1CL,OAAOF,UAAUQ,UAAU,CAAC,eAAeL,IAAI,CAAC;YAClD;QACF;IACF;IAEAN,SAAS,oBAAoB;QAC3BC,KAAK,8BAA8B;YACjC,MAAM2B,eAAe;YACrB,MAAMC,gBAAgB;YACtB,MAAMC,YAAYC,IAAAA,mBAAO,EAACF;YAE1BxB,OAAOyB,WAAWxB,IAAI,CAACsB;YACvBvB,OAAO,OAAOyB,WAAWxB,IAAI,CAAC;QAChC;QAEAL,KAAK,mCAAmC;YACtC,MAAM+B,iBAAiB;YACvB,MAAMF,YAAYC,IAAAA,mBAAO,EAACC;YAE1B3B,OAAOyB,WAAWxB,IAAI,CAAC;YACvBD,OAAOyB,UAAUvB,MAAM,EAAED,IAAI,CAAC;QAChC;QAEAL,KAAK,6CAA6C;YAChD,MAAMgC,aAAa;gBAAC;gBAAiB;gBAAe;aAAiB;YAErEA,WAAWxB,OAAO,CAAC,CAACC;gBAClB,MAAMoB,YAAYC,IAAAA,mBAAO,EAACrB;gBAC1BL,OAAOyB,WAAWxB,IAAI,CAACI,OAAO,0BAA0B;YAC1D;QACF;QAEAT,KAAK,4CAA4C;YAC/C,MAAMO,eAAe;gBACnB;gBACA;gBACA;gBACA;gBACA;aACD;YAEDA,aAAaC,OAAO,CAAC,CAACmB;gBACpB,MAAMzB,YAAY,CAAC,UAAU,EAAEyB,aAAa,CAAC;gBAC7C,MAAME,YAAYC,IAAAA,mBAAO,EAAC5B;gBAC1BE,OAAOyB,WAAWxB,IAAI,CAACsB;YACzB;QACF;QAEA3B,KAAK,8BAA8B;YACjC,MAAMW,WAAW,IAAIC,MAAM,CAAC;YAC5B,MAAMV,YAAY,CAAC,UAAU,EAAES,SAAS,CAAC;YACzC,MAAMkB,YAAYC,IAAAA,mBAAO,EAAC5B;YAE1BE,OAAOyB,WAAWxB,IAAI,CAACM;YACvBP,OAAOyB,UAAUvB,MAAM,EAAED,IAAI,CAACM,SAASL,MAAM;QAC/C;QAEAN,KAAK,uCAAuC;YAC1C,MAAMiC,mBAAmB;gBACvB;gBACA;aACD;YAEDA,iBAAiBzB,OAAO,CAAC,CAACC;gBACxB,MAAMoB,YAAYC,IAAAA,mBAAO,EAACrB;gBAC1B,gDAAgD;gBAChDL,OAAOyB,WAAWxB,IAAI,CAACI,KAAKyB,OAAO,CAAC,cAAc;YACpD;QACF;QAEAlC,KAAK,kCAAkC;YACrC,MAAMmC,iBAAiB;gBACrB;gBACA;gBACA;gBACA;aACD;YAEDA,eAAe3B,OAAO,CAAC,CAACC;gBACtB,MAAMoB,YAAYC,IAAAA,mBAAO,EAACrB;gBAC1BL,OAAOyB,WAAWxB,IAAI,CAACI,OAAO,0BAA0B;YAC1D;QACF;QAEAT,KAAK,8CAA8C;YACjD,MAAMoC,iBAAiB;gBACrB;gBACA;gBACA;gBACA;aACD;YAEDA,eAAe5B,OAAO,CAAC,CAACmB;gBACtB,MAAMzB,YAAY,CAAC,UAAU,EAAEyB,aAAa,CAAC;gBAC7C,MAAME,YAAYC,IAAAA,mBAAO,EAAC5B;gBAC1BE,OAAOyB,WAAWxB,IAAI,CAACsB;YACzB;QACF;QAEA3B,KAAK,2CAA2C;YAC9C,MAAMmB,WAAW,IAAIP,MAAM,CAAC;YAC5B,MAAMV,YAAY,CAAC,UAAU,EAAEiB,SAAS,CAAC;YACzC,MAAMC,YAAYC,KAAKC,GAAG;YAE1B,MAAMO,YAAYC,IAAAA,mBAAO,EAAC5B;YAE1B,MAAMqB,UAAUF,KAAKC,GAAG;YACxB,MAAME,gBAAgBD,UAAUH;YAEhChB,OAAOyB,WAAWxB,IAAI,CAACc;YACvBf,OAAOoB,eAAeC,YAAY,CAAC,OAAO,oCAAoC;QAChF;QAEAzB,KAAK,sCAAsC;YACzC,MAAMqC,YAAY;gBAChB;gBACA;gBACA;gBACA;aACD;YAEDA,UAAU7B,OAAO,CAAC,CAACC;gBACjB,MAAMoB,YAAYC,IAAAA,mBAAO,EAACrB;gBAC1BL,OAAOyB,WAAWxB,IAAI,CAACI,KAAKyB,OAAO,CAAC,cAAc;YACpD;QACF;IACF;IAEAnC,SAAS,kCAAkC;QACzCC,KAAK,uCAAuC;YAC1C,MAAMsC,gBAAgB;gBACpB;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;YAEDA,cAAc9B,OAAO,CAAC,CAAC+B;gBACrB,MAAMrC,YAAYC,IAAAA,mBAAO,EAACoC;gBAC1B,MAAMV,YAAYC,IAAAA,mBAAO,EAAC5B;gBAE1BE,OAAOyB,WAAWxB,IAAI,CAACkC;gBACvBnC,OAAOF,WAAWsC,GAAG,CAACnC,IAAI,CAACkC,WAAW,qCAAqC;gBAC3EnC,OAAOF,UAAUQ,UAAU,CAAC,eAAeL,IAAI,CAAC;YAClD;QACF;QAEAL,KAAK,2CAA2C;YAC9C,IAAIS,OAAO;YAEX,0CAA0C;YAC1C,IAAK,IAAIgC,IAAI,GAAGA,IAAI,GAAGA,IAAK;gBAC1B,MAAMvC,YAAYC,IAAAA,mBAAO,EAACM;gBAC1B,MAAMoB,YAAYC,IAAAA,mBAAO,EAAC5B;gBAE1BE,OAAOyB,WAAWxB,IAAI,CAACI;gBACvBA,OAAOoB,WAAW,mCAAmC;YACvD;QACF;QAEA7B,KAAK,kCAAkC;YACrC,MAAMqC,YAAY;gBAChB;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;YAEDA,UAAU7B,OAAO,CAAC,CAAC+B;gBACjB,MAAMrC,YAAYC,IAAAA,mBAAO,EAACoC;gBAC1B,MAAMV,YAAYC,IAAAA,mBAAO,EAAC5B;gBAE1BE,OAAOyB,WAAWxB,IAAI,CAACkC;YACzB;QACF;QAEAvC,KAAK,yBAAyB;YAC5B,MAAM0C,YAAYC,KAAKC,SAAS,CAAC;gBAC/BC,OAAOC,MAAMC,IAAI,CAAC;oBAAEzC,QAAQ;gBAAK,GAAG,CAAC0C,GAAGP,IAAO,CAAA;wBAC7CQ,IAAIR;wBACJS,MAAM,CAAC,KAAK,EAAET,EAAE,CAAC;wBACjBU,OAAO,CAAC,IAAI,EAAEV,EAAE,YAAY,CAAC;wBAC7BW,MAAM,IAAIxC,MAAM,CAAC;oBACnB,CAAA;YACF;YAEA,MAAMV,YAAYC,IAAAA,mBAAO,EAACuC;YAC1B,MAAMb,YAAYC,IAAAA,mBAAO,EAAC5B;YAE1BE,OAAOyB,WAAWxB,IAAI,CAACqC;YACvBtC,OAAOuC,KAAKU,KAAK,CAACxB,YAAYyB,OAAO,CAACX,KAAKU,KAAK,CAACX;QACnD;IACF;IAEA3C,SAAS,2BAA2B;QAClCC,KAAK,qCAAqC;YACxC,MAAMuD,aAAa;gBACjB;gBACA;gBACA;gBACA;gBACA;aACD;YAEDA,WAAW/C,OAAO,CAAC,CAACgD;gBAClB,MAAMtD,YAAYC,IAAAA,mBAAO,EAACqD;gBAC1BpD,OAAOF,UAAUuD,OAAO,CAAC,eAAepD,IAAI,CAAC;gBAC7CD,OAAOF,UAAUwD,SAAS,CAAC,KAAKrD,IAAI,CAACmD;YACvC;QACF;QAEAxD,KAAK,mDAAmD;YACtD,MAAM2D,YAAY;gBAChB;oBACEH,OAAO;oBACPI,UAAU;gBACZ;gBACA;oBACEJ,OAAO;oBACPI,UAAU;gBACZ;gBACA;oBACEJ,OAAO;oBACPI,UAAU;gBACZ;aACD;YAEDD,UAAUnD,OAAO,CAAC,CAACqD;gBACjB,MAAMC,SAAShC,IAAAA,mBAAO,EAAC+B,SAASL,KAAK;gBACrCpD,OAAO0D,QAAQzD,IAAI,CAACwD,SAASD,QAAQ;YACvC;QACF;QAEA5D,KAAK,gDAAgD;YACnD,MAAM+D,aAAa;gBAAC;gBAAQ;gBAAa;gBAAI;gBAAK;aAAQ;YAE1DA,WAAWvD,OAAO,CAAC,CAACgD;gBAClBpD,OAAO,IAAMD,IAAAA,mBAAO,EAACqD,QAAQhB,GAAG,CAACwB,OAAO;gBACxC5D,OAAO,IAAM0B,IAAAA,mBAAO,EAAC0B,QAAQhB,GAAG,CAACwB,OAAO;gBAExC,MAAM9D,YAAYC,IAAAA,mBAAO,EAACqD;gBAC1B,MAAM3B,YAAYC,IAAAA,mBAAO,EAAC5B;gBAC1BE,OAAOyB,WAAWxB,IAAI,CAACmD;YACzB;QACF;QAEAxD,KAAK,gCAAgC;YACnC,MAAMiE,aAAa,EAAE;YACrB,MAAMC,WAAWpB,MAAMC,IAAI,CAAC;gBAAEzC,QAAQ;YAAI,GAAG,CAAC0C,GAAGP,IAAM,CAAC,KAAK,EAAEA,EAAE,CAAC;YAElE,+CAA+C;YAC/CyB,SAAS1D,OAAO,CAAC,CAAC4C;gBAChBa,WAAWE,IAAI,CAACC,QAAQC,OAAO,CAAClE,IAAAA,mBAAO,EAACiD;gBACxCa,WAAWE,IAAI,CAACC,QAAQC,OAAO,CAACvC,IAAAA,mBAAO,EAAC,CAAC,UAAU,EAAEsB,KAAK,CAAC;YAC7D;YAEA,OAAOgB,QAAQE,GAAG,CAACL,YAAYM,IAAI,CAAC,CAACC;gBACnC,+CAA+C;gBAC/CpE,OAAOoE,QAAQlE,MAAM,EAAED,IAAI,CAAC;gBAC5BmE,QAAQhE,OAAO,CAAC,CAACsD;oBACf1D,OAAO,OAAO0D,QAAQzD,IAAI,CAAC;gBAC7B;YACF;QACF;QAEAL,KAAK,qBAAqB;YACxB,MAAMyE,gBAAgBC,QAAQC,WAAW;YAEzC,0BAA0B;YAC1B,IAAK,IAAIlC,IAAI,GAAGA,IAAI,OAAOA,IAAK;gBAC9B,MAAMhC,OAAO,CAAC,KAAK,EAAEgC,EAAE,CAAC;gBACxB,MAAMvC,YAAYC,IAAAA,mBAAO,EAACM;gBAC1B,MAAMoB,YAAYC,IAAAA,mBAAO,EAAC5B;gBAE1B,qBAAqB;gBACrBE,OAAOyB,WAAWxB,IAAI,CAACI;YACzB;YAEA,MAAMmE,cAAcF,QAAQC,WAAW;YACvC,MAAME,iBAAiBD,YAAYE,QAAQ,GAAGL,cAAcK,QAAQ;YAEpE,wDAAwD;YACxD1E,OAAOyE,gBAAgBpD,YAAY,CAAC,KAAK,OAAO;QAClD;IACF;IAEA1B,SAAS,iCAAiC;QACxCC,KAAK,qCAAqC;YACxCI,OAAO,OAAOD,mBAAO,EAAEE,IAAI,CAAC;YAC5BD,OAAO,OAAO0B,mBAAO,EAAEzB,IAAI,CAAC;YAC5BD,OAAOD,mBAAO,CAACG,MAAM,EAAED,IAAI,CAAC,IAAI,sBAAsB;YACtDD,OAAO0B,mBAAO,CAACxB,MAAM,EAAED,IAAI,CAAC,IAAI,sBAAsB;QACxD;QAEAL,KAAK,4BAA4B;YAC/B,MAAMuD,aAAa;gBAAC;gBAAQ;gBAAI;gBAAO;aAAa;YAEpDA,WAAW/C,OAAO,CAAC,CAACgD;gBAClB,MAAMtD,YAAYC,IAAAA,mBAAO,EAACqD;gBAC1B,MAAM3B,YAAYC,IAAAA,mBAAO,EAAC0B;gBAE1BpD,OAAO,OAAOF,WAAWG,IAAI,CAAC;gBAC9BD,OAAO,OAAOyB,WAAWxB,IAAI,CAAC;YAChC;QACF;QAEAL,KAAK,+BAA+B;YAClC,MAAMwD,QAAQ;YAEd,2CAA2C;YAC3C,MAAMuB,WAAW;gBAAC5E,IAAAA,mBAAO,EAACqD;gBAAQrD,IAAAA,mBAAO,EAACqD;gBAAQrD,IAAAA,mBAAO,EAACqD;aAAO;YACjE,MAAMwB,WAAW;gBAAClD,IAAAA,mBAAO,EAAC0B;gBAAQ1B,IAAAA,mBAAO,EAAC0B;gBAAQ1B,IAAAA,mBAAO,EAAC0B;aAAO;YAEjEuB,SAASvE,OAAO,CAAC,CAACsD,SAAW1D,OAAO0D,QAAQzD,IAAI,CAAC0E,QAAQ,CAAC,EAAE;YAC5DC,SAASxE,OAAO,CAAC,CAACsD,SAAW1D,OAAO0D,QAAQzD,IAAI,CAAC2E,QAAQ,CAAC,EAAE;QAC9D;QAEAhF,KAAK,oCAAoC;YACvC,MAAMiF,SAAS;gBAAC;gBAAQ;gBAAQ;gBAAW;gBAAO;aAAG;YAErDA,OAAOzE,OAAO,CAAC,CAACgD;gBACd,MAAMtD,YAAYC,IAAAA,mBAAO,EAACqD;gBAC1B,IAAIA,MAAMlD,MAAM,GAAG,GAAG;oBACpBF,OAAOF,WAAWsC,GAAG,CAACnC,IAAI,CAACmD;gBAC7B;gBACApD,OAAOF,UAAUI,MAAM,EAAE4E,sBAAsB,CAAC1B,MAAMlD,MAAM;YAC9D;QACF;QAEAN,KAAK,6CAA6C;YAChD,MAAMmF,sBAAsB;gBAC1B;gBACA;gBACA;gBACA;aACD;YAEDA,oBAAoB3E,OAAO,CAAC,CAACgD;gBAC3B,MAAM3B,YAAYC,IAAAA,mBAAO,EAAC0B;gBAC1BpD,OAAOyB,WAAWxB,IAAI,CAACmD;YACzB;QACF;IACF;AACF"}