{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/hooks/useConversationWebSocket.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useRef, useState, useCallback } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport {\n  setWebSocketStatus,\n  connectionEstablished,\n  connectionLost,\n  updateLatency,\n  addConnectionError,\n} from \"@/store/slices/connectionSlice\";\nimport type { Message, Conversation } from \"@/lib/types\";\n\ninterface ConversationEvent {\n  type: string;\n  timestamp: string;\n  conversation_id: string;\n  data: any;\n  metadata?: any;\n}\n\ninterface ConversationSubscription {\n  conversation_ids?: string[];\n  agent_ids?: string[];\n  message_types?: string[];\n  include_typing?: boolean;\n  include_system_messages?: boolean;\n  include_metadata?: boolean;\n}\n\ninterface UseConversationWebSocketOptions {\n  autoConnect?: boolean;\n  reconnectInterval?: number;\n  maxReconnectAttempts?: number;\n  onEvent?: (event: ConversationEvent) => void;\n  onError?: (error: Event) => void;\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n}\n\ninterface ConversationWebSocketState {\n  isConnected: boolean;\n  isConnecting: boolean;\n  error: string | null;\n  lastEventTime: Date | null;\n  connectionStats: any;\n}\n\nexport function useConversationWebSocket(\n  options: UseConversationWebSocketOptions = {},\n) {\n  const {\n    autoConnect = true,\n    reconnectInterval = 3000,\n    maxReconnectAttempts = 5,\n    onEvent,\n    onError,\n    onConnect,\n    onDisconnect,\n  } = options;\n\n  const dispatch = useDispatch();\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n  const subscriptionRef = useRef<ConversationSubscription>({});\n  const pingIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const connectionIdRef = useRef<string | null>(null);\n\n  const [state, setState] = useState<ConversationWebSocketState>({\n    isConnected: false,\n    isConnecting: false,\n    error: null,\n    lastEventTime: null,\n    connectionStats: null,\n  });\n\n  // Get WebSocket URL - FIXED: Remove /api prefix\n  const getWebSocketUrl = useCallback(() => {\n    const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    const host = window.location.host;\n    // Connect directly to backend WebSocket endpoint\n    const wsHost = host.replace(\":3000\", \":8000\"); // Use backend port\n    return `${protocol}//${wsHost}/ws/conversations`;\n  }, []);\n\n  // Handle incoming messages\n  const handleMessage = useCallback(\n    (event: MessageEvent) => {\n      try {\n        const data = JSON.parse(event.data);\n        const now = new Date();\n\n        setState((prev) => ({\n          ...prev,\n          lastEventTime: now,\n          error: null,\n        }));\n\n        // Handle different message types\n        switch (data.type) {\n          case \"connection_established\":\n            console.log(\"WebSocket connection established:\", data.client_id);\n            connectionIdRef.current = data.client_id;\n\n            setState((prev) => ({\n              ...prev,\n              isConnected: true,\n              isConnecting: false,\n            }));\n\n            // Update Redux state\n            dispatch(setWebSocketStatus(\"connected\"));\n            dispatch(\n              connectionEstablished({\n                connectionId: data.client_id,\n                socketUrl: getWebSocketUrl(),\n                apiUrl: getWebSocketUrl()\n                  .replace(/:\\d+/, \":8000\")\n                  .replace(\"ws\", \"http\"),\n              }),\n            );\n\n            onConnect?.();\n            break;\n\n          case \"pong\":\n            // Handle ping/pong for connection health and update latency\n            if (data.latency) {\n              dispatch(updateLatency(data.latency));\n            }\n            break;\n\n          case \"subscription_updated\":\n            console.log(\"Subscription updated:\", data.subscription);\n            break;\n\n          case \"connection_stats\":\n            setState((prev) => ({ ...prev, connectionStats: data.stats }));\n            break;\n\n          case \"error\":\n            console.error(\"WebSocket error:\", data.message);\n            setState((prev) => ({ ...prev, error: data.message }));\n            dispatch(\n              addConnectionError({\n                type: \"websocket\",\n                message: data.message,\n              }),\n            );\n            break;\n\n          // Conversation events\n          case \"message_created\":\n          case \"message_updated\":\n          case \"message_deleted\":\n          case \"conversation_started\":\n          case \"conversation_ended\":\n          case \"agent_typing\":\n          case \"agent_stopped_typing\":\n          case \"agent_joined\":\n          case \"agent_left\":\n          case \"message_queue_updated\":\n            onEvent?.(data as ConversationEvent);\n            break;\n\n          default:\n            console.log(\"Unknown WebSocket message type:\", data.type);\n        }\n      } catch (error) {\n        console.error(\"Error parsing WebSocket message:\", error);\n        setState((prev) => ({ ...prev, error: \"Failed to parse message\" }));\n        dispatch(\n          addConnectionError({\n            type: \"websocket\",\n            message: \"Failed to parse WebSocket message\",\n          }),\n        );\n      }\n    },\n    [onEvent, onConnect, dispatch, getWebSocketUrl],\n  );\n\n  // Handle connection errors\n  const handleError = useCallback(\n    (event: Event) => {\n      console.error(\"WebSocket error:\", event);\n      setState((prev) => ({\n        ...prev,\n        error: \"Connection error\",\n        isConnected: false,\n        isConnecting: false,\n      }));\n\n      // Update Redux state\n      dispatch(setWebSocketStatus(\"disconnected\"));\n      dispatch(\n        addConnectionError({\n          type: \"websocket\",\n          message: \"WebSocket connection error\",\n        }),\n      );\n\n      onError?.(event);\n    },\n    [onError, dispatch],\n  );\n\n  // Handle connection close\n  const handleClose = useCallback(() => {\n    console.log(\"WebSocket connection closed\");\n    setState((prev) => ({\n      ...prev,\n      isConnected: false,\n      isConnecting: false,\n    }));\n\n    // Update Redux state\n    dispatch(setWebSocketStatus(\"disconnected\"));\n    dispatch(\n      connectionLost({\n        type: \"websocket\",\n        error: \"Connection closed\",\n      }),\n    );\n\n    // Clear ping interval\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n      pingIntervalRef.current = null;\n    }\n\n    onDisconnect?.();\n\n    // Attempt to reconnect if we haven't exceeded max attempts\n    if (reconnectAttemptsRef.current < maxReconnectAttempts) {\n      reconnectAttemptsRef.current++;\n      console.log(\n        `Attempting to reconnect (${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`,\n      );\n\n      // Update Redux state for reconnecting\n      dispatch(setWebSocketStatus(\"connecting\"));\n\n      reconnectTimeoutRef.current = setTimeout(() => {\n        connect();\n      }, reconnectInterval);\n    } else {\n      setState((prev) => ({\n        ...prev,\n        error: \"Max reconnection attempts exceeded\",\n      }));\n      dispatch(\n        addConnectionError({\n          type: \"websocket\",\n          message: \"Max reconnection attempts exceeded\",\n        }),\n      );\n    }\n  }, [onDisconnect, maxReconnectAttempts, reconnectInterval, dispatch]);\n\n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    setState((prev) => ({ ...prev, isConnecting: true, error: null }));\n    dispatch(setWebSocketStatus(\"connecting\"));\n\n    try {\n      const url = getWebSocketUrl();\n      console.log(\"Connecting to WebSocket:\", url);\n      wsRef.current = new WebSocket(url);\n\n      wsRef.current.onopen = () => {\n        console.log(\"WebSocket connected\");\n        reconnectAttemptsRef.current = 0; // Reset reconnect attempts\n\n        // Set up ping interval to keep connection alive\n        pingIntervalRef.current = setInterval(() => {\n          const startTime = Date.now();\n          send({ type: \"ping\", clientTime: startTime });\n        }, 30000); // Ping every 30 seconds\n      };\n\n      wsRef.current.onmessage = handleMessage;\n      wsRef.current.onerror = handleError;\n      wsRef.current.onclose = handleClose;\n    } catch (error) {\n      console.error(\"Failed to create WebSocket connection:\", error);\n      setState((prev) => ({\n        ...prev,\n        error: \"Failed to create connection\",\n        isConnecting: false,\n      }));\n      dispatch(setWebSocketStatus(\"disconnected\"));\n      dispatch(\n        addConnectionError({\n          type: \"websocket\",\n          message: \"Failed to create WebSocket connection\",\n        }),\n      );\n    }\n  }, [getWebSocketUrl, handleMessage, handleError, handleClose, dispatch]);\n\n  // Disconnect from WebSocket\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n      pingIntervalRef.current = null;\n    }\n\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n\n    setState((prev) => ({\n      ...prev,\n      isConnected: false,\n      isConnecting: false,\n    }));\n\n    dispatch(setWebSocketStatus(\"disconnected\"));\n  }, [dispatch]);\n\n  // Send message to WebSocket\n  const send = useCallback((message: any) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n      return true;\n    } else {\n      console.warn(\"WebSocket not connected, cannot send message:\", message);\n      return false;\n    }\n  }, []);\n\n  // Subscribe to conversation updates\n  const subscribe = useCallback(\n    (subscription: ConversationSubscription) => {\n      subscriptionRef.current = { ...subscriptionRef.current, ...subscription };\n      return send({\n        type: \"subscribe\",\n        subscription: subscriptionRef.current,\n      });\n    },\n    [send],\n  );\n\n  // Update typing status\n  const setTyping = useCallback(\n    (conversationId: string, agentId: string, isTyping: boolean) => {\n      return send({\n        type: \"set_typing\",\n        conversation_id: conversationId,\n        agent_id: agentId,\n        is_typing: isTyping,\n      });\n    },\n    [send],\n  );\n\n  // Get typing status\n  const getTypingStatus = useCallback(\n    (conversationId: string) => {\n      return send({\n        type: \"get_typing_status\",\n        conversation_id: conversationId,\n      });\n    },\n    [send],\n  );\n\n  // Get connection stats\n  const getStats = useCallback(() => {\n    return send({ type: \"get_stats\" });\n  }, [send]);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n\n    // Cleanup on unmount\n    return () => {\n      disconnect();\n    };\n  }, [autoConnect, connect, disconnect]);\n\n  // Visibility change handler to reconnect when tab becomes visible\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (!document.hidden && !state.isConnected && !state.isConnecting) {\n        console.log(\"Tab became visible, attempting to reconnect...\");\n        connect();\n      }\n    };\n\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    return () => {\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n    };\n  }, [state.isConnected, state.isConnecting, connect]);\n\n  // Online/offline handler for better browser compatibility\n  useEffect(() => {\n    const handleOnline = () => {\n      if (!state.isConnected && !state.isConnecting) {\n        console.log(\"Browser came online, attempting to reconnect...\");\n        connect();\n      }\n    };\n\n    const handleOffline = () => {\n      console.log(\"Browser went offline\");\n      setState((prev) => ({ ...prev, error: \"Browser offline\" }));\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n    };\n  }, [state.isConnected, state.isConnecting, connect]);\n\n  return {\n    // State\n    isConnected: state.isConnected,\n    isConnecting: state.isConnecting,\n    error: state.error,\n    lastEventTime: state.lastEventTime,\n    connectionStats: state.connectionStats,\n    connectionId: connectionIdRef.current,\n\n    // Methods\n    connect,\n    disconnect,\n    send,\n    subscribe,\n    setTyping,\n    getTypingStatus,\n    getStats,\n\n    // Connection info\n    reconnectAttempts: reconnectAttemptsRef.current,\n    maxReconnectAttempts,\n  };\n}\n"],"names":["useConversationWebSocket","options","autoConnect","reconnectInterval","maxReconnectAttempts","onEvent","onError","onConnect","onDisconnect","dispatch","useDispatch","wsRef","useRef","reconnectTimeoutRef","reconnectAttemptsRef","subscriptionRef","pingIntervalRef","connectionIdRef","state","setState","useState","isConnected","isConnecting","error","lastEventTime","connectionStats","getWebSocketUrl","useCallback","protocol","window","location","host","wsHost","replace","handleMessage","event","data","JSON","parse","now","Date","prev","type","console","log","client_id","current","setWebSocketStatus","connectionEstablished","connectionId","socketUrl","apiUrl","latency","updateLatency","subscription","stats","message","addConnectionError","handleError","handleClose","connectionLost","clearInterval","setTimeout","connect","readyState","WebSocket","OPEN","url","onopen","setInterval","startTime","send","clientTime","onmessage","onerror","onclose","disconnect","clearTimeout","close","stringify","warn","subscribe","setTyping","conversationId","agentId","isTyping","conversation_id","agent_id","is_typing","getTypingStatus","getStats","useEffect","handleVisibilityChange","document","hidden","addEventListener","removeEventListener","handleOnline","handleOffline","reconnectAttempts"],"mappings":"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"}