30a6856c10e196f4d9a2c22acf59bf1a
/**
 * Phase 1: lib/conversation-orchestrator.ts Comprehensive Test Suite
 * Target: Complete conversation orchestration functionality
 * Goal: Maximum statement coverage for conversation management
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _conversationorchestrator = require("../../lib/conversation-orchestrator");
const _llmclient = require("../../lib/llm-client");
const _llmsecureclient = require("../../lib/llm-secure-client");
const _conversationlogger = require("../../lib/conversation-logger");
// Mock dependencies
_globals.jest.mock("@/lib/knowledge-retriever");
_globals.jest.mock("@/lib/llm-client", ()=>({
        LLMClient: _globals.jest.fn().mockImplementation(()=>({
                generateResponse: _globals.jest.fn().mockResolvedValue("Generated response"),
                streamGenerateResponse: _globals.jest.fn().mockImplementation(async function*() {
                    yield {
                        text: "Streaming ",
                        isComplete: false
                    };
                    yield {
                        text: "response",
                        isComplete: false
                    };
                    yield {
                        text: "",
                        isComplete: true
                    };
                })
            }))
    }));
_globals.jest.mock("@/lib/llm-secure-client", ()=>({
        LLMSecureClient: _globals.jest.fn().mockImplementation(()=>({
                generateResponse: _globals.jest.fn().mockResolvedValue("Secure response"),
                streamGenerateResponse: _globals.jest.fn().mockImplementation(async function*() {
                    yield {
                        text: "Secure ",
                        isComplete: false
                    };
                    yield {
                        text: "response",
                        isComplete: false
                    };
                    yield {
                        text: "",
                        isComplete: true
                    };
                })
            }))
    }));
_globals.jest.mock("@/lib/conversation-logger", ()=>({
        ConversationLogger: {
            init: _globals.jest.fn().mockReturnValue({
                log: _globals.jest.fn(),
                error: _globals.jest.fn(),
                warn: _globals.jest.fn()
            })
        }
    }));
_globals.jest.mock("@/lib/debug-logger", ()=>({
        debugLog: _globals.jest.fn()
    }));
// Mock timers
_globals.jest.useFakeTimers();
describe("lib/conversation-orchestrator.ts - Complete Coverage", ()=>{
    let mockConversation;
    let mockAgents;
    let mockLLMClient;
    let mockKnowledgeRetriever;
    let mockLogger;
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        _globals.jest.clearAllTimers();
        // Setup mock conversation
        mockConversation = {
            id: "conv-123",
            title: "Test Conversation",
            messages: [
                {
                    id: "msg-1",
                    conversationId: "conv-123",
                    agentId: "agent-1",
                    content: "Hello",
                    timestamp: new Date("2024-01-01"),
                    tags: []
                }
            ],
            participants: [
                "agent-1",
                "agent-2"
            ],
            created: new Date("2024-01-01"),
            updated: new Date("2024-01-01"),
            tags: []
        };
        // Setup mock agents
        mockAgents = [
            {
                id: "agent-1",
                name: "Agent One",
                type: "conversational",
                status: "active",
                systemPrompt: "You are agent one",
                knowledgeIds: [
                    "knowledge-1"
                ],
                conversationIds: [
                    "conv-123"
                ],
                beliefs: [],
                preferences: {},
                capabilities: [],
                created: new Date("2024-01-01"),
                updated: new Date("2024-01-01")
            },
            {
                id: "agent-2",
                name: "Agent Two",
                type: "conversational",
                status: "active",
                systemPrompt: "You are agent two",
                knowledgeIds: [
                    "knowledge-2"
                ],
                conversationIds: [
                    "conv-123"
                ],
                beliefs: [],
                preferences: {},
                capabilities: [],
                created: new Date("2024-01-01"),
                updated: new Date("2024-01-01")
            }
        ];
        // Setup mock LLM client
        mockLLMClient = new _llmclient.LLMClient();
        // Setup mock knowledge retriever
        mockKnowledgeRetriever = {
            getRelatedKnowledge: _globals.jest.fn().mockResolvedValue([
                {
                    id: "knowledge-1",
                    title: "Test Knowledge",
                    content: "Test knowledge content",
                    tags: [
                        "test"
                    ],
                    timestamp: new Date("2024-01-01")
                }
            ])
        };
        // Setup mock logger
        mockLogger = {
            log: _globals.jest.fn(),
            error: _globals.jest.fn(),
            warn: _globals.jest.fn()
        };
    });
    afterEach(()=>{
        _globals.jest.clearAllTimers();
    });
    describe("Constructor and Initialization", ()=>{
        test("initializes with basic configuration", ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            expect(_conversationlogger.ConversationLogger.init).toHaveBeenCalledWith("conv-123");
            expect(orchestrator).toBeDefined();
        });
        test("initializes with custom options", ()=>{
            const options = {
                maxConcurrentResponses: 3,
                responseDelay: 1000,
                autoSelectRespondents: false,
                onMessageGenerated: _globals.jest.fn(),
                onError: _globals.jest.fn()
            };
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, options);
            expect(orchestrator).toBeDefined();
        });
        test("initializes with empty conversation", ()=>{
            const emptyConversation = {
                ...mockConversation,
                messages: []
            };
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(emptyConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            expect(orchestrator).toBeDefined();
        });
        test("initializes with response delay range", ()=>{
            const options = {
                responseDelay: [
                    1000,
                    3000
                ]
            };
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, options);
            expect(orchestrator).toBeDefined();
        });
    });
    describe("handleNewMessage method", ()=>{
        test("handles new message successfully", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const newMessage = {
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "New message",
                timestamp: new Date("2024-01-02"),
                tags: []
            };
            await orchestrator.handleNewMessage(newMessage);
            // Should process queue
            _globals.jest.runOnlyPendingTimers();
            expect(mockLogger.log).toHaveBeenCalledWith("NEW_MESSAGE", expect.any(String), expect.any(Object));
        });
        test("ignores message with no agent ID", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const systemMessage = {
                id: "msg-system",
                conversationId: "conv-123",
                content: "System message",
                timestamp: new Date("2024-01-02"),
                tags: []
            };
            await orchestrator.handleNewMessage(systemMessage);
            expect(mockLogger.warn).toHaveBeenCalledWith("NO_AGENT_ID", expect.any(String));
        });
        test("skips already processed message", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const oldMessage = {
                id: "msg-1",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "Old message",
                timestamp: new Date("2024-01-01"),
                tags: []
            };
            await orchestrator.handleNewMessage(oldMessage);
            expect(mockLogger.log).toHaveBeenCalledWith("SKIP_MESSAGE", expect.any(String), expect.any(Object));
        });
        test("handles custom response options", async ()=>{
            const onChunk = _globals.jest.fn();
            const onMessageGenerated = _globals.jest.fn();
            const options = {
                autoSelectRespondents: true
            };
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, options);
            const newMessage = {
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "New message",
                timestamp: new Date("2024-01-02"),
                tags: []
            };
            const responseOptions = {
                maxKnowledgeEntries: 5,
                includeAgentKnowledge: true,
                includeTags: [
                    "important"
                ],
                streamResponse: true,
                onChunk,
                onMessageGenerated,
                responseDelay: 0
            };
            await orchestrator.handleNewMessage(newMessage, responseOptions);
            _globals.jest.runAllTimers();
            // Wait for async operations
            await new Promise((resolve)=>setImmediate(resolve));
        });
        test("handles error callback", async ()=>{
            const onError = _globals.jest.fn();
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, {
                onError
            });
            // Make LLM client throw error
            mockLLMClient.generateResponse.mockRejectedValue(new Error("LLM error"));
            const newMessage = {
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "New message",
                timestamp: new Date("2024-01-02"),
                tags: []
            };
            await orchestrator.handleNewMessage(newMessage);
            _globals.jest.runAllTimers();
            await new Promise((resolve)=>setImmediate(resolve));
            expect(onError).toHaveBeenCalledWith(expect.any(Error));
        });
    });
    describe("generateAgentResponse method", ()=>{
        test("generates response with streaming", async ()=>{
            const onChunk = _globals.jest.fn();
            const onMessageGenerated = _globals.jest.fn();
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, {
                onMessageGenerated
            });
            const agent = mockAgents[0];
            const options = {
                streamResponse: true,
                onChunk,
                includeAgentKnowledge: true,
                maxKnowledgeEntries: 3
            };
            await orchestrator.generateAgentResponse(agent, options);
            expect(onChunk).toHaveBeenCalledWith("Streaming ", false);
            expect(onChunk).toHaveBeenCalledWith("response", false);
            expect(onChunk).toHaveBeenCalledWith("", true);
            expect(onMessageGenerated).toHaveBeenCalled();
        });
        test("generates response without streaming", async ()=>{
            const onMessageGenerated = _globals.jest.fn();
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const agent = mockAgents[0];
            const options = {
                streamResponse: false,
                onMessageGenerated
            };
            await orchestrator.generateAgentResponse(agent, options);
            expect(mockLLMClient.generateResponse).toHaveBeenCalled();
            expect(onMessageGenerated).toHaveBeenCalled();
        });
        test("generates response to specific message", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const agent = mockAgents[1];
            const targetMessage = mockConversation.messages[0];
            const options = {
                messageToRespondTo: targetMessage
            };
            await orchestrator.generateAgentResponse(agent, options);
            expect(mockLLMClient.generateResponse).toHaveBeenCalledWith(expect.stringContaining("Hello"), expect.any(String));
        });
        test("includes knowledge entries in prompt", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const agent = mockAgents[0];
            const options = {
                includeAgentKnowledge: true,
                maxKnowledgeEntries: 2,
                includeTags: [
                    "test"
                ]
            };
            await orchestrator.generateAgentResponse(agent, options);
            expect(mockKnowledgeRetriever.getRelatedKnowledge).toHaveBeenCalledWith([
                "knowledge-1"
            ], 2, [
                "test"
            ]);
        });
        test("handles LLM secure client", async ()=>{
            const mockSecureClient = new _llmsecureclient.LLMSecureClient();
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockSecureClient, mockKnowledgeRetriever);
            const agent = mockAgents[0];
            await orchestrator.generateAgentResponse(agent);
            expect(mockSecureClient.generateResponse).toHaveBeenCalled();
        });
    });
    describe("getAvailableRespondents method", ()=>{
        test("returns agents not currently processing", ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            // Simulate one agent processing
            orchestrator.processingAgents.add("agent-1");
            const availableAgents = orchestrator.getAvailableRespondents();
            expect(availableAgents).toHaveLength(1);
            expect(availableAgents[0].id).toBe("agent-2");
        });
        test("excludes agent who sent the message", ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const message = {
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "Test",
                timestamp: new Date(),
                tags: []
            };
            const availableAgents = orchestrator.getAvailableRespondents(message);
            expect(availableAgents).toHaveLength(1);
            expect(availableAgents[0].id).toBe("agent-2");
        });
        test("returns empty array when all agents are processing", ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            // All agents processing
            orchestrator.processingAgents.add("agent-1");
            orchestrator.processingAgents.add("agent-2");
            const availableAgents = orchestrator.getAvailableRespondents();
            expect(availableAgents).toHaveLength(0);
        });
    });
    describe("Queue Processing", ()=>{
        test("processes queue with delay", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, {
                responseDelay: 1000
            });
            const newMessage = {
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "Test",
                timestamp: new Date(),
                tags: []
            };
            await orchestrator.handleNewMessage(newMessage);
            // Process queue
            _globals.jest.advanceTimersByTime(100); // Queue processor interval
            _globals.jest.advanceTimersByTime(1000); // Response delay
            await new Promise((resolve)=>setImmediate(resolve));
            expect(mockLLMClient.generateResponse).toHaveBeenCalled();
        });
        test("processes queue with random delay range", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, {
                responseDelay: [
                    500,
                    1500
                ]
            });
            const newMessage = {
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "Test",
                timestamp: new Date(),
                tags: []
            };
            await orchestrator.handleNewMessage(newMessage);
            // Process queue
            _globals.jest.advanceTimersByTime(100); // Queue processor interval
            _globals.jest.advanceTimersByTime(1500); // Max delay
            await new Promise((resolve)=>setImmediate(resolve));
            expect(mockLLMClient.generateResponse).toHaveBeenCalled();
        });
        test("respects max concurrent responses", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, {
                maxConcurrentResponses: 1,
                responseDelay: 0
            });
            // Add multiple messages to queue
            await orchestrator.handleNewMessage({
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "Test 1",
                timestamp: new Date(),
                tags: []
            });
            await orchestrator.handleNewMessage({
                id: "msg-3",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "Test 2",
                timestamp: new Date(),
                tags: []
            });
            // Process queue
            _globals.jest.runAllTimers();
            await new Promise((resolve)=>setImmediate(resolve));
            // Should only process one at a time
            expect(orchestrator.processingAgents.size).toBeLessThanOrEqual(1);
        });
    });
    describe("updateConversation method", ()=>{
        test("updates conversation and processes new messages", ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const updatedConversation = {
                ...mockConversation,
                messages: [
                    ...mockConversation.messages,
                    {
                        id: "msg-2",
                        conversationId: "conv-123",
                        agentId: "agent-2",
                        content: "New message",
                        timestamp: new Date(),
                        tags: []
                    }
                ]
            };
            orchestrator.updateConversation(updatedConversation);
            expect(mockLogger.log).toHaveBeenCalledWith("UPDATE_CONVERSATION", expect.any(String), expect.any(Object));
        });
        test("handles conversation with no new messages", ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            orchestrator.updateConversation(mockConversation);
            expect(mockLogger.log).toHaveBeenCalledWith("UPDATE_CONVERSATION", expect.any(String), expect.objectContaining({
                newMessageCount: 0
            }));
        });
    });
    describe("updateAgents method", ()=>{
        test("updates agents map", ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const newAgent = {
                id: "agent-3",
                name: "Agent Three",
                type: "conversational",
                status: "active",
                systemPrompt: "You are agent three",
                knowledgeIds: [],
                conversationIds: [
                    "conv-123"
                ],
                beliefs: [],
                preferences: {},
                capabilities: [],
                created: new Date(),
                updated: new Date()
            };
            orchestrator.updateAgents([
                ...mockAgents,
                newAgent
            ]);
            expect(mockLogger.log).toHaveBeenCalledWith("UPDATE_AGENTS", expect.any(String), expect.objectContaining({
                agentCount: 3
            }));
        });
    });
    describe("clearQueue method", ()=>{
        test("clears response queue", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            // Add message to queue
            await orchestrator.handleNewMessage({
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "Test",
                timestamp: new Date(),
                tags: []
            });
            orchestrator.clearQueue();
            expect(mockLogger.log).toHaveBeenCalledWith("CLEAR_QUEUE", expect.any(String));
        });
    });
    describe("destroy method", ()=>{
        test("cleans up resources", ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            orchestrator.destroy();
            expect(mockLogger.log).toHaveBeenCalledWith("DESTROY", expect.any(String));
        });
    });
    describe("Error Handling", ()=>{
        test("handles error in generateAgentResponse", async ()=>{
            const onError = _globals.jest.fn();
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, {
                onError
            });
            mockLLMClient.generateResponse.mockRejectedValue(new Error("Generation failed"));
            const agent = mockAgents[0];
            await orchestrator.generateAgentResponse(agent);
            expect(mockLogger.error).toHaveBeenCalledWith("RESPONSE_ERROR", expect.any(String), expect.any(Error));
            expect(onError).toHaveBeenCalledWith(expect.any(Error));
        });
        test("handles error in streaming response", async ()=>{
            const onError = _globals.jest.fn();
            const onChunk = _globals.jest.fn();
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, {
                onError
            });
            // Make streaming throw error
            mockLLMClient.streamGenerateResponse.mockImplementation(async function*() {
                throw new Error("Stream failed");
            });
            const agent = mockAgents[0];
            const options = {
                streamResponse: true,
                onChunk
            };
            await orchestrator.generateAgentResponse(agent, options);
            expect(mockLogger.error).toHaveBeenCalledWith("RESPONSE_ERROR", expect.any(String), expect.any(Error));
        });
    });
    describe("Edge Cases", ()=>{
        test("handles agent not in agents map", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const unknownAgent = {
                id: "unknown-agent",
                name: "Unknown",
                type: "conversational",
                status: "active",
                systemPrompt: "Unknown",
                knowledgeIds: [],
                conversationIds: [],
                beliefs: [],
                preferences: {},
                capabilities: [],
                created: new Date(),
                updated: new Date()
            };
            await orchestrator.generateAgentResponse(unknownAgent);
            expect(mockLLMClient.generateResponse).toHaveBeenCalled();
        });
        test("handles empty knowledge entries", async ()=>{
            mockKnowledgeRetriever.getRelatedKnowledge.mockResolvedValue([]);
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever);
            const agent = mockAgents[0];
            const options = {
                includeAgentKnowledge: true
            };
            await orchestrator.generateAgentResponse(agent, options);
            expect(mockLLMClient.generateResponse).toHaveBeenCalled();
        });
        test("handles forced response", async ()=>{
            const orchestrator = new _conversationorchestrator.ConversationOrchestrator(mockConversation, mockAgents, mockLLMClient, mockKnowledgeRetriever, {
                autoSelectRespondents: false
            });
            const newMessage = {
                id: "msg-2",
                conversationId: "conv-123",
                agentId: "agent-1",
                content: "Test",
                timestamp: new Date(),
                tags: []
            };
            const options = {
                force: true
            };
            await orchestrator.handleNewMessage(newMessage, options);
            _globals.jest.runAllTimers();
            await new Promise((resolve)=>setImmediate(resolve));
            expect(mockLLMClient.generateResponse).toHaveBeenCalled();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2NvbnZlcnNhdGlvbi1vcmNoZXN0cmF0b3IudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBoYXNlIDE6IGxpYi9jb252ZXJzYXRpb24tb3JjaGVzdHJhdG9yLnRzIENvbXByZWhlbnNpdmUgVGVzdCBTdWl0ZVxuICogVGFyZ2V0OiBDb21wbGV0ZSBjb252ZXJzYXRpb24gb3JjaGVzdHJhdGlvbiBmdW5jdGlvbmFsaXR5XG4gKiBHb2FsOiBNYXhpbXVtIHN0YXRlbWVudCBjb3ZlcmFnZSBmb3IgY29udmVyc2F0aW9uIG1hbmFnZW1lbnRcbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSBcIkBqZXN0L2dsb2JhbHNcIjtcbmltcG9ydCB0eXBlIHsgTW9jayB9IGZyb20gXCJqZXN0LW1vY2tcIjtcblxuLy8gTW9jayBkZXBlbmRlbmNpZXNcbmplc3QubW9jayhcIkAvbGliL2tub3dsZWRnZS1yZXRyaWV2ZXJcIik7XG5qZXN0Lm1vY2soXCJAL2xpYi9sbG0tY2xpZW50XCIsICgpID0+ICh7XG4gIExMTUNsaWVudDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xuICAgIGdlbmVyYXRlUmVzcG9uc2U6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShcIkdlbmVyYXRlZCByZXNwb25zZVwiKSxcbiAgICBzdHJlYW1HZW5lcmF0ZVJlc3BvbnNlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB7IHRleHQ6IFwiU3RyZWFtaW5nIFwiLCBpc0NvbXBsZXRlOiBmYWxzZSB9O1xuICAgICAgeWllbGQgeyB0ZXh0OiBcInJlc3BvbnNlXCIsIGlzQ29tcGxldGU6IGZhbHNlIH07XG4gICAgICB5aWVsZCB7IHRleHQ6IFwiXCIsIGlzQ29tcGxldGU6IHRydWUgfTtcbiAgICB9KSxcbiAgfSkpLFxufSkpO1xuamVzdC5tb2NrKFwiQC9saWIvbGxtLXNlY3VyZS1jbGllbnRcIiwgKCkgPT4gKHtcbiAgTExNU2VjdXJlQ2xpZW50OiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgZ2VuZXJhdGVSZXNwb25zZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFwiU2VjdXJlIHJlc3BvbnNlXCIpLFxuICAgIHN0cmVhbUdlbmVyYXRlUmVzcG9uc2U6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHsgdGV4dDogXCJTZWN1cmUgXCIsIGlzQ29tcGxldGU6IGZhbHNlIH07XG4gICAgICB5aWVsZCB7IHRleHQ6IFwicmVzcG9uc2VcIiwgaXNDb21wbGV0ZTogZmFsc2UgfTtcbiAgICAgIHlpZWxkIHsgdGV4dDogXCJcIiwgaXNDb21wbGV0ZTogdHJ1ZSB9O1xuICAgIH0pLFxuICB9KSksXG59KSk7XG5qZXN0Lm1vY2soXCJAL2xpYi9jb252ZXJzYXRpb24tbG9nZ2VyXCIsICgpID0+ICh7XG4gIENvbnZlcnNhdGlvbkxvZ2dlcjoge1xuICAgIGluaXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgbG9nOiBqZXN0LmZuKCksXG4gICAgICBlcnJvcjogamVzdC5mbigpLFxuICAgICAgd2FybjogamVzdC5mbigpLFxuICAgIH0pLFxuICB9LFxufSkpO1xuamVzdC5tb2NrKFwiQC9saWIvZGVidWctbG9nZ2VyXCIsICgpID0+ICh7XG4gIGRlYnVnTG9nOiBqZXN0LmZuKCksXG59KSk7XG5cbmltcG9ydCB7XG4gIENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcixcbiAgdHlwZSBSZXNwb25zZU9wdGlvbnMsXG4gIHR5cGUgT3JjaGVzdHJhdG9yT3B0aW9ucyxcbn0gZnJvbSBcIi4uLy4uL2xpYi9jb252ZXJzYXRpb24tb3JjaGVzdHJhdG9yXCI7XG5pbXBvcnQgeyBLbm93bGVkZ2VSZXRyaWV2ZXIgfSBmcm9tIFwiLi4vLi4vbGliL2tub3dsZWRnZS1yZXRyaWV2ZXJcIjtcbmltcG9ydCB7IExMTUNsaWVudCB9IGZyb20gXCIuLi8uLi9saWIvbGxtLWNsaWVudFwiO1xuaW1wb3J0IHsgTExNU2VjdXJlQ2xpZW50IH0gZnJvbSBcIi4uLy4uL2xpYi9sbG0tc2VjdXJlLWNsaWVudFwiO1xuaW1wb3J0IHsgQ29udmVyc2F0aW9uTG9nZ2VyIH0gZnJvbSBcIi4uLy4uL2xpYi9jb252ZXJzYXRpb24tbG9nZ2VyXCI7XG5pbXBvcnQgdHlwZSB7XG4gIEFnZW50LFxuICBDb252ZXJzYXRpb24sXG4gIE1lc3NhZ2UsXG4gIEtub3dsZWRnZUVudHJ5LFxufSBmcm9tIFwiLi4vLi4vbGliL3R5cGVzXCI7XG5cbi8vIE1vY2sgdGltZXJzXG5qZXN0LnVzZUZha2VUaW1lcnMoKTtcblxuZGVzY3JpYmUoXCJsaWIvY29udmVyc2F0aW9uLW9yY2hlc3RyYXRvci50cyAtIENvbXBsZXRlIENvdmVyYWdlXCIsICgpID0+IHtcbiAgbGV0IG1vY2tDb252ZXJzYXRpb246IENvbnZlcnNhdGlvbjtcbiAgbGV0IG1vY2tBZ2VudHM6IEFnZW50W107XG4gIGxldCBtb2NrTExNQ2xpZW50OiBMTE1DbGllbnQ7XG4gIGxldCBtb2NrS25vd2xlZGdlUmV0cmlldmVyOiBLbm93bGVkZ2VSZXRyaWV2ZXI7XG4gIGxldCBtb2NrTG9nZ2VyOiBhbnk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgamVzdC5jbGVhckFsbFRpbWVycygpO1xuXG4gICAgLy8gU2V0dXAgbW9jayBjb252ZXJzYXRpb25cbiAgICBtb2NrQ29udmVyc2F0aW9uID0ge1xuICAgICAgaWQ6IFwiY29udi0xMjNcIixcbiAgICAgIHRpdGxlOiBcIlRlc3QgQ29udmVyc2F0aW9uXCIsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibXNnLTFcIixcbiAgICAgICAgICBjb252ZXJzYXRpb25JZDogXCJjb252LTEyM1wiLFxuICAgICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiSGVsbG9cIixcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKFwiMjAyNC0wMS0wMVwiKSxcbiAgICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBwYXJ0aWNpcGFudHM6IFtcImFnZW50LTFcIiwgXCJhZ2VudC0yXCJdLFxuICAgICAgY3JlYXRlZDogbmV3IERhdGUoXCIyMDI0LTAxLTAxXCIpLFxuICAgICAgdXBkYXRlZDogbmV3IERhdGUoXCIyMDI0LTAxLTAxXCIpLFxuICAgICAgdGFnczogW10sXG4gICAgfTtcblxuICAgIC8vIFNldHVwIG1vY2sgYWdlbnRzXG4gICAgbW9ja0FnZW50cyA9IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBuYW1lOiBcIkFnZW50IE9uZVwiLFxuICAgICAgICB0eXBlOiBcImNvbnZlcnNhdGlvbmFsXCIsXG4gICAgICAgIHN0YXR1czogXCJhY3RpdmVcIixcbiAgICAgICAgc3lzdGVtUHJvbXB0OiBcIllvdSBhcmUgYWdlbnQgb25lXCIsXG4gICAgICAgIGtub3dsZWRnZUlkczogW1wia25vd2xlZGdlLTFcIl0sXG4gICAgICAgIGNvbnZlcnNhdGlvbklkczogW1wiY29udi0xMjNcIl0sXG4gICAgICAgIGJlbGllZnM6IFtdLFxuICAgICAgICBwcmVmZXJlbmNlczoge30sXG4gICAgICAgIGNhcGFiaWxpdGllczogW10sXG4gICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKFwiMjAyNC0wMS0wMVwiKSxcbiAgICAgICAgdXBkYXRlZDogbmV3IERhdGUoXCIyMDI0LTAxLTAxXCIpLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYWdlbnQtMlwiLFxuICAgICAgICBuYW1lOiBcIkFnZW50IFR3b1wiLFxuICAgICAgICB0eXBlOiBcImNvbnZlcnNhdGlvbmFsXCIsXG4gICAgICAgIHN0YXR1czogXCJhY3RpdmVcIixcbiAgICAgICAgc3lzdGVtUHJvbXB0OiBcIllvdSBhcmUgYWdlbnQgdHdvXCIsXG4gICAgICAgIGtub3dsZWRnZUlkczogW1wia25vd2xlZGdlLTJcIl0sXG4gICAgICAgIGNvbnZlcnNhdGlvbklkczogW1wiY29udi0xMjNcIl0sXG4gICAgICAgIGJlbGllZnM6IFtdLFxuICAgICAgICBwcmVmZXJlbmNlczoge30sXG4gICAgICAgIGNhcGFiaWxpdGllczogW10sXG4gICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKFwiMjAyNC0wMS0wMVwiKSxcbiAgICAgICAgdXBkYXRlZDogbmV3IERhdGUoXCIyMDI0LTAxLTAxXCIpLFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgLy8gU2V0dXAgbW9jayBMTE0gY2xpZW50XG4gICAgbW9ja0xMTUNsaWVudCA9IG5ldyAoTExNQ2xpZW50IGFzIGFueSkoKTtcblxuICAgIC8vIFNldHVwIG1vY2sga25vd2xlZGdlIHJldHJpZXZlclxuICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIgPSB7XG4gICAgICBnZXRSZWxhdGVkS25vd2xlZGdlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwia25vd2xlZGdlLTFcIixcbiAgICAgICAgICB0aXRsZTogXCJUZXN0IEtub3dsZWRnZVwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiVGVzdCBrbm93bGVkZ2UgY29udGVudFwiLFxuICAgICAgICAgIHRhZ3M6IFtcInRlc3RcIl0sXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShcIjIwMjQtMDEtMDFcIiksXG4gICAgICAgIH0sXG4gICAgICBdKSxcbiAgICB9IGFzIGFueTtcblxuICAgIC8vIFNldHVwIG1vY2sgbG9nZ2VyXG4gICAgbW9ja0xvZ2dlciA9IHtcbiAgICAgIGxvZzogamVzdC5mbigpLFxuICAgICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICB9O1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxUaW1lcnMoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDb25zdHJ1Y3RvciBhbmQgSW5pdGlhbGl6YXRpb25cIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJpbml0aWFsaXplcyB3aXRoIGJhc2ljIGNvbmZpZ3VyYXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChDb252ZXJzYXRpb25Mb2dnZXIuaW5pdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJjb252LTEyM1wiKTtcbiAgICAgIGV4cGVjdChvcmNoZXN0cmF0b3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaW5pdGlhbGl6ZXMgd2l0aCBjdXN0b20gb3B0aW9uc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBPcmNoZXN0cmF0b3JPcHRpb25zID0ge1xuICAgICAgICBtYXhDb25jdXJyZW50UmVzcG9uc2VzOiAzLFxuICAgICAgICByZXNwb25zZURlbGF5OiAxMDAwLFxuICAgICAgICBhdXRvU2VsZWN0UmVzcG9uZGVudHM6IGZhbHNlLFxuICAgICAgICBvbk1lc3NhZ2VHZW5lcmF0ZWQ6IGplc3QuZm4oKSxcbiAgICAgICAgb25FcnJvcjogamVzdC5mbigpLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChvcmNoZXN0cmF0b3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaW5pdGlhbGl6ZXMgd2l0aCBlbXB0eSBjb252ZXJzYXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZW1wdHlDb252ZXJzYXRpb24gPSB7XG4gICAgICAgIC4uLm1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIGVtcHR5Q29udmVyc2F0aW9uLFxuICAgICAgICBtb2NrQWdlbnRzLFxuICAgICAgICBtb2NrTExNQ2xpZW50LFxuICAgICAgICBtb2NrS25vd2xlZGdlUmV0cmlldmVyLFxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KG9yY2hlc3RyYXRvcikudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJpbml0aWFsaXplcyB3aXRoIHJlc3BvbnNlIGRlbGF5IHJhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IE9yY2hlc3RyYXRvck9wdGlvbnMgPSB7XG4gICAgICAgIHJlc3BvbnNlRGVsYXk6IFsxMDAwLCAzMDAwXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuXG4gICAgICBleHBlY3Qob3JjaGVzdHJhdG9yKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImhhbmRsZU5ld01lc3NhZ2UgbWV0aG9kXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiaGFuZGxlcyBuZXcgbWVzc2FnZSBzdWNjZXNzZnVsbHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld01lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBcIm1zZy0yXCIsXG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiBcImNvbnYtMTIzXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBjb250ZW50OiBcIk5ldyBtZXNzYWdlXCIsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoXCIyMDI0LTAxLTAyXCIpLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKG5ld01lc3NhZ2UpO1xuXG4gICAgICAvLyBTaG91bGQgcHJvY2VzcyBxdWV1ZVxuICAgICAgamVzdC5ydW5Pbmx5UGVuZGluZ1RpbWVycygpO1xuXG4gICAgICBleHBlY3QobW9ja0xvZ2dlci5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIk5FV19NRVNTQUdFXCIsXG4gICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgZXhwZWN0LmFueShPYmplY3QpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJpZ25vcmVzIG1lc3NhZ2Ugd2l0aCBubyBhZ2VudCBJRFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmNoZXN0cmF0b3IgPSBuZXcgQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yKFxuICAgICAgICBtb2NrQ29udmVyc2F0aW9uLFxuICAgICAgICBtb2NrQWdlbnRzLFxuICAgICAgICBtb2NrTExNQ2xpZW50LFxuICAgICAgICBtb2NrS25vd2xlZGdlUmV0cmlldmVyLFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3lzdGVtTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgaWQ6IFwibXNnLXN5c3RlbVwiLFxuICAgICAgICBjb252ZXJzYXRpb25JZDogXCJjb252LTEyM1wiLFxuICAgICAgICBjb250ZW50OiBcIlN5c3RlbSBtZXNzYWdlXCIsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoXCIyMDI0LTAxLTAyXCIpLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKHN5c3RlbU1lc3NhZ2UpO1xuXG4gICAgICBleHBlY3QobW9ja0xvZ2dlci53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJOT19BR0VOVF9JRFwiLFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNraXBzIGFscmVhZHkgcHJvY2Vzc2VkIG1lc3NhZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG9sZE1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBcIm1zZy0xXCIsIC8vIFNhbWUgYXMgaW5pdGlhbCBtZXNzYWdlXG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiBcImNvbnYtMTIzXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBjb250ZW50OiBcIk9sZCBtZXNzYWdlXCIsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoXCIyMDI0LTAxLTAxXCIpLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKG9sZE1lc3NhZ2UpO1xuXG4gICAgICBleHBlY3QobW9ja0xvZ2dlci5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIlNLSVBfTUVTU0FHRVwiLFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBjdXN0b20gcmVzcG9uc2Ugb3B0aW9uc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvbkNodW5rID0gamVzdC5mbigpO1xuICAgICAgY29uc3Qgb25NZXNzYWdlR2VuZXJhdGVkID0gamVzdC5mbigpO1xuXG4gICAgICBjb25zdCBvcHRpb25zOiBPcmNoZXN0cmF0b3JPcHRpb25zID0ge1xuICAgICAgICBhdXRvU2VsZWN0UmVzcG9uZGVudHM6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvcmNoZXN0cmF0b3IgPSBuZXcgQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yKFxuICAgICAgICBtb2NrQ29udmVyc2F0aW9uLFxuICAgICAgICBtb2NrQWdlbnRzLFxuICAgICAgICBtb2NrTExNQ2xpZW50LFxuICAgICAgICBtb2NrS25vd2xlZGdlUmV0cmlldmVyLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgbmV3TWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgaWQ6IFwibXNnLTJcIixcbiAgICAgICAgY29udmVyc2F0aW9uSWQ6IFwiY29udi0xMjNcIixcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiTmV3IG1lc3NhZ2VcIixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShcIjIwMjQtMDEtMDJcIiksXG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VPcHRpb25zOiBSZXNwb25zZU9wdGlvbnMgPSB7XG4gICAgICAgIG1heEtub3dsZWRnZUVudHJpZXM6IDUsXG4gICAgICAgIGluY2x1ZGVBZ2VudEtub3dsZWRnZTogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZVRhZ3M6IFtcImltcG9ydGFudFwiXSxcbiAgICAgICAgc3RyZWFtUmVzcG9uc2U6IHRydWUsXG4gICAgICAgIG9uQ2h1bmssXG4gICAgICAgIG9uTWVzc2FnZUdlbmVyYXRlZCxcbiAgICAgICAgcmVzcG9uc2VEZWxheTogMCxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKG5ld01lc3NhZ2UsIHJlc3BvbnNlT3B0aW9ucyk7XG5cbiAgICAgIGplc3QucnVuQWxsVGltZXJzKCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGFzeW5jIG9wZXJhdGlvbnNcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRJbW1lZGlhdGUocmVzb2x2ZSkpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZXJyb3IgY2FsbGJhY2tcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb25FcnJvciA9IGplc3QuZm4oKTtcblxuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICAgeyBvbkVycm9yIH0sXG4gICAgICApO1xuXG4gICAgICAvLyBNYWtlIExMTSBjbGllbnQgdGhyb3cgZXJyb3JcbiAgICAgIChtb2NrTExNQ2xpZW50LmdlbmVyYXRlUmVzcG9uc2UgYXMgTW9jaykubW9ja1JlamVjdGVkVmFsdWUoXG4gICAgICAgIG5ldyBFcnJvcihcIkxMTSBlcnJvclwiKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld01lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBcIm1zZy0yXCIsXG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiBcImNvbnYtMTIzXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBjb250ZW50OiBcIk5ldyBtZXNzYWdlXCIsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoXCIyMDI0LTAxLTAyXCIpLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKG5ld01lc3NhZ2UpO1xuXG4gICAgICBqZXN0LnJ1bkFsbFRpbWVycygpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldEltbWVkaWF0ZShyZXNvbHZlKSk7XG5cbiAgICAgIGV4cGVjdChvbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3QuYW55KEVycm9yKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiZ2VuZXJhdGVBZ2VudFJlc3BvbnNlIG1ldGhvZFwiLCAoKSA9PiB7XG4gICAgdGVzdChcImdlbmVyYXRlcyByZXNwb25zZSB3aXRoIHN0cmVhbWluZ1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvbkNodW5rID0gamVzdC5mbigpO1xuICAgICAgY29uc3Qgb25NZXNzYWdlR2VuZXJhdGVkID0gamVzdC5mbigpO1xuXG4gICAgICBjb25zdCBvcmNoZXN0cmF0b3IgPSBuZXcgQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yKFxuICAgICAgICBtb2NrQ29udmVyc2F0aW9uLFxuICAgICAgICBtb2NrQWdlbnRzLFxuICAgICAgICBtb2NrTExNQ2xpZW50LFxuICAgICAgICBtb2NrS25vd2xlZGdlUmV0cmlldmVyLFxuICAgICAgICB7IG9uTWVzc2FnZUdlbmVyYXRlZCB9LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgYWdlbnQgPSBtb2NrQWdlbnRzWzBdO1xuICAgICAgY29uc3Qgb3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0ge1xuICAgICAgICBzdHJlYW1SZXNwb25zZTogdHJ1ZSxcbiAgICAgICAgb25DaHVuayxcbiAgICAgICAgaW5jbHVkZUFnZW50S25vd2xlZGdlOiB0cnVlLFxuICAgICAgICBtYXhLbm93bGVkZ2VFbnRyaWVzOiAzLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgb3JjaGVzdHJhdG9yLmdlbmVyYXRlQWdlbnRSZXNwb25zZShhZ2VudCwgb3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChvbkNodW5rKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIlN0cmVhbWluZyBcIiwgZmFsc2UpO1xuICAgICAgZXhwZWN0KG9uQ2h1bmspLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwicmVzcG9uc2VcIiwgZmFsc2UpO1xuICAgICAgZXhwZWN0KG9uQ2h1bmspLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiXCIsIHRydWUpO1xuICAgICAgZXhwZWN0KG9uTWVzc2FnZUdlbmVyYXRlZCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImdlbmVyYXRlcyByZXNwb25zZSB3aXRob3V0IHN0cmVhbWluZ1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvbk1lc3NhZ2VHZW5lcmF0ZWQgPSBqZXN0LmZuKCk7XG5cbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBhZ2VudCA9IG1vY2tBZ2VudHNbMF07XG4gICAgICBjb25zdCBvcHRpb25zOiBSZXNwb25zZU9wdGlvbnMgPSB7XG4gICAgICAgIHN0cmVhbVJlc3BvbnNlOiBmYWxzZSxcbiAgICAgICAgb25NZXNzYWdlR2VuZXJhdGVkLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgb3JjaGVzdHJhdG9yLmdlbmVyYXRlQWdlbnRSZXNwb25zZShhZ2VudCwgb3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChtb2NrTExNQ2xpZW50LmdlbmVyYXRlUmVzcG9uc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChvbk1lc3NhZ2VHZW5lcmF0ZWQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJnZW5lcmF0ZXMgcmVzcG9uc2UgdG8gc3BlY2lmaWMgbWVzc2FnZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmNoZXN0cmF0b3IgPSBuZXcgQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yKFxuICAgICAgICBtb2NrQ29udmVyc2F0aW9uLFxuICAgICAgICBtb2NrQWdlbnRzLFxuICAgICAgICBtb2NrTExNQ2xpZW50LFxuICAgICAgICBtb2NrS25vd2xlZGdlUmV0cmlldmVyLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgYWdlbnQgPSBtb2NrQWdlbnRzWzFdO1xuICAgICAgY29uc3QgdGFyZ2V0TWVzc2FnZSA9IG1vY2tDb252ZXJzYXRpb24ubWVzc2FnZXNbMF07XG4gICAgICBjb25zdCBvcHRpb25zOiBSZXNwb25zZU9wdGlvbnMgPSB7XG4gICAgICAgIG1lc3NhZ2VUb1Jlc3BvbmRUbzogdGFyZ2V0TWVzc2FnZSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5nZW5lcmF0ZUFnZW50UmVzcG9uc2UoYWdlbnQsIG9wdGlvbnMpO1xuXG4gICAgICBleHBlY3QobW9ja0xMTUNsaWVudC5nZW5lcmF0ZVJlc3BvbnNlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXCJIZWxsb1wiKSxcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJpbmNsdWRlcyBrbm93bGVkZ2UgZW50cmllcyBpbiBwcm9tcHRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGFnZW50ID0gbW9ja0FnZW50c1swXTtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFJlc3BvbnNlT3B0aW9ucyA9IHtcbiAgICAgICAgaW5jbHVkZUFnZW50S25vd2xlZGdlOiB0cnVlLFxuICAgICAgICBtYXhLbm93bGVkZ2VFbnRyaWVzOiAyLFxuICAgICAgICBpbmNsdWRlVGFnczogW1widGVzdFwiXSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5nZW5lcmF0ZUFnZW50UmVzcG9uc2UoYWdlbnQsIG9wdGlvbnMpO1xuXG4gICAgICBleHBlY3QobW9ja0tub3dsZWRnZVJldHJpZXZlci5nZXRSZWxhdGVkS25vd2xlZGdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgW1wia25vd2xlZGdlLTFcIl0sXG4gICAgICAgIDIsXG4gICAgICAgIFtcInRlc3RcIl0sXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgTExNIHNlY3VyZSBjbGllbnRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NlY3VyZUNsaWVudCA9IG5ldyAoTExNU2VjdXJlQ2xpZW50IGFzIGFueSkoKTtcblxuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja1NlY3VyZUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGFnZW50ID0gbW9ja0FnZW50c1swXTtcbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5nZW5lcmF0ZUFnZW50UmVzcG9uc2UoYWdlbnQpO1xuXG4gICAgICBleHBlY3QobW9ja1NlY3VyZUNsaWVudC5nZW5lcmF0ZVJlc3BvbnNlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiZ2V0QXZhaWxhYmxlUmVzcG9uZGVudHMgbWV0aG9kXCIsICgpID0+IHtcbiAgICB0ZXN0KFwicmV0dXJucyBhZ2VudHMgbm90IGN1cnJlbnRseSBwcm9jZXNzaW5nXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICApO1xuXG4gICAgICAvLyBTaW11bGF0ZSBvbmUgYWdlbnQgcHJvY2Vzc2luZ1xuICAgICAgKG9yY2hlc3RyYXRvciBhcyBhbnkpLnByb2Nlc3NpbmdBZ2VudHMuYWRkKFwiYWdlbnQtMVwiKTtcblxuICAgICAgY29uc3QgYXZhaWxhYmxlQWdlbnRzID0gb3JjaGVzdHJhdG9yLmdldEF2YWlsYWJsZVJlc3BvbmRlbnRzKCk7XG5cbiAgICAgIGV4cGVjdChhdmFpbGFibGVBZ2VudHMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChhdmFpbGFibGVBZ2VudHNbMF0uaWQpLnRvQmUoXCJhZ2VudC0yXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImV4Y2x1ZGVzIGFnZW50IHdobyBzZW50IHRoZSBtZXNzYWdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICBpZDogXCJtc2ctMlwiLFxuICAgICAgICBjb252ZXJzYXRpb25JZDogXCJjb252LTEyM1wiLFxuICAgICAgICBhZ2VudElkOiBcImFnZW50LTFcIixcbiAgICAgICAgY29udGVudDogXCJUZXN0XCIsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgdGFnczogW10sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBhdmFpbGFibGVBZ2VudHMgPSBvcmNoZXN0cmF0b3IuZ2V0QXZhaWxhYmxlUmVzcG9uZGVudHMobWVzc2FnZSk7XG5cbiAgICAgIGV4cGVjdChhdmFpbGFibGVBZ2VudHMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChhdmFpbGFibGVBZ2VudHNbMF0uaWQpLnRvQmUoXCJhZ2VudC0yXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJldHVybnMgZW1wdHkgYXJyYXkgd2hlbiBhbGwgYWdlbnRzIGFyZSBwcm9jZXNzaW5nXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICApO1xuXG4gICAgICAvLyBBbGwgYWdlbnRzIHByb2Nlc3NpbmdcbiAgICAgIChvcmNoZXN0cmF0b3IgYXMgYW55KS5wcm9jZXNzaW5nQWdlbnRzLmFkZChcImFnZW50LTFcIik7XG4gICAgICAob3JjaGVzdHJhdG9yIGFzIGFueSkucHJvY2Vzc2luZ0FnZW50cy5hZGQoXCJhZ2VudC0yXCIpO1xuXG4gICAgICBjb25zdCBhdmFpbGFibGVBZ2VudHMgPSBvcmNoZXN0cmF0b3IuZ2V0QXZhaWxhYmxlUmVzcG9uZGVudHMoKTtcblxuICAgICAgZXhwZWN0KGF2YWlsYWJsZUFnZW50cykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlF1ZXVlIFByb2Nlc3NpbmdcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJwcm9jZXNzZXMgcXVldWUgd2l0aCBkZWxheVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmNoZXN0cmF0b3IgPSBuZXcgQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yKFxuICAgICAgICBtb2NrQ29udmVyc2F0aW9uLFxuICAgICAgICBtb2NrQWdlbnRzLFxuICAgICAgICBtb2NrTExNQ2xpZW50LFxuICAgICAgICBtb2NrS25vd2xlZGdlUmV0cmlldmVyLFxuICAgICAgICB7IHJlc3BvbnNlRGVsYXk6IDEwMDAgfSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld01lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBcIm1zZy0yXCIsXG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiBcImNvbnYtMTIzXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBjb250ZW50OiBcIlRlc3RcIixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKG5ld01lc3NhZ2UpO1xuXG4gICAgICAvLyBQcm9jZXNzIHF1ZXVlXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwKTsgLy8gUXVldWUgcHJvY2Vzc29yIGludGVydmFsXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwMCk7IC8vIFJlc3BvbnNlIGRlbGF5XG5cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRJbW1lZGlhdGUocmVzb2x2ZSkpO1xuXG4gICAgICBleHBlY3QobW9ja0xMTUNsaWVudC5nZW5lcmF0ZVJlc3BvbnNlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicHJvY2Vzc2VzIHF1ZXVlIHdpdGggcmFuZG9tIGRlbGF5IHJhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICAgIHsgcmVzcG9uc2VEZWxheTogWzUwMCwgMTUwMF0gfSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld01lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBcIm1zZy0yXCIsXG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiBcImNvbnYtMTIzXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBjb250ZW50OiBcIlRlc3RcIixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKG5ld01lc3NhZ2UpO1xuXG4gICAgICAvLyBQcm9jZXNzIHF1ZXVlXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwKTsgLy8gUXVldWUgcHJvY2Vzc29yIGludGVydmFsXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTUwMCk7IC8vIE1heCBkZWxheVxuXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0SW1tZWRpYXRlKHJlc29sdmUpKTtcblxuICAgICAgZXhwZWN0KG1vY2tMTE1DbGllbnQuZ2VuZXJhdGVSZXNwb25zZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJlc3BlY3RzIG1heCBjb25jdXJyZW50IHJlc3BvbnNlc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmNoZXN0cmF0b3IgPSBuZXcgQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yKFxuICAgICAgICBtb2NrQ29udmVyc2F0aW9uLFxuICAgICAgICBtb2NrQWdlbnRzLFxuICAgICAgICBtb2NrTExNQ2xpZW50LFxuICAgICAgICBtb2NrS25vd2xlZGdlUmV0cmlldmVyLFxuICAgICAgICB7XG4gICAgICAgICAgbWF4Q29uY3VycmVudFJlc3BvbnNlczogMSxcbiAgICAgICAgICByZXNwb25zZURlbGF5OiAwLFxuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgICAgLy8gQWRkIG11bHRpcGxlIG1lc3NhZ2VzIHRvIHF1ZXVlXG4gICAgICBhd2FpdCBvcmNoZXN0cmF0b3IuaGFuZGxlTmV3TWVzc2FnZSh7XG4gICAgICAgIGlkOiBcIm1zZy0yXCIsXG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiBcImNvbnYtMTIzXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBjb250ZW50OiBcIlRlc3QgMVwiLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKHtcbiAgICAgICAgaWQ6IFwibXNnLTNcIixcbiAgICAgICAgY29udmVyc2F0aW9uSWQ6IFwiY29udi0xMjNcIixcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiVGVzdCAyXCIsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgdGFnczogW10sXG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvY2VzcyBxdWV1ZVxuICAgICAgamVzdC5ydW5BbGxUaW1lcnMoKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRJbW1lZGlhdGUocmVzb2x2ZSkpO1xuXG4gICAgICAvLyBTaG91bGQgb25seSBwcm9jZXNzIG9uZSBhdCBhIHRpbWVcbiAgICAgIGV4cGVjdCgob3JjaGVzdHJhdG9yIGFzIGFueSkucHJvY2Vzc2luZ0FnZW50cy5zaXplKS50b0JlTGVzc1RoYW5PckVxdWFsKFxuICAgICAgICAxLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJ1cGRhdGVDb252ZXJzYXRpb24gbWV0aG9kXCIsICgpID0+IHtcbiAgICB0ZXN0KFwidXBkYXRlcyBjb252ZXJzYXRpb24gYW5kIHByb2Nlc3NlcyBuZXcgbWVzc2FnZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRDb252ZXJzYXRpb24gPSB7XG4gICAgICAgIC4uLm1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAgLi4ubW9ja0NvbnZlcnNhdGlvbi5tZXNzYWdlcyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogXCJtc2ctMlwiLFxuICAgICAgICAgICAgY29udmVyc2F0aW9uSWQ6IFwiY29udi0xMjNcIixcbiAgICAgICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMlwiLFxuICAgICAgICAgICAgY29udGVudDogXCJOZXcgbWVzc2FnZVwiLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgdGFnczogW10sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH07XG5cbiAgICAgIG9yY2hlc3RyYXRvci51cGRhdGVDb252ZXJzYXRpb24odXBkYXRlZENvbnZlcnNhdGlvbik7XG5cbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiVVBEQVRFX0NPTlZFUlNBVElPTlwiLFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFuZGxlcyBjb252ZXJzYXRpb24gd2l0aCBubyBuZXcgbWVzc2FnZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICk7XG5cbiAgICAgIG9yY2hlc3RyYXRvci51cGRhdGVDb252ZXJzYXRpb24obW9ja0NvbnZlcnNhdGlvbik7XG5cbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiVVBEQVRFX0NPTlZFUlNBVElPTlwiLFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgbmV3TWVzc2FnZUNvdW50OiAwIH0pLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJ1cGRhdGVBZ2VudHMgbWV0aG9kXCIsICgpID0+IHtcbiAgICB0ZXN0KFwidXBkYXRlcyBhZ2VudHMgbWFwXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBuZXdBZ2VudDogQWdlbnQgPSB7XG4gICAgICAgIGlkOiBcImFnZW50LTNcIixcbiAgICAgICAgbmFtZTogXCJBZ2VudCBUaHJlZVwiLFxuICAgICAgICB0eXBlOiBcImNvbnZlcnNhdGlvbmFsXCIsXG4gICAgICAgIHN0YXR1czogXCJhY3RpdmVcIixcbiAgICAgICAgc3lzdGVtUHJvbXB0OiBcIllvdSBhcmUgYWdlbnQgdGhyZWVcIixcbiAgICAgICAga25vd2xlZGdlSWRzOiBbXSxcbiAgICAgICAgY29udmVyc2F0aW9uSWRzOiBbXCJjb252LTEyM1wiXSxcbiAgICAgICAgYmVsaWVmczogW10sXG4gICAgICAgIHByZWZlcmVuY2VzOiB7fSxcbiAgICAgICAgY2FwYWJpbGl0aWVzOiBbXSxcbiAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZDogbmV3IERhdGUoKSxcbiAgICAgIH07XG5cbiAgICAgIG9yY2hlc3RyYXRvci51cGRhdGVBZ2VudHMoWy4uLm1vY2tBZ2VudHMsIG5ld0FnZW50XSk7XG5cbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiVVBEQVRFX0FHRU5UU1wiLFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgYWdlbnRDb3VudDogMyB9KSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiY2xlYXJRdWV1ZSBtZXRob2RcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjbGVhcnMgcmVzcG9uc2UgcXVldWVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICk7XG5cbiAgICAgIC8vIEFkZCBtZXNzYWdlIHRvIHF1ZXVlXG4gICAgICBhd2FpdCBvcmNoZXN0cmF0b3IuaGFuZGxlTmV3TWVzc2FnZSh7XG4gICAgICAgIGlkOiBcIm1zZy0yXCIsXG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiBcImNvbnYtMTIzXCIsXG4gICAgICAgIGFnZW50SWQ6IFwiYWdlbnQtMVwiLFxuICAgICAgICBjb250ZW50OiBcIlRlc3RcIixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgIH0pO1xuXG4gICAgICBvcmNoZXN0cmF0b3IuY2xlYXJRdWV1ZSgpO1xuXG4gICAgICBleHBlY3QobW9ja0xvZ2dlci5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkNMRUFSX1FVRVVFXCIsXG4gICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiZGVzdHJveSBtZXRob2RcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjbGVhbnMgdXAgcmVzb3VyY2VzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICApO1xuXG4gICAgICBvcmNoZXN0cmF0b3IuZGVzdHJveSgpO1xuXG4gICAgICBleHBlY3QobW9ja0xvZ2dlci5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkRFU1RST1lcIixcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFcnJvciBIYW5kbGluZ1wiLCAoKSA9PiB7XG4gICAgdGVzdChcImhhbmRsZXMgZXJyb3IgaW4gZ2VuZXJhdGVBZ2VudFJlc3BvbnNlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSBqZXN0LmZuKCk7XG5cbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICAgIHsgb25FcnJvciB9LFxuICAgICAgKTtcblxuICAgICAgKG1vY2tMTE1DbGllbnQuZ2VuZXJhdGVSZXNwb25zZSBhcyBNb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IEVycm9yKFwiR2VuZXJhdGlvbiBmYWlsZWRcIiksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBhZ2VudCA9IG1vY2tBZ2VudHNbMF07XG4gICAgICBhd2FpdCBvcmNoZXN0cmF0b3IuZ2VuZXJhdGVBZ2VudFJlc3BvbnNlKGFnZW50KTtcblxuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIlJFU1BPTlNFX0VSUk9SXCIsXG4gICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgZXhwZWN0LmFueShFcnJvciksXG4gICAgICApO1xuICAgICAgZXhwZWN0KG9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5hbnkoRXJyb3IpKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGVycm9yIGluIHN0cmVhbWluZyByZXNwb25zZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvbkVycm9yID0gamVzdC5mbigpO1xuICAgICAgY29uc3Qgb25DaHVuayA9IGplc3QuZm4oKTtcblxuICAgICAgY29uc3Qgb3JjaGVzdHJhdG9yID0gbmV3IENvbnZlcnNhdGlvbk9yY2hlc3RyYXRvcihcbiAgICAgICAgbW9ja0NvbnZlcnNhdGlvbixcbiAgICAgICAgbW9ja0FnZW50cyxcbiAgICAgICAgbW9ja0xMTUNsaWVudCxcbiAgICAgICAgbW9ja0tub3dsZWRnZVJldHJpZXZlcixcbiAgICAgICAgeyBvbkVycm9yIH0sXG4gICAgICApO1xuXG4gICAgICAvLyBNYWtlIHN0cmVhbWluZyB0aHJvdyBlcnJvclxuICAgICAgKG1vY2tMTE1DbGllbnQuc3RyZWFtR2VuZXJhdGVSZXNwb25zZSBhcyBNb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGZhaWxlZFwiKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGFnZW50ID0gbW9ja0FnZW50c1swXTtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFJlc3BvbnNlT3B0aW9ucyA9IHtcbiAgICAgICAgc3RyZWFtUmVzcG9uc2U6IHRydWUsXG4gICAgICAgIG9uQ2h1bmssXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBvcmNoZXN0cmF0b3IuZ2VuZXJhdGVBZ2VudFJlc3BvbnNlKGFnZW50LCBvcHRpb25zKTtcblxuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIlJFU1BPTlNFX0VSUk9SXCIsXG4gICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgZXhwZWN0LmFueShFcnJvciksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkVkZ2UgQ2FzZXNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJoYW5kbGVzIGFnZW50IG5vdCBpbiBhZ2VudHMgbWFwXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICApO1xuXG4gICAgICBjb25zdCB1bmtub3duQWdlbnQ6IEFnZW50ID0ge1xuICAgICAgICBpZDogXCJ1bmtub3duLWFnZW50XCIsXG4gICAgICAgIG5hbWU6IFwiVW5rbm93blwiLFxuICAgICAgICB0eXBlOiBcImNvbnZlcnNhdGlvbmFsXCIsXG4gICAgICAgIHN0YXR1czogXCJhY3RpdmVcIixcbiAgICAgICAgc3lzdGVtUHJvbXB0OiBcIlVua25vd25cIixcbiAgICAgICAga25vd2xlZGdlSWRzOiBbXSxcbiAgICAgICAgY29udmVyc2F0aW9uSWRzOiBbXSxcbiAgICAgICAgYmVsaWVmczogW10sXG4gICAgICAgIHByZWZlcmVuY2VzOiB7fSxcbiAgICAgICAgY2FwYWJpbGl0aWVzOiBbXSxcbiAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZDogbmV3IERhdGUoKSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5nZW5lcmF0ZUFnZW50UmVzcG9uc2UodW5rbm93bkFnZW50KTtcblxuICAgICAgZXhwZWN0KG1vY2tMTE1DbGllbnQuZ2VuZXJhdGVSZXNwb25zZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZW1wdHkga25vd2xlZGdlIGVudHJpZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIuZ2V0UmVsYXRlZEtub3dsZWRnZSBhcyBNb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShcbiAgICAgICAgW10sXG4gICAgICApO1xuXG4gICAgICBjb25zdCBvcmNoZXN0cmF0b3IgPSBuZXcgQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yKFxuICAgICAgICBtb2NrQ29udmVyc2F0aW9uLFxuICAgICAgICBtb2NrQWdlbnRzLFxuICAgICAgICBtb2NrTExNQ2xpZW50LFxuICAgICAgICBtb2NrS25vd2xlZGdlUmV0cmlldmVyLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgYWdlbnQgPSBtb2NrQWdlbnRzWzBdO1xuICAgICAgY29uc3Qgb3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0ge1xuICAgICAgICBpbmNsdWRlQWdlbnRLbm93bGVkZ2U6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBvcmNoZXN0cmF0b3IuZ2VuZXJhdGVBZ2VudFJlc3BvbnNlKGFnZW50LCBvcHRpb25zKTtcblxuICAgICAgZXhwZWN0KG1vY2tMTE1DbGllbnQuZ2VuZXJhdGVSZXNwb25zZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZm9yY2VkIHJlc3BvbnNlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9yY2hlc3RyYXRvciA9IG5ldyBDb252ZXJzYXRpb25PcmNoZXN0cmF0b3IoXG4gICAgICAgIG1vY2tDb252ZXJzYXRpb24sXG4gICAgICAgIG1vY2tBZ2VudHMsXG4gICAgICAgIG1vY2tMTE1DbGllbnQsXG4gICAgICAgIG1vY2tLbm93bGVkZ2VSZXRyaWV2ZXIsXG4gICAgICAgIHsgYXV0b1NlbGVjdFJlc3BvbmRlbnRzOiBmYWxzZSB9LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgbmV3TWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgaWQ6IFwibXNnLTJcIixcbiAgICAgICAgY29udmVyc2F0aW9uSWQ6IFwiY29udi0xMjNcIixcbiAgICAgICAgYWdlbnRJZDogXCJhZ2VudC0xXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiVGVzdFwiLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0ge1xuICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IG9yY2hlc3RyYXRvci5oYW5kbGVOZXdNZXNzYWdlKG5ld01lc3NhZ2UsIG9wdGlvbnMpO1xuXG4gICAgICBqZXN0LnJ1bkFsbFRpbWVycygpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldEltbWVkaWF0ZShyZXNvbHZlKSk7XG5cbiAgICAgIGV4cGVjdChtb2NrTExNQ2xpZW50LmdlbmVyYXRlUmVzcG9uc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIkxMTUNsaWVudCIsImZuIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZ2VuZXJhdGVSZXNwb25zZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwic3RyZWFtR2VuZXJhdGVSZXNwb25zZSIsInRleHQiLCJpc0NvbXBsZXRlIiwiTExNU2VjdXJlQ2xpZW50IiwiQ29udmVyc2F0aW9uTG9nZ2VyIiwiaW5pdCIsIm1vY2tSZXR1cm5WYWx1ZSIsImxvZyIsImVycm9yIiwid2FybiIsImRlYnVnTG9nIiwidXNlRmFrZVRpbWVycyIsImRlc2NyaWJlIiwibW9ja0NvbnZlcnNhdGlvbiIsIm1vY2tBZ2VudHMiLCJtb2NrTExNQ2xpZW50IiwibW9ja0tub3dsZWRnZVJldHJpZXZlciIsIm1vY2tMb2dnZXIiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImNsZWFyQWxsVGltZXJzIiwiaWQiLCJ0aXRsZSIsIm1lc3NhZ2VzIiwiY29udmVyc2F0aW9uSWQiLCJhZ2VudElkIiwiY29udGVudCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0YWdzIiwicGFydGljaXBhbnRzIiwiY3JlYXRlZCIsInVwZGF0ZWQiLCJuYW1lIiwidHlwZSIsInN0YXR1cyIsInN5c3RlbVByb21wdCIsImtub3dsZWRnZUlkcyIsImNvbnZlcnNhdGlvbklkcyIsImJlbGllZnMiLCJwcmVmZXJlbmNlcyIsImNhcGFiaWxpdGllcyIsImdldFJlbGF0ZWRLbm93bGVkZ2UiLCJhZnRlckVhY2giLCJ0ZXN0Iiwib3JjaGVzdHJhdG9yIiwiQ29udmVyc2F0aW9uT3JjaGVzdHJhdG9yIiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0JlRGVmaW5lZCIsIm9wdGlvbnMiLCJtYXhDb25jdXJyZW50UmVzcG9uc2VzIiwicmVzcG9uc2VEZWxheSIsImF1dG9TZWxlY3RSZXNwb25kZW50cyIsIm9uTWVzc2FnZUdlbmVyYXRlZCIsIm9uRXJyb3IiLCJlbXB0eUNvbnZlcnNhdGlvbiIsIm5ld01lc3NhZ2UiLCJoYW5kbGVOZXdNZXNzYWdlIiwicnVuT25seVBlbmRpbmdUaW1lcnMiLCJhbnkiLCJTdHJpbmciLCJPYmplY3QiLCJzeXN0ZW1NZXNzYWdlIiwib2xkTWVzc2FnZSIsIm9uQ2h1bmsiLCJyZXNwb25zZU9wdGlvbnMiLCJtYXhLbm93bGVkZ2VFbnRyaWVzIiwiaW5jbHVkZUFnZW50S25vd2xlZGdlIiwiaW5jbHVkZVRhZ3MiLCJzdHJlYW1SZXNwb25zZSIsInJ1bkFsbFRpbWVycyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0SW1tZWRpYXRlIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsImFnZW50IiwiZ2VuZXJhdGVBZ2VudFJlc3BvbnNlIiwidG9IYXZlQmVlbkNhbGxlZCIsInRhcmdldE1lc3NhZ2UiLCJtZXNzYWdlVG9SZXNwb25kVG8iLCJzdHJpbmdDb250YWluaW5nIiwibW9ja1NlY3VyZUNsaWVudCIsInByb2Nlc3NpbmdBZ2VudHMiLCJhZGQiLCJhdmFpbGFibGVBZ2VudHMiLCJnZXRBdmFpbGFibGVSZXNwb25kZW50cyIsInRvSGF2ZUxlbmd0aCIsInRvQmUiLCJtZXNzYWdlIiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsInNpemUiLCJ0b0JlTGVzc1RoYW5PckVxdWFsIiwidXBkYXRlZENvbnZlcnNhdGlvbiIsInVwZGF0ZUNvbnZlcnNhdGlvbiIsIm9iamVjdENvbnRhaW5pbmciLCJuZXdNZXNzYWdlQ291bnQiLCJuZXdBZ2VudCIsInVwZGF0ZUFnZW50cyIsImFnZW50Q291bnQiLCJjbGVhclF1ZXVlIiwiZGVzdHJveSIsInVua25vd25BZ2VudCIsImZvcmNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDOzs7O3lCQUVvQjswQ0EwQ2Q7MkJBRW1CO2lDQUNNO29DQUNHO0FBM0NuQyxvQkFBb0I7QUFDcEJBLGFBQUksQ0FBQ0MsSUFBSSxDQUFDO0FBQ1ZELGFBQUksQ0FBQ0MsSUFBSSxDQUFDLG9CQUFvQixJQUFPLENBQUE7UUFDbkNDLFdBQVdGLGFBQUksQ0FBQ0csRUFBRSxHQUFHQyxrQkFBa0IsQ0FBQyxJQUFP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