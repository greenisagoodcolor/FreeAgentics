{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/belief-extraction.ts"],"sourcesContent":["import type { KnowledgeEntry } from \"@/lib/types\";\nimport { extractTagsFromMarkdown } from \"@/lib/utils\";\n// import { generateResponse } from \"@/lib/llm-service\" // Avoid direct import from llm-service\n\n// Types for the belief extraction pipeline\nexport interface ExtractedBelief {\n  content: string;\n  confidence: \"High\" | \"Medium\" | \"Low\";\n  source: \"conversation\";\n  tags: string[];\n}\n\nexport interface RefinedBelief {\n  originalIndex: number;\n  accuracy: number; // 1-5 scale\n  relevance: number; // 1-5 scale\n  category: \"Fact\" | \"Opinion\" | \"Preference\" | \"Relationship\" | \"Other\";\n  title: string;\n  refined_content: string;\n  confidence: \"High\" | \"Medium\" | \"Low\";\n  tags: string[];\n  selected?: boolean;\n  novelty?: \"High\" | \"Medium\" | \"Low\";\n}\n\n/**\n * Creates fallback refined beliefs when LLM refinement fails\n */\nexport function createFallbackRefinedBeliefs(\n  beliefs: ExtractedBelief[],\n): RefinedBelief[] {\n  return beliefs.map((belief, index) => ({\n    originalIndex: index,\n    accuracy: 3, // Medium accuracy\n    relevance: 3, // Medium relevance\n    category: \"Fact\" as const,\n    title: `Knowledge about ${belief.tags[0] || \"topic\"}`,\n    refined_content: belief.content,\n    confidence: belief.confidence,\n    tags: belief.tags,\n    selected: true,\n    novelty: \"Medium\",\n  }));\n}\n\n/**\n * Parses raw LLM response to extract beliefs\n */\nexport function parseBeliefs(response: string): ExtractedBelief[] {\n  const beliefs: ExtractedBelief[] = [];\n\n  // Split by bullet points or numbered lists, but only process top-level items (not indented sub-items)\n  const lines = response\n    .split(/\\n+/)\n    .filter(\n      (line) => {\n        const trimmed = line.trim();\n        // Must be a bullet/number format\n        if (!(trimmed.startsWith(\"-\") || trimmed.startsWith(\"•\") || /^\\d+\\./.test(trimmed))) {\n          return false;\n        }\n        // Check for excessive indentation (more than 8 spaces suggests a sub-item)\n        // This allows for reasonable formatting indentation while filtering true sub-items\n        const leadingSpaces = line.match(/^ */)[0].length;\n        return leadingSpaces <= 8;\n      }\n    );\n\n  for (const line of lines) {\n    // Remove bullet points, numbers, and leading whitespace\n    const withoutBullets = line.replace(/^\\s*[-•]\\s*/, \"\").replace(/^\\s*\\d+\\.\\s*/, \"\").trim();\n\n    // Extract confidence level if present (case insensitive, use last occurrence)\n    let confidence: \"High\" | \"Medium\" | \"Low\" = \"Medium\";\n    const confidenceMatches = Array.from(withoutBullets.matchAll(/\\$\\$(High|Medium|Low)\\$\\$/gi));\n    \n    if (confidenceMatches.length > 0) {\n      // Use the last confidence marker found and preserve its exact case\n      const lastMatch = confidenceMatches[confidenceMatches.length - 1];\n      const originalCase = lastMatch[1];\n      // Preserve original case while ensuring type safety\n      if (originalCase.toLowerCase() === \"high\") {\n        confidence = originalCase as any;\n      } else if (originalCase.toLowerCase() === \"medium\") {\n        confidence = originalCase as any;\n      } else if (originalCase.toLowerCase() === \"low\") {\n        confidence = originalCase as any;\n      }\n    }\n\n    // Clean up the content by removing confidence markers and preserving [[tags]]\n    const cleanContent = withoutBullets\n      .replace(/\\$\\$(High|Medium|Low)\\$\\$/gi, \"\")\n      .trim();\n\n    // Extract tags using the existing utility\n    const tags = extractTagsFromMarkdown(cleanContent);\n\n    if (cleanContent) {\n      beliefs.push({\n        content: cleanContent,\n        confidence,\n        source: \"conversation\",\n        tags,\n      });\n    }\n  }\n\n  return beliefs;\n}\n\n/**\n * Filters out beliefs that are duplicates of existing knowledge\n */\nfunction filterDuplicateBeliefs(\n  beliefs: ExtractedBelief[],\n  existingKnowledge: KnowledgeEntry[],\n): ExtractedBelief[] {\n  // Simple implementation - can be enhanced with more sophisticated similarity detection\n  return beliefs.filter((belief) => {\n    // Check if this belief is similar to any existing knowledge\n    return !existingKnowledge.some((entry) => {\n      // Check for content similarity\n      const contentSimilarity = calculateTextSimilarity(\n        belief.content,\n        entry.content,\n      );\n\n      // Check for tag overlap\n      const tagOverlap = belief.tags.some((tag) => entry.tags.includes(tag));\n\n      // Consider it a duplicate if content is very similar or there's significant tag overlap\n      return contentSimilarity > 0.7 || (tagOverlap && contentSimilarity > 0.5);\n    });\n  });\n}\n\n/**\n * Calculates text similarity between two strings (simple implementation)\n */\nfunction calculateTextSimilarity(text1: string, text2: string): number {\n  // Normalize texts\n  const normalize = (text: string) =>\n    text.toLowerCase().replace(/[^\\w\\s]/g, \"\");\n  const normalizedText1 = normalize(text1);\n  const normalizedText2 = normalize(text2);\n\n  // Simple word overlap for now\n  const words1 = new Set(normalizedText1.split(/\\s+/));\n  const words2 = new Set(normalizedText2.split(/\\s+/));\n\n  // Count common words\n  let commonWords = 0;\n  for (const word of words1) {\n    if (words2.has(word)) commonWords++;\n  }\n\n  // Calculate Jaccard similarity\n  const totalUniqueWords = new Set([...words1, ...words2]).size;\n  return totalUniqueWords > 0 ? commonWords / totalUniqueWords : 0;\n}\n\n/**\n * Parses refined beliefs from a JSON string, handling potential errors.\n */\nexport function parseRefinedBeliefs(\n  response: string,\n  sourceBeliefs: ExtractedBelief[],\n): RefinedBelief[] {\n  try {\n    // Attempt to parse the JSON response\n    const refinedBeliefs = JSON.parse(response) as RefinedBelief[];\n\n    // Validate the parsed beliefs to ensure they have the required properties\n    const validBeliefs = refinedBeliefs.filter(\n      (belief) =>\n        belief &&\n        typeof belief.originalIndex === \"number\" &&\n        typeof belief.refined_content === \"string\" &&\n        belief.refined_content.trim() !== \"\",\n    );\n\n    if (validBeliefs.length === 0) {\n      console.warn(\"No valid beliefs found in parsed JSON\");\n      return createFallbackRefinedBeliefs(sourceBeliefs);\n    }\n\n    // Set all beliefs as selected by default and ensure tags are properly extracted\n    return validBeliefs.map((belief) => ({\n      ...belief,\n      selected: belief.selected !== false, // Default to true if not explicitly set to false\n      // Ensure tags are properly extracted if missing\n      tags: belief.tags || extractTagsFromMarkdown(belief.refined_content),\n      // Add novelty field if missing\n      novelty: belief.novelty || \"Medium\",\n    }));\n  } catch (error) {\n    console.error(\"Error parsing refined beliefs JSON:\", error);\n    console.log(\"Raw response:\", response);\n    return createFallbackRefinedBeliefs(sourceBeliefs);\n  }\n}\n"],"names":["createFallbackRefinedBeliefs","parseBeliefs","parseRefinedBeliefs","beliefs","map","belief","index","originalIndex","accuracy","relevance","category","title","tags","refined_content","content","confidence","selected","novelty","response","lines","split","filter","line","trimmed","trim","startsWith","test","leadingSpaces","match","length","withoutBullets","replace","confidenceMatches","Array","from","matchAll","lastMatch","originalCase","toLowerCase","cleanContent","extractTagsFromMarkdown","push","source","filterDuplicateBeliefs","existingKnowledge","some","entry","contentSimilarity","calculateTextSimilarity","tagOverlap","tag","includes","text1","text2","normalize","text","normalizedText1","normalizedText2","words1","Set","words2","commonWords","word","has","totalUniqueWords","size","sourceBeliefs","refinedBeliefs","JSON","parse","validBeliefs","console","warn","error","log"],"mappings":"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"}