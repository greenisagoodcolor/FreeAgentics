1f1c731269e2ee5d6883f87bce4232d4
/**
 * Phase 1: lib/utils.ts Maximum Coverage Test Suite
 * Target: Complete coverage of all utility functions with all edge cases
 * Goal: Maximize statement coverage for highest impact
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _utils = require("../../lib/utils");
describe("lib/utils.ts - Maximum Coverage", ()=>{
    describe("cn (className merger) - Complete Coverage", ()=>{
        test("basic functionality", ()=>{
            expect((0, _utils.cn)("class1", "class2")).toBe("class1 class2");
            expect((0, _utils.cn)("bg-red-500", "text-white")).toBe("bg-red-500 text-white");
        });
        test("conditional classes - all branches", ()=>{
            expect((0, _utils.cn)("base", true && "conditional", false && "not-included")).toBe("base conditional");
            expect((0, _utils.cn)("base", false && "false-class")).toBe("base");
            expect((0, _utils.cn)("base", undefined && "undefined-class")).toBe("base");
            expect((0, _utils.cn)("base", null && "null-class")).toBe("base");
            expect((0, _utils.cn)("base", 0 && "zero-class")).toBe("base");
            expect((0, _utils.cn)("base", "" && "empty-class")).toBe("base");
            expect((0, _utils.cn)("base", "truthy" && "truthy-class")).toBe("base truthy-class");
        });
        test("handles all input types", ()=>{
            expect((0, _utils.cn)("base", undefined, null, "valid")).toBe("base valid");
            expect((0, _utils.cn)(undefined, null)).toBe("");
            expect((0, _utils.cn)()).toBe("");
            expect((0, _utils.cn)("")).toBe("");
            expect((0, _utils.cn)(null, undefined, false, "", 0)).toBe("");
        });
        test("array inputs - all cases", ()=>{
            expect((0, _utils.cn)([
                "class1",
                "class2"
            ])).toBe("class1 class2");
            expect((0, _utils.cn)([
                "class1",
                false && "class2",
                "class3"
            ])).toBe("class1 class3");
            expect((0, _utils.cn)([
                undefined,
                null,
                "",
                "valid"
            ])).toBe("valid");
            expect((0, _utils.cn)([])).toBe("");
        });
        test("object inputs", ()=>{
            expect((0, _utils.cn)({
                conditional: true,
                "false-conditional": false
            })).toBe("conditional");
            expect((0, _utils.cn)({
                test: true
            })).toBe("test");
            expect((0, _utils.cn)({
                test: false
            })).toBe("");
            expect((0, _utils.cn)({})).toBe("");
        });
        test("complex mixed inputs", ()=>{
            const result = (0, _utils.cn)("base", {
                conditional: true,
                "false-conditional": false
            }, [
                "array-class-1",
                "array-class-2"
            ], undefined, null, false && "false-class", true && "true-class");
            expect(result).toContain("base");
            expect(result).toContain("conditional");
            expect(result).not.toContain("false-conditional");
            expect(result).toContain("array-class-1");
            expect(result).toContain("array-class-2");
            expect(result).toContain("true-class");
            expect(result).not.toContain("false-class");
        });
        test("tailwind merge functionality", ()=>{
            // Test conflicting classes are properly merged
            const result = (0, _utils.cn)("bg-red-500", "bg-blue-500");
            expect(result).not.toContain("bg-red-500");
            expect(result).toContain("bg-blue-500");
        });
        test("extreme cases", ()=>{
            const longClass = "a".repeat(1000);
            expect(()=>(0, _utils.cn)(longClass)).not.toThrow();
            expect((0, _utils.cn)(longClass)).toBe(longClass);
            const manyClasses = Array.from({
                length: 100
            }, (_, i)=>`class-${i}`);
            expect(()=>(0, _utils.cn)(...manyClasses)).not.toThrow();
        });
    });
    describe("extractTagsFromMarkdown - Complete Coverage", ()=>{
        test("wiki-style tags [[tag]] - all variants", ()=>{
            expect((0, _utils.extractTagsFromMarkdown)("[[tag1]]")).toEqual([
                "tag1"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[tag1]] and [[tag2]]")).toEqual([
                "tag1",
                "tag2"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[tag with spaces]]")).toEqual([
                "tag with spaces"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[ trimmed ]]")).toEqual([
                "trimmed"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[tag-with-hyphens]]")).toEqual([
                "tag-with-hyphens"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[tag_with_underscores]]")).toEqual([
                "tag_with_underscores"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[123numeric]]")).toEqual([
                "123numeric"
            ]);
        });
        test("hash-style tags #tag - all variants", ()=>{
            expect((0, _utils.extractTagsFromMarkdown)("#tag1")).toEqual([
                "tag1"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("#tag1 and #tag2")).toEqual([
                "tag1",
                "tag2"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("#tag-with-hyphens")).toEqual([
                "tag-with-hyphens"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("#tag_with_underscores")).toEqual([
                "tag_with_underscores"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("#123numeric")).toEqual([
                "123numeric"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("#MixedCase")).toEqual([
                "MixedCase"
            ]);
        });
        test("mixed tag formats - all combinations", ()=>{
            expect((0, _utils.extractTagsFromMarkdown)("[[wiki-tag]] and #hashtag")).toEqual([
                "wiki-tag",
                "hashtag"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("#first [[second]] #third")).toEqual([
                "first",
                "second",
                "third"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[a]] #b [[c]] #d")).toEqual([
                "a",
                "b",
                "c",
                "d"
            ]);
        });
        test("duplicate removal - all scenarios", ()=>{
            expect((0, _utils.extractTagsFromMarkdown)("[[tag1]] #tag1")).toEqual([
                "tag1"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[tag1]] [[tag1]] #tag1")).toEqual([
                "tag1"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("#tag1 #tag1 [[tag1]]")).toEqual([
                "tag1"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[duplicate]] #other [[duplicate]]")).toEqual([
                "duplicate",
                "other"
            ]);
        });
        test("edge cases and boundaries", ()=>{
            expect((0, _utils.extractTagsFromMarkdown)("")).toEqual([]);
            expect((0, _utils.extractTagsFromMarkdown)("no tags here")).toEqual([]);
            expect((0, _utils.extractTagsFromMarkdown)("almost [tag] but not quite")).toEqual([]);
            expect((0, _utils.extractTagsFromMarkdown)("hash but no #")).toEqual([]);
            expect((0, _utils.extractTagsFromMarkdown)("# space breaks it")).toEqual([]);
            expect((0, _utils.extractTagsFromMarkdown)("[single bracket]")).toEqual([]);
            // [[]] creates match[1] = '' and match[2] = undefined, causing error
            expect(()=>(0, _utils.extractTagsFromMarkdown)("[[]]")).toThrow();
            expect((0, _utils.extractTagsFromMarkdown)("#")).toEqual([]);
        });
        test("whitespace handling", ()=>{
            expect((0, _utils.extractTagsFromMarkdown)("[[ spaced tag ]]")).toEqual([
                "spaced tag"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[  multiple   spaces  ]]")).toEqual([
                "multiple   spaces"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[	tab	tag	]]")).toEqual([
                "tab	tag"
            ]);
        });
        test("special characters and unicode", ()=>{
            expect((0, _utils.extractTagsFromMarkdown)("[[tag-with-special!@#$%]]")).toEqual([
                "tag-with-special!@#$%"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[测试标签]]")).toEqual([
                "测试标签"
            ]);
            // Hash tags only support \w characters and hyphens, not unicode
            expect((0, _utils.extractTagsFromMarkdown)("#basic-tag")).toEqual([
                "basic-tag"
            ]);
            expect((0, _utils.extractTagsFromMarkdown)("[[العربية]]")).toEqual([
                "العربية"
            ]);
        });
        test("complex markdown scenarios", ()=>{
            const complexMarkdown = `
        # Header with #header-tag
        
        Paragraph with [[wiki-tag]] and #hash-tag.
        
        > Blockquote with [[quote-tag]]
        
        \`code with [[not-a-tag]]\` inline
        
        \`\`\`
        code block
        [[also-not-a-tag]]
        #also-not-hash
        \`\`\`
        
        But this [[real-tag]] and #real-hash work.
        
        - List with #list-tag
        - Another [[list-wiki]]
        
        [Link text](url) with [[link-tag]]
        
        ![Image alt](url) [[image-tag]]
        
        **Bold [[bold-tag]]** and *italic #italic-tag*
      `;
            const result = (0, _utils.extractTagsFromMarkdown)(complexMarkdown);
            expect(result).toContain("header-tag");
            expect(result).toContain("wiki-tag");
            expect(result).toContain("hash-tag");
            expect(result).toContain("quote-tag");
            expect(result).toContain("real-tag");
            expect(result).toContain("real-hash");
            expect(result).toContain("list-tag");
            expect(result).toContain("list-wiki");
            expect(result).toContain("link-tag");
            expect(result).toContain("image-tag");
            expect(result).toContain("bold-tag");
            expect(result).toContain("italic-tag");
        // Note: Code blocks still match because regex doesn't parse markdown structure
        });
        test("performance with large input", ()=>{
            const largeTags = Array.from({
                length: 500
            }, (_, i)=>`[[tag${i}]]`).join(" ");
            const hashTags = Array.from({
                length: 500
            }, (_, i)=>`#hash${i}`).join(" ");
            const combined = largeTags + " " + hashTags;
            const result = (0, _utils.extractTagsFromMarkdown)(combined);
            expect(result).toHaveLength(1000);
            expect(result[0]).toBe("tag0");
            expect(result[999]).toBe("hash499");
        });
    });
    describe("formatTimestamp - Complete Coverage", ()=>{
        test("Date object inputs - all paths", ()=>{
            const date = new Date("2024-01-15T10:30:00Z");
            expect((0, _utils.formatTimestamp)(date)).toBe("2024-01-15");
            const invalidDate = new Date("invalid");
            expect((0, _utils.formatTimestamp)(invalidDate)).toBe("Invalid date");
        });
        test("string inputs - ISO formats", ()=>{
            expect((0, _utils.formatTimestamp)("2024-01-15T10:30:00Z")).toBe("2024-01-15");
            expect((0, _utils.formatTimestamp)("2024-01-15T10:30:00.123Z")).toBe("2024-01-15");
            expect((0, _utils.formatTimestamp)("2024-01-15T10:30:00+05:00")).toBe("2024-01-15");
            expect((0, _utils.formatTimestamp)("2024-01-15T10:30:00-08:00")).toBe("2024-01-15");
        });
        test("string inputs - slash format conversion", ()=>{
            expect((0, _utils.formatTimestamp)("2024/01/15")).toBe("2024-01-15");
            expect((0, _utils.formatTimestamp)("2024/12/25")).toBe("2024-12-25");
            // Single digits need leading zeros in the original format
            expect((0, _utils.formatTimestamp)("2024/01/05")).toBe("2024-01-05");
            expect((0, _utils.formatTimestamp)("1999/01/01")).toBe("1999-01-01");
        });
        test("string inputs - month name formats (Mon DD, YYYY)", ()=>{
            expect((0, _utils.formatTimestamp)("Jan 15, 2024")).toBe("2024-01-15");
            expect((0, _utils.formatTimestamp)("Feb 28, 2024")).toBe("2024-02-28");
            expect((0, _utils.formatTimestamp)("Mar 1, 2024")).toBe("2024-03-01");
            expect((0, _utils.formatTimestamp)("Apr 30, 2024")).toBe("2024-04-30");
            expect((0, _utils.formatTimestamp)("May 15, 2024")).toBe("2024-05-15");
            expect((0, _utils.formatTimestamp)("Jun 20, 2024")).toBe("2024-06-20");
            expect((0, _utils.formatTimestamp)("Jul 4, 2024")).toBe("2024-07-04");
            expect((0, _utils.formatTimestamp)("Aug 31, 2024")).toBe("2024-08-31");
            expect((0, _utils.formatTimestamp)("Sep 15, 2024")).toBe("2024-09-15");
            expect((0, _utils.formatTimestamp)("Oct 31, 2024")).toBe("2024-10-31");
            expect((0, _utils.formatTimestamp)("Nov 11, 2024")).toBe("2024-11-11");
            expect((0, _utils.formatTimestamp)("Dec 25, 2024")).toBe("2024-12-25");
        });
        test("string inputs - month name formats without comma", ()=>{
            expect((0, _utils.formatTimestamp)("Jan 15 2024")).toBe("2024-01-15");
            expect((0, _utils.formatTimestamp)("Dec 25 2024")).toBe("2024-12-25");
        });
        test("string inputs - day first format (DD Mon YYYY)", ()=>{
            expect((0, _utils.formatTimestamp)("15 Jan 2024")).toBe("2024-01-15");
            expect((0, _utils.formatTimestamp)("28 Feb 2024")).toBe("2024-02-28");
            expect((0, _utils.formatTimestamp)("1 Mar 2024")).toBe("2024-03-01");
            expect((0, _utils.formatTimestamp)("30 Apr 2024")).toBe("2024-04-30");
            expect((0, _utils.formatTimestamp)("15 May 2024")).toBe("2024-05-15");
            expect((0, _utils.formatTimestamp)("20 Jun 2024")).toBe("2024-06-20");
            expect((0, _utils.formatTimestamp)("4 Jul 2024")).toBe("2024-07-04");
            expect((0, _utils.formatTimestamp)("31 Aug 2024")).toBe("2024-08-31");
            expect((0, _utils.formatTimestamp)("15 Sep 2024")).toBe("2024-09-15");
            expect((0, _utils.formatTimestamp)("31 Oct 2024")).toBe("2024-10-31");
            expect((0, _utils.formatTimestamp)("11 Nov 2024")).toBe("2024-11-11");
            expect((0, _utils.formatTimestamp)("25 Dec 2024")).toBe("2024-12-25");
        });
        test("single digit day padding", ()=>{
            expect((0, _utils.formatTimestamp)("Jan 1, 2024")).toBe("2024-01-01");
            expect((0, _utils.formatTimestamp)("Jan 9, 2024")).toBe("2024-01-09");
            expect((0, _utils.formatTimestamp)("1 Jan 2024")).toBe("2024-01-01");
            expect((0, _utils.formatTimestamp)("9 Jan 2024")).toBe("2024-01-09");
        });
        test("numeric timestamp inputs", ()=>{
            const timestamp = new Date("2024-01-15T10:30:00Z").getTime();
            expect((0, _utils.formatTimestamp)(timestamp)).toBe("2024-01-15");
            expect((0, _utils.formatTimestamp)(0)).toBe("1970-01-01");
        });
        test("null and undefined handling", ()=>{
            expect((0, _utils.formatTimestamp)(null)).toBe("Invalid date");
            expect((0, _utils.formatTimestamp)(undefined)).toBe("Invalid date");
        });
        test("invalid date handling", ()=>{
            expect((0, _utils.formatTimestamp)("invalid-date")).toBe("Invalid date");
            expect((0, _utils.formatTimestamp)("")).toBe("Invalid date");
            expect((0, _utils.formatTimestamp)("not a date")).toBe("Invalid date");
            expect((0, _utils.formatTimestamp)("2024-13-45")).toBe("Invalid date");
            // Note: Date constructor may normalize invalid dates like Feb 31 -> Mar 2
            expect((0, _utils.formatTimestamp)("completely-invalid-format")).toBe("Invalid date");
            expect((0, _utils.formatTimestamp)(NaN)).toBe("Invalid date");
        });
        test("console logging paths", ()=>{
            const consoleSpy = jest.spyOn(console, "warn").mockImplementation();
            const errorSpy = jest.spyOn(console, "error").mockImplementation();
            (0, _utils.formatTimestamp)("completely invalid input");
            expect(consoleSpy).toHaveBeenCalled();
            // Test error path by causing an exception
            const originalGetTime = Date.prototype.getTime;
            Date.prototype.getTime = jest.fn(()=>{
                throw new Error("Test error");
            });
            (0, _utils.formatTimestamp)("2024-01-15");
            expect(errorSpy).toHaveBeenCalled();
            Date.prototype.getTime = originalGetTime;
            consoleSpy.mockRestore();
            errorSpy.mockRestore();
        });
        test("edge dates and special cases", ()=>{
            // Leap year
            expect((0, _utils.formatTimestamp)("2024-02-29")).toBe("2024-02-29");
            expect((0, _utils.formatTimestamp)("Feb 29, 2024")).toBe("2024-02-29");
            // Year boundaries
            expect((0, _utils.formatTimestamp)("1900-01-01")).toBe("1900-01-01");
            expect((0, _utils.formatTimestamp)("2099-12-31")).toBe("2099-12-31");
            // Unix epoch
            expect((0, _utils.formatTimestamp)("1970-01-01")).toBe("1970-01-01");
        });
        test("all code paths with try-catch", ()=>{
            // Force different error conditions
            const testCases = [
                "",
                "invalid",
                "2024-invalid-date",
                null,
                undefined,
                NaN,
                {},
                [],
                "2024/15/32"
            ];
            testCases.forEach((testCase)=>{
                const result = (0, _utils.formatTimestamp)(testCase);
                expect(result).toBe("Invalid date");
            });
        });
    });
    describe("stress tests and extreme cases", ()=>{
        test("memory and performance", ()=>{
            // Test with very large inputs
            const hugeString = "a".repeat(100000);
            expect(()=>(0, _utils.cn)(hugeString)).not.toThrow();
            const hugeMarkdown = "[[tag]] ".repeat(10000);
            expect(()=>(0, _utils.extractTagsFromMarkdown)(hugeMarkdown)).not.toThrow();
            expect(()=>(0, _utils.formatTimestamp)(hugeString)).not.toThrow();
        });
        test("unicode and special character handling", ()=>{
            const unicodeTest = "\uD83D\uDE80 [[emoji-tag]] #unicode-测试 [[العربية]] #русский";
            const result = (0, _utils.extractTagsFromMarkdown)(unicodeTest);
            expect(result).toContain("emoji-tag");
            expect(()=>(0, _utils.cn)("\uD83D\uDE80", "测试", "العربية", "русский")).not.toThrow();
        });
        test("concurrent execution simulation", ()=>{
            // Simulate rapid successive calls
            const promises = Array.from({
                length: 100
            }, (_, i)=>{
                return Promise.resolve().then(()=>{
                    (0, _utils.cn)(`class-${i}`, i % 2 === 0 && "even");
                    (0, _utils.extractTagsFromMarkdown)(`[[tag-${i}]] #hash-${i}`);
                    (0, _utils.formatTimestamp)(`2024-01-${i % 28 + 1}`);
                });
            });
            return Promise.all(promises);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL3V0aWxzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQaGFzZSAxOiBsaWIvdXRpbHMudHMgTWF4aW11bSBDb3ZlcmFnZSBUZXN0IFN1aXRlXG4gKiBUYXJnZXQ6IENvbXBsZXRlIGNvdmVyYWdlIG9mIGFsbCB1dGlsaXR5IGZ1bmN0aW9ucyB3aXRoIGFsbCBlZGdlIGNhc2VzXG4gKiBHb2FsOiBNYXhpbWl6ZSBzdGF0ZW1lbnQgY292ZXJhZ2UgZm9yIGhpZ2hlc3QgaW1wYWN0XG4gKi9cblxuaW1wb3J0IHsgY24sIGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duLCBmb3JtYXRUaW1lc3RhbXAgfSBmcm9tIFwiLi4vLi4vbGliL3V0aWxzXCI7XG5cbmRlc2NyaWJlKFwibGliL3V0aWxzLnRzIC0gTWF4aW11bSBDb3ZlcmFnZVwiLCAoKSA9PiB7XG4gIGRlc2NyaWJlKFwiY24gKGNsYXNzTmFtZSBtZXJnZXIpIC0gQ29tcGxldGUgQ292ZXJhZ2VcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChjbihcImNsYXNzMVwiLCBcImNsYXNzMlwiKSkudG9CZShcImNsYXNzMSBjbGFzczJcIik7XG4gICAgICBleHBlY3QoY24oXCJiZy1yZWQtNTAwXCIsIFwidGV4dC13aGl0ZVwiKSkudG9CZShcImJnLXJlZC01MDAgdGV4dC13aGl0ZVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJjb25kaXRpb25hbCBjbGFzc2VzIC0gYWxsIGJyYW5jaGVzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChjbihcImJhc2VcIiwgdHJ1ZSAmJiBcImNvbmRpdGlvbmFsXCIsIGZhbHNlICYmIFwibm90LWluY2x1ZGVkXCIpKS50b0JlKFxuICAgICAgICBcImJhc2UgY29uZGl0aW9uYWxcIixcbiAgICAgICk7XG4gICAgICBleHBlY3QoY24oXCJiYXNlXCIsIGZhbHNlICYmIFwiZmFsc2UtY2xhc3NcIikpLnRvQmUoXCJiYXNlXCIpO1xuICAgICAgZXhwZWN0KGNuKFwiYmFzZVwiLCB1bmRlZmluZWQgJiYgXCJ1bmRlZmluZWQtY2xhc3NcIikpLnRvQmUoXCJiYXNlXCIpO1xuICAgICAgZXhwZWN0KGNuKFwiYmFzZVwiLCBudWxsICYmIFwibnVsbC1jbGFzc1wiKSkudG9CZShcImJhc2VcIik7XG4gICAgICBleHBlY3QoY24oXCJiYXNlXCIsIDAgJiYgXCJ6ZXJvLWNsYXNzXCIpKS50b0JlKFwiYmFzZVwiKTtcbiAgICAgIGV4cGVjdChjbihcImJhc2VcIiwgXCJcIiAmJiBcImVtcHR5LWNsYXNzXCIpKS50b0JlKFwiYmFzZVwiKTtcbiAgICAgIGV4cGVjdChjbihcImJhc2VcIiwgXCJ0cnV0aHlcIiAmJiBcInRydXRoeS1jbGFzc1wiKSkudG9CZShcImJhc2UgdHJ1dGh5LWNsYXNzXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgYWxsIGlucHV0IHR5cGVzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChjbihcImJhc2VcIiwgdW5kZWZpbmVkLCBudWxsLCBcInZhbGlkXCIpKS50b0JlKFwiYmFzZSB2YWxpZFwiKTtcbiAgICAgIGV4cGVjdChjbih1bmRlZmluZWQsIG51bGwpKS50b0JlKFwiXCIpO1xuICAgICAgZXhwZWN0KGNuKCkpLnRvQmUoXCJcIik7XG4gICAgICBleHBlY3QoY24oXCJcIikpLnRvQmUoXCJcIik7XG4gICAgICBleHBlY3QoY24obnVsbCwgdW5kZWZpbmVkLCBmYWxzZSwgXCJcIiwgMCkpLnRvQmUoXCJcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiYXJyYXkgaW5wdXRzIC0gYWxsIGNhc2VzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChjbihbXCJjbGFzczFcIiwgXCJjbGFzczJcIl0pKS50b0JlKFwiY2xhc3MxIGNsYXNzMlwiKTtcbiAgICAgIGV4cGVjdChjbihbXCJjbGFzczFcIiwgZmFsc2UgJiYgXCJjbGFzczJcIiwgXCJjbGFzczNcIl0pKS50b0JlKFwiY2xhc3MxIGNsYXNzM1wiKTtcbiAgICAgIGV4cGVjdChjbihbdW5kZWZpbmVkLCBudWxsLCBcIlwiLCBcInZhbGlkXCJdKSkudG9CZShcInZhbGlkXCIpO1xuICAgICAgZXhwZWN0KGNuKFtdKSkudG9CZShcIlwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJvYmplY3QgaW5wdXRzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChjbih7IGNvbmRpdGlvbmFsOiB0cnVlLCBcImZhbHNlLWNvbmRpdGlvbmFsXCI6IGZhbHNlIH0pKS50b0JlKFxuICAgICAgICBcImNvbmRpdGlvbmFsXCIsXG4gICAgICApO1xuICAgICAgZXhwZWN0KGNuKHsgdGVzdDogdHJ1ZSB9KSkudG9CZShcInRlc3RcIik7XG4gICAgICBleHBlY3QoY24oeyB0ZXN0OiBmYWxzZSB9KSkudG9CZShcIlwiKTtcbiAgICAgIGV4cGVjdChjbih7fSkpLnRvQmUoXCJcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiY29tcGxleCBtaXhlZCBpbnB1dHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY24oXG4gICAgICAgIFwiYmFzZVwiLFxuICAgICAgICB7IGNvbmRpdGlvbmFsOiB0cnVlLCBcImZhbHNlLWNvbmRpdGlvbmFsXCI6IGZhbHNlIH0sXG4gICAgICAgIFtcImFycmF5LWNsYXNzLTFcIiwgXCJhcnJheS1jbGFzcy0yXCJdLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGZhbHNlICYmIFwiZmFsc2UtY2xhc3NcIixcbiAgICAgICAgdHJ1ZSAmJiBcInRydWUtY2xhc3NcIixcbiAgICAgICk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJiYXNlXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiY29uZGl0aW9uYWxcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS5ub3QudG9Db250YWluKFwiZmFsc2UtY29uZGl0aW9uYWxcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJhcnJheS1jbGFzcy0xXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiYXJyYXktY2xhc3MtMlwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcInRydWUtY2xhc3NcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS5ub3QudG9Db250YWluKFwiZmFsc2UtY2xhc3NcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwidGFpbHdpbmQgbWVyZ2UgZnVuY3Rpb25hbGl0eVwiLCAoKSA9PiB7XG4gICAgICAvLyBUZXN0IGNvbmZsaWN0aW5nIGNsYXNzZXMgYXJlIHByb3Blcmx5IG1lcmdlZFxuICAgICAgY29uc3QgcmVzdWx0ID0gY24oXCJiZy1yZWQtNTAwXCIsIFwiYmctYmx1ZS01MDBcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS5ub3QudG9Db250YWluKFwiYmctcmVkLTUwMFwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcImJnLWJsdWUtNTAwXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImV4dHJlbWUgY2FzZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9uZ0NsYXNzID0gXCJhXCIucmVwZWF0KDEwMDApO1xuICAgICAgZXhwZWN0KCgpID0+IGNuKGxvbmdDbGFzcykpLm5vdC50b1Rocm93KCk7XG4gICAgICBleHBlY3QoY24obG9uZ0NsYXNzKSkudG9CZShsb25nQ2xhc3MpO1xuXG4gICAgICBjb25zdCBtYW55Q2xhc3NlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gYGNsYXNzLSR7aX1gKTtcbiAgICAgIGV4cGVjdCgoKSA9PiBjbiguLi5tYW55Q2xhc3NlcykpLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24gLSBDb21wbGV0ZSBDb3ZlcmFnZVwiLCAoKSA9PiB7XG4gICAgdGVzdChcIndpa2ktc3R5bGUgdGFncyBbW3RhZ11dIC0gYWxsIHZhcmlhbnRzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltbdGFnMV1dXCIpKS50b0VxdWFsKFtcInRhZzFcIl0pO1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiW1t0YWcxXV0gYW5kIFtbdGFnMl1dXCIpKS50b0VxdWFsKFtcbiAgICAgICAgXCJ0YWcxXCIsXG4gICAgICAgIFwidGFnMlwiLFxuICAgICAgXSk7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCJbW3RhZyB3aXRoIHNwYWNlc11dXCIpKS50b0VxdWFsKFtcbiAgICAgICAgXCJ0YWcgd2l0aCBzcGFjZXNcIixcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiW1sgdHJpbW1lZCBdXVwiKSkudG9FcXVhbChbXCJ0cmltbWVkXCJdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltbdGFnLXdpdGgtaHlwaGVuc11dXCIpKS50b0VxdWFsKFtcbiAgICAgICAgXCJ0YWctd2l0aC1oeXBoZW5zXCIsXG4gICAgICBdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltbdGFnX3dpdGhfdW5kZXJzY29yZXNdXVwiKSkudG9FcXVhbChbXG4gICAgICAgIFwidGFnX3dpdGhfdW5kZXJzY29yZXNcIixcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiW1sxMjNudW1lcmljXV1cIikpLnRvRXF1YWwoW1wiMTIzbnVtZXJpY1wiXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiaGFzaC1zdHlsZSB0YWdzICN0YWcgLSBhbGwgdmFyaWFudHNcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiI3RhZzFcIikpLnRvRXF1YWwoW1widGFnMVwiXSk7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCIjdGFnMSBhbmQgI3RhZzJcIikpLnRvRXF1YWwoW1xuICAgICAgICBcInRhZzFcIixcbiAgICAgICAgXCJ0YWcyXCIsXG4gICAgICBdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIiN0YWctd2l0aC1oeXBoZW5zXCIpKS50b0VxdWFsKFtcbiAgICAgICAgXCJ0YWctd2l0aC1oeXBoZW5zXCIsXG4gICAgICBdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIiN0YWdfd2l0aF91bmRlcnNjb3Jlc1wiKSkudG9FcXVhbChbXG4gICAgICAgIFwidGFnX3dpdGhfdW5kZXJzY29yZXNcIixcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiIzEyM251bWVyaWNcIikpLnRvRXF1YWwoW1wiMTIzbnVtZXJpY1wiXSk7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCIjTWl4ZWRDYXNlXCIpKS50b0VxdWFsKFtcIk1peGVkQ2FzZVwiXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwibWl4ZWQgdGFnIGZvcm1hdHMgLSBhbGwgY29tYmluYXRpb25zXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltbd2lraS10YWddXSBhbmQgI2hhc2h0YWdcIikpLnRvRXF1YWwoW1xuICAgICAgICBcIndpa2ktdGFnXCIsXG4gICAgICAgIFwiaGFzaHRhZ1wiLFxuICAgICAgXSk7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCIjZmlyc3QgW1tzZWNvbmRdXSAjdGhpcmRcIikpLnRvRXF1YWwoW1xuICAgICAgICBcImZpcnN0XCIsXG4gICAgICAgIFwic2Vjb25kXCIsXG4gICAgICAgIFwidGhpcmRcIixcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiW1thXV0gI2IgW1tjXV0gI2RcIikpLnRvRXF1YWwoW1xuICAgICAgICBcImFcIixcbiAgICAgICAgXCJiXCIsXG4gICAgICAgIFwiY1wiLFxuICAgICAgICBcImRcIixcbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImR1cGxpY2F0ZSByZW1vdmFsIC0gYWxsIHNjZW5hcmlvc1wiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCJbW3RhZzFdXSAjdGFnMVwiKSkudG9FcXVhbChbXCJ0YWcxXCJdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltbdGFnMV1dIFtbdGFnMV1dICN0YWcxXCIpKS50b0VxdWFsKFtcbiAgICAgICAgXCJ0YWcxXCIsXG4gICAgICBdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIiN0YWcxICN0YWcxIFtbdGFnMV1dXCIpKS50b0VxdWFsKFtcInRhZzFcIl0pO1xuICAgICAgZXhwZWN0KFxuICAgICAgICBleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltbZHVwbGljYXRlXV0gI290aGVyIFtbZHVwbGljYXRlXV1cIiksXG4gICAgICApLnRvRXF1YWwoW1wiZHVwbGljYXRlXCIsIFwib3RoZXJcIl0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImVkZ2UgY2FzZXMgYW5kIGJvdW5kYXJpZXNcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiXCIpKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIm5vIHRhZ3MgaGVyZVwiKSkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCJhbG1vc3QgW3RhZ10gYnV0IG5vdCBxdWl0ZVwiKSkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCJoYXNoIGJ1dCBubyAjXCIpKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIiMgc3BhY2UgYnJlYWtzIGl0XCIpKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltzaW5nbGUgYnJhY2tldF1cIikpLnRvRXF1YWwoW10pO1xuICAgICAgLy8gW1tdXSBjcmVhdGVzIG1hdGNoWzFdID0gJycgYW5kIG1hdGNoWzJdID0gdW5kZWZpbmVkLCBjYXVzaW5nIGVycm9yXG4gICAgICBleHBlY3QoKCkgPT4gZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCJbW11dXCIpKS50b1Rocm93KCk7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCIjXCIpKS50b0VxdWFsKFtdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJ3aGl0ZXNwYWNlIGhhbmRsaW5nXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltbIHNwYWNlZCB0YWcgXV1cIikpLnRvRXF1YWwoW1xuICAgICAgICBcInNwYWNlZCB0YWdcIixcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiW1sgIG11bHRpcGxlICAgc3BhY2VzICBdXVwiKSkudG9FcXVhbChbXG4gICAgICAgIFwibXVsdGlwbGUgICBzcGFjZXNcIixcbiAgICAgIF0pO1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiW1tcdHRhYlx0dGFnXHRdXVwiKSkudG9FcXVhbChbXCJ0YWJcdHRhZ1wiXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCB1bmljb2RlXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChleHRyYWN0VGFnc0Zyb21NYXJrZG93bihcIltbdGFnLXdpdGgtc3BlY2lhbCFAIyQlXV1cIikpLnRvRXF1YWwoW1xuICAgICAgICBcInRhZy13aXRoLXNwZWNpYWwhQCMkJVwiLFxuICAgICAgXSk7XG4gICAgICBleHBlY3QoZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oXCJbW+a1i+ivleagh+etvl1dXCIpKS50b0VxdWFsKFtcIua1i+ivleagh+etvlwiXSk7XG4gICAgICAvLyBIYXNoIHRhZ3Mgb25seSBzdXBwb3J0IFxcdyBjaGFyYWN0ZXJzIGFuZCBoeXBoZW5zLCBub3QgdW5pY29kZVxuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiI2Jhc2ljLXRhZ1wiKSkudG9FcXVhbChbXCJiYXNpYy10YWdcIl0pO1xuICAgICAgZXhwZWN0KGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKFwiW1vYp9mE2LnYsdio2YrYqV1dXCIpKS50b0VxdWFsKFtcItin2YTYudix2KjZitipXCJdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJjb21wbGV4IG1hcmtkb3duIHNjZW5hcmlvc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wbGV4TWFya2Rvd24gPSBgXG4gICAgICAgICMgSGVhZGVyIHdpdGggI2hlYWRlci10YWdcbiAgICAgICAgXG4gICAgICAgIFBhcmFncmFwaCB3aXRoIFtbd2lraS10YWddXSBhbmQgI2hhc2gtdGFnLlxuICAgICAgICBcbiAgICAgICAgPiBCbG9ja3F1b3RlIHdpdGggW1txdW90ZS10YWddXVxuICAgICAgICBcbiAgICAgICAgXFxgY29kZSB3aXRoIFtbbm90LWEtdGFnXV1cXGAgaW5saW5lXG4gICAgICAgIFxuICAgICAgICBcXGBcXGBcXGBcbiAgICAgICAgY29kZSBibG9ja1xuICAgICAgICBbW2Fsc28tbm90LWEtdGFnXV1cbiAgICAgICAgI2Fsc28tbm90LWhhc2hcbiAgICAgICAgXFxgXFxgXFxgXG4gICAgICAgIFxuICAgICAgICBCdXQgdGhpcyBbW3JlYWwtdGFnXV0gYW5kICNyZWFsLWhhc2ggd29yay5cbiAgICAgICAgXG4gICAgICAgIC0gTGlzdCB3aXRoICNsaXN0LXRhZ1xuICAgICAgICAtIEFub3RoZXIgW1tsaXN0LXdpa2ldXVxuICAgICAgICBcbiAgICAgICAgW0xpbmsgdGV4dF0odXJsKSB3aXRoIFtbbGluay10YWddXVxuICAgICAgICBcbiAgICAgICAgIVtJbWFnZSBhbHRdKHVybCkgW1tpbWFnZS10YWddXVxuICAgICAgICBcbiAgICAgICAgKipCb2xkIFtbYm9sZC10YWddXSoqIGFuZCAqaXRhbGljICNpdGFsaWMtdGFnKlxuICAgICAgYDtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oY29tcGxleE1hcmtkb3duKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcImhlYWRlci10YWdcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJ3aWtpLXRhZ1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcImhhc2gtdGFnXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwicXVvdGUtdGFnXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwicmVhbC10YWdcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJyZWFsLWhhc2hcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJsaXN0LXRhZ1wiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcImxpc3Qtd2lraVwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbihcImxpbmstdGFnXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiaW1hZ2UtdGFnXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiYm9sZC10YWdcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oXCJpdGFsaWMtdGFnXCIpO1xuICAgICAgLy8gTm90ZTogQ29kZSBibG9ja3Mgc3RpbGwgbWF0Y2ggYmVjYXVzZSByZWdleCBkb2Vzbid0IHBhcnNlIG1hcmtkb3duIHN0cnVjdHVyZVxuICAgIH0pO1xuXG4gICAgdGVzdChcInBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VUYWdzID0gQXJyYXkuZnJvbShcbiAgICAgICAgeyBsZW5ndGg6IDUwMCB9LFxuICAgICAgICAoXywgaSkgPT4gYFtbdGFnJHtpfV1dYCxcbiAgICAgICkuam9pbihcIiBcIik7XG4gICAgICBjb25zdCBoYXNoVGFncyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUwMCB9LCAoXywgaSkgPT4gYCNoYXNoJHtpfWApLmpvaW4oXG4gICAgICAgIFwiIFwiLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkID0gbGFyZ2VUYWdzICsgXCIgXCIgKyBoYXNoVGFncztcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oY29tYmluZWQpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDEwMDApO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXSkudG9CZShcInRhZzBcIik7XG4gICAgICBleHBlY3QocmVzdWx0Wzk5OV0pLnRvQmUoXCJoYXNoNDk5XCIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImZvcm1hdFRpbWVzdGFtcCAtIENvbXBsZXRlIENvdmVyYWdlXCIsICgpID0+IHtcbiAgICB0ZXN0KFwiRGF0ZSBvYmplY3QgaW5wdXRzIC0gYWxsIHBhdGhzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShcIjIwMjQtMDEtMTVUMTA6MzA6MDBaXCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChkYXRlKSkudG9CZShcIjIwMjQtMDEtMTVcIik7XG5cbiAgICAgIGNvbnN0IGludmFsaWREYXRlID0gbmV3IERhdGUoXCJpbnZhbGlkXCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChpbnZhbGlkRGF0ZSkpLnRvQmUoXCJJbnZhbGlkIGRhdGVcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic3RyaW5nIGlucHV0cyAtIElTTyBmb3JtYXRzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIyMDI0LTAxLTE1VDEwOjMwOjAwWlwiKSkudG9CZShcIjIwMjQtMDEtMTVcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiMjAyNC0wMS0xNVQxMDozMDowMC4xMjNaXCIpKS50b0JlKFwiMjAyNC0wMS0xNVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIyMDI0LTAxLTE1VDEwOjMwOjAwKzA1OjAwXCIpKS50b0JlKFwiMjAyNC0wMS0xNVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIyMDI0LTAxLTE1VDEwOjMwOjAwLTA4OjAwXCIpKS50b0JlKFwiMjAyNC0wMS0xNVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzdHJpbmcgaW5wdXRzIC0gc2xhc2ggZm9ybWF0IGNvbnZlcnNpb25cIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIjIwMjQvMDEvMTVcIikpLnRvQmUoXCIyMDI0LTAxLTE1XCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIjIwMjQvMTIvMjVcIikpLnRvQmUoXCIyMDI0LTEyLTI1XCIpO1xuICAgICAgLy8gU2luZ2xlIGRpZ2l0cyBuZWVkIGxlYWRpbmcgemVyb3MgaW4gdGhlIG9yaWdpbmFsIGZvcm1hdFxuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIjIwMjQvMDEvMDVcIikpLnRvQmUoXCIyMDI0LTAxLTA1XCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIjE5OTkvMDEvMDFcIikpLnRvQmUoXCIxOTk5LTAxLTAxXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInN0cmluZyBpbnB1dHMgLSBtb250aCBuYW1lIGZvcm1hdHMgKE1vbiBERCwgWVlZWSlcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIkphbiAxNSwgMjAyNFwiKSkudG9CZShcIjIwMjQtMDEtMTVcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiRmViIDI4LCAyMDI0XCIpKS50b0JlKFwiMjAyNC0wMi0yOFwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCJNYXIgMSwgMjAyNFwiKSkudG9CZShcIjIwMjQtMDMtMDFcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiQXByIDMwLCAyMDI0XCIpKS50b0JlKFwiMjAyNC0wNC0zMFwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCJNYXkgMTUsIDIwMjRcIikpLnRvQmUoXCIyMDI0LTA1LTE1XCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIkp1biAyMCwgMjAyNFwiKSkudG9CZShcIjIwMjQtMDYtMjBcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiSnVsIDQsIDIwMjRcIikpLnRvQmUoXCIyMDI0LTA3LTA0XCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIkF1ZyAzMSwgMjAyNFwiKSkudG9CZShcIjIwMjQtMDgtMzFcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiU2VwIDE1LCAyMDI0XCIpKS50b0JlKFwiMjAyNC0wOS0xNVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCJPY3QgMzEsIDIwMjRcIikpLnRvQmUoXCIyMDI0LTEwLTMxXCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIk5vdiAxMSwgMjAyNFwiKSkudG9CZShcIjIwMjQtMTEtMTFcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiRGVjIDI1LCAyMDI0XCIpKS50b0JlKFwiMjAyNC0xMi0yNVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzdHJpbmcgaW5wdXRzIC0gbW9udGggbmFtZSBmb3JtYXRzIHdpdGhvdXQgY29tbWFcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIkphbiAxNSAyMDI0XCIpKS50b0JlKFwiMjAyNC0wMS0xNVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCJEZWMgMjUgMjAyNFwiKSkudG9CZShcIjIwMjQtMTItMjVcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic3RyaW5nIGlucHV0cyAtIGRheSBmaXJzdCBmb3JtYXQgKEREIE1vbiBZWVlZKVwiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiMTUgSmFuIDIwMjRcIikpLnRvQmUoXCIyMDI0LTAxLTE1XCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIjI4IEZlYiAyMDI0XCIpKS50b0JlKFwiMjAyNC0wMi0yOFwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIxIE1hciAyMDI0XCIpKS50b0JlKFwiMjAyNC0wMy0wMVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIzMCBBcHIgMjAyNFwiKSkudG9CZShcIjIwMjQtMDQtMzBcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiMTUgTWF5IDIwMjRcIikpLnRvQmUoXCIyMDI0LTA1LTE1XCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIjIwIEp1biAyMDI0XCIpKS50b0JlKFwiMjAyNC0wNi0yMFwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCI0IEp1bCAyMDI0XCIpKS50b0JlKFwiMjAyNC0wNy0wNFwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIzMSBBdWcgMjAyNFwiKSkudG9CZShcIjIwMjQtMDgtMzFcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiMTUgU2VwIDIwMjRcIikpLnRvQmUoXCIyMDI0LTA5LTE1XCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIjMxIE9jdCAyMDI0XCIpKS50b0JlKFwiMjAyNC0xMC0zMVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIxMSBOb3YgMjAyNFwiKSkudG9CZShcIjIwMjQtMTEtMTFcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiMjUgRGVjIDIwMjRcIikpLnRvQmUoXCIyMDI0LTEyLTI1XCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNpbmdsZSBkaWdpdCBkYXkgcGFkZGluZ1wiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiSmFuIDEsIDIwMjRcIikpLnRvQmUoXCIyMDI0LTAxLTAxXCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcIkphbiA5LCAyMDI0XCIpKS50b0JlKFwiMjAyNC0wMS0wOVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIxIEphbiAyMDI0XCIpKS50b0JlKFwiMjAyNC0wMS0wMVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCI5IEphbiAyMDI0XCIpKS50b0JlKFwiMjAyNC0wMS0wOVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJudW1lcmljIHRpbWVzdGFtcCBpbnB1dHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoXCIyMDI0LTAxLTE1VDEwOjMwOjAwWlwiKS5nZXRUaW1lKCk7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKHRpbWVzdGFtcCkpLnRvQmUoXCIyMDI0LTAxLTE1XCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcCgwKSkudG9CZShcIjE5NzAtMDEtMDFcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwibnVsbCBhbmQgdW5kZWZpbmVkIGhhbmRsaW5nXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAobnVsbCBhcyBhbnkpKS50b0JlKFwiSW52YWxpZCBkYXRlXCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcCh1bmRlZmluZWQgYXMgYW55KSkudG9CZShcIkludmFsaWQgZGF0ZVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJpbnZhbGlkIGRhdGUgaGFuZGxpbmdcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChcImludmFsaWQtZGF0ZVwiKSkudG9CZShcIkludmFsaWQgZGF0ZVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCJcIikpLnRvQmUoXCJJbnZhbGlkIGRhdGVcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwibm90IGEgZGF0ZVwiKSkudG9CZShcIkludmFsaWQgZGF0ZVwiKTtcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIyMDI0LTEzLTQ1XCIpKS50b0JlKFwiSW52YWxpZCBkYXRlXCIpO1xuICAgICAgLy8gTm90ZTogRGF0ZSBjb25zdHJ1Y3RvciBtYXkgbm9ybWFsaXplIGludmFsaWQgZGF0ZXMgbGlrZSBGZWIgMzEgLT4gTWFyIDJcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCJjb21wbGV0ZWx5LWludmFsaWQtZm9ybWF0XCIpKS50b0JlKFwiSW52YWxpZCBkYXRlXCIpO1xuICAgICAgZXhwZWN0KGZvcm1hdFRpbWVzdGFtcChOYU4pKS50b0JlKFwiSW52YWxpZCBkYXRlXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImNvbnNvbGUgbG9nZ2luZyBwYXRoc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCBcIndhcm5cIikubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgICBjb25zdCBlcnJvclNweSA9IGplc3Quc3B5T24oY29uc29sZSwgXCJlcnJvclwiKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgZm9ybWF0VGltZXN0YW1wKFwiY29tcGxldGVseSBpbnZhbGlkIGlucHV0XCIpO1xuXG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICAvLyBUZXN0IGVycm9yIHBhdGggYnkgY2F1c2luZyBhbiBleGNlcHRpb25cbiAgICAgIGNvbnN0IG9yaWdpbmFsR2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG4gICAgICBEYXRlLnByb3RvdHlwZS5nZXRUaW1lID0gamVzdC5mbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlc3QgZXJyb3JcIik7XG4gICAgICB9KTtcblxuICAgICAgZm9ybWF0VGltZXN0YW1wKFwiMjAyNC0wMS0xNVwiKTtcblxuICAgICAgZXhwZWN0KGVycm9yU3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIERhdGUucHJvdG90eXBlLmdldFRpbWUgPSBvcmlnaW5hbEdldFRpbWU7XG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgICBlcnJvclNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImVkZ2UgZGF0ZXMgYW5kIHNwZWNpYWwgY2FzZXNcIiwgKCkgPT4ge1xuICAgICAgLy8gTGVhcCB5ZWFyXG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiMjAyNC0wMi0yOVwiKSkudG9CZShcIjIwMjQtMDItMjlcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiRmViIDI5LCAyMDI0XCIpKS50b0JlKFwiMjAyNC0wMi0yOVwiKTtcblxuICAgICAgLy8gWWVhciBib3VuZGFyaWVzXG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiMTkwMC0wMS0wMVwiKSkudG9CZShcIjE5MDAtMDEtMDFcIik7XG4gICAgICBleHBlY3QoZm9ybWF0VGltZXN0YW1wKFwiMjA5OS0xMi0zMVwiKSkudG9CZShcIjIwOTktMTItMzFcIik7XG5cbiAgICAgIC8vIFVuaXggZXBvY2hcbiAgICAgIGV4cGVjdChmb3JtYXRUaW1lc3RhbXAoXCIxOTcwLTAxLTAxXCIpKS50b0JlKFwiMTk3MC0wMS0wMVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJhbGwgY29kZSBwYXRocyB3aXRoIHRyeS1jYXRjaFwiLCAoKSA9PiB7XG4gICAgICAvLyBGb3JjZSBkaWZmZXJlbnQgZXJyb3IgY29uZGl0aW9uc1xuICAgICAgY29uc3QgdGVzdENhc2VzID0gW1xuICAgICAgICBcIlwiLFxuICAgICAgICBcImludmFsaWRcIixcbiAgICAgICAgXCIyMDI0LWludmFsaWQtZGF0ZVwiLFxuICAgICAgICBudWxsLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIE5hTixcbiAgICAgICAge30sXG4gICAgICAgIFtdLFxuICAgICAgICBcIjIwMjQvMTUvMzJcIiwgLy8gSW52YWxpZCBtb250aC9kYXlcbiAgICAgIF07XG5cbiAgICAgIHRlc3RDYXNlcy5mb3JFYWNoKCh0ZXN0Q2FzZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRUaW1lc3RhbXAodGVzdENhc2UgYXMgYW55KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShcIkludmFsaWQgZGF0ZVwiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcInN0cmVzcyB0ZXN0cyBhbmQgZXh0cmVtZSBjYXNlc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcIm1lbW9yeSBhbmQgcGVyZm9ybWFuY2VcIiwgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB3aXRoIHZlcnkgbGFyZ2UgaW5wdXRzXG4gICAgICBjb25zdCBodWdlU3RyaW5nID0gXCJhXCIucmVwZWF0KDEwMDAwMCk7XG4gICAgICBleHBlY3QoKCkgPT4gY24oaHVnZVN0cmluZykpLm5vdC50b1Rocm93KCk7XG5cbiAgICAgIGNvbnN0IGh1Z2VNYXJrZG93biA9IFwiW1t0YWddXSBcIi5yZXBlYXQoMTAwMDApO1xuICAgICAgZXhwZWN0KCgpID0+IGV4dHJhY3RUYWdzRnJvbU1hcmtkb3duKGh1Z2VNYXJrZG93bikpLm5vdC50b1Rocm93KCk7XG5cbiAgICAgIGV4cGVjdCgoKSA9PiBmb3JtYXRUaW1lc3RhbXAoaHVnZVN0cmluZykpLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwidW5pY29kZSBhbmQgc3BlY2lhbCBjaGFyYWN0ZXIgaGFuZGxpbmdcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdW5pY29kZVRlc3QgPSBcIvCfmoAgW1tlbW9qaS10YWddXSAjdW5pY29kZS3mtYvor5UgW1vYp9mE2LnYsdio2YrYqV1dICPRgNGD0YHRgdC60LjQuVwiO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24odW5pY29kZVRlc3QpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKFwiZW1vamktdGFnXCIpO1xuXG4gICAgICBleHBlY3QoKCkgPT4gY24oXCLwn5qAXCIsIFwi5rWL6K+VXCIsIFwi2KfZhNi52LHYqNmK2KlcIiwgXCLRgNGD0YHRgdC60LjQuVwiKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJjb25jdXJyZW50IGV4ZWN1dGlvbiBzaW11bGF0aW9uXCIsICgpID0+IHtcbiAgICAgIC8vIFNpbXVsYXRlIHJhcGlkIHN1Y2Nlc3NpdmUgY2FsbHNcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBjbihgY2xhc3MtJHtpfWAsIGkgJSAyID09PSAwICYmIFwiZXZlblwiKTtcbiAgICAgICAgICBleHRyYWN0VGFnc0Zyb21NYXJrZG93bihgW1t0YWctJHtpfV1dICNoYXNoLSR7aX1gKTtcbiAgICAgICAgICBmb3JtYXRUaW1lc3RhbXAoYDIwMjQtMDEtJHsoaSAlIDI4KSArIDF9YCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJ0ZXN0IiwiZXhwZWN0IiwiY24iLCJ0b0JlIiwidW5kZWZpbmVkIiwiY29uZGl0aW9uYWwiLCJyZXN1bHQiLCJ0b0NvbnRhaW4iLCJub3QiLCJsb25nQ2xhc3MiLCJyZXBlYXQiLCJ0b1Rocm93IiwibWFueUNsYXNzZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImV4dHJhY3RUYWdzRnJvbU1hcmtkb3duIiwidG9FcXVhbCIsImNvbXBsZXhNYXJrZG93biIsImxhcmdlVGFncyIsImpvaW4iLCJoYXNoVGFncyIsImNvbWJpbmVkIiwidG9IYXZlTGVuZ3RoIiwiZGF0ZSIsIkRhdGUiLCJmb3JtYXRUaW1lc3RhbXAiLCJpbnZhbGlkRGF0ZSIsInRpbWVzdGFtcCIsImdldFRpbWUiLCJOYU4iLCJjb25zb2xlU3B5IiwiamVzdCIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImVycm9yU3B5IiwidG9IYXZlQmVlbkNhbGxlZCIsIm9yaWdpbmFsR2V0VGltZSIsInByb3RvdHlwZSIsImZuIiwiRXJyb3IiLCJtb2NrUmVzdG9yZSIsInRlc3RDYXNlcyIsImZvckVhY2giLCJ0ZXN0Q2FzZSIsImh1Z2VTdHJpbmciLCJodWdlTWFya2Rvd24iLCJ1bmljb2RlVGVzdCIsInByb21pc2VzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiYWxsIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDOzs7O3VCQUU0RDtBQUU3REEsU0FBUyxtQ0FBbUM7SUFDMUNBLFNBQVMsNkNBQTZDO1FBQ3BE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