{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/__tests__/lib/advanced-algorithms.test.ts"],"sourcesContent":["/**\n * Advanced Algorithms Tests\n *\n * Tests for mathematical algorithms, optimization functions, machine learning utilities,\n * and computational methods following ADR-007 requirements for algorithm coverage.\n */\n\nimport { jest } from \"@jest/globals\";\n\n// Matrix Operations Library\nclass Matrix {\n  private data: number[][];\n  public rows: number;\n  public cols: number;\n\n  constructor(rows: number, cols: number, initialValue: number = 0) {\n    this.rows = rows;\n    this.cols = cols;\n    this.data = Array(rows)\n      .fill(null)\n      .map(() => Array(cols).fill(initialValue));\n  }\n\n  static fromArray(array: number[][]): Matrix {\n    const matrix = new Matrix(array.length, array[0]?.length || 0);\n    matrix.data = array.map((row) => [...row]);\n    return matrix;\n  }\n\n  get(row: number, col: number): number {\n    if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {\n      throw new Error(\"Index out of bounds\");\n    }\n    return this.data[row][col];\n  }\n\n  set(row: number, col: number, value: number): void {\n    if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {\n      throw new Error(\"Index out of bounds\");\n    }\n    this.data[row][col] = value;\n  }\n\n  multiply(other: Matrix): Matrix {\n    if (this.cols !== other.rows) {\n      throw new Error(\"Matrix dimensions incompatible for multiplication\");\n    }\n\n    const result = new Matrix(this.rows, other.cols);\n\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < other.cols; j++) {\n        let sum = 0;\n        for (let k = 0; k < this.cols; k++) {\n          sum += this.data[i][k] * other.data[k][j];\n        }\n        result.set(i, j, sum);\n      }\n    }\n\n    return result;\n  }\n\n  add(other: Matrix): Matrix {\n    if (this.rows !== other.rows || this.cols !== other.cols) {\n      throw new Error(\"Matrix dimensions must match for addition\");\n    }\n\n    const result = new Matrix(this.rows, this.cols);\n\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.cols; j++) {\n        result.set(i, j, this.get(i, j) + other.get(i, j));\n      }\n    }\n\n    return result;\n  }\n\n  subtract(other: Matrix): Matrix {\n    if (this.rows !== other.rows || this.cols !== other.cols) {\n      throw new Error(\"Matrix dimensions must match for subtraction\");\n    }\n\n    const result = new Matrix(this.rows, this.cols);\n\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.cols; j++) {\n        result.set(i, j, this.get(i, j) - other.get(i, j));\n      }\n    }\n\n    return result;\n  }\n\n  transpose(): Matrix {\n    const result = new Matrix(this.cols, this.rows);\n\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.cols; j++) {\n        result.set(j, i, this.get(i, j));\n      }\n    }\n\n    return result;\n  }\n\n  determinant(): number {\n    if (this.rows !== this.cols) {\n      throw new Error(\"Determinant only defined for square matrices\");\n    }\n\n    if (this.rows === 1) {\n      return this.get(0, 0);\n    }\n\n    if (this.rows === 2) {\n      return this.get(0, 0) * this.get(1, 1) - this.get(0, 1) * this.get(1, 0);\n    }\n\n    let det = 0;\n    for (let j = 0; j < this.cols; j++) {\n      const subMatrix = this.getSubMatrix(0, j);\n      const cofactor =\n        Math.pow(-1, j) * this.get(0, j) * subMatrix.determinant();\n      det += cofactor;\n    }\n\n    return det;\n  }\n\n  private getSubMatrix(excludeRow: number, excludeCol: number): Matrix {\n    const result = new Matrix(this.rows - 1, this.cols - 1);\n\n    let resultRow = 0;\n    for (let i = 0; i < this.rows; i++) {\n      if (i === excludeRow) continue;\n\n      let resultCol = 0;\n      for (let j = 0; j < this.cols; j++) {\n        if (j === excludeCol) continue;\n\n        result.set(resultRow, resultCol, this.get(i, j));\n        resultCol++;\n      }\n      resultRow++;\n    }\n\n    return result;\n  }\n\n  toArray(): number[][] {\n    return this.data.map((row) => [...row]);\n  }\n}\n\n// Optimization Algorithms\ninterface OptimizationResult {\n  solution: number[];\n  value: number;\n  iterations: number;\n  converged: boolean;\n}\n\nclass GradientDescent {\n  private learningRate: number;\n  private maxIterations: number;\n  private tolerance: number;\n\n  constructor(\n    learningRate: number = 0.01,\n    maxIterations: number = 1000,\n    tolerance: number = 1e-6,\n  ) {\n    this.learningRate = learningRate;\n    this.maxIterations = maxIterations;\n    this.tolerance = tolerance;\n  }\n\n  optimize(\n    objectiveFunction: (x: number[]) => number,\n    gradientFunction: (x: number[]) => number[],\n    initialGuess: number[],\n  ): OptimizationResult {\n    let x = [...initialGuess];\n    let iteration = 0;\n    let previousValue = objectiveFunction(x);\n\n    for (iteration = 0; iteration < this.maxIterations; iteration++) {\n      const gradient = gradientFunction(x);\n\n      // Update parameters\n      for (let i = 0; i < x.length; i++) {\n        x[i] -= this.learningRate * gradient[i];\n      }\n\n      const currentValue = objectiveFunction(x);\n\n      // Check convergence\n      if (Math.abs(currentValue - previousValue) < this.tolerance) {\n        return {\n          solution: x,\n          value: currentValue,\n          iterations: iteration + 1,\n          converged: true,\n        };\n      }\n\n      previousValue = currentValue;\n    }\n\n    return {\n      solution: x,\n      value: objectiveFunction(x),\n      iterations: this.maxIterations,\n      converged: false,\n    };\n  }\n}\n\n// Genetic Algorithm\ninterface GeneticAlgorithmOptions {\n  populationSize: number;\n  mutationRate: number;\n  crossoverRate: number;\n  eliteSize: number;\n  maxGenerations: number;\n  targetFitness?: number;\n}\n\ninterface Individual {\n  genes: number[];\n  fitness: number;\n}\n\nclass GeneticAlgorithm {\n  private options: GeneticAlgorithmOptions;\n\n  constructor(options: Partial<GeneticAlgorithmOptions> = {}) {\n    this.options = {\n      populationSize: 100,\n      mutationRate: 0.01,\n      crossoverRate: 0.8,\n      eliteSize: 10,\n      maxGenerations: 1000,\n      ...options,\n    };\n  }\n\n  optimize(\n    fitnessFunction: (genes: number[]) => number,\n    geneLength: number,\n    geneRange: [number, number] = [0, 1],\n  ): OptimizationResult {\n    // Initialize population\n    let population = this.initializePopulation(geneLength, geneRange);\n\n    // Evaluate initial population\n    population = this.evaluatePopulation(population, fitnessFunction);\n\n    let generation = 0;\n    let bestIndividual = this.getBestIndividual(population);\n\n    for (\n      generation = 0;\n      generation < this.options.maxGenerations;\n      generation++\n    ) {\n      // Selection\n      const parents = this.selection(population);\n\n      // Crossover\n      let offspring = this.crossover(parents);\n\n      // Mutation\n      offspring = this.mutate(offspring, geneRange);\n\n      // Evaluate offspring\n      offspring = this.evaluatePopulation(offspring, fitnessFunction);\n\n      // Replacement\n      population = this.replacement(population, offspring);\n\n      // Update best individual\n      const currentBest = this.getBestIndividual(population);\n      if (currentBest.fitness > bestIndividual.fitness) {\n        bestIndividual = currentBest;\n      }\n\n      // Check termination condition\n      if (\n        this.options.targetFitness &&\n        bestIndividual.fitness >= this.options.targetFitness\n      ) {\n        return {\n          solution: bestIndividual.genes,\n          value: bestIndividual.fitness,\n          iterations: generation + 1,\n          converged: true,\n        };\n      }\n    }\n\n    return {\n      solution: bestIndividual.genes,\n      value: bestIndividual.fitness,\n      iterations: this.options.maxGenerations,\n      converged: false,\n    };\n  }\n\n  private initializePopulation(\n    geneLength: number,\n    geneRange: [number, number],\n  ): Individual[] {\n    const population: Individual[] = [];\n\n    for (let i = 0; i < this.options.populationSize; i++) {\n      const genes: number[] = [];\n      for (let j = 0; j < geneLength; j++) {\n        const value =\n          Math.random() * (geneRange[1] - geneRange[0]) + geneRange[0];\n        genes.push(value);\n      }\n      population.push({ genes, fitness: 0 });\n    }\n\n    return population;\n  }\n\n  private evaluatePopulation(\n    population: Individual[],\n    fitnessFunction: (genes: number[]) => number,\n  ): Individual[] {\n    return population.map((individual) => ({\n      ...individual,\n      fitness: fitnessFunction(individual.genes),\n    }));\n  }\n\n  private selection(population: Individual[]): Individual[] {\n    // Tournament selection\n    const parents: Individual[] = [];\n    const tournamentSize = Math.max(\n      2,\n      Math.floor(this.options.populationSize * 0.1),\n    );\n\n    for (let i = 0; i < this.options.populationSize; i++) {\n      const tournament: Individual[] = [];\n\n      for (let j = 0; j < tournamentSize; j++) {\n        const randomIndex = Math.floor(Math.random() * population.length);\n        tournament.push(population[randomIndex]);\n      }\n\n      const winner = tournament.reduce((best, current) =>\n        current.fitness > best.fitness ? current : best,\n      );\n\n      parents.push({ ...winner });\n    }\n\n    return parents;\n  }\n\n  private crossover(parents: Individual[]): Individual[] {\n    const offspring: Individual[] = [];\n\n    for (let i = 0; i < parents.length; i += 2) {\n      const parent1 = parents[i];\n      const parent2 = parents[i + 1] || parents[0];\n\n      if (Math.random() < this.options.crossoverRate) {\n        const crossoverPoint = Math.floor(Math.random() * parent1.genes.length);\n\n        const child1Genes = [\n          ...parent1.genes.slice(0, crossoverPoint),\n          ...parent2.genes.slice(crossoverPoint),\n        ];\n\n        const child2Genes = [\n          ...parent2.genes.slice(0, crossoverPoint),\n          ...parent1.genes.slice(crossoverPoint),\n        ];\n\n        offspring.push({ genes: child1Genes, fitness: 0 });\n        offspring.push({ genes: child2Genes, fitness: 0 });\n      } else {\n        offspring.push({ ...parent1 });\n        offspring.push({ ...parent2 });\n      }\n    }\n\n    return offspring.slice(0, this.options.populationSize);\n  }\n\n  private mutate(\n    population: Individual[],\n    geneRange: [number, number],\n  ): Individual[] {\n    return population.map((individual) => {\n      const mutatedGenes = individual.genes.map((gene) => {\n        if (Math.random() < this.options.mutationRate) {\n          const mutationStrength = 0.1;\n          const mutation =\n            (Math.random() - 0.5) *\n            2 *\n            mutationStrength *\n            (geneRange[1] - geneRange[0]);\n          return Math.max(\n            geneRange[0],\n            Math.min(geneRange[1], gene + mutation),\n          );\n        }\n        return gene;\n      });\n\n      return { genes: mutatedGenes, fitness: individual.fitness };\n    });\n  }\n\n  private replacement(\n    oldPopulation: Individual[],\n    offspring: Individual[],\n  ): Individual[] {\n    // Elitism + replace worst\n    const combined = [...oldPopulation, ...offspring];\n    combined.sort((a, b) => b.fitness - a.fitness);\n\n    return combined.slice(0, this.options.populationSize);\n  }\n\n  private getBestIndividual(population: Individual[]): Individual {\n    return population.reduce((best, current) =>\n      current.fitness > best.fitness ? current : best,\n    );\n  }\n}\n\n// Machine Learning Utilities\nclass NeuralNetwork {\n  private weights: Matrix[];\n  private biases: Matrix[];\n  private learningRate: number;\n\n  constructor(layers: number[], learningRate: number = 0.01) {\n    this.learningRate = learningRate;\n    this.weights = [];\n    this.biases = [];\n\n    // Initialize weights and biases\n    for (let i = 0; i < layers.length - 1; i++) {\n      const weight = new Matrix(layers[i + 1], layers[i]);\n      const bias = new Matrix(layers[i + 1], 1);\n\n      // Xavier initialization\n      const limit = Math.sqrt(6 / (layers[i] + layers[i + 1]));\n\n      for (let row = 0; row < weight.rows; row++) {\n        for (let col = 0; col < weight.cols; col++) {\n          weight.set(row, col, (Math.random() - 0.5) * 2 * limit);\n        }\n        bias.set(row, 0, (Math.random() - 0.5) * 2 * limit);\n      }\n\n      this.weights.push(weight);\n      this.biases.push(bias);\n    }\n  }\n\n  private sigmoid(x: number): number {\n    return 1 / (1 + Math.exp(-x));\n  }\n\n  private sigmoidDerivative(x: number): number {\n    const s = this.sigmoid(x);\n    return s * (1 - s);\n  }\n\n  private applyActivation(matrix: Matrix): Matrix {\n    const result = new Matrix(matrix.rows, matrix.cols);\n\n    for (let i = 0; i < matrix.rows; i++) {\n      for (let j = 0; j < matrix.cols; j++) {\n        result.set(i, j, this.sigmoid(matrix.get(i, j)));\n      }\n    }\n\n    return result;\n  }\n\n  forward(input: number[]): number[] {\n    let current = Matrix.fromArray([input]).transpose();\n\n    for (let i = 0; i < this.weights.length; i++) {\n      current = this.weights[i].multiply(current).add(this.biases[i]);\n      current = this.applyActivation(current);\n    }\n\n    const result: number[] = [];\n    for (let i = 0; i < current.rows; i++) {\n      result.push(current.get(i, 0));\n    }\n\n    return result;\n  }\n\n  train(inputs: number[][], outputs: number[][], epochs: number): number[] {\n    const losses: number[] = [];\n\n    for (let epoch = 0; epoch < epochs; epoch++) {\n      let totalLoss = 0;\n\n      for (let i = 0; i < inputs.length; i++) {\n        const predicted = this.forward(inputs[i]);\n        const target = outputs[i];\n\n        // Calculate loss (MSE)\n        let loss = 0;\n        for (let j = 0; j < predicted.length; j++) {\n          loss += Math.pow(predicted[j] - target[j], 2);\n        }\n        loss /= predicted.length;\n        totalLoss += loss;\n\n        // Backpropagation (simplified)\n        this.backward(inputs[i], target, predicted);\n      }\n\n      losses.push(totalLoss / inputs.length);\n    }\n\n    return losses;\n  }\n\n  private backward(\n    input: number[],\n    target: number[],\n    predicted: number[],\n  ): void {\n    // Simplified backpropagation - calculate output error\n    const outputError: number[] = [];\n    for (let i = 0; i < predicted.length; i++) {\n      outputError.push(\n        (target[i] - predicted[i]) * this.sigmoidDerivative(predicted[i]),\n      );\n    }\n\n    // Update weights (simplified - only output layer)\n    if (this.weights.length > 0) {\n      const lastWeightIndex = this.weights.length - 1;\n      const lastWeight = this.weights[lastWeightIndex];\n\n      for (let i = 0; i < lastWeight.rows; i++) {\n        for (let j = 0; j < lastWeight.cols; j++) {\n          const delta = this.learningRate * outputError[i] * input[j];\n          lastWeight.set(i, j, lastWeight.get(i, j) + delta);\n        }\n\n        // Update bias\n        const biasIndex = this.biases.length - 1;\n        const currentBias = this.biases[biasIndex].get(i, 0);\n        this.biases[biasIndex].set(\n          i,\n          0,\n          currentBias + this.learningRate * outputError[i],\n        );\n      }\n    }\n  }\n}\n\n// Statistical Functions\nclass Statistics {\n  static mean(values: number[]): number {\n    if (values.length === 0) return 0;\n    return values.reduce((sum, value) => sum + value, 0) / values.length;\n  }\n\n  static median(values: number[]): number {\n    if (values.length === 0) return 0;\n\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n\n    return sorted.length % 2 === 0\n      ? (sorted[mid - 1] + sorted[mid]) / 2\n      : sorted[mid];\n  }\n\n  static standardDeviation(values: number[]): number {\n    if (values.length === 0) return 0;\n\n    const mean = this.mean(values);\n    const variance =\n      values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) /\n      values.length;\n\n    return Math.sqrt(variance);\n  }\n\n  static correlation(x: number[], y: number[]): number {\n    if (x.length !== y.length || x.length === 0) {\n      throw new Error(\"Arrays must have the same non-zero length\");\n    }\n\n    const meanX = this.mean(x);\n    const meanY = this.mean(y);\n\n    let numerator = 0;\n    let sumSquareX = 0;\n    let sumSquareY = 0;\n\n    for (let i = 0; i < x.length; i++) {\n      const deltaX = x[i] - meanX;\n      const deltaY = y[i] - meanY;\n\n      numerator += deltaX * deltaY;\n      sumSquareX += deltaX * deltaX;\n      sumSquareY += deltaY * deltaY;\n    }\n\n    const denominator = Math.sqrt(sumSquareX * sumSquareY);\n\n    return denominator === 0 ? 0 : numerator / denominator;\n  }\n\n  static linearRegression(\n    x: number[],\n    y: number[],\n  ): { slope: number; intercept: number; r2: number } {\n    if (x.length !== y.length || x.length === 0) {\n      throw new Error(\"Arrays must have the same non-zero length\");\n    }\n\n    const n = x.length;\n    const sumX = x.reduce((sum, val) => sum + val, 0);\n    const sumY = y.reduce((sum, val) => sum + val, 0);\n    const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);\n    const sumXX = x.reduce((sum, val) => sum + val * val, 0);\n    const sumYY = y.reduce((sum, val) => sum + val * val, 0);\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n\n    // Calculate R-squared\n    const meanY = sumY / n;\n    const totalSumSquares = sumYY - n * meanY * meanY;\n    const residualSumSquares = y.reduce((sum, val, i) => {\n      const predicted = slope * x[i] + intercept;\n      return sum + Math.pow(val - predicted, 2);\n    }, 0);\n\n    const r2 = 1 - residualSumSquares / totalSumSquares;\n\n    return { slope, intercept, r2 };\n  }\n}\n\n// Graph Algorithms\ninterface GraphNode {\n  id: string;\n  data?: any;\n}\n\ninterface GraphEdge {\n  from: string;\n  to: string;\n  weight?: number;\n  data?: any;\n}\n\nclass Graph {\n  private nodes: Map<string, GraphNode> = new Map();\n  private adjacencyList: Map<string, string[]> = new Map();\n  private edges: Map<string, GraphEdge> = new Map();\n\n  addNode(node: GraphNode): void {\n    this.nodes.set(node.id, node);\n    if (!this.adjacencyList.has(node.id)) {\n      this.adjacencyList.set(node.id, []);\n    }\n  }\n\n  addEdge(edge: GraphEdge): void {\n    const edgeKey = `${edge.from}-${edge.to}`;\n    this.edges.set(edgeKey, edge);\n\n    if (!this.adjacencyList.has(edge.from)) {\n      this.adjacencyList.set(edge.from, []);\n    }\n    if (!this.adjacencyList.has(edge.to)) {\n      this.adjacencyList.set(edge.to, []);\n    }\n\n    this.adjacencyList.get(edge.from)!.push(edge.to);\n  }\n\n  getNeighbors(nodeId: string): string[] {\n    return this.adjacencyList.get(nodeId) || [];\n  }\n\n  dijkstra(\n    startId: string,\n    endId: string,\n  ): { path: string[]; distance: number } | null {\n    const distances = new Map<string, number>();\n    const previous = new Map<string, string | null>();\n    const unvisited = new Set<string>();\n\n    // Initialize distances\n    for (const nodeId of this.nodes.keys()) {\n      distances.set(nodeId, nodeId === startId ? 0 : Infinity);\n      previous.set(nodeId, null);\n      unvisited.add(nodeId);\n    }\n\n    while (unvisited.size > 0) {\n      // Find node with minimum distance\n      let currentNode: string | null = null;\n      let minDistance = Infinity;\n\n      for (const nodeId of unvisited) {\n        const distance = distances.get(nodeId)!;\n        if (distance < minDistance) {\n          minDistance = distance;\n          currentNode = nodeId;\n        }\n      }\n\n      if (currentNode === null || minDistance === Infinity) {\n        break; // No path exists\n      }\n\n      unvisited.delete(currentNode);\n\n      if (currentNode === endId) {\n        // Reconstruct path\n        const path: string[] = [];\n        let current: string | null = endId;\n\n        while (current !== null) {\n          path.unshift(current);\n          current = previous.get(current)!;\n        }\n\n        return { path, distance: distances.get(endId)! };\n      }\n\n      // Update distances to neighbors\n      const neighbors = this.getNeighbors(currentNode);\n      for (const neighborId of neighbors) {\n        if (!unvisited.has(neighborId)) continue;\n\n        const edgeKey = `${currentNode}-${neighborId}`;\n        const edge = this.edges.get(edgeKey);\n        const weight = edge?.weight || 1;\n\n        const newDistance = distances.get(currentNode)! + weight;\n\n        if (newDistance < distances.get(neighborId)!) {\n          distances.set(neighborId, newDistance);\n          previous.set(neighborId, currentNode);\n        }\n      }\n    }\n\n    return null; // No path found\n  }\n\n  bfs(startId: string): string[] {\n    const visited = new Set<string>();\n    const queue: string[] = [startId];\n    const result: string[] = [];\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n\n      if (visited.has(current)) continue;\n\n      visited.add(current);\n      result.push(current);\n\n      const neighbors = this.getNeighbors(current);\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          queue.push(neighbor);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  dfs(startId: string): string[] {\n    const visited = new Set<string>();\n    const result: string[] = [];\n\n    const dfsRecursive = (nodeId: string) => {\n      visited.add(nodeId);\n      result.push(nodeId);\n\n      const neighbors = this.getNeighbors(nodeId);\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          dfsRecursive(neighbor);\n        }\n      }\n    };\n\n    dfsRecursive(startId);\n    return result;\n  }\n\n  detectCycles(): boolean {\n    const visited = new Set<string>();\n    const recStack = new Set<string>();\n\n    const hasCycleRecursive = (nodeId: string): boolean => {\n      visited.add(nodeId);\n      recStack.add(nodeId);\n\n      const neighbors = this.getNeighbors(nodeId);\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          if (hasCycleRecursive(neighbor)) {\n            return true;\n          }\n        } else if (recStack.has(neighbor)) {\n          return true;\n        }\n      }\n\n      recStack.delete(nodeId);\n      return false;\n    };\n\n    for (const nodeId of this.nodes.keys()) {\n      if (!visited.has(nodeId)) {\n        if (hasCycleRecursive(nodeId)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n\n// Tests\ndescribe(\"Advanced Algorithms\", () => {\n  describe(\"Matrix Operations\", () => {\n    test(\"should create matrix with correct dimensions\", () => {\n      const matrix = new Matrix(3, 4, 5);\n\n      expect(matrix.rows).toBe(3);\n      expect(matrix.cols).toBe(4);\n      expect(matrix.get(0, 0)).toBe(5);\n      expect(matrix.get(2, 3)).toBe(5);\n    });\n\n    test(\"should handle matrix multiplication\", () => {\n      const a = Matrix.fromArray([\n        [1, 2],\n        [3, 4],\n      ]);\n      const b = Matrix.fromArray([\n        [5, 6],\n        [7, 8],\n      ]);\n\n      const result = a.multiply(b);\n\n      expect(result.get(0, 0)).toBe(19); // 1*5 + 2*7\n      expect(result.get(0, 1)).toBe(22); // 1*6 + 2*8\n      expect(result.get(1, 0)).toBe(43); // 3*5 + 4*7\n      expect(result.get(1, 1)).toBe(50); // 3*6 + 4*8\n    });\n\n    test(\"should calculate determinant\", () => {\n      const matrix2x2 = Matrix.fromArray([\n        [1, 2],\n        [3, 4],\n      ]);\n      expect(matrix2x2.determinant()).toBe(-2);\n\n      const matrix3x3 = Matrix.fromArray([\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n      ]);\n      expect(matrix3x3.determinant()).toBe(0); // Singular matrix\n    });\n\n    test(\"should transpose matrix\", () => {\n      const matrix = Matrix.fromArray([\n        [1, 2, 3],\n        [4, 5, 6],\n      ]);\n      const transposed = matrix.transpose();\n\n      expect(transposed.rows).toBe(3);\n      expect(transposed.cols).toBe(2);\n      expect(transposed.get(0, 0)).toBe(1);\n      expect(transposed.get(1, 0)).toBe(2);\n      expect(transposed.get(2, 1)).toBe(6);\n    });\n\n    test(\"should handle matrix addition and subtraction\", () => {\n      const a = Matrix.fromArray([\n        [1, 2],\n        [3, 4],\n      ]);\n      const b = Matrix.fromArray([\n        [5, 6],\n        [7, 8],\n      ]);\n\n      const sum = a.add(b);\n      expect(sum.get(0, 0)).toBe(6);\n      expect(sum.get(1, 1)).toBe(12);\n\n      const diff = a.subtract(b);\n      expect(diff.get(0, 0)).toBe(-4);\n      expect(diff.get(1, 1)).toBe(-4);\n    });\n\n    test(\"should throw error for invalid operations\", () => {\n      const a = new Matrix(2, 3);\n      const b = new Matrix(2, 2);\n\n      expect(() => a.multiply(b)).toThrow(\"Matrix dimensions incompatible\");\n      expect(() => a.add(b)).toThrow(\"Matrix dimensions must match\");\n      expect(() => a.determinant()).toThrow(\n        \"Determinant only defined for square matrices\",\n      );\n    });\n  });\n\n  describe(\"Gradient Descent\", () => {\n    test(\"should minimize quadratic function\", () => {\n      const gd = new GradientDescent(0.1, 100, 1e-6);\n\n      // Minimize f(x) = x^2, gradient = 2x\n      const objective = (x: number[]) => x[0] * x[0];\n      const gradient = (x: number[]) => [2 * x[0]];\n\n      const result = gd.optimize(objective, gradient, [10]);\n\n      expect(result.converged).toBe(true);\n      expect(Math.abs(result.solution[0])).toBeLessThan(0.1);\n      expect(result.value).toBeLessThan(0.01);\n    });\n\n    test(\"should handle multi-dimensional optimization\", () => {\n      const gd = new GradientDescent(0.01, 1000, 1e-6);\n\n      // Minimize f(x,y) = x^2 + y^2\n      const objective = (x: number[]) => x[0] * x[0] + x[1] * x[1];\n      const gradient = (x: number[]) => [2 * x[0], 2 * x[1]];\n\n      const result = gd.optimize(objective, gradient, [5, -3]);\n\n      expect(result.converged).toBe(true);\n      expect(Math.abs(result.solution[0])).toBeLessThan(0.1);\n      expect(Math.abs(result.solution[1])).toBeLessThan(0.1);\n    });\n\n    test(\"should return non-converged result for difficult problems\", () => {\n      const gd = new GradientDescent(0.001, 10, 1e-6); // Too few iterations\n\n      const objective = (x: number[]) => x[0] * x[0];\n      const gradient = (x: number[]) => [2 * x[0]];\n\n      const result = gd.optimize(objective, gradient, [100]);\n\n      expect(result.converged).toBe(false);\n      expect(result.iterations).toBe(10);\n    });\n  });\n\n  describe(\"Genetic Algorithm\", () => {\n    test(\"should optimize simple function\", () => {\n      const ga = new GeneticAlgorithm({\n        populationSize: 50,\n        maxGenerations: 100,\n        mutationRate: 0.1,\n      });\n\n      // Maximize f(x) = -(x-5)^2 + 25 (peak at x=5)\n      const fitness = (genes: number[]) => {\n        const x = genes[0] * 10; // Scale from [0,1] to [0,10]\n        return -Math.pow(x - 5, 2) + 25;\n      };\n\n      const result = ga.optimize(fitness, 1, [0, 1]);\n\n      expect(result.solution).toHaveLength(1);\n      const scaledSolution = result.solution[0] * 10;\n      expect(Math.abs(scaledSolution - 5)).toBeLessThan(1);\n      expect(result.value).toBeGreaterThan(20);\n    });\n\n    test(\"should handle multi-dimensional optimization\", () => {\n      const ga = new GeneticAlgorithm({\n        populationSize: 100,\n        maxGenerations: 50,\n        mutationRate: 0.05,\n      });\n\n      // Maximize f(x,y) = -(x-3)^2 - (y-4)^2 + 25\n      const fitness = (genes: number[]) => {\n        const x = genes[0] * 10;\n        const y = genes[1] * 10;\n        return -Math.pow(x - 3, 2) - Math.pow(y - 4, 2) + 25;\n      };\n\n      const result = ga.optimize(fitness, 2, [0, 1]);\n\n      expect(result.solution).toHaveLength(2);\n      expect(result.iterations).toBeGreaterThan(0);\n    });\n\n    test(\"should terminate early with target fitness\", () => {\n      const ga = new GeneticAlgorithm({\n        populationSize: 50,\n        maxGenerations: 1000,\n        targetFitness: 20,\n      });\n\n      const fitness = (genes: number[]) => {\n        const x = genes[0] * 10;\n        return -Math.pow(x - 5, 2) + 25;\n      };\n\n      const result = ga.optimize(fitness, 1, [0, 1]);\n\n      expect(result.converged).toBe(true);\n      expect(result.iterations).toBeLessThan(1000);\n      expect(result.value).toBeGreaterThanOrEqual(20);\n    });\n  });\n\n  describe(\"Neural Network\", () => {\n    test(\"should create network with correct architecture\", () => {\n      const nn = new NeuralNetwork([2, 3, 1]);\n\n      // Test that network can process input\n      const output = nn.forward([0.5, 0.3]);\n\n      expect(output).toHaveLength(1);\n      expect(output[0]).toBeGreaterThanOrEqual(0);\n      expect(output[0]).toBeLessThanOrEqual(1);\n    });\n\n    test(\"should train on XOR problem\", () => {\n      const nn = new NeuralNetwork([2, 4, 1], 0.5);\n\n      const inputs = [\n        [0, 0],\n        [0, 1],\n        [1, 0],\n        [1, 1],\n      ];\n\n      const outputs = [[0], [1], [1], [0]];\n\n      const losses = nn.train(inputs, outputs, 100);\n\n      expect(losses).toHaveLength(100);\n      expect(losses[losses.length - 1]).toBeLessThan(losses[0]);\n    });\n\n    test(\"should learn simple pattern\", () => {\n      const nn = new NeuralNetwork([1, 2, 1], 0.1);\n\n      // Learn f(x) = x\n      const inputs = [[0], [0.25], [0.5], [0.75], [1]];\n      const outputs = [[0], [0.25], [0.5], [0.75], [1]];\n\n      nn.train(inputs, outputs, 200);\n\n      const testOutput = nn.forward([0.6]);\n      expect(Math.abs(testOutput[0] - 0.6)).toBeLessThan(0.3);\n    });\n  });\n\n  describe(\"Statistics\", () => {\n    test(\"should calculate mean correctly\", () => {\n      expect(Statistics.mean([1, 2, 3, 4, 5])).toBe(3);\n      expect(Statistics.mean([10])).toBe(10);\n      expect(Statistics.mean([])).toBe(0);\n    });\n\n    test(\"should calculate median correctly\", () => {\n      expect(Statistics.median([1, 2, 3, 4, 5])).toBe(3);\n      expect(Statistics.median([1, 2, 3, 4])).toBe(2.5);\n      expect(Statistics.median([5, 1, 3])).toBe(3);\n    });\n\n    test(\"should calculate standard deviation\", () => {\n      const std = Statistics.standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]);\n      expect(Math.abs(std - 2)).toBeLessThan(0.1);\n    });\n\n    test(\"should calculate correlation\", () => {\n      const x = [1, 2, 3, 4, 5];\n      const y = [2, 4, 6, 8, 10];\n\n      const correlation = Statistics.correlation(x, y);\n      expect(Math.abs(correlation - 1)).toBeLessThan(0.01); // Perfect positive correlation\n    });\n\n    test(\"should perform linear regression\", () => {\n      const x = [1, 2, 3, 4, 5];\n      const y = [2, 4, 6, 8, 10]; // y = 2x\n\n      const regression = Statistics.linearRegression(x, y);\n\n      expect(Math.abs(regression.slope - 2)).toBeLessThan(0.01);\n      expect(Math.abs(regression.intercept)).toBeLessThan(0.01);\n      expect(regression.r2).toBeGreaterThan(0.99);\n    });\n\n    test(\"should handle edge cases\", () => {\n      expect(() => Statistics.correlation([], [])).toThrow();\n      expect(() => Statistics.correlation([1], [1, 2])).toThrow();\n      expect(() => Statistics.linearRegression([], [])).toThrow();\n    });\n  });\n\n  describe(\"Graph Algorithms\", () => {\n    let graph: Graph;\n\n    beforeEach(() => {\n      graph = new Graph();\n\n      // Create test graph\n      graph.addNode({ id: \"A\" });\n      graph.addNode({ id: \"B\" });\n      graph.addNode({ id: \"C\" });\n      graph.addNode({ id: \"D\" });\n\n      graph.addEdge({ from: \"A\", to: \"B\", weight: 1 });\n      graph.addEdge({ from: \"A\", to: \"C\", weight: 4 });\n      graph.addEdge({ from: \"B\", to: \"C\", weight: 2 });\n      graph.addEdge({ from: \"B\", to: \"D\", weight: 5 });\n      graph.addEdge({ from: \"C\", to: \"D\", weight: 1 });\n    });\n\n    test(\"should perform breadth-first search\", () => {\n      const result = graph.bfs(\"A\");\n\n      expect(result).toContain(\"A\");\n      expect(result).toContain(\"B\");\n      expect(result).toContain(\"C\");\n      expect(result[0]).toBe(\"A\"); // Start node should be first\n    });\n\n    test(\"should perform depth-first search\", () => {\n      const result = graph.dfs(\"A\");\n\n      expect(result).toContain(\"A\");\n      expect(result).toContain(\"B\");\n      expect(result).toContain(\"C\");\n      expect(result[0]).toBe(\"A\"); // Start node should be first\n    });\n\n    test(\"should find shortest path with Dijkstra\", () => {\n      const result = graph.dijkstra(\"A\", \"D\");\n\n      expect(result).not.toBeNull();\n      expect(result!.path[0]).toBe(\"A\");\n      expect(result!.path[result!.path.length - 1]).toBe(\"D\");\n      expect(result!.distance).toBe(5); // A -> B -> C -> D = 1 + 2 + 1 = 4 or A -> C -> D = 4 + 1 = 5\n    });\n\n    test(\"should detect cycles\", () => {\n      const cyclicGraph = new Graph();\n      cyclicGraph.addNode({ id: \"X\" });\n      cyclicGraph.addNode({ id: \"Y\" });\n      cyclicGraph.addNode({ id: \"Z\" });\n\n      cyclicGraph.addEdge({ from: \"X\", to: \"Y\" });\n      cyclicGraph.addEdge({ from: \"Y\", to: \"Z\" });\n      cyclicGraph.addEdge({ from: \"Z\", to: \"X\" }); // Creates cycle\n\n      expect(cyclicGraph.detectCycles()).toBe(true);\n      expect(graph.detectCycles()).toBe(false); // Original graph is acyclic\n    });\n\n    test(\"should handle disconnected nodes\", () => {\n      graph.addNode({ id: \"E\" }); // Isolated node\n\n      const result = graph.dijkstra(\"A\", \"E\");\n      expect(result).toBeNull(); // No path exists\n    });\n\n    test(\"should return empty arrays for non-existent nodes\", () => {\n      const neighbors = graph.getNeighbors(\"NonExistent\");\n      expect(neighbors).toEqual([]);\n    });\n  });\n});\n"],"names":["Matrix","constructor","rows","cols","initialValue","data","Array","fill","map","fromArray","array","matrix","length","row","get","col","Error","set","value","multiply","other","result","i","j","sum","k","add","subtract","transpose","determinant","det","subMatrix","getSubMatrix","cofactor","Math","pow","excludeRow","excludeCol","resultRow","resultCol","toArray","GradientDescent","learningRate","maxIterations","tolerance","optimize","objectiveFunction","gradientFunction","initialGuess","x","iteration","previousValue","gradient","currentValue","abs","solution","iterations","converged","GeneticAlgorithm","options","populationSize","mutationRate","crossoverRate","eliteSize","maxGenerations","fitnessFunction","geneLength","geneRange","population","initializePopulation","evaluatePopulation","generation","bestIndividual","getBestIndividual","parents","selection","offspring","crossover","mutate","replacement","currentBest","fitness","targetFitness","genes","random","push","individual","tournamentSize","max","floor","tournament","randomIndex","winner","reduce","best","current","parent1","parent2","crossoverPoint","child1Genes","slice","child2Genes","mutatedGenes","gene","mutationStrength","mutation","min","oldPopulation","combined","sort","a","b","NeuralNetwork","layers","weights","biases","weight","bias","limit","sqrt","sigmoid","exp","sigmoidDerivative","s","applyActivation","forward","input","train","inputs","outputs","epochs","losses","epoch","totalLoss","predicted","target","loss","backward","outputError","lastWeightIndex","lastWeight","delta","biasIndex","currentBias","Statistics","mean","values","median","sorted","mid","standardDeviation","variance","correlation","y","meanX","meanY","numerator","sumSquareX","sumSquareY","deltaX","deltaY","denominator","linearRegression","n","sumX","val","sumY","sumXY","sumXX","sumYY","slope","intercept","totalSumSquares","residualSumSquares","r2","Graph","addNode","node","nodes","id","adjacencyList","has","addEdge","edge","edgeKey","from","to","edges","getNeighbors","nodeId","dijkstra","startId","endId","distances","Map","previous","unvisited","Set","keys","Infinity","size","currentNode","minDistance","distance","delete","path","unshift","neighbors","neighborId","newDistance","bfs","visited","queue","shift","neighbor","dfs","dfsRecursive","detectCycles","recStack","hasCycleRecursive","describe","test","expect","toBe","matrix2x2","matrix3x3","transposed","diff","toThrow","gd","objective","toBeLessThan","ga","toHaveLength","scaledSolution","toBeGreaterThan","toBeGreaterThanOrEqual","nn","output","toBeLessThanOrEqual","testOutput","std","regression","graph","beforeEach","toContain","not","toBeNull","cyclicGraph","toEqual"],"mappings":"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"}