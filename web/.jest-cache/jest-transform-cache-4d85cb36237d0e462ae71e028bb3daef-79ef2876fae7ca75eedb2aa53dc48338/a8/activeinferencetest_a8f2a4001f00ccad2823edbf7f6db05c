533932c4b9e7de14d7d89774dd70cee6
/**
 * Active Inference Tests
 *
 * Tests for active inference, free energy minimization, and belief updating
 * following ADR-007 comprehensive testing requirements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _activeinference = require("../../lib/active-inference");
describe("Active Inference Engine", ()=>{
    let engine;
    let testModel;
    beforeEach(()=>{
        testModel = {
            states: [
                "exploring",
                "exploiting",
                "resting"
            ],
            observations: [
                "high_reward",
                "low_reward",
                "no_reward"
            ],
            actions: [
                "move_forward",
                "turn",
                "wait"
            ],
            // Transition dynamics P(s'|s,a)
            transitionModel: {
                exploring: {
                    move_forward: {
                        exploring: 0.7,
                        exploiting: 0.2,
                        resting: 0.1
                    },
                    turn: {
                        exploring: 0.8,
                        exploiting: 0.1,
                        resting: 0.1
                    },
                    wait: {
                        exploring: 0.3,
                        exploiting: 0.1,
                        resting: 0.6
                    }
                },
                exploiting: {
                    move_forward: {
                        exploring: 0.1,
                        exploiting: 0.8,
                        resting: 0.1
                    },
                    turn: {
                        exploring: 0.3,
                        exploiting: 0.6,
                        resting: 0.1
                    },
                    wait: {
                        exploring: 0.1,
                        exploiting: 0.3,
                        resting: 0.6
                    }
                },
                resting: {
                    move_forward: {
                        exploring: 0.6,
                        exploiting: 0.3,
                        resting: 0.1
                    },
                    turn: {
                        exploring: 0.4,
                        exploiting: 0.2,
                        resting: 0.4
                    },
                    wait: {
                        exploring: 0.1,
                        exploiting: 0.1,
                        resting: 0.8
                    }
                }
            },
            // Observation model P(o|s)
            observationModel: {
                exploring: {
                    high_reward: 0.3,
                    low_reward: 0.5,
                    no_reward: 0.2
                },
                exploiting: {
                    high_reward: 0.7,
                    low_reward: 0.2,
                    no_reward: 0.1
                },
                resting: {
                    high_reward: 0.1,
                    low_reward: 0.2,
                    no_reward: 0.7
                }
            },
            // Prior preferences (negative log probabilities)
            preferences: {
                high_reward: -2.0,
                low_reward: -0.5,
                no_reward: 0.5
            }
        };
        engine = (0, _activeinference.createActiveInferenceEngine)({
            model: testModel,
            precision: 1.0,
            learningRate: 0.1,
            planningHorizon: 3
        });
    });
    describe("Engine Creation and Configuration", ()=>{
        it("creates engine with valid configuration", ()=>{
            expect(engine).toMatchObject({
                model: testModel,
                precision: 1.0,
                learningRate: 0.1,
                planningHorizon: 3
            });
        });
        it("initializes with uniform beliefs", ()=>{
            const beliefs = engine.getCurrentBeliefs();
            const stateProbs = Object.values(beliefs.states);
            expect(Math.abs(stateProbs.reduce((sum, p)=>sum + p, 0) - 1.0)).toBeLessThan(0.001);
            stateProbs.forEach((p)=>{
                expect(p).toBeCloseTo(1.0 / testModel.states.length, 5);
            });
        });
        it("validates model structure", ()=>{
            const invalidModel = {
                ...testModel,
                transitionModel: {}
            };
            expect(()=>{
                (0, _activeinference.createActiveInferenceEngine)({
                    model: invalidModel
                });
            }).toThrow("Invalid generative model");
        });
    });
    describe("Belief Updates", ()=>{
        it("updates beliefs based on observations", ()=>{
            const initialBeliefs = engine.getCurrentBeliefs();
            const observation = {
                type: "observation",
                value: "high_reward",
                confidence: 0.9
            };
            const updatedBeliefs = (0, _activeinference.updateBeliefs)(engine, observation);
            // Should increase belief in exploiting state (high reward association)
            expect(updatedBeliefs.states.exploiting).toBeGreaterThan(initialBeliefs.states.exploiting);
        });
        it("incorporates observation confidence", ()=>{
            const highConfObs = {
                type: "observation",
                value: "high_reward",
                confidence: 0.95
            };
            const lowConfObs = {
                type: "observation",
                value: "high_reward",
                confidence: 0.3
            };
            const highConfBeliefs = (0, _activeinference.updateBeliefs)(engine, highConfObs);
            const lowConfBeliefs = (0, _activeinference.updateBeliefs)(engine, lowConfObs);
            // High confidence should lead to stronger belief updates
            const highConfChange = Math.abs(highConfBeliefs.states.exploiting - 1 / 3);
            const lowConfChange = Math.abs(lowConfBeliefs.states.exploiting - 1 / 3);
            expect(highConfChange).toBeGreaterThan(lowConfChange);
        });
        it("maintains probability normalization", ()=>{
            const observations = [
                {
                    type: "observation",
                    value: "high_reward",
                    confidence: 0.8
                },
                {
                    type: "observation",
                    value: "low_reward",
                    confidence: 0.7
                },
                {
                    type: "observation",
                    value: "no_reward",
                    confidence: 0.9
                }
            ];
            observations.forEach((obs)=>{
                const beliefs = (0, _activeinference.updateBeliefs)(engine, obs);
                const sum = Object.values(beliefs.states).reduce((s, p)=>s + p, 0);
                expect(sum).toBeCloseTo(1.0, 5);
            });
        });
    });
    describe("Free Energy Calculations", ()=>{
        it("calculates variational free energy", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.6,
                    exploiting: 0.3,
                    resting: 0.1
                },
                uncertainty: 0.2
            };
            const observation = "high_reward";
            const freeEnergy = engine.calculateFreeEnergy(beliefs, observation);
            expect(freeEnergy).toBeGreaterThan(0);
            expect(Number.isFinite(freeEnergy)).toBe(true);
        });
        it("increases with prediction error", ()=>{
            // Belief state that predicts low rewards
            const pessimisticBeliefs = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.1,
                    resting: 0.8
                },
                uncertainty: 0.1
            };
            // But observes high reward
            const observation = "high_reward";
            const highError = engine.calculateFreeEnergy(pessimisticBeliefs, observation);
            // Belief state that predicts high rewards
            const optimisticBeliefs = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.8,
                    resting: 0.1
                },
                uncertainty: 0.1
            };
            const lowError = engine.calculateFreeEnergy(optimisticBeliefs, observation);
            expect(highError).toBeGreaterThan(lowError);
        });
        it("includes entropy/uncertainty term", ()=>{
            const certainBeliefs = {
                states: {
                    exploring: 0.98,
                    exploiting: 0.01,
                    resting: 0.01
                },
                uncertainty: 0.01
            };
            const uncertainBeliefs = {
                states: {
                    exploring: 0.34,
                    exploiting: 0.33,
                    resting: 0.33
                },
                uncertainty: 0.8
            };
            const observation = "low_reward";
            const certainFE = engine.calculateFreeEnergy(certainBeliefs, observation);
            const uncertainFE = engine.calculateFreeEnergy(uncertainBeliefs, observation);
            // Higher uncertainty should contribute to free energy
            expect(Math.abs(certainFE - uncertainFE)).toBeGreaterThan(0.1);
        });
    });
    describe("Expected Free Energy", ()=>{
        it("calculates expected free energy for policies", ()=>{
            const policy = [
                {
                    action: "move_forward",
                    timestep: 0
                },
                {
                    action: "turn",
                    timestep: 1
                },
                {
                    action: "wait",
                    timestep: 2
                }
            ];
            const efe = (0, _activeinference.calculateExpectedFreeEnergy)(engine, policy);
            expect(Number.isFinite(efe.total)).toBe(true);
            expect(Number.isFinite(efe.epistemic)).toBe(true);
            expect(Number.isFinite(efe.pragmatic)).toBe(true);
            expect(efe).toHaveProperty("total");
            expect(efe).toHaveProperty("epistemic");
            expect(efe).toHaveProperty("pragmatic");
        });
        it("balances epistemic and pragmatic value", ()=>{
            const exploratoryPolicy = [
                {
                    action: "turn",
                    timestep: 0
                },
                {
                    action: "move_forward",
                    timestep: 1
                }
            ];
            const exploitativePolicy = [
                {
                    action: "wait",
                    timestep: 0
                },
                {
                    action: "wait",
                    timestep: 1
                }
            ];
            const exploratory = (0, _activeinference.calculateExpectedFreeEnergy)(engine, exploratoryPolicy);
            const exploitative = (0, _activeinference.calculateExpectedFreeEnergy)(engine, exploitativePolicy);
            expect(exploratory.epistemic).toBeLessThan(exploitative.epistemic);
        });
        it("considers future outcomes", ()=>{
            const shortPolicy = [
                {
                    action: "move_forward",
                    timestep: 0
                }
            ];
            const longPolicy = [
                {
                    action: "move_forward",
                    timestep: 0
                },
                {
                    action: "move_forward",
                    timestep: 1
                },
                {
                    action: "move_forward",
                    timestep: 2
                }
            ];
            const shortEFE = (0, _activeinference.calculateExpectedFreeEnergy)(engine, shortPolicy);
            const longEFE = (0, _activeinference.calculateExpectedFreeEnergy)(engine, longPolicy);
            // Longer horizon should affect total expected free energy
            expect(shortEFE.total).not.toBe(longEFE.total);
        });
    });
    describe("Action Selection", ()=>{
        it("selects actions that minimize expected free energy", ()=>{
            const currentBeliefs = {
                states: {
                    exploring: 0.7,
                    exploiting: 0.2,
                    resting: 0.1
                },
                uncertainty: 0.3
            };
            const selectedAction = (0, _activeinference.selectAction)(engine, currentBeliefs);
            expect(testModel.actions).toContain(selectedAction.type);
            expect(selectedAction.confidence).toBeGreaterThan(0);
            expect(selectedAction.confidence).toBeLessThanOrEqual(1);
        });
        it("increases exploration under high uncertainty", ()=>{
            const lowUncertainty = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.8,
                    resting: 0.1
                },
                uncertainty: 0.1
            };
            const highUncertainty = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.8,
                    resting: 0.1
                },
                uncertainty: 0.8
            };
            const lowUncAction = (0, _activeinference.selectAction)(engine, lowUncertainty);
            const highUncAction = (0, _activeinference.selectAction)(engine, highUncertainty);
            // High uncertainty should favor exploratory actions
            expect(highUncAction.type).not.toBe("wait");
        });
        it("respects action constraints", ()=>{
            const constrainedEngine = (0, _activeinference.createActiveInferenceEngine)({
                model: testModel,
                actionConstraints: {
                    wait: {
                        maxFrequency: 0.3
                    }
                }
            });
            const actions = [];
            for(let i = 0; i < 100; i++){
                const action = (0, _activeinference.selectAction)(constrainedEngine, engine.getCurrentBeliefs());
                actions.push(action.type);
            }
            const waitFrequency = actions.filter((a)=>a === "wait").length / actions.length;
            expect(waitFrequency).toBeLessThanOrEqual(0.35); // Allow small variance
        });
    });
    describe("Inference Process", ()=>{
        it("performs complete inference cycle", async ()=>{
            const observation = {
                type: "observation",
                value: "high_reward",
                confidence: 0.9
            };
            const result = await (0, _activeinference.performInference)(engine, observation);
            expect(result).toHaveProperty("beliefs");
            expect(result).toHaveProperty("selectedAction");
            expect(result).toHaveProperty("freeEnergy");
            expect(result).toHaveProperty("confidence");
        });
        it("adapts to changing observations", async ()=>{
            const observations = [
                {
                    type: "observation",
                    value: "no_reward",
                    confidence: 0.9
                },
                {
                    type: "observation",
                    value: "low_reward",
                    confidence: 0.8
                },
                {
                    type: "observation",
                    value: "high_reward",
                    confidence: 0.95
                }
            ];
            const results = [];
            for (const obs of observations){
                const result = await (0, _activeinference.performInference)(engine, obs);
                results.push(result);
            }
            // Should adapt behavior based on observation history
            expect(results[0].selectedAction.type).not.toBe(results[2].selectedAction.type);
        });
        it("maintains computational efficiency", async ()=>{
            const startTime = Date.now();
            const iterations = 100;
            for(let i = 0; i < iterations; i++){
                const obs = {
                    type: "observation",
                    value: [
                        "high_reward",
                        "low_reward",
                        "no_reward"
                    ][i % 3],
                    confidence: 0.8
                };
                await (0, _activeinference.performInference)(engine, obs);
            }
            const totalTime = Date.now() - startTime;
            const avgTime = totalTime / iterations;
            expect(avgTime).toBeLessThan(10); // Should be fast (< 10ms per inference)
        });
    });
    describe("Epistemic and Pragmatic Value", ()=>{
        it("calculates epistemic value (information gain)", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.5,
                    exploiting: 0.3,
                    resting: 0.2
                },
                uncertainty: 0.4
            };
            const action = "move_forward";
            const epistemicValue = (0, _activeinference.calculateEpistemic)(engine, beliefs, action);
            expect(epistemicValue).toBeGreaterThanOrEqual(0);
            expect(Number.isFinite(epistemicValue)).toBe(true);
        });
        it("calculates pragmatic value (goal achievement)", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.2,
                    exploiting: 0.7,
                    resting: 0.1
                },
                uncertainty: 0.2
            };
            const action = "move_forward";
            const pragmaticValue = (0, _activeinference.calculatePragmatic)(engine, beliefs, action);
            expect(Number.isFinite(pragmaticValue)).toBe(true);
        // Should be negative (lower is better) for good actions
        });
        it("trades off exploration vs exploitation", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.4,
                    exploiting: 0.4,
                    resting: 0.2
                },
                uncertainty: 0.5
            };
            const explore = (0, _activeinference.calculateEpistemic)(engine, beliefs, "turn");
            const exploit = (0, _activeinference.calculatePragmatic)(engine, beliefs, "wait");
            // Both values should influence decision
            expect(explore).toBeGreaterThan(0);
            expect(Math.abs(exploit)).toBeGreaterThan(0);
        });
    });
    describe("Variational Free Energy Minimization", ()=>{
        it("minimizes free energy through gradient descent", async ()=>{
            const initialBeliefs = {
                states: {
                    exploring: 0.6,
                    exploiting: 0.2,
                    resting: 0.2
                },
                uncertainty: 0.5
            };
            const observation = "high_reward";
            const initialFE = engine.calculateFreeEnergy(initialBeliefs, observation);
            const optimized = await (0, _activeinference.minimizeVariationalFreeEnergy)(engine, initialBeliefs, observation, {
                maxIterations: 50
            });
            const finalFE = engine.calculateFreeEnergy(optimized, observation);
            expect(finalFE).toBeLessThan(initialFE);
        });
        it("converges to stable solution", async ()=>{
            const beliefs = {
                states: {
                    exploring: 0.33,
                    exploiting: 0.33,
                    resting: 0.34
                },
                uncertainty: 0.3
            };
            const observation = "low_reward";
            const optimized = await (0, _activeinference.minimizeVariationalFreeEnergy)(engine, beliefs, observation, {
                maxIterations: 100,
                tolerance: 0.001
            });
            // Should converge to stable beliefs
            expect(optimized.converged).toBe(true);
            expect(optimized.iterations).toBeLessThan(100);
        });
    });
    describe("Predictive Processing", ()=>{
        it("predicts future sensory outcomes", ()=>{
            const currentBeliefs = {
                states: {
                    exploring: 0.7,
                    exploiting: 0.2,
                    resting: 0.1
                },
                uncertainty: 0.2
            };
            const action = "move_forward";
            const predictions = (0, _activeinference.predictSensoryOutcomes)(engine, currentBeliefs, action);
            expect(predictions).toHaveProperty("high_reward");
            expect(predictions).toHaveProperty("low_reward");
            expect(predictions).toHaveProperty("no_reward");
            const totalProb = Object.values(predictions).reduce((sum, p)=>sum + p, 0);
            expect(totalProb).toBeCloseTo(1.0, 5);
        });
        it("updates predictions based on actions", ()=>{
            const beliefs = {
                states: {
                    exploring: 0.1,
                    exploiting: 0.8,
                    resting: 0.1
                },
                uncertainty: 0.1
            };
            const movePredict = (0, _activeinference.predictSensoryOutcomes)(engine, beliefs, "move_forward");
            const waitPredict = (0, _activeinference.predictSensoryOutcomes)(engine, beliefs, "wait");
            // Different actions should lead to different predictions
            expect(movePredict.high_reward).not.toBe(waitPredict.high_reward);
        });
    });
    describe("Policy Evaluation", ()=>{
        it("evaluates action sequences", ()=>{
            const policy = [
                {
                    action: "move_forward",
                    timestep: 0
                },
                {
                    action: "move_forward",
                    timestep: 1
                },
                {
                    action: "turn",
                    timestep: 2
                }
            ];
            const evaluation = (0, _activeinference.evaluateActionPolicy)(engine, policy);
            expect(evaluation).toHaveProperty("expectedReturn");
            expect(evaluation).toHaveProperty("uncertainty");
            expect(evaluation).toHaveProperty("feasibility");
        });
        it("compares alternative policies", ()=>{
            const greedyPolicy = [
                {
                    action: "wait",
                    timestep: 0
                },
                {
                    action: "wait",
                    timestep: 1
                }
            ];
            const balancedPolicy = [
                {
                    action: "move_forward",
                    timestep: 0
                },
                {
                    action: "turn",
                    timestep: 1
                }
            ];
            const greedyEval = (0, _activeinference.evaluateActionPolicy)(engine, greedyPolicy);
            const balancedEval = (0, _activeinference.evaluateActionPolicy)(engine, balancedPolicy);
            // Policies should have different characteristics
            expect(greedyEval.uncertainty).not.toBe(balancedEval.uncertainty);
        });
    });
    describe("Integration Tests", ()=>{
        it("handles continuous operation", async ()=>{
            const session = {
                observations: 0,
                actions: [],
                beliefs: [],
                freeEnergies: []
            };
            // Simulate extended interaction
            for(let t = 0; t < 20; t++){
                const obs = {
                    type: "observation",
                    value: Math.random() > 0.5 ? "high_reward" : "low_reward",
                    confidence: 0.8 + Math.random() * 0.2
                };
                const result = await (0, _activeinference.performInference)(engine, obs);
                session.observations++;
                session.actions.push(result.selectedAction.type);
                session.beliefs.push(result.beliefs);
                session.freeEnergies.push(result.freeEnergy);
            }
            // Should show adaptive behavior
            const uniqueActions = new Set(session.actions).size;
            expect(uniqueActions).toBeGreaterThan(1);
            // Free energy should generally decrease
            const avgEarlyFE = session.freeEnergies.slice(0, 5).reduce((a, b)=>a + b) / 5;
            const avgLateFE = session.freeEnergies.slice(-5).reduce((a, b)=>a + b) / 5;
            expect(avgLateFE).toBeLessThanOrEqual(avgEarlyFE);
        });
        it("recovers from unexpected observations", async ()=>{
            // Set strong beliefs
            engine.setBeliefs({
                states: {
                    exploring: 0.05,
                    exploiting: 0.9,
                    resting: 0.05
                },
                uncertainty: 0.1
            });
            // Unexpected observation
            const surprise = {
                type: "observation",
                value: "no_reward",
                confidence: 0.95
            };
            const beforeFE = engine.calculateFreeEnergy(engine.getCurrentBeliefs(), "no_reward");
            const result = await (0, _activeinference.performInference)(engine, surprise);
            const afterFE = result.freeEnergy;
            // Should adapt beliefs to reduce surprise
            expect(result.beliefs.states.exploiting).toBeLessThan(0.9);
            expect(result.beliefs.uncertainty).toBeGreaterThan(0.1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2FjdGl2ZS1pbmZlcmVuY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFjdGl2ZSBJbmZlcmVuY2UgVGVzdHNcbiAqXG4gKiBUZXN0cyBmb3IgYWN0aXZlIGluZmVyZW5jZSwgZnJlZSBlbmVyZ3kgbWluaW1pemF0aW9uLCBhbmQgYmVsaWVmIHVwZGF0aW5nXG4gKiBmb2xsb3dpbmcgQURSLTAwNyBjb21wcmVoZW5zaXZlIHRlc3RpbmcgcmVxdWlyZW1lbnRzLlxuICovXG5cbmltcG9ydCB7XG4gIEFjdGl2ZUluZmVyZW5jZUVuZ2luZSxcbiAgY3JlYXRlQWN0aXZlSW5mZXJlbmNlRW5naW5lLFxuICBwZXJmb3JtSW5mZXJlbmNlLFxuICBzZWxlY3RBY3Rpb24sXG4gIHVwZGF0ZUJlbGllZnMsXG4gIGNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneSxcbiAgY2FsY3VsYXRlRXBpc3RlbWljLFxuICBjYWxjdWxhdGVQcmFnbWF0aWMsXG4gIG1pbmltaXplVmFyaWF0aW9uYWxGcmVlRW5lcmd5LFxuICBwcmVkaWN0U2Vuc29yeU91dGNvbWVzLFxuICBldmFsdWF0ZUFjdGlvblBvbGljeSxcbiAgR2VuZXJhdGl2ZU1vZGVsLFxuICBCZWxpZWZzLFxuICBTZW5zb3J5SW5wdXQsXG4gIEFjdGlvbixcbiAgUG9saWN5LFxufSBmcm9tIFwiQC9saWIvYWN0aXZlLWluZmVyZW5jZVwiO1xuXG5kZXNjcmliZShcIkFjdGl2ZSBJbmZlcmVuY2UgRW5naW5lXCIsICgpID0+IHtcbiAgbGV0IGVuZ2luZTogQWN0aXZlSW5mZXJlbmNlRW5naW5lO1xuICBsZXQgdGVzdE1vZGVsOiBHZW5lcmF0aXZlTW9kZWw7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgdGVzdE1vZGVsID0ge1xuICAgICAgc3RhdGVzOiBbXCJleHBsb3JpbmdcIiwgXCJleHBsb2l0aW5nXCIsIFwicmVzdGluZ1wiXSxcbiAgICAgIG9ic2VydmF0aW9uczogW1wiaGlnaF9yZXdhcmRcIiwgXCJsb3dfcmV3YXJkXCIsIFwibm9fcmV3YXJkXCJdLFxuICAgICAgYWN0aW9uczogW1wibW92ZV9mb3J3YXJkXCIsIFwidHVyblwiLCBcIndhaXRcIl0sXG5cbiAgICAgIC8vIFRyYW5zaXRpb24gZHluYW1pY3MgUChzJ3xzLGEpXG4gICAgICB0cmFuc2l0aW9uTW9kZWw6IHtcbiAgICAgICAgZXhwbG9yaW5nOiB7XG4gICAgICAgICAgbW92ZV9mb3J3YXJkOiB7IGV4cGxvcmluZzogMC43LCBleHBsb2l0aW5nOiAwLjIsIHJlc3Rpbmc6IDAuMSB9LFxuICAgICAgICAgIHR1cm46IHsgZXhwbG9yaW5nOiAwLjgsIGV4cGxvaXRpbmc6IDAuMSwgcmVzdGluZzogMC4xIH0sXG4gICAgICAgICAgd2FpdDogeyBleHBsb3Jpbmc6IDAuMywgZXhwbG9pdGluZzogMC4xLCByZXN0aW5nOiAwLjYgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXhwbG9pdGluZzoge1xuICAgICAgICAgIG1vdmVfZm9yd2FyZDogeyBleHBsb3Jpbmc6IDAuMSwgZXhwbG9pdGluZzogMC44LCByZXN0aW5nOiAwLjEgfSxcbiAgICAgICAgICB0dXJuOiB7IGV4cGxvcmluZzogMC4zLCBleHBsb2l0aW5nOiAwLjYsIHJlc3Rpbmc6IDAuMSB9LFxuICAgICAgICAgIHdhaXQ6IHsgZXhwbG9yaW5nOiAwLjEsIGV4cGxvaXRpbmc6IDAuMywgcmVzdGluZzogMC42IH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICBtb3ZlX2ZvcndhcmQ6IHsgZXhwbG9yaW5nOiAwLjYsIGV4cGxvaXRpbmc6IDAuMywgcmVzdGluZzogMC4xIH0sXG4gICAgICAgICAgdHVybjogeyBleHBsb3Jpbmc6IDAuNCwgZXhwbG9pdGluZzogMC4yLCByZXN0aW5nOiAwLjQgfSxcbiAgICAgICAgICB3YWl0OiB7IGV4cGxvcmluZzogMC4xLCBleHBsb2l0aW5nOiAwLjEsIHJlc3Rpbmc6IDAuOCB9LFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgLy8gT2JzZXJ2YXRpb24gbW9kZWwgUChvfHMpXG4gICAgICBvYnNlcnZhdGlvbk1vZGVsOiB7XG4gICAgICAgIGV4cGxvcmluZzogeyBoaWdoX3Jld2FyZDogMC4zLCBsb3dfcmV3YXJkOiAwLjUsIG5vX3Jld2FyZDogMC4yIH0sXG4gICAgICAgIGV4cGxvaXRpbmc6IHsgaGlnaF9yZXdhcmQ6IDAuNywgbG93X3Jld2FyZDogMC4yLCBub19yZXdhcmQ6IDAuMSB9LFxuICAgICAgICByZXN0aW5nOiB7IGhpZ2hfcmV3YXJkOiAwLjEsIGxvd19yZXdhcmQ6IDAuMiwgbm9fcmV3YXJkOiAwLjcgfSxcbiAgICAgIH0sXG5cbiAgICAgIC8vIFByaW9yIHByZWZlcmVuY2VzIChuZWdhdGl2ZSBsb2cgcHJvYmFiaWxpdGllcylcbiAgICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGhpZ2hfcmV3YXJkOiAtMi4wLCAvLyBTdHJvbmdseSBwcmVmZXJyZWRcbiAgICAgICAgbG93X3Jld2FyZDogLTAuNSwgLy8gTWlsZGx5IHByZWZlcnJlZFxuICAgICAgICBub19yZXdhcmQ6IDAuNSwgLy8gU2xpZ2h0bHkgZGlzcHJlZmVycmVkXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBlbmdpbmUgPSBjcmVhdGVBY3RpdmVJbmZlcmVuY2VFbmdpbmUoe1xuICAgICAgbW9kZWw6IHRlc3RNb2RlbCxcbiAgICAgIHByZWNpc2lvbjogMS4wLFxuICAgICAgbGVhcm5pbmdSYXRlOiAwLjEsXG4gICAgICBwbGFubmluZ0hvcml6b246IDMsXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRW5naW5lIENyZWF0aW9uIGFuZCBDb25maWd1cmF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcImNyZWF0ZXMgZW5naW5lIHdpdGggdmFsaWQgY29uZmlndXJhdGlvblwiLCAoKSA9PiB7XG4gICAgICBleHBlY3QoZW5naW5lKS50b01hdGNoT2JqZWN0KHtcbiAgICAgICAgbW9kZWw6IHRlc3RNb2RlbCxcbiAgICAgICAgcHJlY2lzaW9uOiAxLjAsXG4gICAgICAgIGxlYXJuaW5nUmF0ZTogMC4xLFxuICAgICAgICBwbGFubmluZ0hvcml6b246IDMsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwiaW5pdGlhbGl6ZXMgd2l0aCB1bmlmb3JtIGJlbGllZnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYmVsaWVmcyA9IGVuZ2luZS5nZXRDdXJyZW50QmVsaWVmcygpO1xuICAgICAgY29uc3Qgc3RhdGVQcm9icyA9IE9iamVjdC52YWx1ZXMoYmVsaWVmcy5zdGF0ZXMpO1xuXG4gICAgICBleHBlY3QoXG4gICAgICAgIE1hdGguYWJzKHN0YXRlUHJvYnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAsIDApIC0gMS4wKSxcbiAgICAgICkudG9CZUxlc3NUaGFuKDAuMDAxKTtcbiAgICAgIHN0YXRlUHJvYnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBleHBlY3QocCkudG9CZUNsb3NlVG8oMS4wIC8gdGVzdE1vZGVsLnN0YXRlcy5sZW5ndGgsIDUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInZhbGlkYXRlcyBtb2RlbCBzdHJ1Y3R1cmVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZE1vZGVsID0ge1xuICAgICAgICAuLi50ZXN0TW9kZWwsXG4gICAgICAgIHRyYW5zaXRpb25Nb2RlbDoge30sIC8vIEludmFsaWQ6IGVtcHR5IHRyYW5zaXRpb25zXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBjcmVhdGVBY3RpdmVJbmZlcmVuY2VFbmdpbmUoeyBtb2RlbDogaW52YWxpZE1vZGVsIH0pO1xuICAgICAgfSkudG9UaHJvdyhcIkludmFsaWQgZ2VuZXJhdGl2ZSBtb2RlbFwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJCZWxpZWYgVXBkYXRlc1wiLCAoKSA9PiB7XG4gICAgaXQoXCJ1cGRhdGVzIGJlbGllZnMgYmFzZWQgb24gb2JzZXJ2YXRpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxCZWxpZWZzID0gZW5naW5lLmdldEN1cnJlbnRCZWxpZWZzKCk7XG4gICAgICBjb25zdCBvYnNlcnZhdGlvbjogU2Vuc29yeUlucHV0ID0ge1xuICAgICAgICB0eXBlOiBcIm9ic2VydmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBcImhpZ2hfcmV3YXJkXCIsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRCZWxpZWZzID0gdXBkYXRlQmVsaWVmcyhlbmdpbmUsIG9ic2VydmF0aW9uKTtcblxuICAgICAgLy8gU2hvdWxkIGluY3JlYXNlIGJlbGllZiBpbiBleHBsb2l0aW5nIHN0YXRlIChoaWdoIHJld2FyZCBhc3NvY2lhdGlvbilcbiAgICAgIGV4cGVjdCh1cGRhdGVkQmVsaWVmcy5zdGF0ZXMuZXhwbG9pdGluZykudG9CZUdyZWF0ZXJUaGFuKFxuICAgICAgICBpbml0aWFsQmVsaWVmcy5zdGF0ZXMuZXhwbG9pdGluZyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcImluY29ycG9yYXRlcyBvYnNlcnZhdGlvbiBjb25maWRlbmNlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGhpZ2hDb25mT2JzOiBTZW5zb3J5SW5wdXQgPSB7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2YXRpb25cIixcbiAgICAgICAgdmFsdWU6IFwiaGlnaF9yZXdhcmRcIixcbiAgICAgICAgY29uZmlkZW5jZTogMC45NSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGxvd0NvbmZPYnM6IFNlbnNvcnlJbnB1dCA9IHtcbiAgICAgICAgdHlwZTogXCJvYnNlcnZhdGlvblwiLFxuICAgICAgICB2YWx1ZTogXCJoaWdoX3Jld2FyZFwiLFxuICAgICAgICBjb25maWRlbmNlOiAwLjMsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBoaWdoQ29uZkJlbGllZnMgPSB1cGRhdGVCZWxpZWZzKGVuZ2luZSwgaGlnaENvbmZPYnMpO1xuICAgICAgY29uc3QgbG93Q29uZkJlbGllZnMgPSB1cGRhdGVCZWxpZWZzKGVuZ2luZSwgbG93Q29uZk9icyk7XG5cbiAgICAgIC8vIEhpZ2ggY29uZmlkZW5jZSBzaG91bGQgbGVhZCB0byBzdHJvbmdlciBiZWxpZWYgdXBkYXRlc1xuICAgICAgY29uc3QgaGlnaENvbmZDaGFuZ2UgPSBNYXRoLmFicyhcbiAgICAgICAgaGlnaENvbmZCZWxpZWZzLnN0YXRlcy5leHBsb2l0aW5nIC0gMSAvIDMsXG4gICAgICApO1xuICAgICAgY29uc3QgbG93Q29uZkNoYW5nZSA9IE1hdGguYWJzKGxvd0NvbmZCZWxpZWZzLnN0YXRlcy5leHBsb2l0aW5nIC0gMSAvIDMpO1xuXG4gICAgICBleHBlY3QoaGlnaENvbmZDaGFuZ2UpLnRvQmVHcmVhdGVyVGhhbihsb3dDb25mQ2hhbmdlKTtcbiAgICB9KTtcblxuICAgIGl0KFwibWFpbnRhaW5zIHByb2JhYmlsaXR5IG5vcm1hbGl6YXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb2JzZXJ2YXRpb25zID0gW1xuICAgICAgICB7IHR5cGU6IFwib2JzZXJ2YXRpb25cIiwgdmFsdWU6IFwiaGlnaF9yZXdhcmRcIiwgY29uZmlkZW5jZTogMC44IH0sXG4gICAgICAgIHsgdHlwZTogXCJvYnNlcnZhdGlvblwiLCB2YWx1ZTogXCJsb3dfcmV3YXJkXCIsIGNvbmZpZGVuY2U6IDAuNyB9LFxuICAgICAgICB7IHR5cGU6IFwib2JzZXJ2YXRpb25cIiwgdmFsdWU6IFwibm9fcmV3YXJkXCIsIGNvbmZpZGVuY2U6IDAuOSB9LFxuICAgICAgXTtcblxuICAgICAgb2JzZXJ2YXRpb25zLmZvckVhY2goKG9icykgPT4ge1xuICAgICAgICBjb25zdCBiZWxpZWZzID0gdXBkYXRlQmVsaWVmcyhlbmdpbmUsIG9icyBhcyBTZW5zb3J5SW5wdXQpO1xuICAgICAgICBjb25zdCBzdW0gPSBPYmplY3QudmFsdWVzKGJlbGllZnMuc3RhdGVzKS5yZWR1Y2UoKHMsIHApID0+IHMgKyBwLCAwKTtcbiAgICAgICAgZXhwZWN0KHN1bSkudG9CZUNsb3NlVG8oMS4wLCA1KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkZyZWUgRW5lcmd5IENhbGN1bGF0aW9uc1wiLCAoKSA9PiB7XG4gICAgaXQoXCJjYWxjdWxhdGVzIHZhcmlhdGlvbmFsIGZyZWUgZW5lcmd5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuNiwgZXhwbG9pdGluZzogMC4zLCByZXN0aW5nOiAwLjEgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuMixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9ic2VydmF0aW9uID0gXCJoaWdoX3Jld2FyZFwiO1xuICAgICAgY29uc3QgZnJlZUVuZXJneSA9IGVuZ2luZS5jYWxjdWxhdGVGcmVlRW5lcmd5KGJlbGllZnMsIG9ic2VydmF0aW9uKTtcblxuICAgICAgZXhwZWN0KGZyZWVFbmVyZ3kpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUoZnJlZUVuZXJneSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcImluY3JlYXNlcyB3aXRoIHByZWRpY3Rpb24gZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgLy8gQmVsaWVmIHN0YXRlIHRoYXQgcHJlZGljdHMgbG93IHJld2FyZHNcbiAgICAgIGNvbnN0IHBlc3NpbWlzdGljQmVsaWVmczogQmVsaWVmcyA9IHtcbiAgICAgICAgc3RhdGVzOiB7IGV4cGxvcmluZzogMC4xLCBleHBsb2l0aW5nOiAwLjEsIHJlc3Rpbmc6IDAuOCB9LFxuICAgICAgICB1bmNlcnRhaW50eTogMC4xLFxuICAgICAgfTtcblxuICAgICAgLy8gQnV0IG9ic2VydmVzIGhpZ2ggcmV3YXJkXG4gICAgICBjb25zdCBvYnNlcnZhdGlvbiA9IFwiaGlnaF9yZXdhcmRcIjtcblxuICAgICAgY29uc3QgaGlnaEVycm9yID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koXG4gICAgICAgIHBlc3NpbWlzdGljQmVsaWVmcyxcbiAgICAgICAgb2JzZXJ2YXRpb24sXG4gICAgICApO1xuXG4gICAgICAvLyBCZWxpZWYgc3RhdGUgdGhhdCBwcmVkaWN0cyBoaWdoIHJld2FyZHNcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNCZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjEsIGV4cGxvaXRpbmc6IDAuOCwgcmVzdGluZzogMC4xIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjEsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBsb3dFcnJvciA9IGVuZ2luZS5jYWxjdWxhdGVGcmVlRW5lcmd5KFxuICAgICAgICBvcHRpbWlzdGljQmVsaWVmcyxcbiAgICAgICAgb2JzZXJ2YXRpb24sXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoaGlnaEVycm9yKS50b0JlR3JlYXRlclRoYW4obG93RXJyb3IpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJpbmNsdWRlcyBlbnRyb3B5L3VuY2VydGFpbnR5IHRlcm1cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgY2VydGFpbkJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuOTgsIGV4cGxvaXRpbmc6IDAuMDEsIHJlc3Rpbmc6IDAuMDEgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuMDEsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1bmNlcnRhaW5CZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjM0LCBleHBsb2l0aW5nOiAwLjMzLCByZXN0aW5nOiAwLjMzIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjgsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvYnNlcnZhdGlvbiA9IFwibG93X3Jld2FyZFwiO1xuICAgICAgY29uc3QgY2VydGFpbkZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koY2VydGFpbkJlbGllZnMsIG9ic2VydmF0aW9uKTtcbiAgICAgIGNvbnN0IHVuY2VydGFpbkZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koXG4gICAgICAgIHVuY2VydGFpbkJlbGllZnMsXG4gICAgICAgIG9ic2VydmF0aW9uLFxuICAgICAgKTtcblxuICAgICAgLy8gSGlnaGVyIHVuY2VydGFpbnR5IHNob3VsZCBjb250cmlidXRlIHRvIGZyZWUgZW5lcmd5XG4gICAgICBleHBlY3QoTWF0aC5hYnMoY2VydGFpbkZFIC0gdW5jZXJ0YWluRkUpKS50b0JlR3JlYXRlclRoYW4oMC4xKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFeHBlY3RlZCBGcmVlIEVuZXJneVwiLCAoKSA9PiB7XG4gICAgaXQoXCJjYWxjdWxhdGVzIGV4cGVjdGVkIGZyZWUgZW5lcmd5IGZvciBwb2xpY2llc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBwb2xpY3k6IFBvbGljeSA9IFtcbiAgICAgICAgeyBhY3Rpb246IFwibW92ZV9mb3J3YXJkXCIsIHRpbWVzdGVwOiAwIH0sXG4gICAgICAgIHsgYWN0aW9uOiBcInR1cm5cIiwgdGltZXN0ZXA6IDEgfSxcbiAgICAgICAgeyBhY3Rpb246IFwid2FpdFwiLCB0aW1lc3RlcDogMiB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgZWZlID0gY2FsY3VsYXRlRXhwZWN0ZWRGcmVlRW5lcmd5KGVuZ2luZSwgcG9saWN5KTtcblxuICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShlZmUudG90YWwpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShlZmUuZXBpc3RlbWljKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUoZWZlLnByYWdtYXRpYykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZWZlKS50b0hhdmVQcm9wZXJ0eShcInRvdGFsXCIpO1xuICAgICAgZXhwZWN0KGVmZSkudG9IYXZlUHJvcGVydHkoXCJlcGlzdGVtaWNcIik7XG4gICAgICBleHBlY3QoZWZlKS50b0hhdmVQcm9wZXJ0eShcInByYWdtYXRpY1wiKTtcbiAgICB9KTtcblxuICAgIGl0KFwiYmFsYW5jZXMgZXBpc3RlbWljIGFuZCBwcmFnbWF0aWMgdmFsdWVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwbG9yYXRvcnlQb2xpY3k6IFBvbGljeSA9IFtcbiAgICAgICAgeyBhY3Rpb246IFwidHVyblwiLCB0aW1lc3RlcDogMCB9LFxuICAgICAgICB7IGFjdGlvbjogXCJtb3ZlX2ZvcndhcmRcIiwgdGltZXN0ZXA6IDEgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV4cGxvaXRhdGl2ZVBvbGljeTogUG9saWN5ID0gW1xuICAgICAgICB7IGFjdGlvbjogXCJ3YWl0XCIsIHRpbWVzdGVwOiAwIH0sXG4gICAgICAgIHsgYWN0aW9uOiBcIndhaXRcIiwgdGltZXN0ZXA6IDEgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV4cGxvcmF0b3J5ID0gY2FsY3VsYXRlRXhwZWN0ZWRGcmVlRW5lcmd5KFxuICAgICAgICBlbmdpbmUsXG4gICAgICAgIGV4cGxvcmF0b3J5UG9saWN5LFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGV4cGxvaXRhdGl2ZSA9IGNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneShcbiAgICAgICAgZW5naW5lLFxuICAgICAgICBleHBsb2l0YXRpdmVQb2xpY3ksXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoZXhwbG9yYXRvcnkuZXBpc3RlbWljKS50b0JlTGVzc1RoYW4oZXhwbG9pdGF0aXZlLmVwaXN0ZW1pYyk7XG4gICAgfSk7XG5cbiAgICBpdChcImNvbnNpZGVycyBmdXR1cmUgb3V0Y29tZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2hvcnRQb2xpY3k6IFBvbGljeSA9IFt7IGFjdGlvbjogXCJtb3ZlX2ZvcndhcmRcIiwgdGltZXN0ZXA6IDAgfV07XG5cbiAgICAgIGNvbnN0IGxvbmdQb2xpY3k6IFBvbGljeSA9IFtcbiAgICAgICAgeyBhY3Rpb246IFwibW92ZV9mb3J3YXJkXCIsIHRpbWVzdGVwOiAwIH0sXG4gICAgICAgIHsgYWN0aW9uOiBcIm1vdmVfZm9yd2FyZFwiLCB0aW1lc3RlcDogMSB9LFxuICAgICAgICB7IGFjdGlvbjogXCJtb3ZlX2ZvcndhcmRcIiwgdGltZXN0ZXA6IDIgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHNob3J0RUZFID0gY2FsY3VsYXRlRXhwZWN0ZWRGcmVlRW5lcmd5KGVuZ2luZSwgc2hvcnRQb2xpY3kpO1xuICAgICAgY29uc3QgbG9uZ0VGRSA9IGNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneShlbmdpbmUsIGxvbmdQb2xpY3kpO1xuXG4gICAgICAvLyBMb25nZXIgaG9yaXpvbiBzaG91bGQgYWZmZWN0IHRvdGFsIGV4cGVjdGVkIGZyZWUgZW5lcmd5XG4gICAgICBleHBlY3Qoc2hvcnRFRkUudG90YWwpLm5vdC50b0JlKGxvbmdFRkUudG90YWwpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkFjdGlvbiBTZWxlY3Rpb25cIiwgKCkgPT4ge1xuICAgIGl0KFwic2VsZWN0cyBhY3Rpb25zIHRoYXQgbWluaW1pemUgZXhwZWN0ZWQgZnJlZSBlbmVyZ3lcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudEJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuNywgZXhwbG9pdGluZzogMC4yLCByZXN0aW5nOiAwLjEgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuMyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNlbGVjdGVkQWN0aW9uID0gc2VsZWN0QWN0aW9uKGVuZ2luZSwgY3VycmVudEJlbGllZnMpO1xuXG4gICAgICBleHBlY3QodGVzdE1vZGVsLmFjdGlvbnMpLnRvQ29udGFpbihzZWxlY3RlZEFjdGlvbi50eXBlKTtcbiAgICAgIGV4cGVjdChzZWxlY3RlZEFjdGlvbi5jb25maWRlbmNlKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3Qoc2VsZWN0ZWRBY3Rpb24uY29uZmlkZW5jZSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICB9KTtcblxuICAgIGl0KFwiaW5jcmVhc2VzIGV4cGxvcmF0aW9uIHVuZGVyIGhpZ2ggdW5jZXJ0YWludHlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG93VW5jZXJ0YWludHk6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuMSwgZXhwbG9pdGluZzogMC44LCByZXN0aW5nOiAwLjEgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuMSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGhpZ2hVbmNlcnRhaW50eTogQmVsaWVmcyA9IHtcbiAgICAgICAgc3RhdGVzOiB7IGV4cGxvcmluZzogMC4xLCBleHBsb2l0aW5nOiAwLjgsIHJlc3Rpbmc6IDAuMSB9LFxuICAgICAgICB1bmNlcnRhaW50eTogMC44LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbG93VW5jQWN0aW9uID0gc2VsZWN0QWN0aW9uKGVuZ2luZSwgbG93VW5jZXJ0YWludHkpO1xuICAgICAgY29uc3QgaGlnaFVuY0FjdGlvbiA9IHNlbGVjdEFjdGlvbihlbmdpbmUsIGhpZ2hVbmNlcnRhaW50eSk7XG5cbiAgICAgIC8vIEhpZ2ggdW5jZXJ0YWludHkgc2hvdWxkIGZhdm9yIGV4cGxvcmF0b3J5IGFjdGlvbnNcbiAgICAgIGV4cGVjdChoaWdoVW5jQWN0aW9uLnR5cGUpLm5vdC50b0JlKFwid2FpdFwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwicmVzcGVjdHMgYWN0aW9uIGNvbnN0cmFpbnRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbmVkRW5naW5lID0gY3JlYXRlQWN0aXZlSW5mZXJlbmNlRW5naW5lKHtcbiAgICAgICAgbW9kZWw6IHRlc3RNb2RlbCxcbiAgICAgICAgYWN0aW9uQ29uc3RyYWludHM6IHtcbiAgICAgICAgICB3YWl0OiB7IG1heEZyZXF1ZW5jeTogMC4zIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBzZWxlY3RBY3Rpb24oXG4gICAgICAgICAgY29uc3RyYWluZWRFbmdpbmUsXG4gICAgICAgICAgZW5naW5lLmdldEN1cnJlbnRCZWxpZWZzKCksXG4gICAgICAgICk7XG4gICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24udHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdhaXRGcmVxdWVuY3kgPVxuICAgICAgICBhY3Rpb25zLmZpbHRlcigoYSkgPT4gYSA9PT0gXCJ3YWl0XCIpLmxlbmd0aCAvIGFjdGlvbnMubGVuZ3RoO1xuICAgICAgZXhwZWN0KHdhaXRGcmVxdWVuY3kpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMC4zNSk7IC8vIEFsbG93IHNtYWxsIHZhcmlhbmNlXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiSW5mZXJlbmNlIFByb2Nlc3NcIiwgKCkgPT4ge1xuICAgIGl0KFwicGVyZm9ybXMgY29tcGxldGUgaW5mZXJlbmNlIGN5Y2xlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9ic2VydmF0aW9uOiBTZW5zb3J5SW5wdXQgPSB7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2YXRpb25cIixcbiAgICAgICAgdmFsdWU6IFwiaGlnaF9yZXdhcmRcIixcbiAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGVyZm9ybUluZmVyZW5jZShlbmdpbmUsIG9ic2VydmF0aW9uKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlUHJvcGVydHkoXCJiZWxpZWZzXCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlUHJvcGVydHkoXCJzZWxlY3RlZEFjdGlvblwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KFwiZnJlZUVuZXJneVwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KFwiY29uZmlkZW5jZVwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwiYWRhcHRzIHRvIGNoYW5naW5nIG9ic2VydmF0aW9uc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZhdGlvbnMgPSBbXG4gICAgICAgIHsgdHlwZTogXCJvYnNlcnZhdGlvblwiLCB2YWx1ZTogXCJub19yZXdhcmRcIiwgY29uZmlkZW5jZTogMC45IH0sXG4gICAgICAgIHsgdHlwZTogXCJvYnNlcnZhdGlvblwiLCB2YWx1ZTogXCJsb3dfcmV3YXJkXCIsIGNvbmZpZGVuY2U6IDAuOCB9LFxuICAgICAgICB7IHR5cGU6IFwib2JzZXJ2YXRpb25cIiwgdmFsdWU6IFwiaGlnaF9yZXdhcmRcIiwgY29uZmlkZW5jZTogMC45NSB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBvYnMgb2Ygb2JzZXJ2YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBlcmZvcm1JbmZlcmVuY2UoZW5naW5lLCBvYnMgYXMgU2Vuc29yeUlucHV0KTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3VsZCBhZGFwdCBiZWhhdmlvciBiYXNlZCBvbiBvYnNlcnZhdGlvbiBoaXN0b3J5XG4gICAgICBleHBlY3QocmVzdWx0c1swXS5zZWxlY3RlZEFjdGlvbi50eXBlKS5ub3QudG9CZShcbiAgICAgICAgcmVzdWx0c1syXS5zZWxlY3RlZEFjdGlvbi50eXBlLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KFwibWFpbnRhaW5zIGNvbXB1dGF0aW9uYWwgZWZmaWNpZW5jeVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IDEwMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2JzOiBTZW5zb3J5SW5wdXQgPSB7XG4gICAgICAgICAgdHlwZTogXCJvYnNlcnZhdGlvblwiLFxuICAgICAgICAgIHZhbHVlOiBbXCJoaWdoX3Jld2FyZFwiLCBcImxvd19yZXdhcmRcIiwgXCJub19yZXdhcmRcIl1baSAlIDNdLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgcGVyZm9ybUluZmVyZW5jZShlbmdpbmUsIG9icyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zdCBhdmdUaW1lID0gdG90YWxUaW1lIC8gaXRlcmF0aW9ucztcblxuICAgICAgZXhwZWN0KGF2Z1RpbWUpLnRvQmVMZXNzVGhhbigxMCk7IC8vIFNob3VsZCBiZSBmYXN0ICg8IDEwbXMgcGVyIGluZmVyZW5jZSlcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFcGlzdGVtaWMgYW5kIFByYWdtYXRpYyBWYWx1ZVwiLCAoKSA9PiB7XG4gICAgaXQoXCJjYWxjdWxhdGVzIGVwaXN0ZW1pYyB2YWx1ZSAoaW5mb3JtYXRpb24gZ2FpbilcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYmVsaWVmczogQmVsaWVmcyA9IHtcbiAgICAgICAgc3RhdGVzOiB7IGV4cGxvcmluZzogMC41LCBleHBsb2l0aW5nOiAwLjMsIHJlc3Rpbmc6IDAuMiB9LFxuICAgICAgICB1bmNlcnRhaW50eTogMC40LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYWN0aW9uID0gXCJtb3ZlX2ZvcndhcmRcIjtcbiAgICAgIGNvbnN0IGVwaXN0ZW1pY1ZhbHVlID0gY2FsY3VsYXRlRXBpc3RlbWljKGVuZ2luZSwgYmVsaWVmcywgYWN0aW9uKTtcblxuICAgICAgZXhwZWN0KGVwaXN0ZW1pY1ZhbHVlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShlcGlzdGVtaWNWYWx1ZSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcImNhbGN1bGF0ZXMgcHJhZ21hdGljIHZhbHVlIChnb2FsIGFjaGlldmVtZW50KVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBiZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjIsIGV4cGxvaXRpbmc6IDAuNywgcmVzdGluZzogMC4xIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjIsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBhY3Rpb24gPSBcIm1vdmVfZm9yd2FyZFwiO1xuICAgICAgY29uc3QgcHJhZ21hdGljVmFsdWUgPSBjYWxjdWxhdGVQcmFnbWF0aWMoZW5naW5lLCBiZWxpZWZzLCBhY3Rpb24pO1xuXG4gICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHByYWdtYXRpY1ZhbHVlKSkudG9CZSh0cnVlKTtcbiAgICAgIC8vIFNob3VsZCBiZSBuZWdhdGl2ZSAobG93ZXIgaXMgYmV0dGVyKSBmb3IgZ29vZCBhY3Rpb25zXG4gICAgfSk7XG5cbiAgICBpdChcInRyYWRlcyBvZmYgZXhwbG9yYXRpb24gdnMgZXhwbG9pdGF0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuNCwgZXhwbG9pdGluZzogMC40LCByZXN0aW5nOiAwLjIgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuNSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGV4cGxvcmUgPSBjYWxjdWxhdGVFcGlzdGVtaWMoZW5naW5lLCBiZWxpZWZzLCBcInR1cm5cIik7XG4gICAgICBjb25zdCBleHBsb2l0ID0gY2FsY3VsYXRlUHJhZ21hdGljKGVuZ2luZSwgYmVsaWVmcywgXCJ3YWl0XCIpO1xuXG4gICAgICAvLyBCb3RoIHZhbHVlcyBzaG91bGQgaW5mbHVlbmNlIGRlY2lzaW9uXG4gICAgICBleHBlY3QoZXhwbG9yZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KE1hdGguYWJzKGV4cGxvaXQpKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiVmFyaWF0aW9uYWwgRnJlZSBFbmVyZ3kgTWluaW1pemF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcIm1pbmltaXplcyBmcmVlIGVuZXJneSB0aHJvdWdoIGdyYWRpZW50IGRlc2NlbnRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbEJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuNiwgZXhwbG9pdGluZzogMC4yLCByZXN0aW5nOiAwLjIgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuNSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9ic2VydmF0aW9uID0gXCJoaWdoX3Jld2FyZFwiO1xuICAgICAgY29uc3QgaW5pdGlhbEZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koaW5pdGlhbEJlbGllZnMsIG9ic2VydmF0aW9uKTtcblxuICAgICAgY29uc3Qgb3B0aW1pemVkID0gYXdhaXQgbWluaW1pemVWYXJpYXRpb25hbEZyZWVFbmVyZ3koXG4gICAgICAgIGVuZ2luZSxcbiAgICAgICAgaW5pdGlhbEJlbGllZnMsXG4gICAgICAgIG9ic2VydmF0aW9uLFxuICAgICAgICB7IG1heEl0ZXJhdGlvbnM6IDUwIH0sXG4gICAgICApO1xuXG4gICAgICBjb25zdCBmaW5hbEZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3kob3B0aW1pemVkLCBvYnNlcnZhdGlvbik7XG5cbiAgICAgIGV4cGVjdChmaW5hbEZFKS50b0JlTGVzc1RoYW4oaW5pdGlhbEZFKTtcbiAgICB9KTtcblxuICAgIGl0KFwiY29udmVyZ2VzIHRvIHN0YWJsZSBzb2x1dGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBiZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjMzLCBleHBsb2l0aW5nOiAwLjMzLCByZXN0aW5nOiAwLjM0IH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjMsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvYnNlcnZhdGlvbiA9IFwibG93X3Jld2FyZFwiO1xuICAgICAgY29uc3Qgb3B0aW1pemVkID0gYXdhaXQgbWluaW1pemVWYXJpYXRpb25hbEZyZWVFbmVyZ3koXG4gICAgICAgIGVuZ2luZSxcbiAgICAgICAgYmVsaWVmcyxcbiAgICAgICAgb2JzZXJ2YXRpb24sXG4gICAgICAgIHsgbWF4SXRlcmF0aW9uczogMTAwLCB0b2xlcmFuY2U6IDAuMDAxIH0sXG4gICAgICApO1xuXG4gICAgICAvLyBTaG91bGQgY29udmVyZ2UgdG8gc3RhYmxlIGJlbGllZnNcbiAgICAgIGV4cGVjdChvcHRpbWl6ZWQuY29udmVyZ2VkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG9wdGltaXplZC5pdGVyYXRpb25zKS50b0JlTGVzc1RoYW4oMTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJQcmVkaWN0aXZlIFByb2Nlc3NpbmdcIiwgKCkgPT4ge1xuICAgIGl0KFwicHJlZGljdHMgZnV0dXJlIHNlbnNvcnkgb3V0Y29tZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudEJlbGllZnM6IEJlbGllZnMgPSB7XG4gICAgICAgIHN0YXRlczogeyBleHBsb3Jpbmc6IDAuNywgZXhwbG9pdGluZzogMC4yLCByZXN0aW5nOiAwLjEgfSxcbiAgICAgICAgdW5jZXJ0YWludHk6IDAuMixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGFjdGlvbiA9IFwibW92ZV9mb3J3YXJkXCI7XG4gICAgICBjb25zdCBwcmVkaWN0aW9ucyA9IHByZWRpY3RTZW5zb3J5T3V0Y29tZXMoXG4gICAgICAgIGVuZ2luZSxcbiAgICAgICAgY3VycmVudEJlbGllZnMsXG4gICAgICAgIGFjdGlvbixcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChwcmVkaWN0aW9ucykudG9IYXZlUHJvcGVydHkoXCJoaWdoX3Jld2FyZFwiKTtcbiAgICAgIGV4cGVjdChwcmVkaWN0aW9ucykudG9IYXZlUHJvcGVydHkoXCJsb3dfcmV3YXJkXCIpO1xuICAgICAgZXhwZWN0KHByZWRpY3Rpb25zKS50b0hhdmVQcm9wZXJ0eShcIm5vX3Jld2FyZFwiKTtcblxuICAgICAgY29uc3QgdG90YWxQcm9iID0gT2JqZWN0LnZhbHVlcyhwcmVkaWN0aW9ucykucmVkdWNlKFxuICAgICAgICAoc3VtLCBwKSA9PiBzdW0gKyBwLFxuICAgICAgICAwLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdCh0b3RhbFByb2IpLnRvQmVDbG9zZVRvKDEuMCwgNSk7XG4gICAgfSk7XG5cbiAgICBpdChcInVwZGF0ZXMgcHJlZGljdGlvbnMgYmFzZWQgb24gYWN0aW9uc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBiZWxpZWZzOiBCZWxpZWZzID0ge1xuICAgICAgICBzdGF0ZXM6IHsgZXhwbG9yaW5nOiAwLjEsIGV4cGxvaXRpbmc6IDAuOCwgcmVzdGluZzogMC4xIH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjEsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb3ZlUHJlZGljdCA9IHByZWRpY3RTZW5zb3J5T3V0Y29tZXMoXG4gICAgICAgIGVuZ2luZSxcbiAgICAgICAgYmVsaWVmcyxcbiAgICAgICAgXCJtb3ZlX2ZvcndhcmRcIixcbiAgICAgICk7XG4gICAgICBjb25zdCB3YWl0UHJlZGljdCA9IHByZWRpY3RTZW5zb3J5T3V0Y29tZXMoZW5naW5lLCBiZWxpZWZzLCBcIndhaXRcIik7XG5cbiAgICAgIC8vIERpZmZlcmVudCBhY3Rpb25zIHNob3VsZCBsZWFkIHRvIGRpZmZlcmVudCBwcmVkaWN0aW9uc1xuICAgICAgZXhwZWN0KG1vdmVQcmVkaWN0LmhpZ2hfcmV3YXJkKS5ub3QudG9CZSh3YWl0UHJlZGljdC5oaWdoX3Jld2FyZCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiUG9saWN5IEV2YWx1YXRpb25cIiwgKCkgPT4ge1xuICAgIGl0KFwiZXZhbHVhdGVzIGFjdGlvbiBzZXF1ZW5jZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcG9saWN5OiBQb2xpY3kgPSBbXG4gICAgICAgIHsgYWN0aW9uOiBcIm1vdmVfZm9yd2FyZFwiLCB0aW1lc3RlcDogMCB9LFxuICAgICAgICB7IGFjdGlvbjogXCJtb3ZlX2ZvcndhcmRcIiwgdGltZXN0ZXA6IDEgfSxcbiAgICAgICAgeyBhY3Rpb246IFwidHVyblwiLCB0aW1lc3RlcDogMiB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgZXZhbHVhdGlvbiA9IGV2YWx1YXRlQWN0aW9uUG9saWN5KGVuZ2luZSwgcG9saWN5KTtcblxuICAgICAgZXhwZWN0KGV2YWx1YXRpb24pLnRvSGF2ZVByb3BlcnR5KFwiZXhwZWN0ZWRSZXR1cm5cIik7XG4gICAgICBleHBlY3QoZXZhbHVhdGlvbikudG9IYXZlUHJvcGVydHkoXCJ1bmNlcnRhaW50eVwiKTtcbiAgICAgIGV4cGVjdChldmFsdWF0aW9uKS50b0hhdmVQcm9wZXJ0eShcImZlYXNpYmlsaXR5XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJjb21wYXJlcyBhbHRlcm5hdGl2ZSBwb2xpY2llc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBncmVlZHlQb2xpY3k6IFBvbGljeSA9IFtcbiAgICAgICAgeyBhY3Rpb246IFwid2FpdFwiLCB0aW1lc3RlcDogMCB9LFxuICAgICAgICB7IGFjdGlvbjogXCJ3YWl0XCIsIHRpbWVzdGVwOiAxIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBiYWxhbmNlZFBvbGljeTogUG9saWN5ID0gW1xuICAgICAgICB7IGFjdGlvbjogXCJtb3ZlX2ZvcndhcmRcIiwgdGltZXN0ZXA6IDAgfSxcbiAgICAgICAgeyBhY3Rpb246IFwidHVyblwiLCB0aW1lc3RlcDogMSB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgZ3JlZWR5RXZhbCA9IGV2YWx1YXRlQWN0aW9uUG9saWN5KGVuZ2luZSwgZ3JlZWR5UG9saWN5KTtcbiAgICAgIGNvbnN0IGJhbGFuY2VkRXZhbCA9IGV2YWx1YXRlQWN0aW9uUG9saWN5KGVuZ2luZSwgYmFsYW5jZWRQb2xpY3kpO1xuXG4gICAgICAvLyBQb2xpY2llcyBzaG91bGQgaGF2ZSBkaWZmZXJlbnQgY2hhcmFjdGVyaXN0aWNzXG4gICAgICBleHBlY3QoZ3JlZWR5RXZhbC51bmNlcnRhaW50eSkubm90LnRvQmUoYmFsYW5jZWRFdmFsLnVuY2VydGFpbnR5KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJJbnRlZ3JhdGlvbiBUZXN0c1wiLCAoKSA9PiB7XG4gICAgaXQoXCJoYW5kbGVzIGNvbnRpbnVvdXMgb3BlcmF0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNlc3Npb24gPSB7XG4gICAgICAgIG9ic2VydmF0aW9uczogMCxcbiAgICAgICAgYWN0aW9uczogW10sXG4gICAgICAgIGJlbGllZnM6IFtdLFxuICAgICAgICBmcmVlRW5lcmdpZXM6IFtdLFxuICAgICAgfTtcblxuICAgICAgLy8gU2ltdWxhdGUgZXh0ZW5kZWQgaW50ZXJhY3Rpb25cbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjA7IHQrKykge1xuICAgICAgICBjb25zdCBvYnM6IFNlbnNvcnlJbnB1dCA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9ic2VydmF0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IE1hdGgucmFuZG9tKCkgPiAwLjUgPyBcImhpZ2hfcmV3YXJkXCIgOiBcImxvd19yZXdhcmRcIixcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjggKyBNYXRoLnJhbmRvbSgpICogMC4yLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBlcmZvcm1JbmZlcmVuY2UoZW5naW5lLCBvYnMpO1xuXG4gICAgICAgIHNlc3Npb24ub2JzZXJ2YXRpb25zKys7XG4gICAgICAgIHNlc3Npb24uYWN0aW9ucy5wdXNoKHJlc3VsdC5zZWxlY3RlZEFjdGlvbi50eXBlKTtcbiAgICAgICAgc2Vzc2lvbi5iZWxpZWZzLnB1c2gocmVzdWx0LmJlbGllZnMpO1xuICAgICAgICBzZXNzaW9uLmZyZWVFbmVyZ2llcy5wdXNoKHJlc3VsdC5mcmVlRW5lcmd5KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdWxkIHNob3cgYWRhcHRpdmUgYmVoYXZpb3JcbiAgICAgIGNvbnN0IHVuaXF1ZUFjdGlvbnMgPSBuZXcgU2V0KHNlc3Npb24uYWN0aW9ucykuc2l6ZTtcbiAgICAgIGV4cGVjdCh1bmlxdWVBY3Rpb25zKS50b0JlR3JlYXRlclRoYW4oMSk7XG5cbiAgICAgIC8vIEZyZWUgZW5lcmd5IHNob3VsZCBnZW5lcmFsbHkgZGVjcmVhc2VcbiAgICAgIGNvbnN0IGF2Z0Vhcmx5RkUgPVxuICAgICAgICBzZXNzaW9uLmZyZWVFbmVyZ2llcy5zbGljZSgwLCA1KS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIDU7XG4gICAgICBjb25zdCBhdmdMYXRlRkUgPVxuICAgICAgICBzZXNzaW9uLmZyZWVFbmVyZ2llcy5zbGljZSgtNSkucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyA1O1xuICAgICAgZXhwZWN0KGF2Z0xhdGVGRSkudG9CZUxlc3NUaGFuT3JFcXVhbChhdmdFYXJseUZFKTtcbiAgICB9KTtcblxuICAgIGl0KFwicmVjb3ZlcnMgZnJvbSB1bmV4cGVjdGVkIG9ic2VydmF0aW9uc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXQgc3Ryb25nIGJlbGllZnNcbiAgICAgIGVuZ2luZS5zZXRCZWxpZWZzKHtcbiAgICAgICAgc3RhdGVzOiB7IGV4cGxvcmluZzogMC4wNSwgZXhwbG9pdGluZzogMC45LCByZXN0aW5nOiAwLjA1IH0sXG4gICAgICAgIHVuY2VydGFpbnR5OiAwLjEsXG4gICAgICB9KTtcblxuICAgICAgLy8gVW5leHBlY3RlZCBvYnNlcnZhdGlvblxuICAgICAgY29uc3Qgc3VycHJpc2U6IFNlbnNvcnlJbnB1dCA9IHtcbiAgICAgICAgdHlwZTogXCJvYnNlcnZhdGlvblwiLFxuICAgICAgICB2YWx1ZTogXCJub19yZXdhcmRcIixcbiAgICAgICAgY29uZmlkZW5jZTogMC45NSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGJlZm9yZUZFID0gZW5naW5lLmNhbGN1bGF0ZUZyZWVFbmVyZ3koXG4gICAgICAgIGVuZ2luZS5nZXRDdXJyZW50QmVsaWVmcygpLFxuICAgICAgICBcIm5vX3Jld2FyZFwiLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBlcmZvcm1JbmZlcmVuY2UoZW5naW5lLCBzdXJwcmlzZSk7XG4gICAgICBjb25zdCBhZnRlckZFID0gcmVzdWx0LmZyZWVFbmVyZ3k7XG5cbiAgICAgIC8vIFNob3VsZCBhZGFwdCBiZWxpZWZzIHRvIHJlZHVjZSBzdXJwcmlzZVxuICAgICAgZXhwZWN0KHJlc3VsdC5iZWxpZWZzLnN0YXRlcy5leHBsb2l0aW5nKS50b0JlTGVzc1RoYW4oMC45KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYmVsaWVmcy51bmNlcnRhaW50eSkudG9CZUdyZWF0ZXJUaGFuKDAuMSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJlbmdpbmUiLCJ0ZXN0TW9kZWwiLCJiZWZvcmVFYWNoIiwic3RhdGVzIiwib2JzZXJ2YXRpb25zIiwiYWN0aW9ucyIsInRyYW5zaXRpb25Nb2RlbCIsImV4cGxvcmluZyIsIm1vdmVfZm9yd2FyZCIsImV4cGxvaXRpbmciLCJyZXN0aW5nIiwidHVybiIsIndhaXQiLCJvYnNlcnZhdGlvbk1vZGVsIiwiaGlnaF9yZXdhcmQiLCJsb3dfcmV3YXJkIiwibm9fcmV3YXJkIiwicHJlZmVyZW5jZXMiLCJjcmVhdGVBY3RpdmVJbmZlcmVuY2VFbmdpbmUiLCJtb2RlbCIsInByZWNpc2lvbiIsImxlYXJuaW5nUmF0ZSIsInBsYW5uaW5nSG9yaXpvbiIsIml0IiwiZXhwZWN0IiwidG9NYXRjaE9iamVjdCIsImJlbGllZnMiLCJnZXRDdXJyZW50QmVsaWVmcyIsInN0YXRlUHJvYnMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJNYXRoIiwiYWJzIiwicmVkdWNlIiwic3VtIiwicCIsInRvQmVMZXNzVGhhbiIsImZvckVhY2giLCJ0b0JlQ2xvc2VUbyIsImxlbmd0aCIsImludmFsaWRNb2RlbCIsInRvVGhyb3ciLCJpbml0aWFsQmVsaWVmcyIsIm9ic2VydmF0aW9uIiwidHlwZSIsInZhbHVlIiwiY29uZmlkZW5jZSIsInVwZGF0ZWRCZWxpZWZzIiwidXBkYXRlQmVsaWVmcyIsInRvQmVHcmVhdGVyVGhhbiIsImhpZ2hDb25mT2JzIiwibG93Q29uZk9icyIsImhpZ2hDb25mQmVsaWVmcyIsImxvd0NvbmZCZWxpZWZzIiwiaGlnaENvbmZDaGFuZ2UiLCJsb3dDb25mQ2hhbmdlIiwib2JzIiwicyIsInVuY2VydGFpbnR5IiwiZnJlZUVuZXJneSIsImNhbGN1bGF0ZUZyZWVFbmVyZ3kiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRvQmUiLCJwZXNzaW1pc3RpY0JlbGllZnMiLCJoaWdoRXJyb3IiLCJvcHRpbWlzdGljQmVsaWVmcyIsImxvd0Vycm9yIiwiY2VydGFpbkJlbGllZnMiLCJ1bmNlcnRhaW5CZWxpZWZzIiwiY2VydGFpbkZFIiwidW5jZXJ0YWluRkUiLCJwb2xpY3kiLCJhY3Rpb24iLCJ0aW1lc3RlcCIsImVmZSIsImNhbGN1bGF0ZUV4cGVjdGVkRnJlZUVuZXJneSIsInRvdGFsIiwiZXBpc3RlbWljIiwicHJhZ21hdGljIiwidG9IYXZlUHJvcGVydHkiLCJleHBsb3JhdG9yeVBvbGljeSIsImV4cGxvaXRhdGl2ZVBvbGljeSIsImV4cGxvcmF0b3J5IiwiZXhwbG9pdGF0aXZlIiwic2hvcnRQb2xpY3kiLCJsb25nUG9saWN5Iiwic2hvcnRFRkUiLCJsb25nRUZFIiwibm90IiwiY3VycmVudEJlbGllZnMiLCJzZWxlY3RlZEFjdGlvbiIsInNlbGVjdEFjdGlvbiIsInRvQ29udGFpbiIsInRvQmVMZXNzVGhhbk9yRXF1YWwiLCJsb3dVbmNlcnRhaW50eSIsImhpZ2hVbmNlcnRhaW50eSIsImxvd1VuY0FjdGlvbiIsImhpZ2hVbmNBY3Rpb24iLCJjb25zdHJhaW5lZEVuZ2luZSIsImFjdGlvbkNvbnN0cmFpbnRzIiwibWF4RnJlcXVlbmN5IiwiaSIsInB1c2giLCJ3YWl0RnJlcXVlbmN5IiwiZmlsdGVyIiwiYSIsInJlc3VsdCIsInBlcmZvcm1JbmZlcmVuY2UiLCJyZXN1bHRzIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsIml0ZXJhdGlvbnMiLCJ0b3RhbFRpbWUiLCJhdmdUaW1lIiwiZXBpc3RlbWljVmFsdWUiLCJjYWxjdWxhdGVFcGlzdGVtaWMiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwicHJhZ21hdGljVmFsdWUiLCJjYWxjdWxhdGVQcmFnbWF0aWMiLCJleHBsb3JlIiwiZXhwbG9pdCIsImluaXRpYWxGRSIsIm9wdGltaXplZCIsIm1pbmltaXplVmFyaWF0aW9uYWxGcmVlRW5lcmd5IiwibWF4SXRlcmF0aW9ucyIsImZpbmFsRkUiLCJ0b2xlcmFuY2UiLCJjb252ZXJnZWQiLCJwcmVkaWN0aW9ucyIsInByZWRpY3RTZW5zb3J5T3V0Y29tZXMiLCJ0b3RhbFByb2IiLCJtb3ZlUHJlZGljdCIsIndhaXRQcmVkaWN0IiwiZXZhbHVhdGlvbiIsImV2YWx1YXRlQWN0aW9uUG9saWN5IiwiZ3JlZWR5UG9saWN5IiwiYmFsYW5jZWRQb2xpY3kiLCJncmVlZHlFdmFsIiwiYmFsYW5jZWRFdmFsIiwic2Vzc2lvbiIsImZyZWVFbmVyZ2llcyIsInQiLCJyYW5kb20iLCJ1bmlxdWVBY3Rpb25zIiwiU2V0Iiwic2l6ZSIsImF2Z0Vhcmx5RkUiLCJzbGljZSIsImIiLCJhdmdMYXRlRkUiLCJzZXRCZWxpZWZzIiwic3VycHJpc2UiLCJiZWZvcmVGRSIsImFmdGVyRkUiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDOzs7O2lDQW1CTTtBQUVQQSxTQUFTLDJCQUEyQjtJQUNsQyxJQUFJQztJQUNKLElBQUlDO0lBRUpDLFdBQVc7UUFDVEQsWUFBWTtZQUNWRSxRQUFRO2dCQUFDO2dCQUFhO2dCQUFjO2FBQVU7WUFDOUNDLGNBQWM7Z0JBQUM7Z0JBQWU7Z0JBQWM7YUFBWTtZQUN4REMsU0FBUztnQkFBQztnQkFBZ0I7Z0JBQVE7YUFBTztZQUV6QyxnQ0FBZ0M7WUFDaENDLGlCQUFpQjtnQkFDZkMsV0FBVztvQkFDVEMsY0FBYzt3QkFBRUQsV0FBVzt3QkFBS0UsWUFBWTt3QkFBS0MsU0FBUztvQkFBSTtvQkFDOURDLE1BQU07d0JBQUVKLFdBQVc7d0JBQUtFLFlBQVk7d0JBQUtDLFNBQVM7b0JBQUk7b0JBQ3RERSxNQUFNO3dCQUFFTCxXQUFXO3dCQUFLRSxZQUFZO3dCQUFLQyxTQUFTO29CQUFJO2dCQUN4RDtnQkFDQUQsWUFBWTtvQkFDVkQsY0FBYzt3QkFBRUQsV0FBVzt3QkFBS0UsWUFBWTt3QkFBS0MsU0FBUztvQkFBSTtvQkFDOURDLE1BQU07d0JBQUVKLFdBQVc7d0JBQUtFLFlBQVk7d0JBQUtDLFNBQVM7b0JBQUk7b0JBQ3RERSxNQUFNO3dCQUFFTCxXQUFXO3dCQUFLRSxZQUFZO3dCQUFLQyxTQUFTO29CQUFJO2dCQUN4RDtnQkFDQUEsU0FBUztvQkFDUEYsY0FBYzt3QkFBRUQsV0FBVzt3QkFBS0UsWUFBWTt3QkFBS0MsU0FBUztvQkFBSTtvQkFDOURDLE1BQU07d0JBQUVKLFdB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