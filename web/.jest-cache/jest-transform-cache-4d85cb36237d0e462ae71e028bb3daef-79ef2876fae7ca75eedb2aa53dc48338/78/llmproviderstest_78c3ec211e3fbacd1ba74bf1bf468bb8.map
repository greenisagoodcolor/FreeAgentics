{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/__tests__/lib/llm-providers.test.ts"],"sourcesContent":["/**\n * Phase 1: lib/llm-providers.ts Comprehensive Test Suite\n * Target: Complete LLM provider implementations\n * Goal: Maximum statement coverage for LLM API interactions\n */\n\nimport {\n  generateOpenAIResponse,\n  generateOpenRouterResponse,\n  streamOpenAIResponse,\n  streamOpenRouterResponse,\n  LLMRequestOptions,\n} from \"../../lib/llm-providers\";\n\n// Mock fetch globally\nconst mockFetch = jest.fn();\nglobal.fetch = mockFetch;\n\n// Mock console methods\nconst originalConsole = { ...console };\nbeforeEach(() => {\n  jest.clearAllMocks();\n  console.log = jest.fn();\n  console.warn = jest.fn();\n  console.error = jest.fn();\n});\n\nafterEach(() => {\n  Object.assign(console, originalConsole);\n});\n\ndescribe(\"lib/llm-providers.ts - Complete Coverage\", () => {\n  const mockOptions: LLMRequestOptions = {\n    temperature: 0.7,\n    maxTokens: 1024,\n    topP: 0.9,\n    frequencyPenalty: 0,\n    presencePenalty: 0,\n    systemFingerprint: false,\n  };\n\n  const testApiKey = \"test-api-key-12345\";\n  const testModel = \"gpt-4o\";\n  const testSystemPrompt = \"You are a helpful assistant.\";\n  const testUserPrompt = \"Hello, how are you?\";\n\n  describe(\"LLMRequestOptions Interface\", () => {\n    test(\"has correct structure and types\", () => {\n      expect(typeof mockOptions.temperature).toBe(\"number\");\n      expect(typeof mockOptions.maxTokens).toBe(\"number\");\n      expect(typeof mockOptions.topP).toBe(\"number\");\n      expect(typeof mockOptions.frequencyPenalty).toBe(\"number\");\n      expect(typeof mockOptions.presencePenalty).toBe(\"number\");\n      expect(typeof mockOptions.systemFingerprint).toBe(\"boolean\");\n    });\n\n    test(\"supports optional systemFingerprint\", () => {\n      const optionsWithoutFingerprint: LLMRequestOptions = {\n        temperature: 0.5,\n        maxTokens: 512,\n        topP: 1.0,\n        frequencyPenalty: 0.1,\n        presencePenalty: 0.1,\n      };\n\n      expect(optionsWithoutFingerprint.systemFingerprint).toBeUndefined();\n\n      const optionsWithFingerprint: LLMRequestOptions = {\n        ...optionsWithoutFingerprint,\n        systemFingerprint: true,\n      };\n\n      expect(optionsWithFingerprint.systemFingerprint).toBe(true);\n    });\n\n    test(\"validates numeric ranges\", () => {\n      const validOptions: LLMRequestOptions = {\n        temperature: 0.7,\n        maxTokens: 1024,\n        topP: 0.9,\n        frequencyPenalty: 0.5,\n        presencePenalty: 0.5,\n        systemFingerprint: true,\n      };\n\n      expect(validOptions.temperature).toBeGreaterThanOrEqual(0);\n      expect(validOptions.temperature).toBeLessThanOrEqual(2);\n      expect(validOptions.maxTokens).toBeGreaterThan(0);\n      expect(validOptions.topP).toBeGreaterThanOrEqual(0);\n      expect(validOptions.topP).toBeLessThanOrEqual(1);\n      expect(validOptions.frequencyPenalty).toBeGreaterThanOrEqual(-2);\n      expect(validOptions.frequencyPenalty).toBeLessThanOrEqual(2);\n      expect(validOptions.presencePenalty).toBeGreaterThanOrEqual(-2);\n      expect(validOptions.presencePenalty).toBeLessThanOrEqual(2);\n    });\n  });\n\n  describe(\"generateOpenAIResponse\", () => {\n    const expectedOpenAIURL = \"https://api.openai.com/v1/chat/completions\";\n\n    test(\"makes successful API call with correct parameters\", async () => {\n      const mockResponse = {\n        choices: [\n          {\n            message: {\n              content: \"Hello! I am doing well, thank you for asking.\",\n            },\n          },\n        ],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      const result = await generateOpenAIResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        mockOptions,\n      );\n\n      expect(mockFetch).toHaveBeenCalledWith(expectedOpenAIURL, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${testApiKey}`,\n        },\n        body: JSON.stringify({\n          model: testModel,\n          messages: [\n            { role: \"system\", content: testSystemPrompt },\n            { role: \"user\", content: testUserPrompt },\n          ],\n          temperature: mockOptions.temperature,\n          max_tokens: mockOptions.maxTokens,\n          top_p: mockOptions.topP,\n          frequency_penalty: mockOptions.frequencyPenalty,\n          presence_penalty: mockOptions.presencePenalty,\n        }),\n      });\n\n      expect(result).toBe(\"Hello! I am doing well, thank you for asking.\");\n    });\n\n    test(\"includes system_fingerprint when enabled\", async () => {\n      const optionsWithFingerprint = {\n        ...mockOptions,\n        systemFingerprint: true,\n      };\n      const mockResponse = {\n        choices: [{ message: { content: \"Response with fingerprint\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      const result = await generateOpenAIResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        optionsWithFingerprint,\n      );\n\n      expect(mockFetch).toHaveBeenCalledWith(\n        expectedOpenAIURL,\n        expect.objectContaining({\n          body: expect.stringContaining('\"system_fingerprint\":true'),\n        }),\n      );\n\n      expect(result).toBe(\"Response with fingerprint\");\n    });\n\n    test(\"excludes system_fingerprint when disabled\", async () => {\n      const optionsWithoutFingerprint = {\n        ...mockOptions,\n        systemFingerprint: false,\n      };\n      const mockResponse = {\n        choices: [{ message: { content: \"Response without fingerprint\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      await generateOpenAIResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        optionsWithoutFingerprint,\n      );\n\n      expect(mockFetch).toHaveBeenCalledWith(\n        expectedOpenAIURL,\n        expect.objectContaining({\n          body: expect.not.stringContaining(\"system_fingerprint\"),\n        }),\n      );\n    });\n\n    test(\"handles API error responses\", async () => {\n      const errorResponse = \"Invalid API key provided\";\n\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 401,\n        statusText: \"Unauthorized\",\n        text: async () => errorResponse,\n      });\n\n      await expect(\n        generateOpenAIResponse(\n          \"invalid-key\",\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow(\n        \"OpenAI API error: 401 Unauthorized - Invalid API key provided\",\n      );\n    });\n\n    test(\"handles rate limit errors\", async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 429,\n        statusText: \"Too Many Requests\",\n        text: async () => \"Rate limit exceeded\",\n      });\n\n      await expect(\n        generateOpenAIResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow(\n        \"OpenAI API error: 429 Too Many Requests - Rate limit exceeded\",\n      );\n    });\n\n    test(\"handles network errors\", async () => {\n      mockFetch.mockRejectedValueOnce(new Error(\"Network error\"));\n\n      await expect(\n        generateOpenAIResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow(\"Network error\");\n    });\n\n    test(\"handles malformed response JSON\", async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => {\n          throw new Error(\"Invalid JSON\");\n        },\n      });\n\n      await expect(\n        generateOpenAIResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow(\"Invalid JSON\");\n    });\n\n    test(\"works with different models\", async () => {\n      const models = [\"gpt-4o\", \"gpt-4\", \"gpt-3.5-turbo\"];\n\n      for (const model of models) {\n        const mockResponse = {\n          choices: [{ message: { content: `Response from ${model}` } }],\n        };\n\n        mockFetch.mockResolvedValueOnce({\n          ok: true,\n          json: async () => mockResponse,\n        });\n\n        const result = await generateOpenAIResponse(\n          testApiKey,\n          model,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        );\n\n        expect(result).toBe(`Response from ${model}`);\n      }\n    });\n\n    test(\"handles edge case parameters\", async () => {\n      const extremeOptions: LLMRequestOptions = {\n        temperature: 2.0,\n        maxTokens: 4096,\n        topP: 1.0,\n        frequencyPenalty: 2.0,\n        presencePenalty: -2.0,\n        systemFingerprint: true,\n      };\n\n      const mockResponse = {\n        choices: [{ message: { content: \"Extreme parameters response\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      const result = await generateOpenAIResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        extremeOptions,\n      );\n\n      expect(result).toBe(\"Extreme parameters response\");\n    });\n  });\n\n  describe(\"generateOpenRouterResponse\", () => {\n    const expectedOpenRouterURL =\n      \"https://openrouter.ai/api/v1/chat/completions\";\n\n    test(\"makes successful API call with correct headers\", async () => {\n      const mockResponse = {\n        choices: [{ message: { content: \"OpenRouter response\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      const result = await generateOpenRouterResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        mockOptions,\n      );\n\n      expect(mockFetch).toHaveBeenCalledWith(expectedOpenRouterURL, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${testApiKey}`,\n          \"HTTP-Referer\": \"https://freeagentics.vercel.app\",\n          \"X-Title\": \"FreeAgentics\",\n        },\n        body: JSON.stringify({\n          model: testModel,\n          messages: [\n            { role: \"system\", content: testSystemPrompt },\n            { role: \"user\", content: testUserPrompt },\n          ],\n          temperature: mockOptions.temperature,\n          max_tokens: mockOptions.maxTokens,\n          top_p: mockOptions.topP,\n          frequency_penalty: mockOptions.frequencyPenalty,\n          presence_penalty: mockOptions.presencePenalty,\n        }),\n      });\n\n      expect(result).toBe(\"OpenRouter response\");\n    });\n\n    test(\"does not include system_fingerprint in OpenRouter requests\", async () => {\n      const optionsWithFingerprint = {\n        ...mockOptions,\n        systemFingerprint: true,\n      };\n      const mockResponse = {\n        choices: [{ message: { content: \"OpenRouter without fingerprint\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      await generateOpenRouterResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        optionsWithFingerprint,\n      );\n\n      expect(mockFetch).toHaveBeenCalledWith(\n        expectedOpenRouterURL,\n        expect.objectContaining({\n          body: expect.not.stringContaining(\"system_fingerprint\"),\n        }),\n      );\n    });\n\n    test(\"handles OpenRouter API errors\", async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 402,\n        statusText: \"Payment Required\",\n        text: async () => \"Insufficient credits\",\n      });\n\n      await expect(\n        generateOpenRouterResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow(\n        \"OpenRouter API error: 402 Payment Required - Insufficient credits\",\n      );\n    });\n\n    test(\"handles different OpenRouter models\", async () => {\n      const openRouterModels = [\n        \"anthropic/claude-3-opus\",\n        \"google/gemini-pro\",\n        \"meta-llama/llama-2-70b-chat\",\n      ];\n\n      for (const model of openRouterModels) {\n        const mockResponse = {\n          choices: [{ message: { content: `Response from ${model}` } }],\n        };\n\n        mockFetch.mockResolvedValueOnce({\n          ok: true,\n          json: async () => mockResponse,\n        });\n\n        const result = await generateOpenRouterResponse(\n          testApiKey,\n          model,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        );\n\n        expect(result).toBe(`Response from ${model}`);\n      }\n    });\n\n    test(\"includes correct referer and title headers\", async () => {\n      const mockResponse = {\n        choices: [{ message: { content: \"Headers test\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      await generateOpenRouterResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        mockOptions,\n      );\n\n      expect(mockFetch).toHaveBeenCalledWith(\n        expectedOpenRouterURL,\n        expect.objectContaining({\n          headers: expect.objectContaining({\n            \"HTTP-Referer\": \"https://freeagentics.vercel.app\",\n            \"X-Title\": \"FreeAgentics\",\n          }),\n        }),\n      );\n    });\n\n    test(\"handles server errors\", async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 500,\n        statusText: \"Internal Server Error\",\n        text: async () => \"Server temporarily unavailable\",\n      });\n\n      await expect(\n        generateOpenRouterResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow(\n        \"OpenRouter API error: 500 Internal Server Error - Server temporarily unavailable\",\n      );\n    });\n  });\n\n  describe(\"streamOpenAIResponse\", () => {\n    test(\"throws not implemented error\", async () => {\n      await expect(\n        streamOpenAIResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow(\"Streaming not yet implemented\");\n    });\n\n    test(\"accepts all required parameters\", () => {\n      // Test that function signature accepts correct parameters\n      expect(() => {\n        streamOpenAIResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        );\n      }).not.toThrow(TypeError);\n    });\n\n    test(\"returns Promise that rejects\", async () => {\n      const promise = streamOpenAIResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        mockOptions,\n      );\n\n      expect(promise).toBeInstanceOf(Promise);\n      await expect(promise).rejects.toThrow();\n    });\n\n    test(\"handles different parameter combinations\", async () => {\n      const variations = [\n        [\"key1\", \"model1\", \"system1\", \"user1\", mockOptions],\n        [\n          \"key2\",\n          \"model2\",\n          \"system2\",\n          \"user2\",\n          { ...mockOptions, temperature: 1.0 },\n        ],\n        [\n          \"key3\",\n          \"model3\",\n          \"system3\",\n          \"user3\",\n          { ...mockOptions, systemFingerprint: true },\n        ],\n      ];\n\n      for (const [\n        apiKey,\n        model,\n        systemPrompt,\n        userPrompt,\n        options,\n      ] of variations) {\n        await expect(\n          streamOpenAIResponse(\n            apiKey as string,\n            model as string,\n            systemPrompt as string,\n            userPrompt as string,\n            options as LLMRequestOptions,\n          ),\n        ).rejects.toThrow(\"Streaming not yet implemented\");\n      }\n    });\n  });\n\n  describe(\"streamOpenRouterResponse\", () => {\n    test(\"throws not implemented error\", async () => {\n      await expect(\n        streamOpenRouterResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow(\"Streaming not yet implemented\");\n    });\n\n    test(\"accepts all required parameters\", () => {\n      expect(() => {\n        streamOpenRouterResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        );\n      }).not.toThrow(TypeError);\n    });\n\n    test(\"returns Promise that rejects\", async () => {\n      const promise = streamOpenRouterResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        mockOptions,\n      );\n\n      expect(promise).toBeInstanceOf(Promise);\n      await expect(promise).rejects.toThrow();\n    });\n\n    test(\"streaming functions have consistent signatures\", async () => {\n      // Both streaming functions should have identical signatures\n      await expect(\n        streamOpenAIResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow();\n\n      await expect(\n        streamOpenRouterResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow();\n    });\n  });\n\n  describe(\"Cross-Provider Consistency\", () => {\n    test(\"both providers handle same request structure\", async () => {\n      const mockOpenAIResponse = {\n        choices: [{ message: { content: \"OpenAI response\" } }],\n      };\n      const mockOpenRouterResponse = {\n        choices: [{ message: { content: \"OpenRouter response\" } }],\n      };\n\n      // Test OpenAI\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockOpenAIResponse,\n      });\n\n      const openAIResult = await generateOpenAIResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        mockOptions,\n      );\n\n      // Test OpenRouter\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockOpenRouterResponse,\n      });\n\n      const openRouterResult = await generateOpenRouterResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        mockOptions,\n      );\n\n      expect(openAIResult).toBe(\"OpenAI response\");\n      expect(openRouterResult).toBe(\"OpenRouter response\");\n    });\n\n    test(\"both providers use same message format\", async () => {\n      const testCases = [\n        { system: \"System prompt 1\", user: \"User prompt 1\" },\n        { system: \"System prompt 2\", user: \"User prompt 2\" },\n      ];\n\n      for (const testCase of testCases) {\n        // OpenAI\n        mockFetch.mockResolvedValueOnce({\n          ok: true,\n          json: async () => ({\n            choices: [{ message: { content: \"response\" } }],\n          }),\n        });\n\n        await generateOpenAIResponse(\n          testApiKey,\n          testModel,\n          testCase.system,\n          testCase.user,\n          mockOptions,\n        );\n\n        const openAICall =\n          mockFetch.mock.calls[mockFetch.mock.calls.length - 1];\n        const openAIBody = JSON.parse(openAICall[1].body);\n\n        // OpenRouter\n        mockFetch.mockResolvedValueOnce({\n          ok: true,\n          json: async () => ({\n            choices: [{ message: { content: \"response\" } }],\n          }),\n        });\n\n        await generateOpenRouterResponse(\n          testApiKey,\n          testModel,\n          testCase.system,\n          testCase.user,\n          mockOptions,\n        );\n\n        const openRouterCall =\n          mockFetch.mock.calls[mockFetch.mock.calls.length - 1];\n        const openRouterBody = JSON.parse(openRouterCall[1].body);\n\n        // Both should have same message structure\n        expect(openAIBody.messages).toEqual(openRouterBody.messages);\n      }\n    });\n\n    test(\"error handling consistency\", async () => {\n      const errorScenarios = [\n        { status: 400, statusText: \"Bad Request\", text: \"Invalid request\" },\n        { status: 401, statusText: \"Unauthorized\", text: \"Invalid API key\" },\n        { status: 429, statusText: \"Too Many Requests\", text: \"Rate limited\" },\n        {\n          status: 500,\n          statusText: \"Internal Server Error\",\n          text: \"Server error\",\n        },\n      ];\n\n      for (const scenario of errorScenarios) {\n        // Test OpenAI error handling\n        mockFetch.mockResolvedValueOnce({\n          ok: false,\n          status: scenario.status,\n          statusText: scenario.statusText,\n          text: async () => scenario.text,\n        });\n\n        await expect(\n          generateOpenAIResponse(\n            testApiKey,\n            testModel,\n            testSystemPrompt,\n            testUserPrompt,\n            mockOptions,\n          ),\n        ).rejects.toThrow(\n          `OpenAI API error: ${scenario.status} ${scenario.statusText} - ${scenario.text}`,\n        );\n\n        // Test OpenRouter error handling\n        mockFetch.mockResolvedValueOnce({\n          ok: false,\n          status: scenario.status,\n          statusText: scenario.statusText,\n          text: async () => scenario.text,\n        });\n\n        await expect(\n          generateOpenRouterResponse(\n            testApiKey,\n            testModel,\n            testSystemPrompt,\n            testUserPrompt,\n            mockOptions,\n          ),\n        ).rejects.toThrow(\n          `OpenRouter API error: ${scenario.status} ${scenario.statusText} - ${scenario.text}`,\n        );\n      }\n    });\n  });\n\n  describe(\"Edge Cases and Robustness\", () => {\n    test(\"handles empty prompts\", async () => {\n      const mockResponse = {\n        choices: [{ message: { content: \"Empty prompt response\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      const result = await generateOpenAIResponse(\n        testApiKey,\n        testModel,\n        \"\",\n        \"\",\n        mockOptions,\n      );\n\n      expect(result).toBe(\"Empty prompt response\");\n    });\n\n    test(\"handles very long prompts\", async () => {\n      const longPrompt = \"A\".repeat(10000);\n      const mockResponse = {\n        choices: [{ message: { content: \"Long prompt response\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      const result = await generateOpenAIResponse(\n        testApiKey,\n        testModel,\n        longPrompt,\n        longPrompt,\n        mockOptions,\n      );\n\n      expect(result).toBe(\"Long prompt response\");\n    });\n\n    test(\"handles special characters in prompts\", async () => {\n      const specialPrompts = [\n        \"Prompt with \\\"quotes\\\" and 'apostrophes'\",\n        \"Prompt with emoji ðŸš€ and unicode Ã±Ã¡Ã©Ã­Ã³Ãº\",\n        \"Prompt with\\nnewlines\\tand\\ttabs\",\n        'Prompt with JSON: {\"key\": \"value\"}',\n      ];\n\n      for (const prompt of specialPrompts) {\n        const mockResponse = {\n          choices: [{ message: { content: `Response to: ${prompt}` } }],\n        };\n\n        mockFetch.mockResolvedValueOnce({\n          ok: true,\n          json: async () => mockResponse,\n        });\n\n        const result = await generateOpenAIResponse(\n          testApiKey,\n          testModel,\n          prompt,\n          prompt,\n          mockOptions,\n        );\n\n        expect(result).toBe(`Response to: ${prompt}`);\n      }\n    });\n\n    test(\"handles zero and boundary parameter values\", async () => {\n      const boundaryOptions: LLMRequestOptions = {\n        temperature: 0,\n        maxTokens: 1,\n        topP: 0,\n        frequencyPenalty: 0,\n        presencePenalty: 0,\n        systemFingerprint: false,\n      };\n\n      const mockResponse = {\n        choices: [{ message: { content: \"Boundary response\" } }],\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse,\n      });\n\n      const result = await generateOpenAIResponse(\n        testApiKey,\n        testModel,\n        testSystemPrompt,\n        testUserPrompt,\n        boundaryOptions,\n      );\n\n      expect(result).toBe(\"Boundary response\");\n    });\n\n    test(\"handles response with unexpected structure\", async () => {\n      const malformedResponse = {\n        choices: [], // Empty choices array\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => malformedResponse,\n      });\n\n      await expect(\n        generateOpenAIResponse(\n          testApiKey,\n          testModel,\n          testSystemPrompt,\n          testUserPrompt,\n          mockOptions,\n        ),\n      ).rejects.toThrow();\n    });\n  });\n});\n"],"names":["mockFetch","jest","fn","global","fetch","originalConsole","console","beforeEach","clearAllMocks","log","warn","error","afterEach","Object","assign","describe","mockOptions","temperature","maxTokens","topP","frequencyPenalty","presencePenalty","systemFingerprint","testApiKey","testModel","testSystemPrompt","testUserPrompt","test","expect","toBe","optionsWithoutFingerprint","toBeUndefined","optionsWithFingerprint","validOptions","toBeGreaterThanOrEqual","toBeLessThanOrEqual","toBeGreaterThan","expectedOpenAIURL","mockResponse","choices","message","content","mockResolvedValueOnce","ok","json","result","generateOpenAIResponse","toHaveBeenCalledWith","method","headers","Authorization","body","JSON","stringify","model","messages","role","max_tokens","top_p","frequency_penalty","presence_penalty","objectContaining","stringContaining","not","errorResponse","status","statusText","text","rejects","toThrow","mockRejectedValueOnce","Error","models","extremeOptions","expectedOpenRouterURL","generateOpenRouterResponse","openRouterModels","streamOpenAIResponse","TypeError","promise","toBeInstanceOf","Promise","variations","apiKey","systemPrompt","userPrompt","options","streamOpenRouterResponse","mockOpenAIResponse","mockOpenRouterResponse","openAIResult","openRouterResult","testCases","system","user","testCase","openAICall","mock","calls","length","openAIBody","parse","openRouterCall","openRouterBody","toEqual","errorScenarios","scenario","longPrompt","repeat","specialPrompts","prompt","boundaryOptions","malformedResponse"],"mappings":"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"}