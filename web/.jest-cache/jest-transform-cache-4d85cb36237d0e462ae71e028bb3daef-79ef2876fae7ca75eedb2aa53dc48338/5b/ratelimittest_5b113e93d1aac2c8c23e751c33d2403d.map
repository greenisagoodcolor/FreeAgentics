{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/__tests__/lib/rate-limit.test.ts"],"sourcesContent":["/**\n * Phase 1: lib/rate-limit.ts Comprehensive Test Suite\n * Target: Complete rate limiting functionality\n * Goal: Maximum statement coverage for rate limiting utilities\n */\n\nimport {\n  rateLimit,\n  type RateLimiter,\n  type RateLimitOptions,\n} from \"../../lib/rate-limit\";\n\ndescribe(\"lib/rate-limit.ts - Complete Coverage\", () => {\n  // Mock timers for testing\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.clearAllTimers();\n    jest.useRealTimers();\n  });\n\n  describe(\"RateLimiter class\", () => {\n    test(\"creates rate limiter with correct options\", () => {\n      const options: RateLimitOptions = {\n        interval: 60000, // 1 minute\n        uniqueTokenPerInterval: 10,\n      };\n\n      const limiter = rateLimit(options);\n\n      expect(limiter).toBeDefined();\n      expect(limiter).toHaveProperty(\"check\");\n      expect(limiter).toHaveProperty(\"getRemainingTokens\");\n      expect(limiter).toHaveProperty(\"getResetTime\");\n      expect(limiter).toHaveProperty(\"cleanup\");\n    });\n\n    describe(\"check method\", () => {\n      test(\"allows first request within limit\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 10,\n        });\n\n        await expect(limiter.check(1, \"user1\")).resolves.toBeUndefined();\n      });\n\n      test(\"allows multiple requests within limit\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 10,\n        });\n\n        await limiter.check(3, \"user1\");\n        await limiter.check(3, \"user1\");\n        await limiter.check(3, \"user1\");\n\n        // Total: 9 tokens, should succeed\n        await expect(limiter.check(1, \"user1\")).resolves.toBeUndefined();\n      });\n\n      test(\"rejects request when limit exceeded\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        await limiter.check(3, \"user1\");\n        await limiter.check(2, \"user1\");\n\n        // Total would be 6, exceeds limit of 5\n        await expect(limiter.check(1, \"user1\")).rejects.toThrow(\n          \"Rate limit exceeded. Try again in 60 seconds.\",\n        );\n      });\n\n      test(\"tracks different identifiers separately\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        await limiter.check(5, \"user1\");\n        await limiter.check(5, \"user2\");\n\n        // user1 is at limit, user2 is at limit, but they're separate\n        await expect(limiter.check(1, \"user1\")).rejects.toThrow();\n        await expect(limiter.check(1, \"user2\")).rejects.toThrow();\n      });\n\n      test(\"resets after interval expires\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        await limiter.check(5, \"user1\");\n\n        // Should be at limit\n        await expect(limiter.check(1, \"user1\")).rejects.toThrow();\n\n        // Advance time past the interval\n        jest.advanceTimersByTime(60001);\n\n        // Should be reset now\n        await expect(limiter.check(5, \"user1\")).resolves.toBeUndefined();\n      });\n\n      test(\"handles exact boundary of reset time\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(5, \"user1\");\n\n        // Advance to exact reset time\n        jest.setSystemTime(startTime + 60000);\n\n        // Should still be limited at exact boundary\n        await expect(limiter.check(1, \"user1\")).rejects.toThrow();\n\n        // One millisecond past reset time\n        jest.setSystemTime(startTime + 60001);\n\n        // Should be reset now\n        await expect(limiter.check(1, \"user1\")).resolves.toBeUndefined();\n      });\n\n      test(\"calculates correct wait time in error message\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(5, \"user1\");\n\n        // Advance part way through interval\n        jest.setSystemTime(startTime + 20000);\n\n        try {\n          await limiter.check(1, \"user1\");\n          fail(\"Should have thrown\");\n        } catch (error: any) {\n          expect(error.message).toBe(\n            \"Rate limit exceeded. Try again in 40 seconds.\",\n          );\n        }\n      });\n\n      test(\"handles zero tokens request\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        await expect(limiter.check(0, \"user1\")).resolves.toBeUndefined();\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(5);\n      });\n\n      test(\"handles negative tokens request\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        await limiter.check(-5, \"user1\");\n        // Negative tokens should still be counted\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(10);\n      });\n\n      test(\"handles very large token requests\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        // First request creates a record even if over limit\n        await expect(limiter.check(100, \"user1\")).resolves.toBeUndefined();\n\n        // But now the user has consumed 100 tokens\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(0);\n\n        // Any subsequent request should fail\n        await expect(limiter.check(1, \"user1\")).rejects.toThrow(\n          \"Rate limit exceeded. Try again in 60 seconds.\",\n        );\n      });\n\n      test(\"handles empty identifier\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        await expect(limiter.check(1, \"\")).resolves.toBeUndefined();\n        expect(limiter.getRemainingTokens(\"\")).toBe(4);\n      });\n\n      test(\"handles special character identifiers\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const specialIds = [\n          \"user@example.com\",\n          \"user-123\",\n          \"user_456\",\n          \"user.789\",\n          \"user:abc\",\n          \"user/path\",\n          \"user\\\\path\",\n          \"user[bracket]\",\n          \"user{brace}\",\n          \"user with spaces\",\n          \"user\\ttab\",\n          \"user\\nnewline\",\n          \"userğŸš€emoji\",\n          \"ä¸­æ–‡ç”¨æˆ·\",\n        ];\n\n        for (const id of specialIds) {\n          await expect(limiter.check(1, id)).resolves.toBeUndefined();\n          expect(limiter.getRemainingTokens(id)).toBe(4);\n        }\n      });\n    });\n\n    describe(\"getRemainingTokens method\", () => {\n      test(\"returns full limit for new identifier\", () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 10,\n        });\n\n        expect(limiter.getRemainingTokens(\"new-user\")).toBe(10);\n      });\n\n      test(\"returns correct remaining tokens after usage\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 10,\n        });\n\n        await limiter.check(3, \"user1\");\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(7);\n\n        await limiter.check(2, \"user1\");\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(5);\n      });\n\n      test(\"returns zero when at limit\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        await limiter.check(5, \"user1\");\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(0);\n      });\n\n      test(\"returns zero when over limit\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        // First request uses 6 tokens (over limit of 5)\n        await limiter.check(6, \"user1\");\n        // User is now over limit\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(0);\n      });\n\n      test(\"returns full limit after reset\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        await limiter.check(5, \"user1\");\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(0);\n\n        jest.advanceTimersByTime(60001);\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(5);\n      });\n\n      test(\"handles multiple identifiers correctly\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 10,\n        });\n\n        await limiter.check(3, \"user1\");\n        await limiter.check(5, \"user2\");\n        await limiter.check(7, \"user3\");\n\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(7);\n        expect(limiter.getRemainingTokens(\"user2\")).toBe(5);\n        expect(limiter.getRemainingTokens(\"user3\")).toBe(3);\n      });\n    });\n\n    describe(\"getResetTime method\", () => {\n      test(\"returns correct reset time for active record\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(1, \"user1\");\n\n        const resetTime = limiter.getResetTime(\"user1\");\n        expect(resetTime).toBe(startTime + 60000);\n      });\n\n      test(\"returns future reset time for new identifier\", () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const now = Date.now();\n        jest.setSystemTime(now);\n\n        const resetTime = limiter.getResetTime(\"new-user\");\n        expect(resetTime).toBe(now + 60000);\n      });\n\n      test(\"maintains reset time through multiple checks\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 10,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(1, \"user1\");\n        const resetTime1 = limiter.getResetTime(\"user1\");\n\n        jest.advanceTimersByTime(10000);\n        await limiter.check(1, \"user1\");\n        const resetTime2 = limiter.getResetTime(\"user1\");\n\n        // Reset time should not change\n        expect(resetTime2).toBe(resetTime1);\n        expect(resetTime2).toBe(startTime + 60000);\n      });\n\n      test(\"returns new reset time after interval expires\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(1, \"user1\");\n        const resetTime1 = limiter.getResetTime(\"user1\");\n\n        jest.setSystemTime(startTime + 60001);\n        await limiter.check(1, \"user1\");\n        const resetTime2 = limiter.getResetTime(\"user1\");\n\n        expect(resetTime2).not.toBe(resetTime1);\n        expect(resetTime2).toBe(startTime + 60001 + 60000);\n      });\n    });\n\n    describe(\"cleanup method\", () => {\n      test(\"removes expired entries\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        // Create entries at different times\n        await limiter.check(1, \"user1\");\n\n        jest.setSystemTime(startTime + 30000);\n        await limiter.check(1, \"user2\");\n\n        jest.setSystemTime(startTime + 60001);\n        await limiter.check(1, \"user3\");\n\n        // user1 should be expired, user2 and user3 should remain\n        limiter.cleanup();\n\n        // user1 should have full tokens (new record)\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(5);\n\n        // user2 should still have its record\n        expect(limiter.getRemainingTokens(\"user2\")).toBe(4);\n\n        // user3 should have its record\n        expect(limiter.getRemainingTokens(\"user3\")).toBe(4);\n      });\n\n      test(\"handles empty store\", () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        // Should not throw\n        expect(() => limiter.cleanup()).not.toThrow();\n      });\n\n      test(\"handles all expired entries\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(1, \"user1\");\n        await limiter.check(1, \"user2\");\n        await limiter.check(1, \"user3\");\n\n        jest.setSystemTime(startTime + 60001);\n        limiter.cleanup();\n\n        // All should have full tokens (new records)\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(5);\n        expect(limiter.getRemainingTokens(\"user2\")).toBe(5);\n        expect(limiter.getRemainingTokens(\"user3\")).toBe(5);\n      });\n\n      test(\"preserves non-expired entries\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(3, \"user1\");\n\n        jest.setSystemTime(startTime + 30000);\n        limiter.cleanup();\n\n        // Should still have the record\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(2);\n      });\n    });\n\n    describe(\"factory function and intervals\", () => {\n      test(\"sets up automatic cleanup interval\", () => {\n        const setIntervalSpy = jest.spyOn(global, \"setInterval\");\n\n        rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        expect(setIntervalSpy).toHaveBeenCalledWith(\n          expect.any(Function),\n          60000,\n        );\n      });\n\n      test(\"cleanup interval runs periodically\", async () => {\n        const limiter = rateLimit({\n          interval: 5000, // 5 seconds\n          uniqueTokenPerInterval: 5,\n        });\n\n        const cleanupSpy = jest.spyOn(limiter, \"cleanup\");\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(1, \"user1\");\n\n        // Fast-forward to trigger cleanup\n        jest.advanceTimersByTime(60000);\n\n        expect(cleanupSpy).toHaveBeenCalledTimes(1);\n\n        // Fast-forward again\n        jest.advanceTimersByTime(60000);\n\n        expect(cleanupSpy).toHaveBeenCalledTimes(2);\n      });\n    });\n\n    describe(\"edge cases and stress testing\", () => {\n      test(\"handles many identifiers\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 10,\n        });\n\n        // Create 1000 different users\n        for (let i = 0; i < 1000; i++) {\n          await limiter.check(1, `user${i}`);\n        }\n\n        // Check a few random ones\n        expect(limiter.getRemainingTokens(\"user0\")).toBe(9);\n        expect(limiter.getRemainingTokens(\"user500\")).toBe(9);\n        expect(limiter.getRemainingTokens(\"user999\")).toBe(9);\n      });\n\n      test(\"handles rapid requests\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 100,\n        });\n\n        const promises = [];\n        for (let i = 0; i < 50; i++) {\n          promises.push(limiter.check(1, \"user1\"));\n        }\n\n        await Promise.all(promises);\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(50);\n      });\n\n      test(\"handles very short intervals\", async () => {\n        const limiter = rateLimit({\n          interval: 100, // 100ms\n          uniqueTokenPerInterval: 5,\n        });\n\n        await limiter.check(5, \"user1\");\n        await expect(limiter.check(1, \"user1\")).rejects.toThrow();\n\n        jest.advanceTimersByTime(101);\n        await expect(limiter.check(5, \"user1\")).resolves.toBeUndefined();\n      });\n\n      test(\"handles very long intervals\", async () => {\n        const limiter = rateLimit({\n          interval: 86400000, // 24 hours\n          uniqueTokenPerInterval: 1000,\n        });\n\n        await limiter.check(999, \"user1\");\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(1);\n\n        // Should still be limited after 23 hours\n        jest.advanceTimersByTime(82800000);\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(1);\n\n        // Should reset after 24 hours\n        jest.advanceTimersByTime(3600001);\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(1000);\n      });\n\n      test(\"handles fractional wait times correctly\", async () => {\n        const limiter = rateLimit({\n          interval: 1500, // 1.5 seconds\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(5, \"user1\");\n\n        // Advance to 0.7 seconds before reset\n        jest.setSystemTime(startTime + 800);\n\n        try {\n          await limiter.check(1, \"user1\");\n          fail(\"Should have thrown\");\n        } catch (error: any) {\n          // Should round up to 1 second\n          expect(error.message).toBe(\n            \"Rate limit exceeded. Try again in 1 seconds.\",\n          );\n        }\n      });\n\n      test(\"handles concurrent operations on same identifier\", async () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 10,\n        });\n\n        // Simulate concurrent requests\n        const promises = [\n          limiter.check(2, \"user1\"),\n          limiter.check(2, \"user1\"),\n          limiter.check(2, \"user1\"),\n          limiter.check(2, \"user1\"),\n          limiter.check(2, \"user1\"),\n        ];\n\n        await Promise.all(promises);\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(0);\n\n        // Next request should fail\n        await expect(limiter.check(1, \"user1\")).rejects.toThrow();\n      });\n\n      test(\"maintains consistency during cleanup\", async () => {\n        const limiter = rateLimit({\n          interval: 5000,\n          uniqueTokenPerInterval: 5,\n        });\n\n        const startTime = Date.now();\n        jest.setSystemTime(startTime);\n\n        await limiter.check(3, \"user1\");\n\n        // Expire the entry\n        jest.setSystemTime(startTime + 5001);\n\n        // Check before cleanup\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(5);\n\n        // Run cleanup\n        limiter.cleanup();\n\n        // Should still return correct value\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(5);\n      });\n\n      test(\"handles limit of zero\", () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: 0,\n        });\n\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(0);\n      });\n\n      test(\"handles negative limit\", () => {\n        const limiter = rateLimit({\n          interval: 60000,\n          uniqueTokenPerInterval: -5,\n        });\n\n        expect(limiter.getRemainingTokens(\"user1\")).toBe(-5);\n      });\n    });\n  });\n});\n"],"names":["describe","beforeEach","jest","useFakeTimers","afterEach","clearAllTimers","useRealTimers","test","options","interval","uniqueTokenPerInterval","limiter","rateLimit","expect","toBeDefined","toHaveProperty","check","resolves","toBeUndefined","rejects","toThrow","advanceTimersByTime","startTime","Date","now","setSystemTime","fail","error","message","toBe","getRemainingTokens","specialIds","id","resetTime","getResetTime","resetTime1","resetTime2","not","cleanup","setIntervalSpy","spyOn","global","toHaveBeenCalledWith","any","Function","cleanupSpy","toHaveBeenCalledTimes","i","promises","push","Promise","all"],"mappings":"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"}