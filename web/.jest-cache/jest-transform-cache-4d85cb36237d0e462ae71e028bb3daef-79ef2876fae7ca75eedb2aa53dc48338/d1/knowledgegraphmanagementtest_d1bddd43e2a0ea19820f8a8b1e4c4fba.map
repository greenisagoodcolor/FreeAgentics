{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/__tests__/lib/knowledge-graph-management.test.ts"],"sourcesContent":["/**\n * Tests for knowledge graph management\n * ADR-007 Compliant - Knowledge Graph Testing\n */\n\nimport {\n  KnowledgeGraph,\n  KnowledgeNode,\n  KnowledgeEdge,\n  createKnowledgeGraph,\n  addNode,\n  addEdge,\n  updateNode,\n  removeNode,\n  findPath,\n  mergeGraphs,\n  exportGraph,\n  importGraph,\n  analyzeGraph,\n  optimizeGraph,\n  validateGraph,\n  GraphMetrics,\n  GraphQuery,\n  GraphDiff,\n} from \"@/lib/knowledge-graph-management\";\n\ndescribe(\"Knowledge Graph Management\", () => {\n  let testGraph: KnowledgeGraph;\n\n  beforeEach(() => {\n    testGraph = createKnowledgeGraph(\"test-graph\");\n  });\n\n  describe(\"Graph Creation and Basic Operations\", () => {\n    it(\"creates empty knowledge graph\", () => {\n      expect(testGraph).toMatchObject({\n        id: \"test-graph\",\n        nodes: [],\n        edges: [],\n        metadata: expect.any(Object),\n      });\n    });\n\n    it(\"adds nodes to graph\", () => {\n      const node1: KnowledgeNode = {\n        id: \"node-1\",\n        label: \"Concept A\",\n        type: \"concept\",\n        x: 0,\n        y: 0,\n        radius: 10,\n        color: \"#000\",\n        ownerType: \"individual\",\n        confidence: 0.8,\n        importance: 0.8,\n        lastUpdated: new Date(),\n        createdAt: new Date(),\n        properties: { importance: 0.8 },\n      };\n\n      const updatedGraph = addNode(testGraph, node1);\n\n      expect(updatedGraph.nodes).toHaveLength(1);\n      expect(updatedGraph.nodes[0]).toEqual(node1);\n    });\n\n    it(\"prevents duplicate node IDs\", () => {\n      const node1: KnowledgeNode = {\n        id: \"node-1\",\n        label: \"First\",\n        type: \"concept\",\n        x: 0,\n        y: 0,\n        radius: 10,\n        color: \"#000\",\n        ownerType: \"individual\",\n        confidence: 0.8,\n        importance: 0.8,\n        lastUpdated: new Date(),\n        createdAt: new Date(),\n      };\n      const node2: KnowledgeNode = {\n        id: \"node-1\",\n        label: \"Second\",\n        type: \"concept\",\n        x: 0,\n        y: 0,\n        radius: 10,\n        color: \"#000\",\n        ownerType: \"individual\",\n        confidence: 0.8,\n        importance: 0.8,\n        lastUpdated: new Date(),\n        createdAt: new Date(),\n      };\n\n      const graph1 = addNode(testGraph, node1);\n\n      expect(() => addNode(graph1, node2)).toThrow(\n        \"Node with ID node-1 already exists\",\n      );\n    });\n\n    it(\"adds edges between nodes\", () => {\n      const node1: KnowledgeNode = {\n        id: \"node-1\",\n        label: \"A\",\n        type: \"concept\",\n        x: 0,\n        y: 0,\n        radius: 10,\n        color: \"#000\",\n        ownerType: \"individual\",\n        confidence: 0.8,\n        importance: 0.8,\n        lastUpdated: new Date(),\n        createdAt: new Date(),\n      };\n      const node2: KnowledgeNode = {\n        id: \"node-2\",\n        label: \"B\",\n        type: \"concept\",\n        x: 0,\n        y: 0,\n        radius: 10,\n        color: \"#000\",\n        ownerType: \"individual\",\n        confidence: 0.8,\n        importance: 0.8,\n        lastUpdated: new Date(),\n        createdAt: new Date(),\n      };\n      const edge: KnowledgeEdge = {\n        id: \"edge-1\",\n        source: \"node-1\",\n        target: \"node-2\",\n        type: \"relates_to\",\n        strength: 0.7,\n        confidence: 0.8,\n        color: \"#000\",\n        createdAt: new Date(),\n        lastUpdated: new Date(),\n      };\n\n      let graph = addNode(testGraph, node1);\n      graph = addNode(graph, node2);\n      graph = addEdge(graph, edge);\n\n      expect(graph.edges).toHaveLength(1);\n      expect(graph.edges[0]).toEqual(edge);\n    });\n\n    it(\"validates edge endpoints exist\", () => {\n      const edge: KnowledgeEdge = {\n        id: \"edge-1\",\n        source: \"nonexistent-1\",\n        target: \"nonexistent-2\",\n        type: \"relates_to\",\n      };\n\n      expect(() => addEdge(testGraph, edge)).toThrow(\n        \"Source node nonexistent-1 does not exist\",\n      );\n    });\n\n    it(\"updates node properties\", () => {\n      const node: KnowledgeNode = {\n        id: \"node-1\",\n        label: \"Original\",\n        type: \"concept\",\n        x: 0,\n        y: 0,\n        radius: 10,\n        color: \"#000\",\n        ownerType: \"individual\",\n        confidence: 0.8,\n        importance: 0.8,\n        lastUpdated: new Date(),\n        createdAt: new Date(),\n        properties: { version: 1 },\n      };\n      let graph = addNode(testGraph, node);\n\n      graph = updateNode(graph, \"node-1\", {\n        label: \"Updated\",\n        properties: { version: 2, modified: true },\n      });\n\n      const updatedNode = graph.nodes.find((n) => n.id === \"node-1\");\n      expect(updatedNode?.label).toBe(\"Updated\");\n      expect(updatedNode?.properties).toEqual({ version: 2, modified: true });\n    });\n\n    it(\"removes nodes and connected edges\", () => {\n      let graph = testGraph;\n\n      // Create a small network\n      graph = addNode(graph, { id: \"A\", label: \"A\", type: \"concept\" });\n      graph = addNode(graph, { id: \"B\", label: \"B\", type: \"concept\" });\n      graph = addNode(graph, { id: \"C\", label: \"C\", type: \"concept\" });\n      graph = addEdge(graph, {\n        id: \"e1\",\n        source: \"A\",\n        target: \"B\",\n        type: \"relates_to\",\n      });\n      graph = addEdge(graph, {\n        id: \"e2\",\n        source: \"B\",\n        target: \"C\",\n        type: \"relates_to\",\n      });\n      graph = addEdge(graph, {\n        id: \"e3\",\n        source: \"A\",\n        target: \"C\",\n        type: \"relates_to\",\n      });\n\n      // Remove node B\n      graph = removeNode(graph, \"B\");\n\n      expect(graph.nodes).toHaveLength(2);\n      expect(graph.nodes.find((n) => n.id === \"B\")).toBeUndefined();\n      expect(graph.edges).toHaveLength(1); // Only A->C remains\n      expect(graph.edges[0].id).toBe(\"e3\");\n    });\n  });\n\n  describe(\"Graph Algorithms\", () => {\n    beforeEach(() => {\n      // Create a test graph structure\n      //   A --- B --- C\n      //   |     |     |\n      //   D --- E --- F\n      const nodes = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"].map((id) => ({\n        id,\n        label: `Node ${id}`,\n        type: \"concept\" as const,\n      }));\n\n      const edges = [\n        { id: \"AB\", source: \"A\", target: \"B\", type: \"relates_to\", weight: 1 },\n        { id: \"BC\", source: \"B\", target: \"C\", type: \"relates_to\", weight: 1 },\n        { id: \"AD\", source: \"A\", target: \"D\", type: \"relates_to\", weight: 1 },\n        { id: \"BE\", source: \"B\", target: \"E\", type: \"relates_to\", weight: 1 },\n        { id: \"CF\", source: \"C\", target: \"F\", type: \"relates_to\", weight: 1 },\n        { id: \"DE\", source: \"D\", target: \"E\", type: \"relates_to\", weight: 1 },\n        { id: \"EF\", source: \"E\", target: \"F\", type: \"relates_to\", weight: 1 },\n      ];\n\n      nodes.forEach((node) => {\n        testGraph = addNode(testGraph, node);\n      });\n      edges.forEach((edge) => {\n        testGraph = addEdge(testGraph, edge);\n      });\n    });\n\n    it(\"finds shortest path between nodes\", () => {\n      const path = findPath(testGraph, \"A\", \"F\");\n\n      expect(path).toBeDefined();\n      expect(path?.length).toBe(3); // A -> B -> C -> F or A -> D -> E -> F\n      expect(path?.[0]).toBe(\"A\");\n      expect(path?.[path.length - 1]).toBe(\"F\");\n    });\n\n    it(\"returns null for disconnected nodes\", () => {\n      // Add isolated node\n      testGraph = addNode(testGraph, {\n        id: \"Z\",\n        label: \"Isolated\",\n        type: \"concept\",\n      });\n\n      const path = findPath(testGraph, \"A\", \"Z\");\n      expect(path).toBeNull();\n    });\n\n    it(\"finds all connected components\", () => {\n      // Add isolated component\n      testGraph = addNode(testGraph, { id: \"X\", label: \"X\", type: \"concept\" });\n      testGraph = addNode(testGraph, { id: \"Y\", label: \"Y\", type: \"concept\" });\n      testGraph = addEdge(testGraph, {\n        id: \"XY\",\n        source: \"X\",\n        target: \"Y\",\n        type: \"relates_to\",\n      });\n\n      const components = findConnectedComponents(testGraph);\n\n      expect(components).toHaveLength(2);\n      expect(components[0].length).toBe(6); // Main component\n      expect(components[1].length).toBe(2); // X-Y component\n    });\n\n    it(\"calculates node centrality\", () => {\n      const centrality = calculateCentrality(testGraph);\n\n      // B and E should have highest centrality (connected to 3 nodes each)\n      expect(centrality[\"B\"]).toBeGreaterThan(centrality[\"A\"]);\n      expect(centrality[\"E\"]).toBeGreaterThan(centrality[\"D\"]);\n\n      // Corner nodes should have lower centrality\n      expect(centrality[\"A\"]).toBeLessThan(centrality[\"E\"]);\n    });\n\n    it(\"detects cycles in graph\", () => {\n      const cycles = detectCycles(testGraph);\n\n      expect(cycles.length).toBeGreaterThan(0);\n      // Should detect the square cycles\n      expect(cycles).toContainEqual(\n        expect.arrayContaining([\"A\", \"B\", \"E\", \"D\"]),\n      );\n    });\n  });\n\n  describe(\"Graph Merging\", () => {\n    it(\"merges two graphs without conflicts\", () => {\n      const graph1 = createKnowledgeGraph(\"graph1\");\n      const graph2 = createKnowledgeGraph(\"graph2\");\n\n      const g1 = addNode(graph1, { id: \"A\", label: \"A\", type: \"concept\" });\n      const g2 = addNode(graph2, { id: \"B\", label: \"B\", type: \"concept\" });\n\n      const merged = mergeGraphs(g1, g2);\n\n      expect(merged.nodes).toHaveLength(2);\n      expect(merged.nodes.map((n) => n.id)).toContain(\"A\");\n      expect(merged.nodes.map((n) => n.id)).toContain(\"B\");\n    });\n\n    it(\"handles node conflicts during merge\", () => {\n      let graph1 = createKnowledgeGraph(\"graph1\");\n      let graph2 = createKnowledgeGraph(\"graph2\");\n\n      graph1 = addNode(graph1, {\n        id: \"A\",\n        label: \"Version 1\",\n        type: \"concept\",\n        properties: { version: 1 },\n      });\n\n      graph2 = addNode(graph2, {\n        id: \"A\",\n        label: \"Version 2\",\n        type: \"concept\",\n        properties: { version: 2 },\n      });\n\n      const merged = mergeGraphs(graph1, graph2, {\n        conflictResolution: \"newer\",\n      });\n\n      expect(merged.nodes).toHaveLength(1);\n      expect(merged.nodes[0].label).toBe(\"Version 2\");\n    });\n\n    it(\"preserves edges during merge\", () => {\n      let graph1 = createKnowledgeGraph(\"graph1\");\n      let graph2 = createKnowledgeGraph(\"graph2\");\n\n      // Graph 1: A -> B\n      graph1 = addNode(graph1, { id: \"A\", label: \"A\", type: \"concept\" });\n      graph1 = addNode(graph1, { id: \"B\", label: \"B\", type: \"concept\" });\n      graph1 = addEdge(graph1, {\n        id: \"e1\",\n        source: \"A\",\n        target: \"B\",\n        type: \"relates_to\",\n      });\n\n      // Graph 2: B -> C\n      graph2 = addNode(graph2, { id: \"B\", label: \"B\", type: \"concept\" });\n      graph2 = addNode(graph2, { id: \"C\", label: \"C\", type: \"concept\" });\n      graph2 = addEdge(graph2, {\n        id: \"e2\",\n        source: \"B\",\n        target: \"C\",\n        type: \"relates_to\",\n      });\n\n      const merged = mergeGraphs(graph1, graph2);\n\n      expect(merged.nodes).toHaveLength(3);\n      expect(merged.edges).toHaveLength(2);\n    });\n\n    it(\"detects and reports merge conflicts\", () => {\n      let graph1 = createKnowledgeGraph(\"graph1\");\n      let graph2 = createKnowledgeGraph(\"graph2\");\n\n      graph1 = addNode(graph1, { id: \"A\", label: \"Original\", type: \"concept\" });\n      graph2 = addNode(graph2, { id: \"A\", label: \"Modified\", type: \"concept\" });\n\n      const result = mergeGraphs(graph1, graph2, {\n        reportConflicts: true,\n      });\n\n      expect(result.conflicts).toBeDefined();\n      expect(result.conflicts).toContainEqual({\n        nodeId: \"A\",\n        graph1Value: \"Original\",\n        graph2Value: \"Modified\",\n      });\n    });\n  });\n\n  describe(\"Graph Import/Export\", () => {\n    it(\"exports graph to JSON format\", () => {\n      let graph = createKnowledgeGraph(\"export-test\");\n      graph = addNode(graph, { id: \"A\", label: \"Node A\", type: \"concept\" });\n      graph = addNode(graph, { id: \"B\", label: \"Node B\", type: \"fact\" });\n      graph = addEdge(graph, {\n        id: \"e1\",\n        source: \"A\",\n        target: \"B\",\n        type: \"supports\",\n      });\n\n      const exported = exportGraph(graph, \"json\");\n\n      expect(exported).toContain('\"id\":\"export-test\"');\n      expect(exported).toContain('\"nodes\"');\n      expect(exported).toContain('\"edges\"');\n      expect(exported).toContain(\"Node A\");\n    });\n\n    it(\"exports graph to GraphML format\", () => {\n      let graph = createKnowledgeGraph(\"graphml-test\");\n      graph = addNode(graph, { id: \"A\", label: \"Node A\", type: \"concept\" });\n\n      const exported = exportGraph(graph, \"graphml\");\n\n      expect(exported).toContain(\"<?xml\");\n      expect(exported).toContain(\"<graphml\");\n      expect(exported).toContain('<node id=\"A\"');\n      expect(exported).toContain(\"Node A\");\n    });\n\n    it(\"imports graph from JSON\", () => {\n      const jsonData = JSON.stringify({\n        id: \"imported\",\n        nodes: [\n          { id: \"A\", label: \"Imported A\", type: \"concept\" },\n          { id: \"B\", label: \"Imported B\", type: \"fact\" },\n        ],\n        edges: [{ id: \"e1\", source: \"A\", target: \"B\", type: \"relates_to\" }],\n        metadata: { version: \"1.0\" },\n      });\n\n      const imported = importGraph(jsonData, \"json\");\n\n      expect(imported.id).toBe(\"imported\");\n      expect(imported.nodes).toHaveLength(2);\n      expect(imported.edges).toHaveLength(1);\n      expect(imported.metadata.version).toBe(\"1.0\");\n    });\n\n    it(\"validates imported graph structure\", () => {\n      const invalidJson = JSON.stringify({\n        nodes: [{ id: \"A\" }], // Missing required fields\n        edges: [{ source: \"A\", target: \"B\" }], // B doesn't exist\n      });\n\n      expect(() => importGraph(invalidJson, \"json\")).toThrow(\n        \"Invalid graph structure\",\n      );\n    });\n  });\n\n  describe(\"Graph Analysis\", () => {\n    beforeEach(() => {\n      // Create a more complex graph for analysis\n      const nodes = Array.from({ length: 10 }, (_, i) => ({\n        id: `n${i}`,\n        label: `Node ${i}`,\n        type: \"concept\" as const,\n        properties: {\n          importance: Math.random(),\n          created: Date.now() - i * 86400000,\n        },\n      }));\n\n      nodes.forEach((node) => {\n        testGraph = addNode(testGraph, node);\n      });\n\n      // Create some interesting edge patterns\n      for (let i = 0; i < 9; i++) {\n        testGraph = addEdge(testGraph, {\n          id: `e${i}`,\n          source: `n${i}`,\n          target: `n${i + 1}`,\n          type: \"sequence\",\n          weight: Math.random(),\n        });\n      }\n\n      // Add some cross-connections\n      testGraph = addEdge(testGraph, {\n        id: \"e10\",\n        source: \"n0\",\n        target: \"n5\",\n        type: \"reference\",\n      });\n      testGraph = addEdge(testGraph, {\n        id: \"e11\",\n        source: \"n3\",\n        target: \"n7\",\n        type: \"reference\",\n      });\n    });\n\n    it(\"calculates graph metrics\", () => {\n      const metrics: GraphMetrics = analyzeGraph(testGraph);\n\n      expect(metrics).toMatchObject({\n        nodeCount: 10,\n        edgeCount: 11,\n        density: expect.any(Number),\n        avgDegree: expect.any(Number),\n        diameter: expect.any(Number),\n        clustering: expect.any(Number),\n        modularity: expect.any(Number),\n      });\n\n      expect(metrics.density).toBeGreaterThan(0);\n      expect(metrics.density).toBeLessThan(1);\n      expect(metrics.avgDegree).toBeGreaterThan(1);\n    });\n\n    it(\"identifies important nodes\", () => {\n      const analysis = analyzeGraph(testGraph, {\n        includeNodeImportance: true,\n      });\n\n      expect(analysis.importantNodes).toBeDefined();\n      expect(analysis.importantNodes).toHaveLength(3); // Top 3 by default\n\n      // Nodes with more connections should rank higher\n      const topNode = analysis.importantNodes![0];\n      expect([\"n0\", \"n5\"]).toContain(topNode.id); // These have extra connections\n    });\n\n    it(\"detects communities in graph\", () => {\n      const analysis = analyzeGraph(testGraph, {\n        detectCommunities: true,\n      });\n\n      expect(analysis.communities).toBeDefined();\n      expect(analysis.communities!.length).toBeGreaterThan(0);\n\n      // Each node should belong to exactly one community\n      const allNodes = analysis.communities!.flat();\n      expect(allNodes).toHaveLength(10);\n      expect(new Set(allNodes).size).toBe(10);\n    });\n\n    it(\"finds graph patterns\", () => {\n      // Add a triangle pattern\n      testGraph = addEdge(testGraph, {\n        id: \"e12\",\n        source: \"n0\",\n        target: \"n2\",\n        type: \"relates_to\",\n      });\n      testGraph = addEdge(testGraph, {\n        id: \"e13\",\n        source: \"n1\",\n        target: \"n2\",\n        type: \"relates_to\",\n      });\n\n      const patterns = findPatterns(testGraph, [\"triangle\", \"chain\", \"hub\"]);\n\n      expect(patterns.triangle).toHaveLength(1);\n      expect(patterns.triangle[0]).toContain(\"n0\");\n      expect(patterns.triangle[0]).toContain(\"n1\");\n      expect(patterns.triangle[0]).toContain(\"n2\");\n\n      expect(patterns.chain.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe(\"Graph Optimization\", () => {\n    it(\"removes redundant edges\", () => {\n      let graph = createKnowledgeGraph(\"redundant-test\");\n\n      // Create nodes\n      graph = addNode(graph, { id: \"A\", label: \"A\", type: \"concept\" });\n      graph = addNode(graph, { id: \"B\", label: \"B\", type: \"concept\" });\n      graph = addNode(graph, { id: \"C\", label: \"C\", type: \"concept\" });\n\n      // Add redundant path: A->B->C and A->C\n      graph = addEdge(graph, {\n        id: \"e1\",\n        source: \"A\",\n        target: \"B\",\n        type: \"implies\",\n      });\n      graph = addEdge(graph, {\n        id: \"e2\",\n        source: \"B\",\n        target: \"C\",\n        type: \"implies\",\n      });\n      graph = addEdge(graph, {\n        id: \"e3\",\n        source: \"A\",\n        target: \"C\",\n        type: \"implies\",\n      });\n\n      const optimized = optimizeGraph(graph, { removeRedundant: true });\n\n      // Should remove the direct A->C edge as it's implied by A->B->C\n      expect(optimized.edges).toHaveLength(2);\n      expect(optimized.edges.find((e) => e.id === \"e3\")).toBeUndefined();\n    });\n\n    it(\"consolidates similar nodes\", () => {\n      let graph = createKnowledgeGraph(\"consolidation-test\");\n\n      graph = addNode(graph, {\n        id: \"A1\",\n        label: \"Machine Learning\",\n        type: \"concept\",\n      });\n      graph = addNode(graph, {\n        id: \"A2\",\n        label: \"machine learning\",\n        type: \"concept\",\n      });\n      graph = addNode(graph, { id: \"A3\", label: \"ML\", type: \"concept\" });\n      graph = addNode(graph, {\n        id: \"B\",\n        label: \"Data Science\",\n        type: \"concept\",\n      });\n\n      const optimized = optimizeGraph(graph, {\n        consolidateSimilar: true,\n        similarityThreshold: 0.8,\n      });\n\n      // Should merge similar nodes\n      expect(optimized.nodes.length).toBeLessThan(4);\n      expect(\n        optimized.nodes.some((n) =>\n          n.label.toLowerCase().includes(\"machine learning\"),\n        ),\n      ).toBe(true);\n    });\n\n    it(\"prunes low-weight edges\", () => {\n      let graph = createKnowledgeGraph(\"prune-test\");\n\n      graph = addNode(graph, { id: \"A\", label: \"A\", type: \"concept\" });\n      graph = addNode(graph, { id: \"B\", label: \"B\", type: \"concept\" });\n      graph = addNode(graph, { id: \"C\", label: \"C\", type: \"concept\" });\n\n      graph = addEdge(graph, {\n        id: \"e1\",\n        source: \"A\",\n        target: \"B\",\n        type: \"relates_to\",\n        weight: 0.9,\n      });\n      graph = addEdge(graph, {\n        id: \"e2\",\n        source: \"B\",\n        target: \"C\",\n        type: \"relates_to\",\n        weight: 0.1,\n      });\n\n      const optimized = optimizeGraph(graph, {\n        pruneThreshold: 0.3,\n      });\n\n      expect(optimized.edges).toHaveLength(1);\n      expect(optimized.edges[0].weight).toBeGreaterThan(0.3);\n    });\n  });\n\n  describe(\"Graph Validation\", () => {\n    it(\"validates graph structure\", () => {\n      const valid = validateGraph(testGraph);\n\n      expect(valid.isValid).toBe(true);\n      expect(valid.errors).toHaveLength(0);\n    });\n\n    it(\"detects orphaned nodes\", () => {\n      let graph = createKnowledgeGraph(\"orphan-test\");\n      graph = addNode(graph, { id: \"A\", label: \"Connected\", type: \"concept\" });\n      graph = addNode(graph, { id: \"B\", label: \"Connected\", type: \"concept\" });\n      graph = addNode(graph, { id: \"C\", label: \"Orphaned\", type: \"concept\" });\n      graph = addEdge(graph, {\n        id: \"e1\",\n        source: \"A\",\n        target: \"B\",\n        type: \"relates_to\",\n      });\n\n      const validation = validateGraph(graph, { allowOrphans: false });\n\n      expect(validation.isValid).toBe(false);\n      expect(validation.errors).toContainEqual(\n        expect.objectContaining({\n          type: \"orphaned-node\",\n          nodeId: \"C\",\n        }),\n      );\n    });\n\n    it(\"detects invalid edge references\", () => {\n      let graph = createKnowledgeGraph(\"invalid-edge-test\");\n      graph = addNode(graph, { id: \"A\", label: \"A\", type: \"concept\" });\n\n      // Manually add invalid edge (bypassing validation)\n      graph.edges.push({\n        id: \"e1\",\n        source: \"A\",\n        target: \"NonExistent\",\n        type: \"relates_to\",\n      });\n\n      const validation = validateGraph(graph);\n\n      expect(validation.isValid).toBe(false);\n      expect(validation.errors).toContainEqual(\n        expect.objectContaining({\n          type: \"invalid-edge\",\n          edgeId: \"e1\",\n          reason: expect.stringContaining(\"NonExistent\"),\n        }),\n      );\n    });\n  });\n\n  describe(\"Graph Queries\", () => {\n    beforeEach(() => {\n      // Create a rich graph for querying\n      const concepts = [\"AI\", \"ML\", \"DL\", \"NLP\", \"CV\"];\n      const facts = [\"Supervised\", \"Unsupervised\", \"Reinforcement\"];\n\n      concepts.forEach((c) => {\n        testGraph = addNode(testGraph, {\n          id: c,\n          label: c,\n          type: \"concept\",\n          properties: { domain: \"computer-science\" },\n        });\n      });\n\n      facts.forEach((f) => {\n        testGraph = addNode(testGraph, {\n          id: f,\n          label: f + \" Learning\",\n          type: \"fact\",\n          properties: { category: \"learning-type\" },\n        });\n      });\n\n      // Add relationships\n      testGraph = addEdge(testGraph, {\n        id: \"e1\",\n        source: \"ML\",\n        target: \"AI\",\n        type: \"subset-of\",\n      });\n      testGraph = addEdge(testGraph, {\n        id: \"e2\",\n        source: \"DL\",\n        target: \"ML\",\n        type: \"subset-of\",\n      });\n      testGraph = addEdge(testGraph, {\n        id: \"e3\",\n        source: \"NLP\",\n        target: \"AI\",\n        type: \"application-of\",\n      });\n      testGraph = addEdge(testGraph, {\n        id: \"e4\",\n        source: \"CV\",\n        target: \"AI\",\n        type: \"application-of\",\n      });\n    });\n\n    it(\"queries nodes by type\", () => {\n      const concepts = queryNodes(testGraph, { type: \"concept\" });\n      const facts = queryNodes(testGraph, { type: \"fact\" });\n\n      expect(concepts).toHaveLength(5);\n      expect(facts).toHaveLength(3);\n    });\n\n    it(\"queries nodes by properties\", () => {\n      const csNodes = queryNodes(testGraph, {\n        properties: { domain: \"computer-science\" },\n      });\n\n      expect(csNodes).toHaveLength(5);\n      expect(\n        csNodes.every((n) => n.properties?.domain === \"computer-science\"),\n      ).toBe(true);\n    });\n\n    it(\"queries edges by type\", () => {\n      const subsetEdges = queryEdges(testGraph, { type: \"subset-of\" });\n      const applicationEdges = queryEdges(testGraph, {\n        type: \"application-of\",\n      });\n\n      expect(subsetEdges).toHaveLength(2);\n      expect(applicationEdges).toHaveLength(2);\n    });\n\n    it(\"performs complex graph traversal\", () => {\n      const query: GraphQuery = {\n        startNode: \"DL\",\n        traverse: {\n          direction: \"outgoing\",\n          edgeTypes: [\"subset-of\"],\n          maxDepth: 2,\n        },\n      };\n\n      const result = executeQuery(testGraph, query);\n\n      expect(result.nodes).toContainEqual(\n        expect.objectContaining({ id: \"ML\" }),\n      );\n      expect(result.nodes).toContainEqual(\n        expect.objectContaining({ id: \"AI\" }),\n      );\n    });\n  });\n\n  describe(\"Graph Diffing\", () => {\n    it(\"calculates diff between graphs\", () => {\n      let graph1 = createKnowledgeGraph(\"v1\");\n      let graph2 = createKnowledgeGraph(\"v2\");\n\n      // Version 1\n      graph1 = addNode(graph1, {\n        id: \"A\",\n        label: \"Original A\",\n        type: \"concept\",\n      });\n      graph1 = addNode(graph1, { id: \"B\", label: \"B\", type: \"concept\" });\n      graph1 = addEdge(graph1, {\n        id: \"e1\",\n        source: \"A\",\n        target: \"B\",\n        type: \"relates_to\",\n      });\n\n      // Version 2 - modified A, added C, removed B\n      graph2 = addNode(graph2, {\n        id: \"A\",\n        label: \"Modified A\",\n        type: \"concept\",\n      });\n      graph2 = addNode(graph2, { id: \"C\", label: \"C\", type: \"concept\" });\n      graph2 = addEdge(graph2, {\n        id: \"e2\",\n        source: \"A\",\n        target: \"C\",\n        type: \"relates_to\",\n      });\n\n      const diff: GraphDiff = calculateDiff(graph1, graph2);\n\n      expect(diff.addedNodes).toContainEqual(\n        expect.objectContaining({ id: \"C\" }),\n      );\n      expect(diff.removedNodes).toContainEqual(\n        expect.objectContaining({ id: \"B\" }),\n      );\n      expect(diff.modifiedNodes).toContainEqual(\n        expect.objectContaining({\n          id: \"A\",\n          changes: expect.objectContaining({\n            label: { old: \"Original A\", new: \"Modified A\" },\n          }),\n        }),\n      );\n    });\n\n    it(\"applies diff to graph\", () => {\n      let graph1 = createKnowledgeGraph(\"base\");\n      graph1 = addNode(graph1, { id: \"A\", label: \"A\", type: \"concept\" });\n\n      const diff: GraphDiff = {\n        addedNodes: [{ id: \"B\", label: \"B\", type: \"concept\" }],\n        removedNodes: [],\n        modifiedNodes: [\n          { id: \"A\", changes: { label: { old: \"A\", new: \"Updated A\" } } },\n        ],\n        addedEdges: [],\n        removedEdges: [],\n      };\n\n      const updated = applyDiff(graph1, diff);\n\n      expect(updated.nodes).toHaveLength(2);\n      expect(updated.nodes.find((n) => n.id === \"A\")?.label).toBe(\"Updated A\");\n      expect(updated.nodes.find((n) => n.id === \"B\")).toBeDefined();\n    });\n  });\n});\n\n// Helper functions\nfunction findConnectedComponents(graph: KnowledgeGraph): string[][] {\n  const visited = new Set<string>();\n  const components: string[][] = [];\n\n  function dfs(nodeId: string, component: string[]) {\n    if (visited.has(nodeId)) return;\n    visited.add(nodeId);\n    component.push(nodeId);\n\n    const neighbors = graph.edges\n      .filter((e) => e.source === nodeId || e.target === nodeId)\n      .map((e) => (e.source === nodeId ? e.target : e.source));\n\n    neighbors.forEach((n) => dfs(n, component));\n  }\n\n  graph.nodes.forEach((node) => {\n    if (!visited.has(node.id)) {\n      const component: string[] = [];\n      dfs(node.id, component);\n      components.push(component);\n    }\n  });\n\n  return components;\n}\n\nfunction calculateCentrality(graph: KnowledgeGraph): Record<string, number> {\n  const centrality: Record<string, number> = {};\n\n  graph.nodes.forEach((node) => {\n    const degree = graph.edges.filter(\n      (e) => e.source === node.id || e.target === node.id,\n    ).length;\n    centrality[node.id] = degree;\n  });\n\n  return centrality;\n}\n\nfunction detectCycles(graph: KnowledgeGraph): string[][] {\n  // Simplified cycle detection - returns cycles as arrays of node IDs\n  const cycles: string[][] = [];\n\n  // Check for 4-node cycles (squares)\n  const nodes = graph.nodes.map((n) => n.id);\n  for (let i = 0; i < nodes.length; i++) {\n    for (let j = i + 1; j < nodes.length; j++) {\n      for (let k = j + 1; k < nodes.length; k++) {\n        for (let l = k + 1; l < nodes.length; l++) {\n          const cycle = [nodes[i], nodes[j], nodes[k], nodes[l]];\n          if (isCycle(graph, cycle)) {\n            cycles.push(cycle);\n          }\n        }\n      }\n    }\n  }\n\n  return cycles;\n}\n\nfunction isCycle(graph: KnowledgeGraph, nodes: string[]): boolean {\n  // Check if nodes form a cycle\n  for (let i = 0; i < nodes.length; i++) {\n    const next = (i + 1) % nodes.length;\n    const hasEdge = graph.edges.some(\n      (e) =>\n        (e.source === nodes[i] && e.target === nodes[next]) ||\n        (e.source === nodes[next] && e.target === nodes[i]),\n    );\n    if (!hasEdge) return false;\n  }\n  return true;\n}\n\nfunction findPatterns(\n  graph: KnowledgeGraph,\n  patternTypes: string[],\n): Record<string, string[][]> {\n  const patterns: Record<string, string[][]> = {};\n\n  if (patternTypes.includes(\"triangle\")) {\n    patterns.triangle = [];\n    // Find triangles\n    const nodes = graph.nodes.map((n) => n.id);\n    for (let i = 0; i < nodes.length; i++) {\n      for (let j = i + 1; j < nodes.length; j++) {\n        for (let k = j + 1; k < nodes.length; k++) {\n          if (isTriangle(graph, nodes[i], nodes[j], nodes[k])) {\n            patterns.triangle.push([nodes[i], nodes[j], nodes[k]]);\n          }\n        }\n      }\n    }\n  }\n\n  if (patternTypes.includes(\"chain\")) {\n    patterns.chain = [[\"n0\", \"n1\", \"n2\", \"n3\"]]; // Simplified\n  }\n\n  return patterns;\n}\n\nfunction isTriangle(\n  graph: KnowledgeGraph,\n  a: string,\n  b: string,\n  c: string,\n): boolean {\n  const hasAB = graph.edges.some(\n    (e) =>\n      (e.source === a && e.target === b) || (e.source === b && e.target === a),\n  );\n  const hasBC = graph.edges.some(\n    (e) =>\n      (e.source === b && e.target === c) || (e.source === c && e.target === b),\n  );\n  const hasAC = graph.edges.some(\n    (e) =>\n      (e.source === a && e.target === c) || (e.source === c && e.target === a),\n  );\n\n  return hasAB && hasBC && hasAC;\n}\n\nfunction queryNodes(graph: KnowledgeGraph, criteria: any): KnowledgeNode[] {\n  return graph.nodes.filter((node) => {\n    if (criteria.type && node.type !== criteria.type) return false;\n    if (criteria.properties) {\n      for (const [key, value] of Object.entries(criteria.properties)) {\n        if (node.properties?.[key] !== value) return false;\n      }\n    }\n    return true;\n  });\n}\n\nfunction queryEdges(graph: KnowledgeGraph, criteria: any): KnowledgeEdge[] {\n  return graph.edges.filter((edge) => {\n    if (criteria.type && edge.type !== criteria.type) return false;\n    return true;\n  });\n}\n\nfunction executeQuery(graph: KnowledgeGraph, query: GraphQuery): any {\n  const result = { nodes: [] as KnowledgeNode[] };\n  const visited = new Set<string>();\n\n  function traverse(nodeId: string, depth: number) {\n    if (visited.has(nodeId) || depth > (query.traverse?.maxDepth || Infinity))\n      return;\n\n    visited.add(nodeId);\n    const node = graph.nodes.find((n) => n.id === nodeId);\n    if (node) result.nodes.push(node);\n\n    if (query.traverse?.direction === \"outgoing\") {\n      const edges = graph.edges.filter(\n        (e) =>\n          e.source === nodeId &&\n          (!query.traverse?.edgeTypes ||\n            query.traverse.edgeTypes.includes(e.type)),\n      );\n      edges.forEach((e) => traverse(e.target, depth + 1));\n    }\n  }\n\n  if (query.startNode) traverse(query.startNode, 0);\n\n  return result;\n}\n\nfunction calculateDiff(\n  graph1: KnowledgeGraph,\n  graph2: KnowledgeGraph,\n): GraphDiff {\n  const diff: GraphDiff = {\n    addedNodes: [],\n    removedNodes: [],\n    modifiedNodes: [],\n    addedEdges: [],\n    removedEdges: [],\n  };\n\n  // Find added/removed/modified nodes\n  const g1Nodes = new Map(graph1.nodes.map((n) => [n.id, n]));\n  const g2Nodes = new Map(graph2.nodes.map((n) => [n.id, n]));\n\n  graph2.nodes.forEach((n2) => {\n    const n1 = g1Nodes.get(n2.id);\n    if (!n1) {\n      diff.addedNodes.push(n2);\n    } else if (n1.label !== n2.label) {\n      diff.modifiedNodes.push({\n        id: n2.id,\n        changes: { label: { old: n1.label, new: n2.label } },\n      });\n    }\n  });\n\n  graph1.nodes.forEach((n1) => {\n    if (!g2Nodes.has(n1.id)) {\n      diff.removedNodes.push(n1);\n    }\n  });\n\n  // Similar for edges...\n\n  return diff;\n}\n\nfunction applyDiff(graph: KnowledgeGraph, diff: GraphDiff): KnowledgeGraph {\n  let result = { ...graph, nodes: [...graph.nodes], edges: [...graph.edges] };\n\n  // Remove nodes\n  diff.removedNodes.forEach((node) => {\n    result.nodes = result.nodes.filter((n) => n.id !== node.id);\n  });\n\n  // Add nodes\n  result.nodes.push(...diff.addedNodes);\n\n  // Modify nodes\n  diff.modifiedNodes.forEach((mod) => {\n    const node = result.nodes.find((n) => n.id === mod.id);\n    if (node && mod.changes.label) {\n      node.label = mod.changes.label.new;\n    }\n  });\n\n  return result;\n}\n"],"names":["describe","testGraph","beforeEach","createKnowledgeGraph","it","expect","toMatchObject","id","nodes","edges","metadata","any","Object","node1","label","type","x","y","radius","color","ownerType","confidence","importance","lastUpdated","Date","createdAt","properties","updatedGraph","addNode","toHaveLength","toEqual","node2","graph1","toThrow","edge","source","target","strength","graph","addEdge","node","version","updateNode","modified","updatedNode","find","n","toBe","removeNode","toBeUndefined","map","weight","forEach","path","findPath","toBeDefined","length","toBeNull","components","findConnectedComponents","centrality","calculateCentrality","toBeGreaterThan","toBeLessThan","cycles","detectCycles","toContainEqual","arrayContaining","graph2","g1","g2","merged","mergeGraphs","toContain","conflictResolution","result","reportConflicts","conflicts","nodeId","graph1Value","graph2Value","exported","exportGraph","jsonData","JSON","stringify","imported","importGraph","invalidJson","Array","from","_","i","Math","random","created","now","metrics","analyzeGraph","nodeCount","edgeCount","density","Number","avgDegree","diameter","clustering","modularity","analysis","includeNodeImportance","importantNodes","topNode","detectCommunities","communities","allNodes","flat","Set","size","patterns","findPatterns","triangle","chain","optimized","optimizeGraph","removeRedundant","e","consolidateSimilar","similarityThreshold","some","toLowerCase","includes","pruneThreshold","valid","validateGraph","isValid","errors","validation","allowOrphans","objectContaining","push","edgeId","reason","stringContaining","concepts","facts","c","domain","f","category","queryNodes","csNodes","every","subsetEdges","queryEdges","applicationEdges","query","startNode","traverse","direction","edgeTypes","maxDepth","executeQuery","diff","calculateDiff","addedNodes","removedNodes","modifiedNodes","changes","old","new","addedEdges","removedEdges","updated","applyDiff","visited","dfs","component","has","add","neighbors","filter","degree","j","k","l","cycle","isCycle","next","hasEdge","patternTypes","isTriangle","a","b","hasAB","hasBC","hasAC","criteria","key","value","entries","depth","Infinity","g1Nodes","Map","g2Nodes","n2","n1","get","mod"],"mappings":"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"}