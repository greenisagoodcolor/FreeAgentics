377bb1144caba5971abc3f5fbf67c8b2
/**
 * Phase 1: lib/api-key-migration.ts Comprehensive Test Suite
 * Target: Complete API key migration functionality
 * Goal: Maximum statement coverage for security migration utilities
 */ "use strict";
// Mock dependencies
jest.mock("../../lib/session-management", ()=>({
        storeSessionId: jest.fn()
    }));
jest.mock("../../lib/feature-flags", ()=>({
        isFeatureEnabled: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _apikeymigration = require("../../lib/api-key-migration");
const _sessionmanagement = require("../../lib/session-management");
const _featureflags = require("../../lib/feature-flags");
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
// Mock localStorage
const mockLocalStorage = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn(),
    length: 0,
    key: jest.fn()
};
Object.defineProperty(window, "localStorage", {
    value: mockLocalStorage,
    writable: true
});
// Mock console methods to avoid noise in tests
const originalConsole = global.console;
beforeAll(()=>{
    global.console = {
        ...originalConsole,
        log: jest.fn(),
        error: jest.fn(),
        warn: jest.fn(),
        info: jest.fn()
    };
});
afterAll(()=>{
    global.console = originalConsole;
});
describe("lib/api-key-migration.ts - Complete Coverage", ()=>{
    beforeEach(()=>{
        // Reset all mocks before each test
        jest.clearAllMocks();
        mockFetch.mockClear();
        mockLocalStorage.getItem.mockClear();
        mockLocalStorage.setItem.mockClear();
        _sessionmanagement.storeSessionId.mockClear();
        _featureflags.isFeatureEnabled.mockClear();
    });
    describe("migrateApiKey function", ()=>{
        test("successfully migrates API key when feature is enabled", async ()=>{
            // Setup mocks
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            });
            const result = await (0, _apikeymigration.migrateApiKey)("openai", "sk-test123");
            expect(result).toBe(true);
            expect(_featureflags.isFeatureEnabled).toHaveBeenCalledWith("useSecureApiStorage");
            expect(mockFetch).toHaveBeenCalledWith("/api/api-key/store", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    provider: "openai",
                    apiKey: "sk-test123"
                })
            });
            expect(_sessionmanagement.storeSessionId).toHaveBeenCalledWith("openai", "test-session-123");
            expect(console.log).toHaveBeenCalledWith("Migrating API key for openai to secure storage");
            expect(console.log).toHaveBeenCalledWith("API key for openai migrated successfully");
        });
        test("returns false when secure storage feature is disabled", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(false);
            const result = await (0, _apikeymigration.migrateApiKey)("anthropic", "claude-key-123");
            expect(result).toBe(false);
            expect(_featureflags.isFeatureEnabled).toHaveBeenCalledWith("useSecureApiStorage");
            expect(mockFetch).not.toHaveBeenCalled();
            expect(_sessionmanagement.storeSessionId).not.toHaveBeenCalled();
            expect(console.log).toHaveBeenCalledWith("Secure API storage is not enabled, skipping migration");
        });
        test("handles API response failure gracefully", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: false,
                        message: "Invalid API key format"
                    })
            });
            const result = await (0, _apikeymigration.migrateApiKey)("google", "invalid-key");
            expect(result).toBe(false);
            expect(mockFetch).toHaveBeenCalled();
            expect(_sessionmanagement.storeSessionId).not.toHaveBeenCalled();
            expect(console.error).toHaveBeenCalledWith("Failed to migrate API key for google:", "Invalid API key format");
        });
        test("handles API response with missing sessionId", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true
                    })
            });
            const result = await (0, _apikeymigration.migrateApiKey)("mistral", "mistral-key-123");
            expect(result).toBe(false);
            expect(_sessionmanagement.storeSessionId).not.toHaveBeenCalled();
            expect(console.error).toHaveBeenCalledWith("Failed to migrate API key for mistral:", undefined);
        });
        test("handles fetch network errors", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockRejectedValueOnce(new Error("Network error"));
            const result = await (0, _apikeymigration.migrateApiKey)("perplexity", "pplx-key-123");
            expect(result).toBe(false);
            expect(_sessionmanagement.storeSessionId).not.toHaveBeenCalled();
            expect(console.error).toHaveBeenCalledWith("Error migrating API key for perplexity:", expect.any(Error));
        });
        test("handles JSON parsing errors", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>{
                    throw new Error("Invalid JSON");
                }
            });
            const result = await (0, _apikeymigration.migrateApiKey)("cohere", "cohere-key-123");
            expect(result).toBe(false);
            expect(_sessionmanagement.storeSessionId).not.toHaveBeenCalled();
            expect(console.error).toHaveBeenCalledWith("Error migrating API key for cohere:", expect.any(Error));
        });
        test("handles different provider names correctly", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            const providers = [
                "openai",
                "anthropic",
                "google",
                "mistral",
                "custom-provider"
            ];
            for (const provider of providers){
                mockFetch.mockResolvedValueOnce({
                    json: async ()=>({
                            success: true,
                            sessionId: `session-${provider}-123`
                        })
                });
                const result = await (0, _apikeymigration.migrateApiKey)(provider, `${provider}-key-123`);
                expect(result).toBe(true);
                expect(mockFetch).toHaveBeenCalledWith("/api/api-key/store", expect.objectContaining({
                    body: JSON.stringify({
                        provider,
                        apiKey: `${provider}-key-123`
                    })
                }));
                expect(_sessionmanagement.storeSessionId).toHaveBeenCalledWith(provider, `session-${provider}-123`);
            }
        });
        test("handles empty and special character inputs", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session"
                    })
            });
            const specialInputs = [
                {
                    provider: "",
                    apiKey: ""
                },
                {
                    provider: "provider with spaces",
                    apiKey: "key-with-special-chars!@#$%"
                },
                {
                    provider: "unicode-provider-\uD83D\uDE80",
                    apiKey: "unicode-key-\xf1\xe1\xe9\xed\xf3\xfa"
                }
            ];
            for (const { provider, apiKey } of specialInputs){
                const result = await (0, _apikeymigration.migrateApiKey)(provider, apiKey);
                expect(result).toBe(true);
                expect(mockFetch).toHaveBeenCalledWith("/api/api-key/store", expect.objectContaining({
                    body: JSON.stringify({
                        provider,
                        apiKey
                    })
                }));
            }
        });
    });
    describe("checkForApiKeysToMigrate function", ()=>{
        test("returns providers when API keys found in localStorage", ()=>{
            const mockSettings = {
                provider: "openai",
                apiKey: "sk-test123",
                model: "gpt-4"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([
                "openai"
            ]);
            expect(mockLocalStorage.getItem).toHaveBeenCalledWith("llm-settings");
        });
        test("returns empty array when no settings in localStorage", ()=>{
            mockLocalStorage.getItem.mockReturnValue(null);
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
            expect(mockLocalStorage.getItem).toHaveBeenCalledWith("llm-settings");
        });
        test("returns empty array when settings exist but no API key", ()=>{
            const mockSettings = {
                provider: "openai",
                model: "gpt-4"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
        });
        test("returns empty array when settings exist but no provider", ()=>{
            const mockSettings = {
                apiKey: "sk-test123",
                model: "gpt-4"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
        });
        test("handles invalid JSON in localStorage gracefully", ()=>{
            mockLocalStorage.getItem.mockReturnValue("invalid-json");
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
            expect(console.error).toHaveBeenCalledWith("Error checking for API keys to migrate:", expect.any(Error));
        });
        test("handles localStorage access errors gracefully", ()=>{
            mockLocalStorage.getItem.mockImplementation(()=>{
                throw new Error("localStorage not available");
            });
            const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
            expect(result).toEqual([]);
            expect(console.error).toHaveBeenCalledWith("Error checking for API keys to migrate:", expect.any(Error));
        });
        test("handles different provider types", ()=>{
            const providers = [
                "openai",
                "anthropic",
                "google",
                "mistral",
                "custom"
            ];
            providers.forEach((provider)=>{
                const mockSettings = {
                    provider,
                    apiKey: `${provider}-key-123`,
                    model: "test-model"
                };
                mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
                const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
                expect(result).toEqual([
                    provider
                ]);
            });
        });
        test("handles edge case settings structures", ()=>{
            const edgeCaseSettings = [
                // Empty objects
                {},
                // Null values
                {
                    provider: null,
                    apiKey: null
                },
                // Empty strings
                {
                    provider: "",
                    apiKey: ""
                },
                // Undefined values
                {
                    provider: undefined,
                    apiKey: undefined
                },
                // Mixed valid/invalid
                {
                    provider: "openai",
                    apiKey: null
                },
                {
                    provider: null,
                    apiKey: "sk-test123"
                }
            ];
            edgeCaseSettings.forEach((settings)=>{
                mockLocalStorage.getItem.mockReturnValue(JSON.stringify(settings));
                const result = (0, _apikeymigration.checkForApiKeysToMigrate)();
                expect(Array.isArray(result)).toBe(true);
            });
        });
    });
    describe("migrateAllApiKeys function", ()=>{
        test("successfully migrates all found API keys", async ()=>{
            const mockSettings = {
                provider: "openai",
                apiKey: "sk-test123",
                model: "gpt-4"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            });
            const result = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(result).toEqual([
                "openai"
            ]);
            expect(mockFetch).toHaveBeenCalled();
            expect(_sessionmanagement.storeSessionId).toHaveBeenCalledWith("openai", "test-session-123");
            // Verify localStorage was updated to remove API key
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith("llm-settings", JSON.stringify({
                provider: "openai",
                apiKey: undefined,
                model: "gpt-4"
            }));
        });
        test("returns empty array when no API keys to migrate", async ()=>{
            mockLocalStorage.getItem.mockReturnValue(null);
            const result = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(result).toEqual([]);
            expect(mockFetch).not.toHaveBeenCalled();
            expect(_sessionmanagement.storeSessionId).not.toHaveBeenCalled();
            expect(mockLocalStorage.setItem).not.toHaveBeenCalled();
        });
        test("handles migration failure gracefully", async ()=>{
            const mockSettings = {
                provider: "openai",
                apiKey: "sk-test123",
                model: "gpt-4"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            _featureflags.isFeatureEnabled.mockReturnValue(false); // Feature disabled
            const result = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(result).toEqual([]);
            expect(mockLocalStorage.setItem).not.toHaveBeenCalled();
        });
        test("handles partial migration success", async ()=>{
            const mockSettings = {
                provider: "anthropic",
                apiKey: "claude-key-123",
                model: "claude-3"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: false,
                        message: "Server error"
                    })
            });
            const result = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(result).toEqual([]);
            expect(mockLocalStorage.setItem).not.toHaveBeenCalled();
        });
        test("handles localStorage errors during migration", async ()=>{
            const mockSettings = {
                provider: "google",
                apiKey: "google-key-123"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            });
            // Make setItem throw an error
            mockLocalStorage.setItem.mockImplementation(()=>{
                throw new Error("localStorage write error");
            });
            const result = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(result).toEqual([]);
            expect(console.error).toHaveBeenCalledWith("Error migrating all API keys:", expect.any(Error));
        });
        test("handles network errors during bulk migration", async ()=>{
            const mockSettings = {
                provider: "mistral",
                apiKey: "mistral-key-123"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockRejectedValueOnce(new Error("Network failure"));
            const result = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(result).toEqual([]);
            expect(mockLocalStorage.setItem).not.toHaveBeenCalled();
            expect(console.error).toHaveBeenCalledWith("Error migrating all API keys:", expect.any(Error));
        });
        test("handles malformed settings during migration", async ()=>{
            mockLocalStorage.getItem.mockReturnValue("invalid-json");
            const result = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(result).toEqual([]);
            expect(console.error).toHaveBeenCalledWith("Error migrating all API keys:", expect.any(Error));
        });
        test("preserves other settings when removing API key", async ()=>{
            const mockSettings = {
                provider: "perplexity",
                apiKey: "pplx-key-123",
                model: "pplx-70b-online",
                temperature: 0.7,
                maxTokens: 1000,
                customSettings: {
                    streaming: true,
                    safeMode: false
                }
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            });
            const result = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(result).toEqual([
                "perplexity"
            ]);
            const expectedUpdatedSettings = {
                provider: "perplexity",
                apiKey: undefined,
                model: "pplx-70b-online",
                temperature: 0.7,
                maxTokens: 1000,
                customSettings: {
                    streaming: true,
                    safeMode: false
                }
            };
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith("llm-settings", JSON.stringify(expectedUpdatedSettings));
        });
    });
    describe("error handling and edge cases", ()=>{
        test("functions handle concurrent calls safely", async ()=>{
            const mockSettings = {
                provider: "openai",
                apiKey: "sk-test123"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValue({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            });
            // Run multiple operations concurrently
            const operations = [
                (0, _apikeymigration.migrateApiKey)("openai", "sk-test123"),
                (0, _apikeymigration.migrateAllApiKeys)(),
                (0, _apikeymigration.checkForApiKeysToMigrate)(),
                (0, _apikeymigration.migrateApiKey)("anthropic", "claude-key-123")
            ];
            const results = await Promise.all(operations);
            expect(results).toHaveLength(4);
            results.forEach((result)=>{
                expect(result).toBeDefined();
            });
        });
        test("functions handle memory constraints", async ()=>{
            const largeApiKey = "x".repeat(10000);
            const largeProvider = "y".repeat(1000);
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            });
            const result = await (0, _apikeymigration.migrateApiKey)(largeProvider, largeApiKey);
            expect(result).toBe(true);
            expect(mockFetch).toHaveBeenCalledWith("/api/api-key/store", expect.objectContaining({
                body: JSON.stringify({
                    provider: largeProvider,
                    apiKey: largeApiKey
                })
            }));
        });
        test("functions maintain state consistency during errors", async ()=>{
            const mockSettings = {
                provider: "openai",
                apiKey: "sk-test123"
            };
            mockLocalStorage.getItem.mockReturnValue(JSON.stringify(mockSettings));
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            // First call succeeds, second fails
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            }).mockRejectedValueOnce(new Error("Network error"));
            const firstResult = await (0, _apikeymigration.migrateAllApiKeys)();
            const secondResult = await (0, _apikeymigration.migrateAllApiKeys)();
            expect(firstResult).toEqual([
                "openai"
            ]);
            expect(secondResult).toEqual([]);
        });
    });
    describe("performance and reliability", ()=>{
        test("handles rapid successive calls", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValue({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            });
            const rapidCalls = Array.from({
                length: 100
            }, (_, i)=>(0, _apikeymigration.migrateApiKey)(`provider-${i}`, `key-${i}`));
            const results = await Promise.all(rapidCalls);
            expect(results).toHaveLength(100);
            results.forEach((result)=>{
                expect(result).toBe(true);
            });
        });
        test("validates input sanitization", async ()=>{
            _featureflags.isFeatureEnabled.mockReturnValue(true);
            mockFetch.mockResolvedValueOnce({
                json: async ()=>({
                        success: true,
                        sessionId: "test-session-123"
                    })
            });
            const maliciousInputs = [
                {
                    provider: '<script>alert("xss")</script>',
                    apiKey: "normal-key"
                },
                {
                    provider: "normal-provider",
                    apiKey: "DROP TABLE users;"
                },
                {
                    provider: "${process.env.SECRET}",
                    apiKey: "#{eval(dangerous_code)}"
                }
            ];
            for (const { provider, apiKey } of maliciousInputs){
                const result = await (0, _apikeymigration.migrateApiKey)(provider, apiKey);
                expect(result).toBe(true);
                // Verify the inputs were passed through without modification
                expect(mockFetch).toHaveBeenCalledWith("/api/api-key/store", expect.objectContaining({
                    body: JSON.stringify({
                        provider,
                        apiKey
                    })
                }));
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9fX3Rlc3RzX18vbGliL2FwaS1rZXktbWlncmF0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQaGFzZSAxOiBsaWIvYXBpLWtleS1taWdyYXRpb24udHMgQ29tcHJlaGVuc2l2ZSBUZXN0IFN1aXRlXG4gKiBUYXJnZXQ6IENvbXBsZXRlIEFQSSBrZXkgbWlncmF0aW9uIGZ1bmN0aW9uYWxpdHlcbiAqIEdvYWw6IE1heGltdW0gc3RhdGVtZW50IGNvdmVyYWdlIGZvciBzZWN1cml0eSBtaWdyYXRpb24gdXRpbGl0aWVzXG4gKi9cblxuaW1wb3J0IHtcbiAgbWlncmF0ZUFwaUtleSxcbiAgY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlLFxuICBtaWdyYXRlQWxsQXBpS2V5cyxcbn0gZnJvbSBcIi4uLy4uL2xpYi9hcGkta2V5LW1pZ3JhdGlvblwiO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKFwiLi4vLi4vbGliL3Nlc3Npb24tbWFuYWdlbWVudFwiLCAoKSA9PiAoe1xuICBzdG9yZVNlc3Npb25JZDogamVzdC5mbigpLFxufSkpO1xuXG5qZXN0Lm1vY2soXCIuLi8uLi9saWIvZmVhdHVyZS1mbGFnc1wiLCAoKSA9PiAoe1xuICBpc0ZlYXR1cmVFbmFibGVkOiBqZXN0LmZuKCksXG59KSk7XG5cbi8vIEltcG9ydCBtb2NrZWQgZnVuY3Rpb25zIGZvciB0eXBlIHNhZmV0eVxuaW1wb3J0IHsgc3RvcmVTZXNzaW9uSWQgfSBmcm9tIFwiLi4vLi4vbGliL3Nlc3Npb24tbWFuYWdlbWVudFwiO1xuaW1wb3J0IHsgaXNGZWF0dXJlRW5hYmxlZCB9IGZyb20gXCIuLi8uLi9saWIvZmVhdHVyZS1mbGFnc1wiO1xuXG4vLyBNb2NrIGZldGNoIGdsb2JhbGx5XG5jb25zdCBtb2NrRmV0Y2ggPSBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZmV0Y2g+O1xuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoO1xuXG4vLyBNb2NrIGxvY2FsU3RvcmFnZVxuY29uc3QgbW9ja0xvY2FsU3RvcmFnZSA9IHtcbiAgZ2V0SXRlbTogamVzdC5mbigpLFxuICBzZXRJdGVtOiBqZXN0LmZuKCksXG4gIHJlbW92ZUl0ZW06IGplc3QuZm4oKSxcbiAgY2xlYXI6IGplc3QuZm4oKSxcbiAgbGVuZ3RoOiAwLFxuICBrZXk6IGplc3QuZm4oKSxcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImxvY2FsU3RvcmFnZVwiLCB7XG4gIHZhbHVlOiBtb2NrTG9jYWxTdG9yYWdlLFxuICB3cml0YWJsZTogdHJ1ZSxcbn0pO1xuXG4vLyBNb2NrIGNvbnNvbGUgbWV0aG9kcyB0byBhdm9pZCBub2lzZSBpbiB0ZXN0c1xuY29uc3Qgb3JpZ2luYWxDb25zb2xlID0gZ2xvYmFsLmNvbnNvbGU7XG5iZWZvcmVBbGwoKCkgPT4ge1xuICBnbG9iYWwuY29uc29sZSA9IHtcbiAgICAuLi5vcmlnaW5hbENvbnNvbGUsXG4gICAgbG9nOiBqZXN0LmZuKCksXG4gICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgaW5mbzogamVzdC5mbigpLFxuICB9IGFzIGFueTtcbn0pO1xuXG5hZnRlckFsbCgoKSA9PiB7XG4gIGdsb2JhbC5jb25zb2xlID0gb3JpZ2luYWxDb25zb2xlO1xufSk7XG5cbmRlc2NyaWJlKFwibGliL2FwaS1rZXktbWlncmF0aW9uLnRzIC0gQ29tcGxldGUgQ292ZXJhZ2VcIiwgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBSZXNldCBhbGwgbW9ja3MgYmVmb3JlIGVhY2ggdGVzdFxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKTtcbiAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja0NsZWFyKCk7XG4gICAgbW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtLm1vY2tDbGVhcigpO1xuICAgIChzdG9yZVNlc3Npb25JZCBhcyBqZXN0Lk1vY2spLm1vY2tDbGVhcigpO1xuICAgIChpc0ZlYXR1cmVFbmFibGVkIGFzIGplc3QuTW9jaykubW9ja0NsZWFyKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwibWlncmF0ZUFwaUtleSBmdW5jdGlvblwiLCAoKSA9PiB7XG4gICAgdGVzdChcInN1Y2Nlc3NmdWxseSBtaWdyYXRlcyBBUEkga2V5IHdoZW4gZmVhdHVyZSBpcyBlbmFibGVkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNldHVwIG1vY2tzXG4gICAgICAoaXNGZWF0dXJlRW5hYmxlZCBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgc2Vzc2lvbklkOiBcInRlc3Qtc2Vzc2lvbi0xMjNcIixcbiAgICAgICAgfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWlncmF0ZUFwaUtleShcIm9wZW5haVwiLCBcInNrLXRlc3QxMjNcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoaXNGZWF0dXJlRW5hYmxlZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJ1c2VTZWN1cmVBcGlTdG9yYWdlXCIpO1xuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCIvYXBpL2FwaS1rZXkvc3RvcmVcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgICAgICBhcGlLZXk6IFwic2stdGVzdDEyM1wiLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KHN0b3JlU2Vzc2lvbklkKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIm9wZW5haVwiLCBcInRlc3Qtc2Vzc2lvbi0xMjNcIik7XG4gICAgICBleHBlY3QoY29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIk1pZ3JhdGluZyBBUEkga2V5IGZvciBvcGVuYWkgdG8gc2VjdXJlIHN0b3JhZ2VcIixcbiAgICAgICk7XG4gICAgICBleHBlY3QoY29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkFQSSBrZXkgZm9yIG9wZW5haSBtaWdyYXRlZCBzdWNjZXNzZnVsbHlcIixcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmV0dXJucyBmYWxzZSB3aGVuIHNlY3VyZSBzdG9yYWdlIGZlYXR1cmUgaXMgZGlzYWJsZWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtaWdyYXRlQXBpS2V5KFwiYW50aHJvcGljXCIsIFwiY2xhdWRlLWtleS0xMjNcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGlzRmVhdHVyZUVuYWJsZWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwidXNlU2VjdXJlQXBpU3RvcmFnZVwiKTtcbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3Qoc3RvcmVTZXNzaW9uSWQpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QoY29uc29sZS5sb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIlNlY3VyZSBBUEkgc3RvcmFnZSBpcyBub3QgZW5hYmxlZCwgc2tpcHBpbmcgbWlncmF0aW9uXCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgQVBJIHJlc3BvbnNlIGZhaWx1cmUgZ3JhY2VmdWxseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAoaXNGZWF0dXJlRW5hYmxlZCBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBBUEkga2V5IGZvcm1hdFwiLFxuICAgICAgICB9KSxcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtaWdyYXRlQXBpS2V5KFwiZ29vZ2xlXCIsIFwiaW52YWxpZC1rZXlcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KHN0b3JlU2Vzc2lvbklkKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkZhaWxlZCB0byBtaWdyYXRlIEFQSSBrZXkgZm9yIGdvb2dsZTpcIixcbiAgICAgICAgXCJJbnZhbGlkIEFQSSBrZXkgZm9ybWF0XCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgQVBJIHJlc3BvbnNlIHdpdGggbWlzc2luZyBzZXNzaW9uSWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIC8vIHNlc3Npb25JZCBtaXNzaW5nXG4gICAgICAgIH0pLFxuICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZ3JhdGVBcGlLZXkoXCJtaXN0cmFsXCIsIFwibWlzdHJhbC1rZXktMTIzXCIpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChzdG9yZVNlc3Npb25JZCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJGYWlsZWQgdG8gbWlncmF0ZSBBUEkga2V5IGZvciBtaXN0cmFsOlwiLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZmV0Y2ggbmV0d29yayBlcnJvcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRmV0Y2gubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcihcIk5ldHdvcmsgZXJyb3JcIikpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtaWdyYXRlQXBpS2V5KFwicGVycGxleGl0eVwiLCBcInBwbHgta2V5LTEyM1wiKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3Qoc3RvcmVTZXNzaW9uSWQpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QoY29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiRXJyb3IgbWlncmF0aW5nIEFQSSBrZXkgZm9yIHBlcnBsZXhpdHk6XCIsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIEpTT04gcGFyc2luZyBlcnJvcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSlNPTlwiKTtcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtaWdyYXRlQXBpS2V5KFwiY29oZXJlXCIsIFwiY29oZXJlLWtleS0xMjNcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHN0b3JlU2Vzc2lvbklkKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkVycm9yIG1pZ3JhdGluZyBBUEkga2V5IGZvciBjb2hlcmU6XCIsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGRpZmZlcmVudCBwcm92aWRlciBuYW1lcyBjb3JyZWN0bHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHByb3ZpZGVycyA9IFtcbiAgICAgICAgXCJvcGVuYWlcIixcbiAgICAgICAgXCJhbnRocm9waWNcIixcbiAgICAgICAgXCJnb29nbGVcIixcbiAgICAgICAgXCJtaXN0cmFsXCIsXG4gICAgICAgIFwiY3VzdG9tLXByb3ZpZGVyXCIsXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIHByb3ZpZGVycykge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHNlc3Npb25JZDogYHNlc3Npb24tJHtwcm92aWRlcn0tMTIzYCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWlncmF0ZUFwaUtleShwcm92aWRlciwgYCR7cHJvdmlkZXJ9LWtleS0xMjNgKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBcIi9hcGkvYXBpLWtleS9zdG9yZVwiLFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIGFwaUtleTogYCR7cHJvdmlkZXJ9LWtleS0xMjNgLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChzdG9yZVNlc3Npb25JZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgYHNlc3Npb24tJHtwcm92aWRlcn0tMTIzYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGVtcHR5IGFuZCBzcGVjaWFsIGNoYXJhY3RlciBpbnB1dHNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHNlc3Npb25JZDogXCJ0ZXN0LXNlc3Npb25cIixcbiAgICAgICAgfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3Qgc3BlY2lhbElucHV0cyA9IFtcbiAgICAgICAgeyBwcm92aWRlcjogXCJcIiwgYXBpS2V5OiBcIlwiIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlcjogXCJwcm92aWRlciB3aXRoIHNwYWNlc1wiLFxuICAgICAgICAgIGFwaUtleTogXCJrZXktd2l0aC1zcGVjaWFsLWNoYXJzIUAjJCVcIixcbiAgICAgICAgfSxcbiAgICAgICAgeyBwcm92aWRlcjogXCJ1bmljb2RlLXByb3ZpZGVyLfCfmoBcIiwgYXBpS2V5OiBcInVuaWNvZGUta2V5LcOxw6HDqcOtw7PDulwiIH0sXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHsgcHJvdmlkZXIsIGFwaUtleSB9IG9mIHNwZWNpYWxJbnB1dHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWlncmF0ZUFwaUtleShwcm92aWRlciwgYXBpS2V5KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgXCIvYXBpL2FwaS1rZXkvc3RvcmVcIixcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHByb3ZpZGVyLCBhcGlLZXkgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlIGZ1bmN0aW9uXCIsICgpID0+IHtcbiAgICB0ZXN0KFwicmV0dXJucyBwcm92aWRlcnMgd2hlbiBBUEkga2V5cyBmb3VuZCBpbiBsb2NhbFN0b3JhZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NldHRpbmdzID0ge1xuICAgICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgICAgYXBpS2V5OiBcInNrLXRlc3QxMjNcIixcbiAgICAgICAgbW9kZWw6IFwiZ3B0LTRcIixcbiAgICAgIH07XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KG1vY2tTZXR0aW5ncykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXCJvcGVuYWlcIl0pO1xuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJsbG0tc2V0dGluZ3NcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmV0dXJucyBlbXB0eSBhcnJheSB3aGVuIG5vIHNldHRpbmdzIGluIGxvY2FsU3RvcmFnZVwiLCAoKSA9PiB7XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcImxsbS1zZXR0aW5nc1wiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJyZXR1cm5zIGVtcHR5IGFycmF5IHdoZW4gc2V0dGluZ3MgZXhpc3QgYnV0IG5vIEFQSSBrZXlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NldHRpbmdzID0ge1xuICAgICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgICAgbW9kZWw6IFwiZ3B0LTRcIixcbiAgICAgICAgLy8gTm8gYXBpS2V5XG4gICAgICB9O1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShtb2NrU2V0dGluZ3MpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInJldHVybnMgZW1wdHkgYXJyYXkgd2hlbiBzZXR0aW5ncyBleGlzdCBidXQgbm8gcHJvdmlkZXJcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NldHRpbmdzID0ge1xuICAgICAgICBhcGlLZXk6IFwic2stdGVzdDEyM1wiLFxuICAgICAgICBtb2RlbDogXCJncHQtNFwiLFxuICAgICAgICAvLyBObyBwcm92aWRlclxuICAgICAgfTtcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoSlNPTi5zdHJpbmdpZnkobW9ja1NldHRpbmdzKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGludmFsaWQgSlNPTiBpbiBsb2NhbFN0b3JhZ2UgZ3JhY2VmdWxseVwiLCAoKSA9PiB7XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKFwiaW52YWxpZC1qc29uXCIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVja0ZvckFwaUtleXNUb01pZ3JhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QoY29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiRXJyb3IgY2hlY2tpbmcgZm9yIEFQSSBrZXlzIHRvIG1pZ3JhdGU6XCIsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGxvY2FsU3RvcmFnZSBhY2Nlc3MgZXJyb3JzIGdyYWNlZnVsbHlcIiwgKCkgPT4ge1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJFcnJvciBjaGVja2luZyBmb3IgQVBJIGtleXMgdG8gbWlncmF0ZTpcIixcbiAgICAgICAgZXhwZWN0LmFueShFcnJvciksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgZGlmZmVyZW50IHByb3ZpZGVyIHR5cGVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVycyA9IFtcIm9wZW5haVwiLCBcImFudGhyb3BpY1wiLCBcImdvb2dsZVwiLCBcIm1pc3RyYWxcIiwgXCJjdXN0b21cIl07XG5cbiAgICAgIHByb3ZpZGVycy5mb3JFYWNoKChwcm92aWRlcikgPT4ge1xuICAgICAgICBjb25zdCBtb2NrU2V0dGluZ3MgPSB7XG4gICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgYXBpS2V5OiBgJHtwcm92aWRlcn0ta2V5LTEyM2AsXG4gICAgICAgICAgbW9kZWw6IFwidGVzdC1tb2RlbFwiLFxuICAgICAgICB9O1xuICAgICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KG1vY2tTZXR0aW5ncykpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW3Byb3ZpZGVyXSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIGVkZ2UgY2FzZSBzZXR0aW5ncyBzdHJ1Y3R1cmVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGVkZ2VDYXNlU2V0dGluZ3MgPSBbXG4gICAgICAgIC8vIEVtcHR5IG9iamVjdHNcbiAgICAgICAge30sXG4gICAgICAgIC8vIE51bGwgdmFsdWVzXG4gICAgICAgIHsgcHJvdmlkZXI6IG51bGwsIGFwaUtleTogbnVsbCB9LFxuICAgICAgICAvLyBFbXB0eSBzdHJpbmdzXG4gICAgICAgIHsgcHJvdmlkZXI6IFwiXCIsIGFwaUtleTogXCJcIiB9LFxuICAgICAgICAvLyBVbmRlZmluZWQgdmFsdWVzXG4gICAgICAgIHsgcHJvdmlkZXI6IHVuZGVmaW5lZCwgYXBpS2V5OiB1bmRlZmluZWQgfSxcbiAgICAgICAgLy8gTWl4ZWQgdmFsaWQvaW52YWxpZFxuICAgICAgICB7IHByb3ZpZGVyOiBcIm9wZW5haVwiLCBhcGlLZXk6IG51bGwgfSxcbiAgICAgICAgeyBwcm92aWRlcjogbnVsbCwgYXBpS2V5OiBcInNrLXRlc3QxMjNcIiB9LFxuICAgICAgXTtcblxuICAgICAgZWRnZUNhc2VTZXR0aW5ncy5mb3JFYWNoKChzZXR0aW5ncykgPT4ge1xuICAgICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrRm9yQXBpS2V5c1RvTWlncmF0ZSgpO1xuICAgICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShyZXN1bHQpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwibWlncmF0ZUFsbEFwaUtleXMgZnVuY3Rpb25cIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzdWNjZXNzZnVsbHkgbWlncmF0ZXMgYWxsIGZvdW5kIEFQSSBrZXlzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICAgIGFwaUtleTogXCJzay10ZXN0MTIzXCIsXG4gICAgICAgIG1vZGVsOiBcImdwdC00XCIsXG4gICAgICB9O1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShtb2NrU2V0dGluZ3MpKTtcbiAgICAgIChpc0ZlYXR1cmVFbmFibGVkIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBzZXNzaW9uSWQ6IFwidGVzdC1zZXNzaW9uLTEyM1wiLFxuICAgICAgICB9KSxcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtaWdyYXRlQWxsQXBpS2V5cygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcIm9wZW5haVwiXSk7XG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3Qoc3RvcmVTZXNzaW9uSWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwib3BlbmFpXCIsIFwidGVzdC1zZXNzaW9uLTEyM1wiKTtcblxuICAgICAgLy8gVmVyaWZ5IGxvY2FsU3RvcmFnZSB3YXMgdXBkYXRlZCB0byByZW1vdmUgQVBJIGtleVxuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwibGxtLXNldHRpbmdzXCIsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgICAgICBhcGlLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgICBtb2RlbDogXCJncHQtNFwiLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwicmV0dXJucyBlbXB0eSBhcnJheSB3aGVuIG5vIEFQSSBrZXlzIHRvIG1pZ3JhdGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWlncmF0ZUFsbEFwaUtleXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QobW9ja0ZldGNoKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KHN0b3JlU2Vzc2lvbklkKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG1pZ3JhdGlvbiBmYWlsdXJlIGdyYWNlZnVsbHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NldHRpbmdzID0ge1xuICAgICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgICAgYXBpS2V5OiBcInNrLXRlc3QxMjNcIixcbiAgICAgICAgbW9kZWw6IFwiZ3B0LTRcIixcbiAgICAgIH07XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KG1vY2tTZXR0aW5ncykpO1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpOyAvLyBGZWF0dXJlIGRpc2FibGVkXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZ3JhdGVBbGxBcGlLZXlzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIHBhcnRpYWwgbWlncmF0aW9uIHN1Y2Nlc3NcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NldHRpbmdzID0ge1xuICAgICAgICBwcm92aWRlcjogXCJhbnRocm9waWNcIixcbiAgICAgICAgYXBpS2V5OiBcImNsYXVkZS1rZXktMTIzXCIsXG4gICAgICAgIG1vZGVsOiBcImNsYXVkZS0zXCIsXG4gICAgICB9O1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShtb2NrU2V0dGluZ3MpKTtcbiAgICAgIChpc0ZlYXR1cmVFbmFibGVkIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogXCJTZXJ2ZXIgZXJyb3JcIixcbiAgICAgICAgfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWlncmF0ZUFsbEFwaUtleXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImhhbmRsZXMgbG9jYWxTdG9yYWdlIGVycm9ycyBkdXJpbmcgbWlncmF0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IFwiZ29vZ2xlXCIsXG4gICAgICAgIGFwaUtleTogXCJnb29nbGUta2V5LTEyM1wiLFxuICAgICAgfTtcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoSlNPTi5zdHJpbmdpZnkobW9ja1NldHRpbmdzKSk7XG4gICAgICAoaXNGZWF0dXJlRW5hYmxlZCBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgc2Vzc2lvbklkOiBcInRlc3Qtc2Vzc2lvbi0xMjNcIixcbiAgICAgICAgfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgLy8gTWFrZSBzZXRJdGVtIHRocm93IGFuIGVycm9yXG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0ubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9jYWxTdG9yYWdlIHdyaXRlIGVycm9yXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZ3JhdGVBbGxBcGlLZXlzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KGNvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkVycm9yIG1pZ3JhdGluZyBhbGwgQVBJIGtleXM6XCIsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG5ldHdvcmsgZXJyb3JzIGR1cmluZyBidWxrIG1pZ3JhdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2V0dGluZ3MgPSB7XG4gICAgICAgIHByb3ZpZGVyOiBcIm1pc3RyYWxcIixcbiAgICAgICAgYXBpS2V5OiBcIm1pc3RyYWwta2V5LTEyM1wiLFxuICAgICAgfTtcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoSlNPTi5zdHJpbmdpZnkobW9ja1NldHRpbmdzKSk7XG4gICAgICAoaXNGZWF0dXJlRW5hYmxlZCBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKFwiTmV0d29yayBmYWlsdXJlXCIpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWlncmF0ZUFsbEFwaUtleXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkVycm9yIG1pZ3JhdGluZyBhbGwgQVBJIGtleXM6XCIsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJoYW5kbGVzIG1hbGZvcm1lZCBzZXR0aW5ncyBkdXJpbmcgbWlncmF0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoXCJpbnZhbGlkLWpzb25cIik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZ3JhdGVBbGxBcGlLZXlzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KGNvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIkVycm9yIG1pZ3JhdGluZyBhbGwgQVBJIGtleXM6XCIsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJwcmVzZXJ2ZXMgb3RoZXIgc2V0dGluZ3Mgd2hlbiByZW1vdmluZyBBUEkga2V5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IFwicGVycGxleGl0eVwiLFxuICAgICAgICBhcGlLZXk6IFwicHBseC1rZXktMTIzXCIsXG4gICAgICAgIG1vZGVsOiBcInBwbHgtNzBiLW9ubGluZVwiLFxuICAgICAgICB0ZW1wZXJhdHVyZTogMC43LFxuICAgICAgICBtYXhUb2tlbnM6IDEwMDAsXG4gICAgICAgIGN1c3RvbVNldHRpbmdzOiB7XG4gICAgICAgICAgc3RyZWFtaW5nOiB0cnVlLFxuICAgICAgICAgIHNhZmVNb2RlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KG1vY2tTZXR0aW5ncykpO1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHNlc3Npb25JZDogXCJ0ZXN0LXNlc3Npb24tMTIzXCIsXG4gICAgICAgIH0pLFxuICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZ3JhdGVBbGxBcGlLZXlzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1wicGVycGxleGl0eVwiXSk7XG5cbiAgICAgIGNvbnN0IGV4cGVjdGVkVXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgICBwcm92aWRlcjogXCJwZXJwbGV4aXR5XCIsXG4gICAgICAgIGFwaUtleTogdW5kZWZpbmVkLFxuICAgICAgICBtb2RlbDogXCJwcGx4LTcwYi1vbmxpbmVcIixcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICAgICAgbWF4VG9rZW5zOiAxMDAwLFxuICAgICAgICBjdXN0b21TZXR0aW5nczoge1xuICAgICAgICAgIHN0cmVhbWluZzogdHJ1ZSxcbiAgICAgICAgICBzYWZlTW9kZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCJsbG0tc2V0dGluZ3NcIixcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRVcGRhdGVkU2V0dGluZ3MpLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJlcnJvciBoYW5kbGluZyBhbmQgZWRnZSBjYXNlc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcImZ1bmN0aW9ucyBoYW5kbGUgY29uY3VycmVudCBjYWxscyBzYWZlbHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NldHRpbmdzID0ge1xuICAgICAgICBwcm92aWRlcjogXCJvcGVuYWlcIixcbiAgICAgICAgYXBpS2V5OiBcInNrLXRlc3QxMjNcIixcbiAgICAgIH07XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKEpTT04uc3RyaW5naWZ5KG1vY2tTZXR0aW5ncykpO1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgc2Vzc2lvbklkOiBcInRlc3Qtc2Vzc2lvbi0xMjNcIixcbiAgICAgICAgfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgLy8gUnVuIG11bHRpcGxlIG9wZXJhdGlvbnMgY29uY3VycmVudGx5XG4gICAgICBjb25zdCBvcGVyYXRpb25zID0gW1xuICAgICAgICBtaWdyYXRlQXBpS2V5KFwib3BlbmFpXCIsIFwic2stdGVzdDEyM1wiKSxcbiAgICAgICAgbWlncmF0ZUFsbEFwaUtleXMoKSxcbiAgICAgICAgY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlKCksXG4gICAgICAgIG1pZ3JhdGVBcGlLZXkoXCJhbnRocm9waWNcIiwgXCJjbGF1ZGUta2V5LTEyM1wiKSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChvcGVyYXRpb25zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCg0KTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJmdW5jdGlvbnMgaGFuZGxlIG1lbW9yeSBjb25zdHJhaW50c1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZUFwaUtleSA9IFwieFwiLnJlcGVhdCgxMDAwMCk7XG4gICAgICBjb25zdCBsYXJnZVByb3ZpZGVyID0gXCJ5XCIucmVwZWF0KDEwMDApO1xuXG4gICAgICAoaXNGZWF0dXJlRW5hYmxlZCBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgc2Vzc2lvbklkOiBcInRlc3Qtc2Vzc2lvbi0xMjNcIixcbiAgICAgICAgfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWlncmF0ZUFwaUtleShsYXJnZVByb3ZpZGVyLCBsYXJnZUFwaUtleSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgXCIvYXBpL2FwaS1rZXkvc3RvcmVcIixcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiBsYXJnZVByb3ZpZGVyLFxuICAgICAgICAgICAgYXBpS2V5OiBsYXJnZUFwaUtleSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcImZ1bmN0aW9ucyBtYWludGFpbiBzdGF0ZSBjb25zaXN0ZW5jeSBkdXJpbmcgZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXR0aW5ncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICAgIGFwaUtleTogXCJzay10ZXN0MTIzXCIsXG4gICAgICB9O1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShtb2NrU2V0dGluZ3MpKTtcbiAgICAgIChpc0ZlYXR1cmVFbmFibGVkIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICAvLyBGaXJzdCBjYWxsIHN1Y2NlZWRzLCBzZWNvbmQgZmFpbHNcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHNlc3Npb25JZDogXCJ0ZXN0LXNlc3Npb24tMTIzXCIsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0gYXMgUmVzcG9uc2UpXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKFwiTmV0d29yayBlcnJvclwiKSk7XG5cbiAgICAgIGNvbnN0IGZpcnN0UmVzdWx0ID0gYXdhaXQgbWlncmF0ZUFsbEFwaUtleXMoKTtcbiAgICAgIGNvbnN0IHNlY29uZFJlc3VsdCA9IGF3YWl0IG1pZ3JhdGVBbGxBcGlLZXlzKCk7XG5cbiAgICAgIGV4cGVjdChmaXJzdFJlc3VsdCkudG9FcXVhbChbXCJvcGVuYWlcIl0pO1xuICAgICAgZXhwZWN0KHNlY29uZFJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwicGVyZm9ybWFuY2UgYW5kIHJlbGlhYmlsaXR5XCIsICgpID0+IHtcbiAgICB0ZXN0KFwiaGFuZGxlcyByYXBpZCBzdWNjZXNzaXZlIGNhbGxzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIChpc0ZlYXR1cmVFbmFibGVkIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHNlc3Npb25JZDogXCJ0ZXN0LXNlc3Npb24tMTIzXCIsXG4gICAgICAgIH0pLFxuICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJhcGlkQ2FsbHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+XG4gICAgICAgIG1pZ3JhdGVBcGlLZXkoYHByb3ZpZGVyLSR7aX1gLCBga2V5LSR7aX1gKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChyYXBpZENhbGxzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCgxMDApO1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInZhbGlkYXRlcyBpbnB1dCBzYW5pdGl6YXRpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKGlzRmVhdHVyZUVuYWJsZWQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHNlc3Npb25JZDogXCJ0ZXN0LXNlc3Npb24tMTIzXCIsXG4gICAgICAgIH0pLFxuICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IG1hbGljaW91c0lucHV0cyA9IFtcbiAgICAgICAgeyBwcm92aWRlcjogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD4nLCBhcGlLZXk6IFwibm9ybWFsLWtleVwiIH0sXG4gICAgICAgIHsgcHJvdmlkZXI6IFwibm9ybWFsLXByb3ZpZGVyXCIsIGFwaUtleTogXCJEUk9QIFRBQkxFIHVzZXJzO1wiIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlcjogXCIke3Byb2Nlc3MuZW52LlNFQ1JFVH1cIixcbiAgICAgICAgICBhcGlLZXk6IFwiI3tldmFsKGRhbmdlcm91c19jb2RlKX1cIixcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgeyBwcm92aWRlciwgYXBpS2V5IH0gb2YgbWFsaWNpb3VzSW5wdXRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZ3JhdGVBcGlLZXkocHJvdmlkZXIsIGFwaUtleSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoZSBpbnB1dHMgd2VyZSBwYXNzZWQgdGhyb3VnaCB3aXRob3V0IG1vZGlmaWNhdGlvblxuICAgICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBcIi9hcGkvYXBpLWtleS9zdG9yZVwiLFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcHJvdmlkZXIsIGFwaUtleSB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInN0b3JlU2Vzc2lvbklkIiwiZm4iLCJpc0ZlYXR1cmVFbmFibGVkIiwibW9ja0ZldGNoIiwiZ2xvYmFsIiwiZmV0Y2giLCJtb2NrTG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiY2xlYXIiLCJsZW5ndGgiLCJrZXkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndpbmRvdyIsInZhbHVlIiwid3JpdGFibGUiLCJvcmlnaW5hbENvbnNvbGUiLCJjb25zb2xlIiwiYmVmb3JlQWxsIiwibG9nIiwiZXJyb3IiLCJ3YXJuIiwiaW5mbyIsImFmdGVyQWxsIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsInRlc3QiLCJtb2NrUmV0dXJuVmFsdWUiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJqc29uIiwic3VjY2VzcyIsInNlc3Npb25JZCIsInJlc3VsdCIsIm1pZ3JhdGVBcGlLZXkiLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcm92aWRlciIsImFwaUtleSIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwiRXJyb3IiLCJhbnkiLCJwcm92aWRlcnMiLCJvYmplY3RDb250YWluaW5nIiwic3BlY2lhbElucHV0cyIsIm1vY2tTZXR0aW5ncyIsIm1vZGVsIiwiY2hlY2tGb3JBcGlLZXlzVG9NaWdyYXRlIiwidG9FcXVhbCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImZvckVhY2giLCJlZGdlQ2FzZVNldHRpbmdzIiwic2V0dGluZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJtaWdyYXRlQWxsQXBpS2V5cyIsInRlbXBlcmF0dXJlIiwibWF4VG9rZW5zIiwiY3VzdG9tU2V0dGluZ3MiLCJzdHJlYW1pbmciLCJzYWZlTW9kZSIsImV4cGVjdGVkVXBkYXRlZFNldHRpbmdzIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJvcGVyYXRpb25zIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJ0b0hhdmVMZW5ndGgiLCJ0b0JlRGVmaW5lZCIsImxhcmdlQXBpS2V5IiwicmVwZWF0IiwibGFyZ2VQcm92aWRlciIsImZpcnN0UmVzdWx0Iiwic2Vjb25kUmVzdWx0IiwicmFwaWRDYWxscyIsImZyb20iLCJfIiwiaSIsIm1hbGljaW91c0lucHV0cyJdLCJtYXBwaW5n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