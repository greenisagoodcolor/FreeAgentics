{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/lib/autonomous-conversation.ts"],"sourcesContent":["import type {\n  Agent,\n  Conversation,\n  Message,\n  Position,\n  KnowledgeEntry,\n} from \"@/lib/types\";\nimport { KnowledgeRetriever } from \"@/lib/knowledge-retriever\";\n\n// Types for autonomous conversation triggers\nexport type TriggerType =\n  | \"proximity\"\n  | \"knowledge_overlap\"\n  | \"scheduled\"\n  | \"user_initiated\"\n  | \"continuation\";\n\nexport interface TriggerContext {\n  agents: Agent[];\n  location?: Position;\n  knowledgeEntries?: KnowledgeEntry[];\n  previousConversation?: Conversation;\n  topic?: string;\n}\n\nexport interface AutonomousConversationOptions {\n  // Minimum distance for proximity-based conversations\n  proximityThreshold: number;\n\n  // Minimum knowledge overlap score to trigger a conversation\n  knowledgeOverlapThreshold: number;\n\n  // Maximum number of autonomous conversations that can happen simultaneously\n  maxSimultaneousConversations: number;\n\n  // Cooldown period (in ms) before an agent can participate in another autonomous conversation\n  conversationCooldown: number;\n\n  // Maximum duration (in ms) for an autonomous conversation before it's automatically ended\n  maxConversationDuration: number;\n\n  // Whether to enable scheduled conversations\n  enableScheduledConversations: boolean;\n\n  // Whether to enable knowledge-based triggers\n  enableKnowledgeBasedTriggers: boolean;\n\n  // Maximum messages before forced ending\n  maxAutonomousMessages: number;\n\n  // Additional properties needed by tests and advanced usage\n  maxTurns?: number;\n  agents?: Agent[];\n  autoTerminate?: boolean;\n}\n\n// Default options\nexport const defaultAutonomousOptions: AutonomousConversationOptions = {\n  proximityThreshold: 1, // Adjacent cells\n  knowledgeOverlapThreshold: 0.3, // 30% overlap\n  maxSimultaneousConversations: 1,\n  conversationCooldown: 5000, // Reduced from 60000 (1 minute) to 5000 (5 seconds) for testing\n  maxConversationDuration: 300000, // 5 minutes\n  enableScheduledConversations: false,\n  enableKnowledgeBasedTriggers: true,\n  maxAutonomousMessages: 4, // Default maximum of 4 messages\n};\n\nexport class AutonomousConversationSystem {\n  private options: AutonomousConversationOptions;\n  private knowledgeRetriever: KnowledgeRetriever;\n  private activeConversations: Set<string> = new Set();\n  private agentLastConversationTime: Map<string, number> = new Map();\n  private conversationTimeouts: Map<string, NodeJS.Timeout> = new Map();\n\n  constructor(options: Partial<AutonomousConversationOptions> = {}) {\n    this.options = { ...defaultAutonomousOptions, ...options };\n    this.knowledgeRetriever = new KnowledgeRetriever();\n  }\n\n  /**\n   * Updates the system options\n   */\n  updateOptions(options: Partial<AutonomousConversationOptions>): void {\n    this.options = { ...this.options, ...options };\n  }\n\n  /**\n   * Resets the cooldown for specific agents\n   */\n  resetCooldown(agentIds: string[]): void {\n    // /* USEFUL FOR PRODUCTION TESTING: Log cooldown reset */\n    // console.log(`Resetting cooldown for agents: ${agentIds.join(\", \")}`)\n    agentIds.forEach((id) => {\n      this.agentLastConversationTime.delete(id);\n    });\n  }\n\n  /**\n   * Checks if an autonomous conversation should be triggered based on agent proximity\n   */\n  checkProximityTrigger(agents: Agent[]): {\n    shouldTrigger: boolean;\n    participants: Agent[];\n  } {\n    // Filter agents that have autonomy enabled\n    const autonomousAgents = agents.filter((agent) => agent.autonomyEnabled);\n\n    // /* USEFUL FOR PRODUCTION TESTING: Log proximity check */\n    // console.log(\n    //   \"Checking proximity trigger with autonomous agents:\",\n    //   autonomousAgents.map(\n    //     (a) =>\n    //       `${a.name} (autonomy: ${a.autonomyEnabled ? \"enabled\" : \"disabled\"}, inConversation: ${a.inConversation ? \"yes\" : \"no\"}, position: ${a.position.x},${a.position.y})`,\n    //   ),\n    // )\n\n    // We need at least 2 autonomous agents to have a conversation\n    if (autonomousAgents.length < 2) {\n      // console.log(\"Not enough autonomous agents for proximity trigger\")\n      return { shouldTrigger: false, participants: [] };\n    }\n\n    // Check for agents that are close to each other\n    const agentGroups: Agent[][] = [];\n\n    // For each agent, find other agents within proximity threshold\n    for (const agent of autonomousAgents) {\n      // Skip agents already in a conversation\n      if (agent.inConversation) {\n        // console.log(`Agent ${agent.name} is already in a conversation, skipping`)\n        continue;\n      }\n\n      // Skip agents on cooldown\n      const lastConversationTime =\n        this.agentLastConversationTime.get(agent.id) || 0;\n      const timeSinceLastConversation = Date.now() - lastConversationTime;\n      const isOnCooldown =\n        timeSinceLastConversation < this.options.conversationCooldown;\n\n      if (isOnCooldown) {\n        // /* USEFUL FOR PRODUCTION TESTING: Log cooldown status */\n        // console.log(\n        //   `Agent ${agent.name} is on cooldown (${Math.round(timeSinceLastConversation / 1000)}s elapsed, cooldown: ${Math.round(this.options.conversationCooldown / 1000)}s), skipping`,\n        // )\n        continue;\n      }\n\n      const nearbyAgents = autonomousAgents.filter((otherAgent) => {\n        // Skip self, agents in conversation, and agents in conversation\n        if (otherAgent.id === agent.id || otherAgent.inConversation) {\n          return false;\n        }\n\n        const otherLastConversationTime =\n          this.agentLastConversationTime.get(otherAgent.id) || 0;\n        const otherTimeSinceLastConversation =\n          Date.now() - otherLastConversationTime;\n        const otherIsOnCooldown =\n          otherTimeSinceLastConversation < this.options.conversationCooldown;\n\n        if (otherIsOnCooldown) {\n          // /* USEFUL FOR PRODUCTION TESTING: Log nearby agent cooldown */\n          // console.log(\n          //   `Nearby agent ${otherAgent.name} is on cooldown (${Math.round(otherTimeSinceLastConversation / 1000)}s elapsed), skipping`,\n          // )\n          return false;\n        }\n\n        // Check if within proximity threshold\n        const distance = Math.sqrt(\n          Math.pow(agent.position.x - otherAgent.position.x, 2) +\n            Math.pow(agent.position.y - otherAgent.position.y, 2),\n        );\n\n        const isNearby = distance <= this.options.proximityThreshold;\n        if (isNearby) {\n          // /* USEFUL FOR PRODUCTION TESTING: Log nearby agent detection */\n          // console.log(\n          //   `Agent ${agent.name} is near ${otherAgent.name} (distance: ${distance.toFixed(2)}, threshold: ${this.options.proximityThreshold})`,\n          // )\n        }\n\n        return isNearby;\n      });\n\n      // If we found nearby agents, create a group\n      if (nearbyAgents.length > 0) {\n        // /* USEFUL FOR PRODUCTION TESTING: Log nearby agents found */\n        // console.log(\n        //   `Found nearby agents for ${agent.name}:`,\n        //   nearbyAgents.map((a) => a.name),\n        // )\n        agentGroups.push([agent, ...nearbyAgents]);\n      }\n    }\n\n    // If we found any groups, return the first one\n    if (agentGroups.length > 0) {\n      // Limit to a reasonable number of participants (2-3 is ideal for conversation)\n      const participants = agentGroups[0].slice(0, 3);\n      // /* USEFUL FOR PRODUCTION TESTING: Log proximity trigger success */\n      // console.log(\n      //   \"Proximity trigger successful with participants:\",\n      //   participants.map((a) => a.name),\n      // )\n      return { shouldTrigger: true, participants };\n    }\n\n    return { shouldTrigger: false, participants: [] };\n  }\n\n  /**\n   * Checks if an autonomous conversation should be triggered based on knowledge overlap\n   */\n  checkKnowledgeOverlapTrigger(agents: Agent[]): {\n    shouldTrigger: boolean;\n    participants: Agent[];\n    topic: string;\n  } {\n    // Only proceed if knowledge-based triggers are enabled\n    if (!this.options.enableKnowledgeBasedTriggers) {\n      return { shouldTrigger: false, participants: [], topic: \"\" };\n    }\n\n    // Filter agents that have autonomy enabled\n    const autonomousAgents = agents.filter((agent) => agent.autonomyEnabled);\n\n    // We need at least 2 autonomous agents to have a conversation\n    if (autonomousAgents.length < 2) {\n      return { shouldTrigger: false, participants: [], topic: \"\" };\n    }\n\n    // Find agents with overlapping knowledge\n    const agentPairs: {\n      agents: [Agent, Agent];\n      overlapScore: number;\n      topic: string;\n    }[] = [];\n\n    // Compare each pair of agents\n    for (let i = 0; i < autonomousAgents.length; i++) {\n      const agent1 = autonomousAgents[i];\n\n      // Skip agents already in a conversation\n      if (agent1.inConversation) continue;\n\n      // Skip agents on cooldown\n      const lastConversationTime1 =\n        this.agentLastConversationTime.get(agent1.id) || 0;\n      if (\n        Date.now() - lastConversationTime1 <\n        this.options.conversationCooldown\n      )\n        continue;\n\n      for (let j = i + 1; j < autonomousAgents.length; j++) {\n        const agent2 = autonomousAgents[j];\n\n        // Skip agents already in a conversation\n        if (agent2.inConversation) continue;\n\n        // Skip agents on cooldown\n        const lastConversationTime2 =\n          this.agentLastConversationTime.get(agent2.id) || 0;\n        if (\n          Date.now() - lastConversationTime2 <\n          this.options.conversationCooldown\n        )\n          continue;\n\n        // Calculate knowledge overlap\n        const { overlapScore, commonTags } = this.calculateKnowledgeOverlap(\n          agent1,\n          agent2,\n        );\n\n        if (\n          overlapScore >= this.options.knowledgeOverlapThreshold &&\n          commonTags.length > 0\n        ) {\n          // Choose a random common tag as the conversation topic\n          const topic =\n            commonTags[Math.floor(Math.random() * commonTags.length)];\n\n          agentPairs.push({\n            agents: [agent1, agent2],\n            overlapScore,\n            topic,\n          });\n        }\n      }\n    }\n\n    // Sort by overlap score (highest first)\n    agentPairs.sort((a, b) => b.overlapScore - a.overlapScore);\n\n    // If we found any pairs with sufficient overlap, return the highest scoring pair\n    if (agentPairs.length > 0) {\n      const { agents, topic } = agentPairs[0];\n      return { shouldTrigger: true, participants: agents, topic };\n    }\n\n    return { shouldTrigger: false, participants: [], topic: \"\" };\n  }\n\n  /**\n   * Calculates knowledge overlap between two agents\n   */\n  private calculateKnowledgeOverlap(\n    agent1: Agent,\n    agent2: Agent,\n  ): { overlapScore: number; commonTags: string[] } {\n    // Extract all tags from both agents' knowledge\n    const tags1 = new Set<string>();\n    const tags2 = new Set<string>();\n\n    agent1.knowledge.forEach((entry) => {\n      entry.tags.forEach((tag) => tags1.add(tag));\n    });\n\n    agent2.knowledge.forEach((entry) => {\n      entry.tags.forEach((tag) => tags2.add(tag));\n    });\n\n    // Find common tags\n    const commonTags: string[] = [];\n    tags1.forEach((tag) => {\n      if (tags2.has(tag)) {\n        commonTags.push(tag);\n      }\n    });\n\n    // Calculate overlap score\n    const totalUniqueTags = new Set([\n      ...Array.from(tags1),\n      ...Array.from(tags2),\n    ]).size;\n    const overlapScore =\n      totalUniqueTags > 0 ? commonTags.length / totalUniqueTags : 0;\n\n    return { overlapScore, commonTags };\n  }\n\n  /**\n   * Initiates an autonomous conversation between agents\n   */\n  initiateConversation(\n    participants: Agent[],\n    trigger: TriggerType,\n    topic?: string,\n  ): Conversation | null {\n    console.log(\n      `AUTONOMOUS SYSTEM: Initiating ${trigger} conversation between: ${participants.map((a) => a.name).join(\", \")}${topic ? ` about ${topic}` : \"\"}`,\n    );\n\n    // Check if we're at the maximum number of simultaneous conversations\n    if (\n      this.activeConversations.size >= this.options.maxSimultaneousConversations\n    ) {\n      console.log(\n        `AUTONOMOUS SYSTEM: Cannot initiate conversation: Maximum simultaneous conversations (${this.options.maxSimultaneousConversations}) reached`,\n      );\n      return null;\n    }\n\n    // Create a new conversation\n    const conversation: Conversation = {\n      id: `auto-conv-${Date.now()}`,\n      participants: participants.map((agent) => agent.id),\n      messages: [],\n      startTime: new Date(),\n      endTime: null,\n      isAutonomous: true,\n      trigger,\n    };\n\n    // Add a system message about the conversation start\n    const systemMessage: Message = {\n      id: `msg-system-${Date.now()}`,\n      content: this.generateConversationStartMessage(\n        participants,\n        trigger,\n        topic,\n      ),\n      senderId: \"system\",\n      timestamp: new Date(),\n      metadata: {\n        isSystemMessage: true,\n        type: \"conversation_starter\",\n      },\n    };\n\n    conversation.messages.push(systemMessage);\n\n    // Track this conversation\n    this.activeConversations.add(conversation.id);\n\n    // Update last conversation time for all participants\n    participants.forEach((agent) => {\n      this.agentLastConversationTime.set(agent.id, Date.now());\n      // /* USEFUL FOR PRODUCTION TESTING: Log cooldown set */\n      // console.log(`AUTONOMOUS SYSTEM: Set cooldown for ${agent.name} at ${new Date().toISOString()}`)\n    });\n\n    // Set a timeout to end the conversation after maxConversationDuration\n    const timeout = setTimeout(() => {\n      console.log(\n        `AUTONOMOUS SYSTEM: Conversation ${conversation.id} reached maximum duration, ending automatically`,\n      );\n      this.endConversation(conversation.id);\n    }, this.options.maxConversationDuration);\n\n    this.conversationTimeouts.set(conversation.id, timeout);\n\n    console.log(\n      `AUTONOMOUS SYSTEM: Conversation ${conversation.id} initiated successfully with ${participants.length} participants`,\n    );\n    return conversation;\n  }\n\n  /**\n   * Ends an autonomous conversation\n   */\n  endConversation(conversationId: string): void {\n    console.log(`Ending conversation ${conversationId}`);\n\n    // Remove from active conversations\n    this.activeConversations.delete(conversationId);\n\n    // Clear the timeout\n    const timeout = this.conversationTimeouts.get(conversationId);\n    if (timeout) {\n      clearTimeout(timeout);\n      this.conversationTimeouts.delete(conversationId);\n      console.log(`Cleared timeout for conversation ${conversationId}`);\n    }\n\n    console.log(`Conversation ${conversationId} ended successfully`);\n  }\n\n  /**\n   * Checks if a conversation should end based on message count\n   */\n  shouldEndConversation(conversation: Conversation): boolean {\n    // This method should only be called for autonomous conversations\n    if (!conversation || !conversation.isAutonomous) return false;\n\n    // Count non-system messages\n    const messageCount = conversation.messages.filter(\n      (msg) => !msg.metadata?.isSystemMessage,\n    ).length;\n\n    // Check if the conversation has reached the maximum message count\n    return messageCount >= this.options.maxAutonomousMessages;\n  }\n\n  /**\n   * Generates a system message for the start of an autonomous conversation\n   */\n  private generateConversationStartMessage(\n    participants: Agent[],\n    trigger: TriggerType,\n    topic?: string,\n  ): string {\n    const agentNames = participants.map((agent) => agent.name).join(\", \");\n\n    switch (trigger) {\n      case \"proximity\":\n        return `${agentNames} have encountered each other and started a conversation.`;\n\n      case \"knowledge_overlap\":\n        if (topic) {\n          return `${agentNames} have started a conversation about their shared knowledge of ${topic}.`;\n        }\n        return `${agentNames} have started a conversation about their shared knowledge.`;\n\n      case \"scheduled\":\n        return `${agentNames} have started a scheduled conversation.`;\n\n      case \"user_initiated\":\n        return `${agentNames} have been prompted to start a conversation.`;\n\n      case \"continuation\":\n        return `${agentNames} have continued their previous conversation.`;\n\n      default:\n        return `${agentNames} have started a conversation.`;\n    }\n  }\n\n  /**\n   * Suggests a topic for conversation based on agents' knowledge\n   */\n  suggestConversationTopic(agents: Agent[]): string | null {\n    // Extract all tags from all agents' knowledge\n    const tagCounts = new Map<string, number>();\n\n    agents.forEach((agent) => {\n      agent.knowledge.forEach((entry) => {\n        entry.tags.forEach((tag) => {\n          tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);\n        });\n      });\n    });\n\n    // Find tags that appear in multiple agents' knowledge\n    const commonTags: [string, number][] = [];\n    tagCounts.forEach((count, tag) => {\n      if (count >= 2) {\n        // At least 2 agents have this tag\n        commonTags.push([tag, count]);\n      }\n    });\n\n    // Sort by frequency (highest first)\n    commonTags.sort((a, b) => b[1] - a[1]);\n\n    // Return the most common tag, or null if none found\n    return commonTags.length > 0 ? commonTags[0][0] : null;\n  }\n\n  /**\n   * Checks all possible triggers and returns the first one that should trigger a conversation\n   */\n  checkAllTriggers(agents: Agent[]): {\n    shouldTrigger: boolean;\n    participants: Agent[];\n    trigger: TriggerType;\n    topic?: string;\n  } {\n    // /* USEFUL FOR PRODUCTION TESTING: Log trigger check */\n    // console.log(\"Checking all autonomous conversation triggers\")\n\n    // Check proximity trigger\n    const proximityResult = this.checkProximityTrigger(agents);\n    if (proximityResult.shouldTrigger) {\n      const topic = this.suggestConversationTopic(proximityResult.participants);\n      return {\n        ...proximityResult,\n        trigger: \"proximity\",\n        topic: topic ?? undefined,\n      };\n    }\n\n    // Check knowledge overlap trigger\n    const knowledgeResult = this.checkKnowledgeOverlapTrigger(agents);\n    if (knowledgeResult.shouldTrigger) {\n      return {\n        ...knowledgeResult,\n        trigger: \"knowledge_overlap\",\n      };\n    }\n\n    // No triggers matched\n    return { shouldTrigger: false, participants: [], trigger: \"proximity\" };\n  }\n\n  /**\n   * Checks if a conversation has reached minimum depth\n   */\n  hasReachedMinimumDepth(conversation: Conversation): boolean {\n    // Always return true since we're not using minimum depth anymore\n    return true;\n  }\n\n  // Methods expected by tests\n  getState(): any {\n    return {\n      messages: [],\n      agents: [],\n      activeConversations: this.activeConversations,\n      options: this.options,\n    };\n  }\n\n  getDynamics(): any {\n    return {\n      turnTaking: \"round-robin\",\n      responseCoordination: \"sequential\",\n    };\n  }\n\n  setTurnTakingStrategy(strategy: string): void {\n    // Store strategy (implementation would handle different strategies)\n  }\n\n  async selectNextSpeaker(): Promise<Agent> {\n    // Return a mock agent for tests\n    return {\n      id: \"test-agent\",\n      name: \"Test Agent\",\n      inConversation: false,\n      position: { x: 0, y: 0 },\n      color: \"#000\",\n      knowledge: [],\n      autonomyEnabled: true,\n    };\n  }\n\n  async recordTurn(agentId: string, message: string): Promise<void> {\n    // Record the turn (implementation would store in conversation state)\n  }\n\n  async waitForResponse(agentId: string, timeout: number): Promise<any> {\n    // Wait for agent response with timeout\n    return Promise.resolve();\n  }\n\n  async getAvailableAgents(): Promise<Agent[]> {\n    return [];\n  }\n\n  async resolveDeadlock(): Promise<any> {\n    return { resolved: true };\n  }\n\n  addMessage(message: any): void {\n    // Add message to conversation state\n  }\n\n  evaluateTopicCoherence(): number {\n    return 0.8;\n  }\n\n  setRules(rules: any[]): void {\n    // Set conversation rules\n  }\n\n  validateResponse(response: any): boolean {\n    return true;\n  }\n\n  async canAgentSpeak(agentId: string): Promise<boolean> {\n    return true;\n  }\n\n  async coordinateResponse(coordination: any): Promise<any> {\n    return { coordinated: true };\n  }\n\n  async resolveConflict(conflict: any): Promise<any> {\n    return { resolved: true };\n  }\n}\n\n// Export legacy names for compatibility\nexport const AutonomousConversationManager = AutonomousConversationSystem;\nexport const createAutonomousConversation = (\n  options: AutonomousConversationOptions,\n) => new AutonomousConversationSystem(options);\n\n// Export types for tests\nexport type ConversationConfig = AutonomousConversationOptions;\nexport type ConversationState = any; // Simplified for now\nexport type AgentParticipant = Agent;\nexport type { Message } from \"@/lib/types\";\nexport type ConversationDynamics = any; // Simplified for now\nexport type TurnTakingStrategy = string;\nexport type ResponseCoordination = any; // Simplified for now\n\n// Export placeholder functions for tests\nexport const orchestrateConversation = (manager: any, options: any) =>\n  Promise.resolve({\n    messages: [],\n    participants: [],\n    duration: 0,\n  });\n\nexport const evaluateConversationQuality = (state: any) => ({\n  overall: 0.5,\n  recommendations: [\"improve clarity\", \"enhance engagement\"],\n});\n\nexport const detectEmergentPatterns = (state: any) => [];\nexport const applyConversationRules = () => {};\n\nexport const generateAgentResponse = (context: any) =>\n  Promise.resolve({\n    content: \"Generated response\",\n    agentId: context?.currentSpeaker?.id || \"unknown\",\n    timestamp: Date.now(),\n  });\n"],"names":["AutonomousConversationManager","AutonomousConversationSystem","applyConversationRules","createAutonomousConversation","defaultAutonomousOptions","detectEmergentPatterns","evaluateConversationQuality","generateAgentResponse","orchestrateConversation","proximityThreshold","knowledgeOverlapThreshold","maxSimultaneousConversations","conversationCooldown","maxConversationDuration","enableScheduledConversations","enableKnowledgeBasedTriggers","maxAutonomousMessages","constructor","options","activeConversations","Set","agentLastConversationTime","Map","conversationTimeouts","knowledgeRetriever","KnowledgeRetriever","updateOptions","resetCooldown","agentIds","forEach","id","delete","checkProximityTrigger","agents","autonomousAgents","filter","agent","autonomyEnabled","length","shouldTrigger","participants","agentGroups","inConversation","lastConversationTime","get","timeSinceLastConversation","Date","now","isOnCooldown","nearbyAgents","otherAgent","otherLastConversationTime","otherTimeSinceLastConversation","otherIsOnCooldown","distance","Math","sqrt","pow","position","x","y","isNearby","push","slice","checkKnowledgeOverlapTrigger","topic","agentPairs","i","agent1","lastConversationTime1","j","agent2","lastConversationTime2","overlapScore","commonTags","calculateKnowledgeOverlap","floor","random","sort","a","b","tags1","tags2","knowledge","entry","tags","tag","add","has","totalUniqueTags","Array","from","size","initiateConversation","trigger","console","log","map","name","join","conversation","messages","startTime","endTime","isAutonomous","systemMessage","content","generateConversationStartMessage","senderId","timestamp","metadata","isSystemMessage","type","set","timeout","setTimeout","endConversation","conversationId","clearTimeout","shouldEndConversation","messageCount","msg","agentNames","suggestConversationTopic","tagCounts","count","checkAllTriggers","proximityResult","undefined","knowledgeResult","hasReachedMinimumDepth","getState","getDynamics","turnTaking","responseCoordination","setTurnTakingStrategy","strategy","selectNextSpeaker","color","recordTurn","agentId","message","waitForResponse","Promise","resolve","getAvailableAgents","resolveDeadlock","resolved","addMessage","evaluateTopicCoherence","setRules","rules","validateResponse","response","canAgentSpeak","coordinateResponse","coordination","coordinated","resolveConflict","conflict","manager","duration","state","overall","recommendations","context","currentSpeaker"],"mappings":"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"}