045a9ff2a6e95a1d4a6338351ddef02e
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AutonomousConversationManager: function() {
        return AutonomousConversationManager;
    },
    AutonomousConversationSystem: function() {
        return AutonomousConversationSystem;
    },
    applyConversationRules: function() {
        return applyConversationRules;
    },
    createAutonomousConversation: function() {
        return createAutonomousConversation;
    },
    defaultAutonomousOptions: function() {
        return defaultAutonomousOptions;
    },
    detectEmergentPatterns: function() {
        return detectEmergentPatterns;
    },
    evaluateConversationQuality: function() {
        return evaluateConversationQuality;
    },
    generateAgentResponse: function() {
        return generateAgentResponse;
    },
    orchestrateConversation: function() {
        return orchestrateConversation;
    }
});
const _knowledgeretriever = require("./knowledge-retriever");
const defaultAutonomousOptions = {
    proximityThreshold: 1,
    knowledgeOverlapThreshold: 0.3,
    maxSimultaneousConversations: 1,
    conversationCooldown: 5000,
    maxConversationDuration: 300000,
    enableScheduledConversations: false,
    enableKnowledgeBasedTriggers: true,
    maxAutonomousMessages: 4
};
class AutonomousConversationSystem {
    constructor(options = {}){
        this.activeConversations = new Set();
        this.agentLastConversationTime = new Map();
        this.conversationTimeouts = new Map();
        this.options = {
            ...defaultAutonomousOptions,
            ...options
        };
        this.knowledgeRetriever = new _knowledgeretriever.KnowledgeRetriever();
    }
    /**
   * Updates the system options
   */ updateOptions(options) {
        this.options = {
            ...this.options,
            ...options
        };
    }
    /**
   * Resets the cooldown for specific agents
   */ resetCooldown(agentIds) {
        // /* USEFUL FOR PRODUCTION TESTING: Log cooldown reset */
        // console.log(`Resetting cooldown for agents: ${agentIds.join(", ")}`)
        agentIds.forEach((id)=>{
            this.agentLastConversationTime.delete(id);
        });
    }
    /**
   * Checks if an autonomous conversation should be triggered based on agent proximity
   */ checkProximityTrigger(agents) {
        // Filter agents that have autonomy enabled
        const autonomousAgents = agents.filter((agent)=>agent.autonomyEnabled);
        // /* USEFUL FOR PRODUCTION TESTING: Log proximity check */
        // console.log(
        //   "Checking proximity trigger with autonomous agents:",
        //   autonomousAgents.map(
        //     (a) =>
        //       `${a.name} (autonomy: ${a.autonomyEnabled ? "enabled" : "disabled"}, inConversation: ${a.inConversation ? "yes" : "no"}, position: ${a.position.x},${a.position.y})`,
        //   ),
        // )
        // We need at least 2 autonomous agents to have a conversation
        if (autonomousAgents.length < 2) {
            // console.log("Not enough autonomous agents for proximity trigger")
            return {
                shouldTrigger: false,
                participants: []
            };
        }
        // Check for agents that are close to each other
        const agentGroups = [];
        // For each agent, find other agents within proximity threshold
        for (const agent of autonomousAgents){
            // Skip agents already in a conversation
            if (agent.inConversation) {
                continue;
            }
            // Skip agents on cooldown
            const lastConversationTime = this.agentLastConversationTime.get(agent.id) || 0;
            const timeSinceLastConversation = Date.now() - lastConversationTime;
            const isOnCooldown = timeSinceLastConversation < this.options.conversationCooldown;
            if (isOnCooldown) {
                continue;
            }
            const nearbyAgents = autonomousAgents.filter((otherAgent)=>{
                // Skip self, agents in conversation, and agents in conversation
                if (otherAgent.id === agent.id || otherAgent.inConversation) {
                    return false;
                }
                const otherLastConversationTime = this.agentLastConversationTime.get(otherAgent.id) || 0;
                const otherTimeSinceLastConversation = Date.now() - otherLastConversationTime;
                const otherIsOnCooldown = otherTimeSinceLastConversation < this.options.conversationCooldown;
                if (otherIsOnCooldown) {
                    // /* USEFUL FOR PRODUCTION TESTING: Log nearby agent cooldown */
                    // console.log(
                    //   `Nearby agent ${otherAgent.name} is on cooldown (${Math.round(otherTimeSinceLastConversation / 1000)}s elapsed), skipping`,
                    // )
                    return false;
                }
                // Check if within proximity threshold
                const distance = Math.sqrt(Math.pow(agent.position.x - otherAgent.position.x, 2) + Math.pow(agent.position.y - otherAgent.position.y, 2));
                const isNearby = distance <= this.options.proximityThreshold;
                if (isNearby) {
                // /* USEFUL FOR PRODUCTION TESTING: Log nearby agent detection */
                // console.log(
                //   `Agent ${agent.name} is near ${otherAgent.name} (distance: ${distance.toFixed(2)}, threshold: ${this.options.proximityThreshold})`,
                // )
                }
                return isNearby;
            });
            // If we found nearby agents, create a group
            if (nearbyAgents.length > 0) {
                // /* USEFUL FOR PRODUCTION TESTING: Log nearby agents found */
                // console.log(
                //   `Found nearby agents for ${agent.name}:`,
                //   nearbyAgents.map((a) => a.name),
                // )
                agentGroups.push([
                    agent,
                    ...nearbyAgents
                ]);
            }
        }
        // If we found any groups, return the first one
        if (agentGroups.length > 0) {
            // Limit to a reasonable number of participants (2-3 is ideal for conversation)
            const participants = agentGroups[0].slice(0, 3);
            // /* USEFUL FOR PRODUCTION TESTING: Log proximity trigger success */
            // console.log(
            //   "Proximity trigger successful with participants:",
            //   participants.map((a) => a.name),
            // )
            return {
                shouldTrigger: true,
                participants
            };
        }
        return {
            shouldTrigger: false,
            participants: []
        };
    }
    /**
   * Checks if an autonomous conversation should be triggered based on knowledge overlap
   */ checkKnowledgeOverlapTrigger(agents) {
        // Only proceed if knowledge-based triggers are enabled
        if (!this.options.enableKnowledgeBasedTriggers) {
            return {
                shouldTrigger: false,
                participants: [],
                topic: ""
            };
        }
        // Filter agents that have autonomy enabled
        const autonomousAgents = agents.filter((agent)=>agent.autonomyEnabled);
        // We need at least 2 autonomous agents to have a conversation
        if (autonomousAgents.length < 2) {
            return {
                shouldTrigger: false,
                participants: [],
                topic: ""
            };
        }
        // Find agents with overlapping knowledge
        const agentPairs = [];
        // Compare each pair of agents
        for(let i = 0; i < autonomousAgents.length; i++){
            const agent1 = autonomousAgents[i];
            // Skip agents already in a conversation
            if (agent1.inConversation) continue;
            // Skip agents on cooldown
            const lastConversationTime1 = this.agentLastConversationTime.get(agent1.id) || 0;
            if (Date.now() - lastConversationTime1 < this.options.conversationCooldown) continue;
            for(let j = i + 1; j < autonomousAgents.length; j++){
                const agent2 = autonomousAgents[j];
                // Skip agents already in a conversation
                if (agent2.inConversation) continue;
                // Skip agents on cooldown
                const lastConversationTime2 = this.agentLastConversationTime.get(agent2.id) || 0;
                if (Date.now() - lastConversationTime2 < this.options.conversationCooldown) continue;
                // Calculate knowledge overlap
                const { overlapScore, commonTags } = this.calculateKnowledgeOverlap(agent1, agent2);
                if (overlapScore >= this.options.knowledgeOverlapThreshold && commonTags.length > 0) {
                    // Choose a random common tag as the conversation topic
                    const topic = commonTags[Math.floor(Math.random() * commonTags.length)];
                    agentPairs.push({
                        agents: [
                            agent1,
                            agent2
                        ],
                        overlapScore,
                        topic
                    });
                }
            }
        }
        // Sort by overlap score (highest first)
        agentPairs.sort((a, b)=>b.overlapScore - a.overlapScore);
        // If we found any pairs with sufficient overlap, return the highest scoring pair
        if (agentPairs.length > 0) {
            const { agents, topic } = agentPairs[0];
            return {
                shouldTrigger: true,
                participants: agents,
                topic
            };
        }
        return {
            shouldTrigger: false,
            participants: [],
            topic: ""
        };
    }
    /**
   * Calculates knowledge overlap between two agents
   */ calculateKnowledgeOverlap(agent1, agent2) {
        // Extract all tags from both agents' knowledge
        const tags1 = new Set();
        const tags2 = new Set();
        agent1.knowledge.forEach((entry)=>{
            entry.tags.forEach((tag)=>tags1.add(tag));
        });
        agent2.knowledge.forEach((entry)=>{
            entry.tags.forEach((tag)=>tags2.add(tag));
        });
        // Find common tags
        const commonTags = [];
        tags1.forEach((tag)=>{
            if (tags2.has(tag)) {
                commonTags.push(tag);
            }
        });
        // Calculate overlap score
        const totalUniqueTags = new Set([
            ...Array.from(tags1),
            ...Array.from(tags2)
        ]).size;
        const overlapScore = totalUniqueTags > 0 ? commonTags.length / totalUniqueTags : 0;
        return {
            overlapScore,
            commonTags
        };
    }
    /**
   * Initiates an autonomous conversation between agents
   */ initiateConversation(participants, trigger, topic) {
        console.log(`AUTONOMOUS SYSTEM: Initiating ${trigger} conversation between: ${participants.map((a)=>a.name).join(", ")}${topic ? ` about ${topic}` : ""}`);
        // Check if we're at the maximum number of simultaneous conversations
        if (this.activeConversations.size >= this.options.maxSimultaneousConversations) {
            console.log(`AUTONOMOUS SYSTEM: Cannot initiate conversation: Maximum simultaneous conversations (${this.options.maxSimultaneousConversations}) reached`);
            return null;
        }
        // Create a new conversation
        const conversation = {
            id: `auto-conv-${Date.now()}`,
            participants: participants.map((agent)=>agent.id),
            messages: [],
            startTime: new Date(),
            endTime: null,
            isAutonomous: true,
            trigger
        };
        // Add a system message about the conversation start
        const systemMessage = {
            id: `msg-system-${Date.now()}`,
            content: this.generateConversationStartMessage(participants, trigger, topic),
            senderId: "system",
            timestamp: new Date(),
            metadata: {
                isSystemMessage: true,
                type: "conversation_starter"
            }
        };
        conversation.messages.push(systemMessage);
        // Track this conversation
        this.activeConversations.add(conversation.id);
        // Update last conversation time for all participants
        participants.forEach((agent)=>{
            this.agentLastConversationTime.set(agent.id, Date.now());
        // /* USEFUL FOR PRODUCTION TESTING: Log cooldown set */
        // console.log(`AUTONOMOUS SYSTEM: Set cooldown for ${agent.name} at ${new Date().toISOString()}`)
        });
        // Set a timeout to end the conversation after maxConversationDuration
        const timeout = setTimeout(()=>{
            console.log(`AUTONOMOUS SYSTEM: Conversation ${conversation.id} reached maximum duration, ending automatically`);
            this.endConversation(conversation.id);
        }, this.options.maxConversationDuration);
        this.conversationTimeouts.set(conversation.id, timeout);
        console.log(`AUTONOMOUS SYSTEM: Conversation ${conversation.id} initiated successfully with ${participants.length} participants`);
        return conversation;
    }
    /**
   * Ends an autonomous conversation
   */ endConversation(conversationId) {
        console.log(`Ending conversation ${conversationId}`);
        // Remove from active conversations
        this.activeConversations.delete(conversationId);
        // Clear the timeout
        const timeout = this.conversationTimeouts.get(conversationId);
        if (timeout) {
            clearTimeout(timeout);
            this.conversationTimeouts.delete(conversationId);
            console.log(`Cleared timeout for conversation ${conversationId}`);
        }
        console.log(`Conversation ${conversationId} ended successfully`);
    }
    /**
   * Checks if a conversation should end based on message count
   */ shouldEndConversation(conversation) {
        // This method should only be called for autonomous conversations
        if (!conversation || !conversation.isAutonomous) return false;
        // Count non-system messages
        const messageCount = conversation.messages.filter((msg)=>!msg.metadata?.isSystemMessage).length;
        // Check if the conversation has reached the maximum message count
        return messageCount >= this.options.maxAutonomousMessages;
    }
    /**
   * Generates a system message for the start of an autonomous conversation
   */ generateConversationStartMessage(participants, trigger, topic) {
        const agentNames = participants.map((agent)=>agent.name).join(", ");
        switch(trigger){
            case "proximity":
                return `${agentNames} have encountered each other and started a conversation.`;
            case "knowledge_overlap":
                if (topic) {
                    return `${agentNames} have started a conversation about their shared knowledge of ${topic}.`;
                }
                return `${agentNames} have started a conversation about their shared knowledge.`;
            case "scheduled":
                return `${agentNames} have started a scheduled conversation.`;
            case "user_initiated":
                return `${agentNames} have been prompted to start a conversation.`;
            case "continuation":
                return `${agentNames} have continued their previous conversation.`;
            default:
                return `${agentNames} have started a conversation.`;
        }
    }
    /**
   * Suggests a topic for conversation based on agents' knowledge
   */ suggestConversationTopic(agents) {
        // Extract all tags from all agents' knowledge
        const tagCounts = new Map();
        agents.forEach((agent)=>{
            agent.knowledge.forEach((entry)=>{
                entry.tags.forEach((tag)=>{
                    tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
                });
            });
        });
        // Find tags that appear in multiple agents' knowledge
        const commonTags = [];
        tagCounts.forEach((count, tag)=>{
            if (count >= 2) {
                // At least 2 agents have this tag
                commonTags.push([
                    tag,
                    count
                ]);
            }
        });
        // Sort by frequency (highest first)
        commonTags.sort((a, b)=>b[1] - a[1]);
        // Return the most common tag, or null if none found
        return commonTags.length > 0 ? commonTags[0][0] : null;
    }
    /**
   * Checks all possible triggers and returns the first one that should trigger a conversation
   */ checkAllTriggers(agents) {
        // /* USEFUL FOR PRODUCTION TESTING: Log trigger check */
        // console.log("Checking all autonomous conversation triggers")
        // Check proximity trigger
        const proximityResult = this.checkProximityTrigger(agents);
        if (proximityResult.shouldTrigger) {
            const topic = this.suggestConversationTopic(proximityResult.participants);
            return {
                ...proximityResult,
                trigger: "proximity",
                topic: topic ?? undefined
            };
        }
        // Check knowledge overlap trigger
        const knowledgeResult = this.checkKnowledgeOverlapTrigger(agents);
        if (knowledgeResult.shouldTrigger) {
            return {
                ...knowledgeResult,
                trigger: "knowledge_overlap"
            };
        }
        // No triggers matched
        return {
            shouldTrigger: false,
            participants: [],
            trigger: "proximity"
        };
    }
    /**
   * Checks if a conversation has reached minimum depth
   */ hasReachedMinimumDepth(conversation) {
        // Always return true since we're not using minimum depth anymore
        return true;
    }
    // Methods expected by tests
    getState() {
        return {
            messages: [],
            agents: [],
            activeConversations: this.activeConversations,
            options: this.options
        };
    }
    getDynamics() {
        return {
            turnTaking: "round-robin",
            responseCoordination: "sequential"
        };
    }
    setTurnTakingStrategy(strategy) {
    // Store strategy (implementation would handle different strategies)
    }
    async selectNextSpeaker() {
        // Return a mock agent for tests
        return {
            id: "test-agent",
            name: "Test Agent",
            inConversation: false,
            position: {
                x: 0,
                y: 0
            },
            color: "#000",
            knowledge: [],
            autonomyEnabled: true
        };
    }
    async recordTurn(agentId, message) {
    // Record the turn (implementation would store in conversation state)
    }
    async waitForResponse(agentId, timeout) {
        // Wait for agent response with timeout
        return Promise.resolve();
    }
    async getAvailableAgents() {
        return [];
    }
    async resolveDeadlock() {
        return {
            resolved: true
        };
    }
    addMessage(message) {
    // Add message to conversation state
    }
    evaluateTopicCoherence() {
        return 0.8;
    }
    setRules(rules) {
    // Set conversation rules
    }
    validateResponse(response) {
        return true;
    }
    async canAgentSpeak(agentId) {
        return true;
    }
    async coordinateResponse(coordination) {
        return {
            coordinated: true
        };
    }
    async resolveConflict(conflict) {
        return {
            resolved: true
        };
    }
}
const AutonomousConversationManager = AutonomousConversationSystem;
const createAutonomousConversation = (options)=>new AutonomousConversationSystem(options);
const orchestrateConversation = (manager, options)=>Promise.resolve({
        messages: [],
        participants: [],
        duration: 0
    });
const evaluateConversationQuality = (state)=>({
        overall: 0.5,
        recommendations: [
            "improve clarity",
            "enhance engagement"
        ]
    });
const detectEmergentPatterns = (state)=>[];
const applyConversationRules = ()=>{};
const generateAgentResponse = (context)=>Promise.resolve({
        content: "Generated response",
        agentId: context?.currentSpeaker?.id || "unknown",
        timestamp: Date.now()
    });

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvYXV0b25vbW91cy1jb252ZXJzYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBBZ2VudCxcbiAgQ29udmVyc2F0aW9uLFxuICBNZXNzYWdlLFxuICBQb3NpdGlvbixcbiAgS25vd2xlZGdlRW50cnksXG59IGZyb20gXCJAL2xpYi90eXBlc1wiO1xuaW1wb3J0IHsgS25vd2xlZGdlUmV0cmlldmVyIH0gZnJvbSBcIkAvbGliL2tub3dsZWRnZS1yZXRyaWV2ZXJcIjtcblxuLy8gVHlwZXMgZm9yIGF1dG9ub21vdXMgY29udmVyc2F0aW9uIHRyaWdnZXJzXG5leHBvcnQgdHlwZSBUcmlnZ2VyVHlwZSA9XG4gIHwgXCJwcm94aW1pdHlcIlxuICB8IFwia25vd2xlZGdlX292ZXJsYXBcIlxuICB8IFwic2NoZWR1bGVkXCJcbiAgfCBcInVzZXJfaW5pdGlhdGVkXCJcbiAgfCBcImNvbnRpbnVhdGlvblwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyaWdnZXJDb250ZXh0IHtcbiAgYWdlbnRzOiBBZ2VudFtdO1xuICBsb2NhdGlvbj86IFBvc2l0aW9uO1xuICBrbm93bGVkZ2VFbnRyaWVzPzogS25vd2xlZGdlRW50cnlbXTtcbiAgcHJldmlvdXNDb252ZXJzYXRpb24/OiBDb252ZXJzYXRpb247XG4gIHRvcGljPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9ub21vdXNDb252ZXJzYXRpb25PcHRpb25zIHtcbiAgLy8gTWluaW11bSBkaXN0YW5jZSBmb3IgcHJveGltaXR5LWJhc2VkIGNvbnZlcnNhdGlvbnNcbiAgcHJveGltaXR5VGhyZXNob2xkOiBudW1iZXI7XG5cbiAgLy8gTWluaW11bSBrbm93bGVkZ2Ugb3ZlcmxhcCBzY29yZSB0byB0cmlnZ2VyIGEgY29udmVyc2F0aW9uXG4gIGtub3dsZWRnZU92ZXJsYXBUaHJlc2hvbGQ6IG51bWJlcjtcblxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBhdXRvbm9tb3VzIGNvbnZlcnNhdGlvbnMgdGhhdCBjYW4gaGFwcGVuIHNpbXVsdGFuZW91c2x5XG4gIG1heFNpbXVsdGFuZW91c0NvbnZlcnNhdGlvbnM6IG51bWJlcjtcblxuICAvLyBDb29sZG93biBwZXJpb2QgKGluIG1zKSBiZWZvcmUgYW4gYWdlbnQgY2FuIHBhcnRpY2lwYXRlIGluIGFub3RoZXIgYXV0b25vbW91cyBjb252ZXJzYXRpb25cbiAgY29udmVyc2F0aW9uQ29vbGRvd246IG51bWJlcjtcblxuICAvLyBNYXhpbXVtIGR1cmF0aW9uIChpbiBtcykgZm9yIGFuIGF1dG9ub21vdXMgY29udmVyc2F0aW9uIGJlZm9yZSBpdCdzIGF1dG9tYXRpY2FsbHkgZW5kZWRcbiAgbWF4Q29udmVyc2F0aW9uRHVyYXRpb246IG51bWJlcjtcblxuICAvLyBXaGV0aGVyIHRvIGVuYWJsZSBzY2hlZHVsZWQgY29udmVyc2F0aW9uc1xuICBlbmFibGVTY2hlZHVsZWRDb252ZXJzYXRpb25zOiBib29sZWFuO1xuXG4gIC8vIFdoZXRoZXIgdG8gZW5hYmxlIGtub3dsZWRnZS1iYXNlZCB0cmlnZ2Vyc1xuICBlbmFibGVLbm93bGVkZ2VCYXNlZFRyaWdnZXJzOiBib29sZWFuO1xuXG4gIC8vIE1heGltdW0gbWVzc2FnZXMgYmVmb3JlIGZvcmNlZCBlbmRpbmdcbiAgbWF4QXV0b25vbW91c01lc3NhZ2VzOiBudW1iZXI7XG5cbiAgLy8gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIG5lZWRlZCBieSB0ZXN0cyBhbmQgYWR2YW5jZWQgdXNhZ2VcbiAgbWF4VHVybnM/OiBudW1iZXI7XG4gIGFnZW50cz86IEFnZW50W107XG4gIGF1dG9UZXJtaW5hdGU/OiBib29sZWFuO1xufVxuXG4vLyBEZWZhdWx0IG9wdGlvbnNcbmV4cG9ydCBjb25zdCBkZWZhdWx0QXV0b25vbW91c09wdGlvbnM6IEF1dG9ub21vdXNDb252ZXJzYXRpb25PcHRpb25zID0ge1xuICBwcm94aW1pdHlUaHJlc2hvbGQ6IDEsIC8vIEFkamFjZW50IGNlbGxzXG4gIGtub3dsZWRnZU92ZXJsYXBUaHJlc2hvbGQ6IDAuMywgLy8gMzAlIG92ZXJsYXBcbiAgbWF4U2ltdWx0YW5lb3VzQ29udmVyc2F0aW9uczogMSxcbiAgY29udmVyc2F0aW9uQ29vbGRvd246IDUwMDAsIC8vIFJlZHVjZWQgZnJvbSA2MDAwMCAoMSBtaW51dGUpIHRvIDUwMDAgKDUgc2Vjb25kcykgZm9yIHRlc3RpbmdcbiAgbWF4Q29udmVyc2F0aW9uRHVyYXRpb246IDMwMDAwMCwgLy8gNSBtaW51dGVzXG4gIGVuYWJsZVNjaGVkdWxlZENvbnZlcnNhdGlvbnM6IGZhbHNlLFxuICBlbmFibGVLbm93bGVkZ2VCYXNlZFRyaWdnZXJzOiB0cnVlLFxuICBtYXhBdXRvbm9tb3VzTWVzc2FnZXM6IDQsIC8vIERlZmF1bHQgbWF4aW11bSBvZiA0IG1lc3NhZ2VzXG59O1xuXG5leHBvcnQgY2xhc3MgQXV0b25vbW91c0NvbnZlcnNhdGlvblN5c3RlbSB7XG4gIHByaXZhdGUgb3B0aW9uczogQXV0b25vbW91c0NvbnZlcnNhdGlvbk9wdGlvbnM7XG4gIHByaXZhdGUga25vd2xlZGdlUmV0cmlldmVyOiBLbm93bGVkZ2VSZXRyaWV2ZXI7XG4gIHByaXZhdGUgYWN0aXZlQ29udmVyc2F0aW9uczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgYWdlbnRMYXN0Q29udmVyc2F0aW9uVGltZTogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBjb252ZXJzYXRpb25UaW1lb3V0czogTWFwPHN0cmluZywgTm9kZUpTLlRpbWVvdXQ+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFBhcnRpYWw8QXV0b25vbW91c0NvbnZlcnNhdGlvbk9wdGlvbnM+ID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLmRlZmF1bHRBdXRvbm9tb3VzT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMua25vd2xlZGdlUmV0cmlldmVyID0gbmV3IEtub3dsZWRnZVJldHJpZXZlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN5c3RlbSBvcHRpb25zXG4gICAqL1xuICB1cGRhdGVPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8QXV0b25vbW91c0NvbnZlcnNhdGlvbk9wdGlvbnM+KTogdm9pZCB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGNvb2xkb3duIGZvciBzcGVjaWZpYyBhZ2VudHNcbiAgICovXG4gIHJlc2V0Q29vbGRvd24oYWdlbnRJZHM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgLy8gLyogVVNFRlVMIEZPUiBQUk9EVUNUSU9OIFRFU1RJTkc6IExvZyBjb29sZG93biByZXNldCAqL1xuICAgIC8vIGNvbnNvbGUubG9nKGBSZXNldHRpbmcgY29vbGRvd24gZm9yIGFnZW50czogJHthZ2VudElkcy5qb2luKFwiLCBcIil9YClcbiAgICBhZ2VudElkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgdGhpcy5hZ2VudExhc3RDb252ZXJzYXRpb25UaW1lLmRlbGV0ZShpZCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFuIGF1dG9ub21vdXMgY29udmVyc2F0aW9uIHNob3VsZCBiZSB0cmlnZ2VyZWQgYmFzZWQgb24gYWdlbnQgcHJveGltaXR5XG4gICAqL1xuICBjaGVja1Byb3hpbWl0eVRyaWdnZXIoYWdlbnRzOiBBZ2VudFtdKToge1xuICAgIHNob3VsZFRyaWdnZXI6IGJvb2xlYW47XG4gICAgcGFydGljaXBhbnRzOiBBZ2VudFtdO1xuICB9IHtcbiAgICAvLyBGaWx0ZXIgYWdlbnRzIHRoYXQgaGF2ZSBhdXRvbm9teSBlbmFibGVkXG4gICAgY29uc3QgYXV0b25vbW91c0FnZW50cyA9IGFnZW50cy5maWx0ZXIoKGFnZW50KSA9PiBhZ2VudC5hdXRvbm9teUVuYWJsZWQpO1xuXG4gICAgLy8gLyogVVNFRlVMIEZPUiBQUk9EVUNUSU9OIFRFU1RJTkc6IExvZyBwcm94aW1pdHkgY2hlY2sgKi9cbiAgICAvLyBjb25zb2xlLmxvZyhcbiAgICAvLyAgIFwiQ2hlY2tpbmcgcHJveGltaXR5IHRyaWdnZXIgd2l0aCBhdXRvbm9tb3VzIGFnZW50czpcIixcbiAgICAvLyAgIGF1dG9ub21vdXNBZ2VudHMubWFwKFxuICAgIC8vICAgICAoYSkgPT5cbiAgICAvLyAgICAgICBgJHthLm5hbWV9IChhdXRvbm9teTogJHthLmF1dG9ub215RW5hYmxlZCA/IFwiZW5hYmxlZFwiIDogXCJkaXNhYmxlZFwifSwgaW5Db252ZXJzYXRpb246ICR7YS5pbkNvbnZlcnNhdGlvbiA/IFwieWVzXCIgOiBcIm5vXCJ9LCBwb3NpdGlvbjogJHthLnBvc2l0aW9uLnh9LCR7YS5wb3NpdGlvbi55fSlgLFxuICAgIC8vICAgKSxcbiAgICAvLyApXG5cbiAgICAvLyBXZSBuZWVkIGF0IGxlYXN0IDIgYXV0b25vbW91cyBhZ2VudHMgdG8gaGF2ZSBhIGNvbnZlcnNhdGlvblxuICAgIGlmIChhdXRvbm9tb3VzQWdlbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiTm90IGVub3VnaCBhdXRvbm9tb3VzIGFnZW50cyBmb3IgcHJveGltaXR5IHRyaWdnZXJcIilcbiAgICAgIHJldHVybiB7IHNob3VsZFRyaWdnZXI6IGZhbHNlLCBwYXJ0aWNpcGFudHM6IFtdIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGFnZW50cyB0aGF0IGFyZSBjbG9zZSB0byBlYWNoIG90aGVyXG4gICAgY29uc3QgYWdlbnRHcm91cHM6IEFnZW50W11bXSA9IFtdO1xuXG4gICAgLy8gRm9yIGVhY2ggYWdlbnQsIGZpbmQgb3RoZXIgYWdlbnRzIHdpdGhpbiBwcm94aW1pdHkgdGhyZXNob2xkXG4gICAgZm9yIChjb25zdCBhZ2VudCBvZiBhdXRvbm9tb3VzQWdlbnRzKSB7XG4gICAgICAvLyBTa2lwIGFnZW50cyBhbHJlYWR5IGluIGEgY29udmVyc2F0aW9uXG4gICAgICBpZiAoYWdlbnQuaW5Db252ZXJzYXRpb24pIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYEFnZW50ICR7YWdlbnQubmFtZX0gaXMgYWxyZWFkeSBpbiBhIGNvbnZlcnNhdGlvbiwgc2tpcHBpbmdgKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBhZ2VudHMgb24gY29vbGRvd25cbiAgICAgIGNvbnN0IGxhc3RDb252ZXJzYXRpb25UaW1lID1cbiAgICAgICAgdGhpcy5hZ2VudExhc3RDb252ZXJzYXRpb25UaW1lLmdldChhZ2VudC5pZCkgfHwgMDtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb252ZXJzYXRpb24gPSBEYXRlLm5vdygpIC0gbGFzdENvbnZlcnNhdGlvblRpbWU7XG4gICAgICBjb25zdCBpc09uQ29vbGRvd24gPVxuICAgICAgICB0aW1lU2luY2VMYXN0Q29udmVyc2F0aW9uIDwgdGhpcy5vcHRpb25zLmNvbnZlcnNhdGlvbkNvb2xkb3duO1xuXG4gICAgICBpZiAoaXNPbkNvb2xkb3duKSB7XG4gICAgICAgIC8vIC8qIFVTRUZVTCBGT1IgUFJPRFVDVElPTiBURVNUSU5HOiBMb2cgY29vbGRvd24gc3RhdHVzICovXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFxuICAgICAgICAvLyAgIGBBZ2VudCAke2FnZW50Lm5hbWV9IGlzIG9uIGNvb2xkb3duICgke01hdGgucm91bmQodGltZVNpbmNlTGFzdENvbnZlcnNhdGlvbiAvIDEwMDApfXMgZWxhcHNlZCwgY29vbGRvd246ICR7TWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMuY29udmVyc2F0aW9uQ29vbGRvd24gLyAxMDAwKX1zKSwgc2tpcHBpbmdgLFxuICAgICAgICAvLyApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZWFyYnlBZ2VudHMgPSBhdXRvbm9tb3VzQWdlbnRzLmZpbHRlcigob3RoZXJBZ2VudCkgPT4ge1xuICAgICAgICAvLyBTa2lwIHNlbGYsIGFnZW50cyBpbiBjb252ZXJzYXRpb24sIGFuZCBhZ2VudHMgaW4gY29udmVyc2F0aW9uXG4gICAgICAgIGlmIChvdGhlckFnZW50LmlkID09PSBhZ2VudC5pZCB8fCBvdGhlckFnZW50LmluQ29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3RoZXJMYXN0Q29udmVyc2F0aW9uVGltZSA9XG4gICAgICAgICAgdGhpcy5hZ2VudExhc3RDb252ZXJzYXRpb25UaW1lLmdldChvdGhlckFnZW50LmlkKSB8fCAwO1xuICAgICAgICBjb25zdCBvdGhlclRpbWVTaW5jZUxhc3RDb252ZXJzYXRpb24gPVxuICAgICAgICAgIERhdGUubm93KCkgLSBvdGhlckxhc3RDb252ZXJzYXRpb25UaW1lO1xuICAgICAgICBjb25zdCBvdGhlcklzT25Db29sZG93biA9XG4gICAgICAgICAgb3RoZXJUaW1lU2luY2VMYXN0Q29udmVyc2F0aW9uIDwgdGhpcy5vcHRpb25zLmNvbnZlcnNhdGlvbkNvb2xkb3duO1xuXG4gICAgICAgIGlmIChvdGhlcklzT25Db29sZG93bikge1xuICAgICAgICAgIC8vIC8qIFVTRUZVTCBGT1IgUFJPRFVDVElPTiBURVNUSU5HOiBMb2cgbmVhcmJ5IGFnZW50IGNvb2xkb3duICovXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXG4gICAgICAgICAgLy8gICBgTmVhcmJ5IGFnZW50ICR7b3RoZXJBZ2VudC5uYW1lfSBpcyBvbiBjb29sZG93biAoJHtNYXRoLnJvdW5kKG90aGVyVGltZVNpbmNlTGFzdENvbnZlcnNhdGlvbiAvIDEwMDApfXMgZWxhcHNlZCksIHNraXBwaW5nYCxcbiAgICAgICAgICAvLyApXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2l0aGluIHByb3hpbWl0eSB0aHJlc2hvbGRcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgTWF0aC5wb3coYWdlbnQucG9zaXRpb24ueCAtIG90aGVyQWdlbnQucG9zaXRpb24ueCwgMikgK1xuICAgICAgICAgICAgTWF0aC5wb3coYWdlbnQucG9zaXRpb24ueSAtIG90aGVyQWdlbnQucG9zaXRpb24ueSwgMiksXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaXNOZWFyYnkgPSBkaXN0YW5jZSA8PSB0aGlzLm9wdGlvbnMucHJveGltaXR5VGhyZXNob2xkO1xuICAgICAgICBpZiAoaXNOZWFyYnkpIHtcbiAgICAgICAgICAvLyAvKiBVU0VGVUwgRk9SIFBST0RVQ1RJT04gVEVTVElORzogTG9nIG5lYXJieSBhZ2VudCBkZXRlY3Rpb24gKi9cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcbiAgICAgICAgICAvLyAgIGBBZ2VudCAke2FnZW50Lm5hbWV9IGlzIG5lYXIgJHtvdGhlckFnZW50Lm5hbWV9IChkaXN0YW5jZTogJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSwgdGhyZXNob2xkOiAke3RoaXMub3B0aW9ucy5wcm94aW1pdHlUaHJlc2hvbGR9KWAsXG4gICAgICAgICAgLy8gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzTmVhcmJ5O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHdlIGZvdW5kIG5lYXJieSBhZ2VudHMsIGNyZWF0ZSBhIGdyb3VwXG4gICAgICBpZiAobmVhcmJ5QWdlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gLyogVVNFRlVMIEZPUiBQUk9EVUNUSU9OIFRFU1RJTkc6IExvZyBuZWFyYnkgYWdlbnRzIGZvdW5kICovXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFxuICAgICAgICAvLyAgIGBGb3VuZCBuZWFyYnkgYWdlbnRzIGZvciAke2FnZW50Lm5hbWV9OmAsXG4gICAgICAgIC8vICAgbmVhcmJ5QWdlbnRzLm1hcCgoYSkgPT4gYS5uYW1lKSxcbiAgICAgICAgLy8gKVxuICAgICAgICBhZ2VudEdyb3Vwcy5wdXNoKFthZ2VudCwgLi4ubmVhcmJ5QWdlbnRzXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZm91bmQgYW55IGdyb3VwcywgcmV0dXJuIHRoZSBmaXJzdCBvbmVcbiAgICBpZiAoYWdlbnRHcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gTGltaXQgdG8gYSByZWFzb25hYmxlIG51bWJlciBvZiBwYXJ0aWNpcGFudHMgKDItMyBpcyBpZGVhbCBmb3IgY29udmVyc2F0aW9uKVxuICAgICAgY29uc3QgcGFydGljaXBhbnRzID0gYWdlbnRHcm91cHNbMF0uc2xpY2UoMCwgMyk7XG4gICAgICAvLyAvKiBVU0VGVUwgRk9SIFBST0RVQ1RJT04gVEVTVElORzogTG9nIHByb3hpbWl0eSB0cmlnZ2VyIHN1Y2Nlc3MgKi9cbiAgICAgIC8vIGNvbnNvbGUubG9nKFxuICAgICAgLy8gICBcIlByb3hpbWl0eSB0cmlnZ2VyIHN1Y2Nlc3NmdWwgd2l0aCBwYXJ0aWNpcGFudHM6XCIsXG4gICAgICAvLyAgIHBhcnRpY2lwYW50cy5tYXAoKGEpID0+IGEubmFtZSksXG4gICAgICAvLyApXG4gICAgICByZXR1cm4geyBzaG91bGRUcmlnZ2VyOiB0cnVlLCBwYXJ0aWNpcGFudHMgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzaG91bGRUcmlnZ2VyOiBmYWxzZSwgcGFydGljaXBhbnRzOiBbXSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbiBhdXRvbm9tb3VzIGNvbnZlcnNhdGlvbiBzaG91bGQgYmUgdHJpZ2dlcmVkIGJhc2VkIG9uIGtub3dsZWRnZSBvdmVybGFwXG4gICAqL1xuICBjaGVja0tub3dsZWRnZU92ZXJsYXBUcmlnZ2VyKGFnZW50czogQWdlbnRbXSk6IHtcbiAgICBzaG91bGRUcmlnZ2VyOiBib29sZWFuO1xuICAgIHBhcnRpY2lwYW50czogQWdlbnRbXTtcbiAgICB0b3BpYzogc3RyaW5nO1xuICB9IHtcbiAgICAvLyBPbmx5IHByb2NlZWQgaWYga25vd2xlZGdlLWJhc2VkIHRyaWdnZXJzIGFyZSBlbmFibGVkXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlS25vd2xlZGdlQmFzZWRUcmlnZ2Vycykge1xuICAgICAgcmV0dXJuIHsgc2hvdWxkVHJpZ2dlcjogZmFsc2UsIHBhcnRpY2lwYW50czogW10sIHRvcGljOiBcIlwiIH07XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIGFnZW50cyB0aGF0IGhhdmUgYXV0b25vbXkgZW5hYmxlZFxuICAgIGNvbnN0IGF1dG9ub21vdXNBZ2VudHMgPSBhZ2VudHMuZmlsdGVyKChhZ2VudCkgPT4gYWdlbnQuYXV0b25vbXlFbmFibGVkKTtcblxuICAgIC8vIFdlIG5lZWQgYXQgbGVhc3QgMiBhdXRvbm9tb3VzIGFnZW50cyB0byBoYXZlIGEgY29udmVyc2F0aW9uXG4gICAgaWYgKGF1dG9ub21vdXNBZ2VudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHsgc2hvdWxkVHJpZ2dlcjogZmFsc2UsIHBhcnRpY2lwYW50czogW10sIHRvcGljOiBcIlwiIH07XG4gICAgfVxuXG4gICAgLy8gRmluZCBhZ2VudHMgd2l0aCBvdmVybGFwcGluZyBrbm93bGVkZ2VcbiAgICBjb25zdCBhZ2VudFBhaXJzOiB7XG4gICAgICBhZ2VudHM6IFtBZ2VudCwgQWdlbnRdO1xuICAgICAgb3ZlcmxhcFNjb3JlOiBudW1iZXI7XG4gICAgICB0b3BpYzogc3RyaW5nO1xuICAgIH1bXSA9IFtdO1xuXG4gICAgLy8gQ29tcGFyZSBlYWNoIHBhaXIgb2YgYWdlbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdXRvbm9tb3VzQWdlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhZ2VudDEgPSBhdXRvbm9tb3VzQWdlbnRzW2ldO1xuXG4gICAgICAvLyBTa2lwIGFnZW50cyBhbHJlYWR5IGluIGEgY29udmVyc2F0aW9uXG4gICAgICBpZiAoYWdlbnQxLmluQ29udmVyc2F0aW9uKSBjb250aW51ZTtcblxuICAgICAgLy8gU2tpcCBhZ2VudHMgb24gY29vbGRvd25cbiAgICAgIGNvbnN0IGxhc3RDb252ZXJzYXRpb25UaW1lMSA9XG4gICAgICAgIHRoaXMuYWdlbnRMYXN0Q29udmVyc2F0aW9uVGltZS5nZXQoYWdlbnQxLmlkKSB8fCAwO1xuICAgICAgaWYgKFxuICAgICAgICBEYXRlLm5vdygpIC0gbGFzdENvbnZlcnNhdGlvblRpbWUxIDxcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbnZlcnNhdGlvbkNvb2xkb3duXG4gICAgICApXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBhdXRvbm9tb3VzQWdlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGFnZW50MiA9IGF1dG9ub21vdXNBZ2VudHNbal07XG5cbiAgICAgICAgLy8gU2tpcCBhZ2VudHMgYWxyZWFkeSBpbiBhIGNvbnZlcnNhdGlvblxuICAgICAgICBpZiAoYWdlbnQyLmluQ29udmVyc2F0aW9uKSBjb250aW51ZTtcblxuICAgICAgICAvLyBTa2lwIGFnZW50cyBvbiBjb29sZG93blxuICAgICAgICBjb25zdCBsYXN0Q29udmVyc2F0aW9uVGltZTIgPVxuICAgICAgICAgIHRoaXMuYWdlbnRMYXN0Q29udmVyc2F0aW9uVGltZS5nZXQoYWdlbnQyLmlkKSB8fCAwO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgRGF0ZS5ub3coKSAtIGxhc3RDb252ZXJzYXRpb25UaW1lMiA8XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnZlcnNhdGlvbkNvb2xkb3duXG4gICAgICAgIClcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUga25vd2xlZGdlIG92ZXJsYXBcbiAgICAgICAgY29uc3QgeyBvdmVybGFwU2NvcmUsIGNvbW1vblRhZ3MgfSA9IHRoaXMuY2FsY3VsYXRlS25vd2xlZGdlT3ZlcmxhcChcbiAgICAgICAgICBhZ2VudDEsXG4gICAgICAgICAgYWdlbnQyLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBvdmVybGFwU2NvcmUgPj0gdGhpcy5vcHRpb25zLmtub3dsZWRnZU92ZXJsYXBUaHJlc2hvbGQgJiZcbiAgICAgICAgICBjb21tb25UYWdzLmxlbmd0aCA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gQ2hvb3NlIGEgcmFuZG9tIGNvbW1vbiB0YWcgYXMgdGhlIGNvbnZlcnNhdGlvbiB0b3BpY1xuICAgICAgICAgIGNvbnN0IHRvcGljID1cbiAgICAgICAgICAgIGNvbW1vblRhZ3NbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29tbW9uVGFncy5sZW5ndGgpXTtcblxuICAgICAgICAgIGFnZW50UGFpcnMucHVzaCh7XG4gICAgICAgICAgICBhZ2VudHM6IFthZ2VudDEsIGFnZW50Ml0sXG4gICAgICAgICAgICBvdmVybGFwU2NvcmUsXG4gICAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvcnQgYnkgb3ZlcmxhcCBzY29yZSAoaGlnaGVzdCBmaXJzdClcbiAgICBhZ2VudFBhaXJzLnNvcnQoKGEsIGIpID0+IGIub3ZlcmxhcFNjb3JlIC0gYS5vdmVybGFwU2NvcmUpO1xuXG4gICAgLy8gSWYgd2UgZm91bmQgYW55IHBhaXJzIHdpdGggc3VmZmljaWVudCBvdmVybGFwLCByZXR1cm4gdGhlIGhpZ2hlc3Qgc2NvcmluZyBwYWlyXG4gICAgaWYgKGFnZW50UGFpcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBhZ2VudHMsIHRvcGljIH0gPSBhZ2VudFBhaXJzWzBdO1xuICAgICAgcmV0dXJuIHsgc2hvdWxkVHJpZ2dlcjogdHJ1ZSwgcGFydGljaXBhbnRzOiBhZ2VudHMsIHRvcGljIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc2hvdWxkVHJpZ2dlcjogZmFsc2UsIHBhcnRpY2lwYW50czogW10sIHRvcGljOiBcIlwiIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBrbm93bGVkZ2Ugb3ZlcmxhcCBiZXR3ZWVuIHR3byBhZ2VudHNcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlS25vd2xlZGdlT3ZlcmxhcChcbiAgICBhZ2VudDE6IEFnZW50LFxuICAgIGFnZW50MjogQWdlbnQsXG4gICk6IHsgb3ZlcmxhcFNjb3JlOiBudW1iZXI7IGNvbW1vblRhZ3M6IHN0cmluZ1tdIH0ge1xuICAgIC8vIEV4dHJhY3QgYWxsIHRhZ3MgZnJvbSBib3RoIGFnZW50cycga25vd2xlZGdlXG4gICAgY29uc3QgdGFnczEgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCB0YWdzMiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgYWdlbnQxLmtub3dsZWRnZS5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgZW50cnkudGFncy5mb3JFYWNoKCh0YWcpID0+IHRhZ3MxLmFkZCh0YWcpKTtcbiAgICB9KTtcblxuICAgIGFnZW50Mi5rbm93bGVkZ2UuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGVudHJ5LnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB0YWdzMi5hZGQodGFnKSk7XG4gICAgfSk7XG5cbiAgICAvLyBGaW5kIGNvbW1vbiB0YWdzXG4gICAgY29uc3QgY29tbW9uVGFnczogc3RyaW5nW10gPSBbXTtcbiAgICB0YWdzMS5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgIGlmICh0YWdzMi5oYXModGFnKSkge1xuICAgICAgICBjb21tb25UYWdzLnB1c2godGFnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENhbGN1bGF0ZSBvdmVybGFwIHNjb3JlXG4gICAgY29uc3QgdG90YWxVbmlxdWVUYWdzID0gbmV3IFNldChbXG4gICAgICAuLi5BcnJheS5mcm9tKHRhZ3MxKSxcbiAgICAgIC4uLkFycmF5LmZyb20odGFnczIpLFxuICAgIF0pLnNpemU7XG4gICAgY29uc3Qgb3ZlcmxhcFNjb3JlID1cbiAgICAgIHRvdGFsVW5pcXVlVGFncyA+IDAgPyBjb21tb25UYWdzLmxlbmd0aCAvIHRvdGFsVW5pcXVlVGFncyA6IDA7XG5cbiAgICByZXR1cm4geyBvdmVybGFwU2NvcmUsIGNvbW1vblRhZ3MgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYW4gYXV0b25vbW91cyBjb252ZXJzYXRpb24gYmV0d2VlbiBhZ2VudHNcbiAgICovXG4gIGluaXRpYXRlQ29udmVyc2F0aW9uKFxuICAgIHBhcnRpY2lwYW50czogQWdlbnRbXSxcbiAgICB0cmlnZ2VyOiBUcmlnZ2VyVHlwZSxcbiAgICB0b3BpYz86IHN0cmluZyxcbiAgKTogQ29udmVyc2F0aW9uIHwgbnVsbCB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgQVVUT05PTU9VUyBTWVNURU06IEluaXRpYXRpbmcgJHt0cmlnZ2VyfSBjb252ZXJzYXRpb24gYmV0d2VlbjogJHtwYXJ0aWNpcGFudHMubWFwKChhKSA9PiBhLm5hbWUpLmpvaW4oXCIsIFwiKX0ke3RvcGljID8gYCBhYm91dCAke3RvcGljfWAgOiBcIlwifWAsXG4gICAgKTtcblxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGF0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBzaW11bHRhbmVvdXMgY29udmVyc2F0aW9uc1xuICAgIGlmIChcbiAgICAgIHRoaXMuYWN0aXZlQ29udmVyc2F0aW9ucy5zaXplID49IHRoaXMub3B0aW9ucy5tYXhTaW11bHRhbmVvdXNDb252ZXJzYXRpb25zXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYEFVVE9OT01PVVMgU1lTVEVNOiBDYW5ub3QgaW5pdGlhdGUgY29udmVyc2F0aW9uOiBNYXhpbXVtIHNpbXVsdGFuZW91cyBjb252ZXJzYXRpb25zICgke3RoaXMub3B0aW9ucy5tYXhTaW11bHRhbmVvdXNDb252ZXJzYXRpb25zfSkgcmVhY2hlZGAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNvbnZlcnNhdGlvblxuICAgIGNvbnN0IGNvbnZlcnNhdGlvbjogQ29udmVyc2F0aW9uID0ge1xuICAgICAgaWQ6IGBhdXRvLWNvbnYtJHtEYXRlLm5vdygpfWAsXG4gICAgICBwYXJ0aWNpcGFudHM6IHBhcnRpY2lwYW50cy5tYXAoKGFnZW50KSA9PiBhZ2VudC5pZCksXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCksXG4gICAgICBlbmRUaW1lOiBudWxsLFxuICAgICAgaXNBdXRvbm9tb3VzOiB0cnVlLFxuICAgICAgdHJpZ2dlcixcbiAgICB9O1xuXG4gICAgLy8gQWRkIGEgc3lzdGVtIG1lc3NhZ2UgYWJvdXQgdGhlIGNvbnZlcnNhdGlvbiBzdGFydFxuICAgIGNvbnN0IHN5c3RlbU1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBpZDogYG1zZy1zeXN0ZW0tJHtEYXRlLm5vdygpfWAsXG4gICAgICBjb250ZW50OiB0aGlzLmdlbmVyYXRlQ29udmVyc2F0aW9uU3RhcnRNZXNzYWdlKFxuICAgICAgICBwYXJ0aWNpcGFudHMsXG4gICAgICAgIHRyaWdnZXIsXG4gICAgICAgIHRvcGljLFxuICAgICAgKSxcbiAgICAgIHNlbmRlcklkOiBcInN5c3RlbVwiLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgaXNTeXN0ZW1NZXNzYWdlOiB0cnVlLFxuICAgICAgICB0eXBlOiBcImNvbnZlcnNhdGlvbl9zdGFydGVyXCIsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb252ZXJzYXRpb24ubWVzc2FnZXMucHVzaChzeXN0ZW1NZXNzYWdlKTtcblxuICAgIC8vIFRyYWNrIHRoaXMgY29udmVyc2F0aW9uXG4gICAgdGhpcy5hY3RpdmVDb252ZXJzYXRpb25zLmFkZChjb252ZXJzYXRpb24uaWQpO1xuXG4gICAgLy8gVXBkYXRlIGxhc3QgY29udmVyc2F0aW9uIHRpbWUgZm9yIGFsbCBwYXJ0aWNpcGFudHNcbiAgICBwYXJ0aWNpcGFudHMuZm9yRWFjaCgoYWdlbnQpID0+IHtcbiAgICAgIHRoaXMuYWdlbnRMYXN0Q29udmVyc2F0aW9uVGltZS5zZXQoYWdlbnQuaWQsIERhdGUubm93KCkpO1xuICAgICAgLy8gLyogVVNFRlVMIEZPUiBQUk9EVUNUSU9OIFRFU1RJTkc6IExvZyBjb29sZG93biBzZXQgKi9cbiAgICAgIC8vIGNvbnNvbGUubG9nKGBBVVRPTk9NT1VTIFNZU1RFTTogU2V0IGNvb2xkb3duIGZvciAke2FnZW50Lm5hbWV9IGF0ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWApXG4gICAgfSk7XG5cbiAgICAvLyBTZXQgYSB0aW1lb3V0IHRvIGVuZCB0aGUgY29udmVyc2F0aW9uIGFmdGVyIG1heENvbnZlcnNhdGlvbkR1cmF0aW9uXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBBVVRPTk9NT1VTIFNZU1RFTTogQ29udmVyc2F0aW9uICR7Y29udmVyc2F0aW9uLmlkfSByZWFjaGVkIG1heGltdW0gZHVyYXRpb24sIGVuZGluZyBhdXRvbWF0aWNhbGx5YCxcbiAgICAgICk7XG4gICAgICB0aGlzLmVuZENvbnZlcnNhdGlvbihjb252ZXJzYXRpb24uaWQpO1xuICAgIH0sIHRoaXMub3B0aW9ucy5tYXhDb252ZXJzYXRpb25EdXJhdGlvbik7XG5cbiAgICB0aGlzLmNvbnZlcnNhdGlvblRpbWVvdXRzLnNldChjb252ZXJzYXRpb24uaWQsIHRpbWVvdXQpO1xuXG4gICAgY29uc29sZS5sb2coXG4gICAgICBgQVVUT05PTU9VUyBTWVNURU06IENvbnZlcnNhdGlvbiAke2NvbnZlcnNhdGlvbi5pZH0gaW5pdGlhdGVkIHN1Y2Nlc3NmdWxseSB3aXRoICR7cGFydGljaXBhbnRzLmxlbmd0aH0gcGFydGljaXBhbnRzYCxcbiAgICApO1xuICAgIHJldHVybiBjb252ZXJzYXRpb247XG4gIH1cblxuICAvKipcbiAgICogRW5kcyBhbiBhdXRvbm9tb3VzIGNvbnZlcnNhdGlvblxuICAgKi9cbiAgZW5kQ29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZyhgRW5kaW5nIGNvbnZlcnNhdGlvbiAke2NvbnZlcnNhdGlvbklkfWApO1xuXG4gICAgLy8gUmVtb3ZlIGZyb20gYWN0aXZlIGNvbnZlcnNhdGlvbnNcbiAgICB0aGlzLmFjdGl2ZUNvbnZlcnNhdGlvbnMuZGVsZXRlKGNvbnZlcnNhdGlvbklkKTtcblxuICAgIC8vIENsZWFyIHRoZSB0aW1lb3V0XG4gICAgY29uc3QgdGltZW91dCA9IHRoaXMuY29udmVyc2F0aW9uVGltZW91dHMuZ2V0KGNvbnZlcnNhdGlvbklkKTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGhpcy5jb252ZXJzYXRpb25UaW1lb3V0cy5kZWxldGUoY29udmVyc2F0aW9uSWQpO1xuICAgICAgY29uc29sZS5sb2coYENsZWFyZWQgdGltZW91dCBmb3IgY29udmVyc2F0aW9uICR7Y29udmVyc2F0aW9uSWR9YCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYENvbnZlcnNhdGlvbiAke2NvbnZlcnNhdGlvbklkfSBlbmRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBjb252ZXJzYXRpb24gc2hvdWxkIGVuZCBiYXNlZCBvbiBtZXNzYWdlIGNvdW50XG4gICAqL1xuICBzaG91bGRFbmRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uOiBDb252ZXJzYXRpb24pOiBib29sZWFuIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZm9yIGF1dG9ub21vdXMgY29udmVyc2F0aW9uc1xuICAgIGlmICghY29udmVyc2F0aW9uIHx8ICFjb252ZXJzYXRpb24uaXNBdXRvbm9tb3VzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDb3VudCBub24tc3lzdGVtIG1lc3NhZ2VzXG4gICAgY29uc3QgbWVzc2FnZUNvdW50ID0gY29udmVyc2F0aW9uLm1lc3NhZ2VzLmZpbHRlcihcbiAgICAgIChtc2cpID0+ICFtc2cubWV0YWRhdGE/LmlzU3lzdGVtTWVzc2FnZSxcbiAgICApLmxlbmd0aDtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjb252ZXJzYXRpb24gaGFzIHJlYWNoZWQgdGhlIG1heGltdW0gbWVzc2FnZSBjb3VudFxuICAgIHJldHVybiBtZXNzYWdlQ291bnQgPj0gdGhpcy5vcHRpb25zLm1heEF1dG9ub21vdXNNZXNzYWdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBzeXN0ZW0gbWVzc2FnZSBmb3IgdGhlIHN0YXJ0IG9mIGFuIGF1dG9ub21vdXMgY29udmVyc2F0aW9uXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlQ29udmVyc2F0aW9uU3RhcnRNZXNzYWdlKFxuICAgIHBhcnRpY2lwYW50czogQWdlbnRbXSxcbiAgICB0cmlnZ2VyOiBUcmlnZ2VyVHlwZSxcbiAgICB0b3BpYz86IHN0cmluZyxcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCBhZ2VudE5hbWVzID0gcGFydGljaXBhbnRzLm1hcCgoYWdlbnQpID0+IGFnZW50Lm5hbWUpLmpvaW4oXCIsIFwiKTtcblxuICAgIHN3aXRjaCAodHJpZ2dlcikge1xuICAgICAgY2FzZSBcInByb3hpbWl0eVwiOlxuICAgICAgICByZXR1cm4gYCR7YWdlbnROYW1lc30gaGF2ZSBlbmNvdW50ZXJlZCBlYWNoIG90aGVyIGFuZCBzdGFydGVkIGEgY29udmVyc2F0aW9uLmA7XG5cbiAgICAgIGNhc2UgXCJrbm93bGVkZ2Vfb3ZlcmxhcFwiOlxuICAgICAgICBpZiAodG9waWMpIHtcbiAgICAgICAgICByZXR1cm4gYCR7YWdlbnROYW1lc30gaGF2ZSBzdGFydGVkIGEgY29udmVyc2F0aW9uIGFib3V0IHRoZWlyIHNoYXJlZCBrbm93bGVkZ2Ugb2YgJHt0b3BpY30uYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7YWdlbnROYW1lc30gaGF2ZSBzdGFydGVkIGEgY29udmVyc2F0aW9uIGFib3V0IHRoZWlyIHNoYXJlZCBrbm93bGVkZ2UuYDtcblxuICAgICAgY2FzZSBcInNjaGVkdWxlZFwiOlxuICAgICAgICByZXR1cm4gYCR7YWdlbnROYW1lc30gaGF2ZSBzdGFydGVkIGEgc2NoZWR1bGVkIGNvbnZlcnNhdGlvbi5gO1xuXG4gICAgICBjYXNlIFwidXNlcl9pbml0aWF0ZWRcIjpcbiAgICAgICAgcmV0dXJuIGAke2FnZW50TmFtZXN9IGhhdmUgYmVlbiBwcm9tcHRlZCB0byBzdGFydCBhIGNvbnZlcnNhdGlvbi5gO1xuXG4gICAgICBjYXNlIFwiY29udGludWF0aW9uXCI6XG4gICAgICAgIHJldHVybiBgJHthZ2VudE5hbWVzfSBoYXZlIGNvbnRpbnVlZCB0aGVpciBwcmV2aW91cyBjb252ZXJzYXRpb24uYDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGAke2FnZW50TmFtZXN9IGhhdmUgc3RhcnRlZCBhIGNvbnZlcnNhdGlvbi5gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWdnZXN0cyBhIHRvcGljIGZvciBjb252ZXJzYXRpb24gYmFzZWQgb24gYWdlbnRzJyBrbm93bGVkZ2VcbiAgICovXG4gIHN1Z2dlc3RDb252ZXJzYXRpb25Ub3BpYyhhZ2VudHM6IEFnZW50W10pOiBzdHJpbmcgfCBudWxsIHtcbiAgICAvLyBFeHRyYWN0IGFsbCB0YWdzIGZyb20gYWxsIGFnZW50cycga25vd2xlZGdlXG4gICAgY29uc3QgdGFnQ291bnRzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAgIGFnZW50cy5mb3JFYWNoKChhZ2VudCkgPT4ge1xuICAgICAgYWdlbnQua25vd2xlZGdlLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIGVudHJ5LnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgICAgdGFnQ291bnRzLnNldCh0YWcsICh0YWdDb3VudHMuZ2V0KHRhZykgfHwgMCkgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEZpbmQgdGFncyB0aGF0IGFwcGVhciBpbiBtdWx0aXBsZSBhZ2VudHMnIGtub3dsZWRnZVxuICAgIGNvbnN0IGNvbW1vblRhZ3M6IFtzdHJpbmcsIG51bWJlcl1bXSA9IFtdO1xuICAgIHRhZ0NvdW50cy5mb3JFYWNoKChjb3VudCwgdGFnKSA9PiB7XG4gICAgICBpZiAoY291bnQgPj0gMikge1xuICAgICAgICAvLyBBdCBsZWFzdCAyIGFnZW50cyBoYXZlIHRoaXMgdGFnXG4gICAgICAgIGNvbW1vblRhZ3MucHVzaChbdGFnLCBjb3VudF0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU29ydCBieSBmcmVxdWVuY3kgKGhpZ2hlc3QgZmlyc3QpXG4gICAgY29tbW9uVGFncy5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIG1vc3QgY29tbW9uIHRhZywgb3IgbnVsbCBpZiBub25lIGZvdW5kXG4gICAgcmV0dXJuIGNvbW1vblRhZ3MubGVuZ3RoID4gMCA/IGNvbW1vblRhZ3NbMF1bMF0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBhbGwgcG9zc2libGUgdHJpZ2dlcnMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG9uZSB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgY29udmVyc2F0aW9uXG4gICAqL1xuICBjaGVja0FsbFRyaWdnZXJzKGFnZW50czogQWdlbnRbXSk6IHtcbiAgICBzaG91bGRUcmlnZ2VyOiBib29sZWFuO1xuICAgIHBhcnRpY2lwYW50czogQWdlbnRbXTtcbiAgICB0cmlnZ2VyOiBUcmlnZ2VyVHlwZTtcbiAgICB0b3BpYz86IHN0cmluZztcbiAgfSB7XG4gICAgLy8gLyogVVNFRlVMIEZPUiBQUk9EVUNUSU9OIFRFU1RJTkc6IExvZyB0cmlnZ2VyIGNoZWNrICovXG4gICAgLy8gY29uc29sZS5sb2coXCJDaGVja2luZyBhbGwgYXV0b25vbW91cyBjb252ZXJzYXRpb24gdHJpZ2dlcnNcIilcblxuICAgIC8vIENoZWNrIHByb3hpbWl0eSB0cmlnZ2VyXG4gICAgY29uc3QgcHJveGltaXR5UmVzdWx0ID0gdGhpcy5jaGVja1Byb3hpbWl0eVRyaWdnZXIoYWdlbnRzKTtcbiAgICBpZiAocHJveGltaXR5UmVzdWx0LnNob3VsZFRyaWdnZXIpIHtcbiAgICAgIGNvbnN0IHRvcGljID0gdGhpcy5zdWdnZXN0Q29udmVyc2F0aW9uVG9waWMocHJveGltaXR5UmVzdWx0LnBhcnRpY2lwYW50cyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcm94aW1pdHlSZXN1bHQsXG4gICAgICAgIHRyaWdnZXI6IFwicHJveGltaXR5XCIsXG4gICAgICAgIHRvcGljOiB0b3BpYyA/PyB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGtub3dsZWRnZSBvdmVybGFwIHRyaWdnZXJcbiAgICBjb25zdCBrbm93bGVkZ2VSZXN1bHQgPSB0aGlzLmNoZWNrS25vd2xlZGdlT3ZlcmxhcFRyaWdnZXIoYWdlbnRzKTtcbiAgICBpZiAoa25vd2xlZGdlUmVzdWx0LnNob3VsZFRyaWdnZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmtub3dsZWRnZVJlc3VsdCxcbiAgICAgICAgdHJpZ2dlcjogXCJrbm93bGVkZ2Vfb3ZlcmxhcFwiLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBObyB0cmlnZ2VycyBtYXRjaGVkXG4gICAgcmV0dXJuIHsgc2hvdWxkVHJpZ2dlcjogZmFsc2UsIHBhcnRpY2lwYW50czogW10sIHRyaWdnZXI6IFwicHJveGltaXR5XCIgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBjb252ZXJzYXRpb24gaGFzIHJlYWNoZWQgbWluaW11bSBkZXB0aFxuICAgKi9cbiAgaGFzUmVhY2hlZE1pbmltdW1EZXB0aChjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbik6IGJvb2xlYW4ge1xuICAgIC8vIEFsd2F5cyByZXR1cm4gdHJ1ZSBzaW5jZSB3ZSdyZSBub3QgdXNpbmcgbWluaW11bSBkZXB0aCBhbnltb3JlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBNZXRob2RzIGV4cGVjdGVkIGJ5IHRlc3RzXG4gIGdldFN0YXRlKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIGFnZW50czogW10sXG4gICAgICBhY3RpdmVDb252ZXJzYXRpb25zOiB0aGlzLmFjdGl2ZUNvbnZlcnNhdGlvbnMsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgfTtcbiAgfVxuXG4gIGdldER5bmFtaWNzKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR1cm5UYWtpbmc6IFwicm91bmQtcm9iaW5cIixcbiAgICAgIHJlc3BvbnNlQ29vcmRpbmF0aW9uOiBcInNlcXVlbnRpYWxcIixcbiAgICB9O1xuICB9XG5cbiAgc2V0VHVyblRha2luZ1N0cmF0ZWd5KHN0cmF0ZWd5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBTdG9yZSBzdHJhdGVneSAoaW1wbGVtZW50YXRpb24gd291bGQgaGFuZGxlIGRpZmZlcmVudCBzdHJhdGVnaWVzKVxuICB9XG5cbiAgYXN5bmMgc2VsZWN0TmV4dFNwZWFrZXIoKTogUHJvbWlzZTxBZ2VudD4ge1xuICAgIC8vIFJldHVybiBhIG1vY2sgYWdlbnQgZm9yIHRlc3RzXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBcInRlc3QtYWdlbnRcIixcbiAgICAgIG5hbWU6IFwiVGVzdCBBZ2VudFwiLFxuICAgICAgaW5Db252ZXJzYXRpb246IGZhbHNlLFxuICAgICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICAgICAgY29sb3I6IFwiIzAwMFwiLFxuICAgICAga25vd2xlZGdlOiBbXSxcbiAgICAgIGF1dG9ub215RW5hYmxlZDogdHJ1ZSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcmVjb3JkVHVybihhZ2VudElkOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFJlY29yZCB0aGUgdHVybiAoaW1wbGVtZW50YXRpb24gd291bGQgc3RvcmUgaW4gY29udmVyc2F0aW9uIHN0YXRlKVxuICB9XG5cbiAgYXN5bmMgd2FpdEZvclJlc3BvbnNlKGFnZW50SWQ6IHN0cmluZywgdGltZW91dDogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyBXYWl0IGZvciBhZ2VudCByZXNwb25zZSB3aXRoIHRpbWVvdXRcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBhc3luYyBnZXRBdmFpbGFibGVBZ2VudHMoKTogUHJvbWlzZTxBZ2VudFtdPiB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXN5bmMgcmVzb2x2ZURlYWRsb2NrKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHsgcmVzb2x2ZWQ6IHRydWUgfTtcbiAgfVxuXG4gIGFkZE1lc3NhZ2UobWVzc2FnZTogYW55KTogdm9pZCB7XG4gICAgLy8gQWRkIG1lc3NhZ2UgdG8gY29udmVyc2F0aW9uIHN0YXRlXG4gIH1cblxuICBldmFsdWF0ZVRvcGljQ29oZXJlbmNlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDAuODtcbiAgfVxuXG4gIHNldFJ1bGVzKHJ1bGVzOiBhbnlbXSk6IHZvaWQge1xuICAgIC8vIFNldCBjb252ZXJzYXRpb24gcnVsZXNcbiAgfVxuXG4gIHZhbGlkYXRlUmVzcG9uc2UocmVzcG9uc2U6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgY2FuQWdlbnRTcGVhayhhZ2VudElkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIGNvb3JkaW5hdGVSZXNwb25zZShjb29yZGluYXRpb246IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHsgY29vcmRpbmF0ZWQ6IHRydWUgfTtcbiAgfVxuXG4gIGFzeW5jIHJlc29sdmVDb25mbGljdChjb25mbGljdDogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4geyByZXNvbHZlZDogdHJ1ZSB9O1xuICB9XG59XG5cbi8vIEV4cG9ydCBsZWdhY3kgbmFtZXMgZm9yIGNvbXBhdGliaWxpdHlcbmV4cG9ydCBjb25zdCBBdXRvbm9tb3VzQ29udmVyc2F0aW9uTWFuYWdlciA9IEF1dG9ub21vdXNDb252ZXJzYXRpb25TeXN0ZW07XG5leHBvcnQgY29uc3QgY3JlYXRlQXV0b25vbW91c0NvbnZlcnNhdGlvbiA9IChcbiAgb3B0aW9uczogQXV0b25vbW91c0NvbnZlcnNhdGlvbk9wdGlvbnMsXG4pID0+IG5ldyBBdXRvbm9tb3VzQ29udmVyc2F0aW9uU3lzdGVtKG9wdGlvbnMpO1xuXG4vLyBFeHBvcnQgdHlwZXMgZm9yIHRlc3RzXG5leHBvcnQgdHlwZSBDb252ZXJzYXRpb25Db25maWcgPSBBdXRvbm9tb3VzQ29udmVyc2F0aW9uT3B0aW9ucztcbmV4cG9ydCB0eXBlIENvbnZlcnNhdGlvblN0YXRlID0gYW55OyAvLyBTaW1wbGlmaWVkIGZvciBub3dcbmV4cG9ydCB0eXBlIEFnZW50UGFydGljaXBhbnQgPSBBZ2VudDtcbmV4cG9ydCB0eXBlIHsgTWVzc2FnZSB9IGZyb20gXCJAL2xpYi90eXBlc1wiO1xuZXhwb3J0IHR5cGUgQ29udmVyc2F0aW9uRHluYW1pY3MgPSBhbnk7IC8vIFNpbXBsaWZpZWQgZm9yIG5vd1xuZXhwb3J0IHR5cGUgVHVyblRha2luZ1N0cmF0ZWd5ID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgUmVzcG9uc2VDb29yZGluYXRpb24gPSBhbnk7IC8vIFNpbXBsaWZpZWQgZm9yIG5vd1xuXG4vLyBFeHBvcnQgcGxhY2Vob2xkZXIgZnVuY3Rpb25zIGZvciB0ZXN0c1xuZXhwb3J0IGNvbnN0IG9yY2hlc3RyYXRlQ29udmVyc2F0aW9uID0gKG1hbmFnZXI6IGFueSwgb3B0aW9uczogYW55KSA9PlxuICBQcm9taXNlLnJlc29sdmUoe1xuICAgIG1lc3NhZ2VzOiBbXSxcbiAgICBwYXJ0aWNpcGFudHM6IFtdLFxuICAgIGR1cmF0aW9uOiAwLFxuICB9KTtcblxuZXhwb3J0IGNvbnN0IGV2YWx1YXRlQ29udmVyc2F0aW9uUXVhbGl0eSA9IChzdGF0ZTogYW55KSA9PiAoe1xuICBvdmVyYWxsOiAwLjUsXG4gIHJlY29tbWVuZGF0aW9uczogW1wiaW1wcm92ZSBjbGFyaXR5XCIsIFwiZW5oYW5jZSBlbmdhZ2VtZW50XCJdLFxufSk7XG5cbmV4cG9ydCBjb25zdCBkZXRlY3RFbWVyZ2VudFBhdHRlcm5zID0gKHN0YXRlOiBhbnkpID0+IFtdO1xuZXhwb3J0IGNvbnN0IGFwcGx5Q29udmVyc2F0aW9uUnVsZXMgPSAoKSA9PiB7fTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQWdlbnRSZXNwb25zZSA9IChjb250ZXh0OiBhbnkpID0+XG4gIFByb21pc2UucmVzb2x2ZSh7XG4gICAgY29udGVudDogXCJHZW5lcmF0ZWQgcmVzcG9uc2VcIixcbiAgICBhZ2VudElkOiBjb250ZXh0Py5jdXJyZW50U3BlYWtlcj8uaWQgfHwgXCJ1bmtub3duXCIsXG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICB9KTtcbiJdLCJuYW1lcyI6WyJBdXRvbm9tb3VzQ29udmVyc2F0aW9uTWFuYWdlciIsIkF1dG9ub21vdXNDb252ZXJzYXRpb25TeXN0ZW0iLCJhcHBseUNvbnZlcnNhdGlvblJ1bGVzIiwiY3JlYXRlQXV0b25vbW91c0NvbnZlcnNhdGlvbiIsImRlZmF1bHRBdXRvbm9tb3VzT3B0aW9ucyIsImRldGVjdEVtZXJnZW50UGF0dGVybnMiLCJldmFsdWF0ZUNvbnZlcnNhdGlvblF1YWxpdHkiLCJnZW5lcmF0ZUFnZW50UmVzcG9uc2UiLCJvcmNoZXN0cmF0ZUNvbnZlcnNhdGlvbiIsInByb3hpbWl0eVRocmVzaG9sZCIsImtub3dsZWRnZU92ZXJsYXBUaHJlc2hvbGQiLCJtYXhTaW11bHRhbmVvdXNDb252ZXJzYXRpb25zIiwiY29udmVyc2F0aW9uQ29vbGRvd24iLCJtYXhDb252ZXJzYXRpb25EdXJhdGlvbiIsImVuYWJsZVNjaGVkdWxlZENvbnZlcnNhdGlvbnMiLCJlbmFibGVLbm93bGVkZ2VCYXNlZFRyaWdnZXJzIiwibWF4QXV0b25vbW91c01lc3NhZ2VzIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiYWN0aXZlQ29udmVyc2F0aW9ucyIsIlNldCIsImFnZW50TGFzdENvbnZlcnNhdGlvblRpbWUiLCJNYXAiLCJjb252ZXJzYXRpb25UaW1lb3V0cyIsImtub3dsZWRnZVJldHJpZXZlciIsIktub3dsZWRnZVJldHJpZXZlciIsInVwZGF0ZU9wdGlvbnMiLCJyZXNldENvb2xkb3duIiwiYWdlbnRJZHMiLCJmb3JFYWNoIiwiaWQiLCJkZWxldGUiLCJjaGVja1Byb3hpbWl0eVRyaWdnZXIiLCJhZ2VudHMiLCJhdXRvbm9tb3VzQWdlbnRzIiwiZmlsdGVyIiwiYWdlbnQiLCJhdXRvbm9teUVuYWJsZWQiLCJsZW5ndGgiLCJzaG91bGRUcmlnZ2VyIiwicGFydGljaXBhbnRzIiwiYWdlbnRHcm91cHMiLCJpbkNvbnZlcnNhdGlvbiIsImxhc3RDb252ZXJzYXRpb25UaW1lIiwiZ2V0IiwidGltZVNpbmNlTGFzdENvbnZlcnNhdGlvbiIsIkRhdGUiLCJub3ciLCJpc09uQ29vbGRvd24iLCJuZWFyYnlBZ2VudHMiLCJvdGhlckFnZW50Iiwib3RoZXJMYXN0Q29udmVyc2F0aW9uVGltZSIsIm90aGVyVGltZVNpbmNlTGFzdENvbnZlcnNhdGlvbiIsIm90aGVySXNPbkNvb2xkb3duIiwiZGlzdGFuY2UiLCJNYXRoIiwic3FydCIsInBvdyIsInBvc2l0aW9uIiwieCIsInkiLCJpc05lYXJieSIsInB1c2giLCJzbGljZSIsImNoZWNrS25vd2xlZGdlT3ZlcmxhcFRyaWdnZXIiLCJ0b3BpYyIsImFnZW50UGFpcnMiLCJpIiwiYWdlbnQxIiwibGFzdENvbnZlcnNhdGlvblRpbWUxIiwiaiIsImFnZW50MiIsImxhc3RDb252ZXJzYXRpb25UaW1lMiIsIm92ZXJsYXBTY29yZSIsImNvbW1vblRhZ3MiLCJjYWxjdWxhdGVLbm93bGVkZ2VPdmVybGFwIiwiZmxvb3IiLCJyYW5kb20iLCJzb3J0IiwiYSIsImIiLCJ0YWdzMSIsInRhZ3MyIiwia25vd2xlZGdlIiwiZW50cnkiLCJ0YWdzIiwidGFnIiwiYWRkIiwiaGFzIiwidG90YWxVbmlxdWVUYWdzIiwiQXJyYXkiLCJmcm9tIiwic2l6ZSIsImluaXRpYXRlQ29udmVyc2F0aW9uIiwidHJpZ2dlciIsImNvbnNvbGUiLCJsb2ciLCJtYXAiLCJuYW1lIiwiam9pbiIsImNvbnZlcnNhdGlvbiIsIm1lc3NhZ2VzIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImlzQXV0b25vbW91cyIsInN5c3RlbU1lc3NhZ2UiLCJjb250ZW50IiwiZ2VuZXJhdGVDb252ZXJzYXRpb25TdGFydE1lc3NhZ2UiLCJzZW5kZXJJZCIsInRpbWVzdGFtcCIsIm1ldGFkYXRhIiwiaXNTeXN0ZW1NZXNzYWdlIiwidHlwZSIsInNldCIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZW5kQ29udmVyc2F0aW9uIiwiY29udmVyc2F0aW9uSWQiLCJjbGVhclRpbWVvdXQiLCJzaG91bGRFbmRDb252ZXJzYXRpb24iLCJtZXNzYWdlQ291bnQiLCJtc2ciLCJhZ2VudE5hbWVzIiwic3VnZ2VzdENvbnZlcnNhdGlvblRvcGljIiwidGFnQ291bnRzIiwiY291bnQiLCJjaGVja0FsbFRyaWdnZXJzIiwicHJveGltaXR5UmVzdWx0IiwidW5kZWZpbmVkIiwia25vd2xlZGdlUmVzdWx0IiwiaGFzUmVhY2hlZE1pbmltdW1EZXB0aCIsImdldFN0YXRlIiwiZ2V0RHluYW1pY3MiLCJ0dXJuVGFraW5nIiwicmVzcG9uc2VDb29yZGluYXRpb24iLCJzZXRUdXJuVGFraW5nU3RyYXRlZ3kiLCJzdHJhdGVneSIsInNlbGVjdE5leHRTcGVha2VyIiwiY29sb3IiLCJyZWNvcmRUdXJuIiwiYWdlbnRJZCIsIm1lc3NhZ2UiLCJ3YWl0Rm9yUmVzcG9uc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldEF2YWlsYWJsZUFnZW50cyIsInJlc29sdmVEZWFkbG9jayIsInJlc29sdmVkIiwiYWRkTWVzc2FnZSIsImV2YWx1YXRlVG9waWNDb2hlcmVuY2UiLCJzZXRSdWxlcyIsInJ1bGVzIiwidmFsaWRhdGVSZXNwb25zZSIsInJlc3BvbnNlIiwiY2FuQWdlbnRTcGVhayIsImNvb3JkaW5hdGVSZXNwb25zZSIsImNvb3JkaW5hdGlvbiIsImNvb3JkaW5hdGVkIiwicmVzb2x2ZUNvbmZsaWN0IiwiY29uZmxpY3QiLCJtYW5hZ2VyIiwiZHVyYXRpb24iLCJzdGF0ZSIsIm92ZXJhbGwiLCJyZWNvbW1lbmRhdGlvbnMiLCJjb250ZXh0IiwiY3VycmVudFNwZWFrZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBd29CYUEsNkJBQTZCO2VBQTdCQTs7SUFwa0JBQyw0QkFBNEI7ZUFBNUJBOztJQWdtQkFDLHNCQUFzQjtlQUF0QkE7O0lBM0JBQyw0QkFBNEI7ZUFBNUJBOztJQWhsQkFDLHdCQUF3QjtlQUF4QkE7O0lBMG1CQUMsc0JBQXNCO2VBQXRCQTs7SUFMQUMsMkJBQTJCO2VBQTNCQTs7SUFRQUMscUJBQXFCO2VBQXJCQTs7SUFmQUMsdUJBQXVCO2VBQXZCQTs7O29DQWhwQnNCO0FBa0Q1QixNQUFNSiwyQkFBMEQ7SUFDckVLLG9CQUFvQjtJQUNwQkMsMkJBQTJCO0lBQzNCQyw4QkFBOEI7SUFDOUJDLHNCQUFzQjtJQUN0QkMseUJBQXlCO0lBQ3pCQyw4QkFBOEI7SUFDOUJDLDhCQUE4QjtJQUM5QkMsdUJBQXVCO0FBQ3pCO0FBRU8sTUFBTWY7SUFPWGdCLFlBQVlDLFVBQWtELENBQUMsQ0FBQyxDQUFFO2FBSjFEQyxzQkFBbUMsSUFBSUM7YUFDdkNDLDRCQUFpRCxJQUFJQzth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