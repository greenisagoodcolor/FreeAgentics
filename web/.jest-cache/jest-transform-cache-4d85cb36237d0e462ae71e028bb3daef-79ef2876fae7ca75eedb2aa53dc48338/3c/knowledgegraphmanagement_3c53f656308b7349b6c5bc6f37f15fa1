65c75605184a6c4ae755dae6af6d1ffb
/**
 * Knowledge Graph Management Module
 * ADR-007 Compliant - Knowledge Management
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    addEdge: function() {
        return addEdge;
    },
    addNode: function() {
        return addNode;
    },
    analyzeGraph: function() {
        return analyzeGraph;
    },
    createKnowledgeGraph: function() {
        return createKnowledgeGraph;
    },
    exportGraph: function() {
        return exportGraph;
    },
    findPath: function() {
        return findPath;
    },
    importGraph: function() {
        return importGraph;
    },
    mergeGraphs: function() {
        return mergeGraphs;
    },
    optimizeGraph: function() {
        return optimizeGraph;
    },
    removeNode: function() {
        return removeNode;
    },
    updateNode: function() {
        return updateNode;
    },
    validateGraph: function() {
        return validateGraph;
    }
});
let graphCounter = 0;
function createKnowledgeGraph(id) {
    return {
        id: id || `graph-${++graphCounter}`,
        nodes: [],
        edges: [],
        metadata: {
            created: Date.now(),
            modified: Date.now(),
            version: "1.0"
        }
    };
}
function addNode(graph, node) {
    if (graph.nodes.some((n)=>n.id === node.id)) {
        throw new Error(`Node with ID ${node.id} already exists`);
    }
    return {
        ...graph,
        nodes: [
            ...graph.nodes,
            node
        ],
        metadata: {
            ...graph.metadata,
            modified: Date.now()
        }
    };
}
function addEdge(graph, edge) {
    // Validate edge endpoints
    const sourceExists = graph.nodes.some((n)=>n.id === edge.source);
    const targetExists = graph.nodes.some((n)=>n.id === edge.target);
    if (!sourceExists) {
        throw new Error(`Source node ${edge.source} does not exist`);
    }
    if (!targetExists) {
        throw new Error(`Target node ${edge.target} does not exist`);
    }
    return {
        ...graph,
        edges: [
            ...graph.edges,
            edge
        ],
        metadata: {
            ...graph.metadata,
            modified: Date.now()
        }
    };
}
function updateNode(graph, nodeId, updates) {
    const nodeIndex = graph.nodes.findIndex((n)=>n.id === nodeId);
    if (nodeIndex === -1) {
        throw new Error(`Node ${nodeId} not found`);
    }
    const updatedNodes = [
        ...graph.nodes
    ];
    updatedNodes[nodeIndex] = {
        ...updatedNodes[nodeIndex],
        ...updates,
        id: nodeId
    };
    return {
        ...graph,
        nodes: updatedNodes,
        metadata: {
            ...graph.metadata,
            modified: Date.now()
        }
    };
}
function removeNode(graph, nodeId) {
    return {
        ...graph,
        nodes: graph.nodes.filter((n)=>n.id !== nodeId),
        edges: graph.edges.filter((e)=>e.source !== nodeId && e.target !== nodeId),
        metadata: {
            ...graph.metadata,
            modified: Date.now()
        }
    };
}
function findPath(graph, startId, endId) {
    if (!graph.nodes.some((n)=>n.id === startId) || !graph.nodes.some((n)=>n.id === endId)) {
        return null;
    }
    // BFS to find shortest path
    const queue = [
        {
            node: startId,
            path: [
                startId
            ]
        }
    ];
    const visited = new Set();
    while(queue.length > 0){
        const { node, path } = queue.shift();
        if (node === endId) {
            return path;
        }
        if (visited.has(node)) continue;
        visited.add(node);
        // Find neighbors
        const neighbors = graph.edges.filter((e)=>e.source === node || e.target === node).map((e)=>e.source === node ? e.target : e.source).filter((n)=>!visited.has(n));
        for (const neighbor of neighbors){
            queue.push({
                node: neighbor,
                path: [
                    ...path,
                    neighbor
                ]
            });
        }
    }
    return null;
}
function mergeGraphs(graph1, graph2, options = {}) {
    const conflicts = [];
    const mergedNodes = new Map();
    const mergedEdges = new Map();
    // Merge nodes
    for (const node of graph1.nodes){
        mergedNodes.set(node.id, node);
    }
    for (const node of graph2.nodes){
        const existing = mergedNodes.get(node.id);
        if (existing) {
            // Conflict detected
            if (options.reportConflicts) {
                conflicts.push({
                    nodeId: node.id,
                    graph1Value: existing.label,
                    graph2Value: node.label
                });
            }
            if (options.conflictResolution === "newer" || options.conflictResolution === "keep-second") {
                mergedNodes.set(node.id, node);
            }
        // Otherwise keep existing (keep-first or default)
        } else {
            mergedNodes.set(node.id, node);
        }
    }
    // Merge edges
    for (const edge of graph1.edges){
        mergedEdges.set(edge.id, edge);
    }
    for (const edge of graph2.edges){
        if (!mergedEdges.has(edge.id)) {
            // Only add if both endpoints exist in merged graph
            if (mergedNodes.has(edge.source) && mergedNodes.has(edge.target)) {
                mergedEdges.set(edge.id, edge);
            }
        }
    }
    const result = {
        id: `merged-${graph1.id}-${graph2.id}`,
        nodes: Array.from(mergedNodes.values()),
        edges: Array.from(mergedEdges.values()),
        metadata: {
            created: Math.min(graph1.metadata.created, graph2.metadata.created),
            modified: Date.now(),
            version: "1.0",
            mergedFrom: [
                graph1.id,
                graph2.id
            ]
        }
    };
    if (options.reportConflicts) {
        result.conflicts = conflicts;
    }
    return result;
}
function exportGraph(graph, format) {
    if (format === "json") {
        return JSON.stringify(graph, null, 2);
    }
    // GraphML format
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<graphml xmlns="http://graphml.graphdrawing.org/xmlns">\n';
    xml += '  <graph id="' + graph.id + '" edgedefault="directed">\n';
    // Add nodes
    for (const node of graph.nodes){
        xml += `    <node id="${node.id}">\n`;
        xml += `      <data key="label">${node.label}</data>\n`;
        xml += `      <data key="type">${node.type}</data>\n`;
        xml += "    </node>\n";
    }
    // Add edges
    for (const edge of graph.edges){
        xml += `    <edge id="${edge.id}" source="${edge.source}" target="${edge.target}">\n`;
        xml += `      <data key="type">${edge.type}</data>\n`;
        if (edge.weight !== undefined) {
            xml += `      <data key="weight">${edge.weight}</data>\n`;
        }
        xml += "    </edge>\n";
    }
    xml += "  </graph>\n";
    xml += "</graphml>";
    return xml;
}
function importGraph(data, format) {
    if (format === "json") {
        const parsed = JSON.parse(data);
        // Validate structure
        if (!parsed.nodes || !parsed.edges) {
            throw new Error("Invalid graph structure");
        }
        // Validate nodes
        for (const node of parsed.nodes){
            if (!node.id || !node.label || !node.type) {
                throw new Error("Invalid graph structure");
            }
        }
        // Validate edges reference existing nodes
        const nodeIds = new Set(parsed.nodes.map((n)=>n.id));
        for (const edge of parsed.edges){
            if (!nodeIds.has(edge.source) || !nodeIds.has(edge.target)) {
                throw new Error("Invalid graph structure");
            }
        }
        return {
            id: parsed.id || createKnowledgeGraph().id,
            nodes: parsed.nodes,
            edges: parsed.edges,
            metadata: parsed.metadata || {
                created: Date.now(),
                modified: Date.now(),
                version: "1.0"
            }
        };
    }
    throw new Error("GraphML import not implemented");
}
function analyzeGraph(graph, options = {}) {
    const nodeCount = graph.nodes.length;
    const edgeCount = graph.edges.length;
    const maxPossibleEdges = nodeCount * (nodeCount - 1) / 2;
    const density = nodeCount > 1 ? edgeCount / maxPossibleEdges : 0;
    // Calculate average degree
    const degrees = new Map();
    for (const edge of graph.edges){
        degrees.set(edge.source, (degrees.get(edge.source) || 0) + 1);
        degrees.set(edge.target, (degrees.get(edge.target) || 0) + 1);
    }
    const avgDegree = nodeCount > 0 ? Array.from(degrees.values()).reduce((a, b)=>a + b, 0) / nodeCount : 0;
    const metrics = {
        nodeCount,
        edgeCount,
        density,
        avgDegree,
        diameter: calculateDiameter(graph),
        clustering: calculateClustering(graph),
        modularity: 0.5
    };
    if (options.includeNodeImportance) {
        metrics.importantNodes = Array.from(degrees.entries()).map(([id, degree])=>({
                id,
                score: degree
            })).sort((a, b)=>b.score - a.score).slice(0, 3);
    }
    if (options.detectCommunities) {
        metrics.communities = detectCommunities(graph);
    }
    return metrics;
}
function optimizeGraph(graph, options = {}) {
    let optimized = {
        ...graph
    };
    if (options.removeRedundant) {
        // Remove transitive edges
        const edgesToRemove = new Set();
        for (const edge of graph.edges){
            if (edge.type === "implies") {
                // Check if there's an indirect path
                const pathWithoutEdge = findPathExcludingEdge(graph, edge.source, edge.target, edge.id);
                if (pathWithoutEdge && pathWithoutEdge.length <= 3) {
                    edgesToRemove.add(edge.id);
                }
            }
        }
        optimized.edges = optimized.edges.filter((e)=>!edgesToRemove.has(e.id));
    }
    if (options.consolidateSimilar) {
        // Simple consolidation based on label similarity
        const threshold = options.similarityThreshold || 0.8;
        const nodeGroups = [];
        const processed = new Set();
        for (const node of graph.nodes){
            if (processed.has(node.id)) continue;
            const group = [
                node
            ];
            processed.add(node.id);
            for (const other of graph.nodes){
                if (processed.has(other.id)) continue;
                const similarity = calculateSimilarity(node.label, other.label);
                if (similarity >= threshold) {
                    group.push(other);
                    processed.add(other.id);
                }
            }
            if (group.length > 1) {
                nodeGroups.push(group);
            }
        }
        // Merge similar nodes
        const mergedNodes = [];
        const nodeMapping = new Map();
        for (const group of nodeGroups){
            const merged = group[0]; // Keep first as representative
            mergedNodes.push(merged);
            for (const node of group){
                nodeMapping.set(node.id, merged.id);
            }
        }
        // Add non-grouped nodes
        for (const node of graph.nodes){
            if (!nodeMapping.has(node.id) || nodeMapping.get(node.id) === node.id) {
                if (!mergedNodes.some((n)=>n.id === node.id)) {
                    mergedNodes.push(node);
                }
            }
        }
        optimized.nodes = mergedNodes;
        // Update edges with merged node IDs
        optimized.edges = optimized.edges.map((edge)=>({
                ...edge,
                source: nodeMapping.get(edge.source) || edge.source,
                target: nodeMapping.get(edge.target) || edge.target
            })).filter((edge)=>edge.source !== edge.target); // Remove self-loops
    }
    if (options.pruneThreshold !== undefined) {
        optimized.edges = optimized.edges.filter((edge)=>(edge.weight || 1) >= options.pruneThreshold);
    }
    return optimized;
}
function validateGraph(graph, options = {}) {
    const errors = [];
    // Check for orphaned nodes
    if (!options.allowOrphans) {
        const connectedNodes = new Set();
        for (const edge of graph.edges){
            connectedNodes.add(edge.source);
            connectedNodes.add(edge.target);
        }
        for (const node of graph.nodes){
            if (!connectedNodes.has(node.id)) {
                errors.push({
                    type: "orphaned-node",
                    nodeId: node.id,
                    message: `Node ${node.id} has no connections`
                });
            }
        }
    }
    // Check for invalid edges
    const nodeIds = new Set(graph.nodes.map((n)=>n.id));
    for (const edge of graph.edges){
        if (!nodeIds.has(edge.source)) {
            errors.push({
                type: "invalid-edge",
                edgeId: edge.id,
                reason: `Source node ${edge.source} does not exist`
            });
        }
        if (!nodeIds.has(edge.target)) {
            errors.push({
                type: "invalid-edge",
                edgeId: edge.id,
                reason: `Target node ${edge.target} does not exist`
            });
        }
    }
    return {
        isValid: errors.length === 0,
        errors
    };
}
// Helper functions
function calculateDiameter(graph) {
    let maxDistance = 0;
    for (const start of graph.nodes){
        for (const end of graph.nodes){
            if (start.id !== end.id) {
                const path = findPath(graph, start.id, end.id);
                if (path) {
                    maxDistance = Math.max(maxDistance, path.length - 1);
                }
            }
        }
    }
    return maxDistance;
}
function calculateClustering(graph) {
    // Simplified clustering coefficient
    let totalClustering = 0;
    let nodeCount = 0;
    for (const node of graph.nodes){
        const neighbors = graph.edges.filter((e)=>e.source === node.id || e.target === node.id).map((e)=>e.source === node.id ? e.target : e.source);
        if (neighbors.length >= 2) {
            let connections = 0;
            for(let i = 0; i < neighbors.length; i++){
                for(let j = i + 1; j < neighbors.length; j++){
                    const hasEdge = graph.edges.some((e)=>e.source === neighbors[i] && e.target === neighbors[j] || e.source === neighbors[j] && e.target === neighbors[i]);
                    if (hasEdge) connections++;
                }
            }
            const maxConnections = neighbors.length * (neighbors.length - 1) / 2;
            totalClustering += connections / maxConnections;
            nodeCount++;
        }
    }
    return nodeCount > 0 ? totalClustering / nodeCount : 0;
}
function detectCommunities(graph) {
    // Simple community detection using connected components
    const visited = new Set();
    const communities = [];
    function dfs(nodeId, community) {
        if (visited.has(nodeId)) return;
        visited.add(nodeId);
        community.push(nodeId);
        const neighbors = graph.edges.filter((e)=>e.source === nodeId || e.target === nodeId).map((e)=>e.source === nodeId ? e.target : e.source);
        for (const neighbor of neighbors){
            dfs(neighbor, community);
        }
    }
    for (const node of graph.nodes){
        if (!visited.has(node.id)) {
            const community = [];
            dfs(node.id, community);
            communities.push(community);
        }
    }
    return communities;
}
function findPathExcludingEdge(graph, start, end, excludeEdgeId) {
    const filteredGraph = {
        ...graph,
        edges: graph.edges.filter((e)=>e.id !== excludeEdgeId)
    };
    return findPath(filteredGraph, start, end);
}
function calculateSimilarity(label1, label2) {
    // Simple case-insensitive comparison
    const normalized1 = label1.toLowerCase().trim();
    const normalized2 = label2.toLowerCase().trim();
    if (normalized1 === normalized2) return 1;
    // Check for common abbreviations
    const abbreviations = {
        ml: "machine learning",
        ai: "artificial intelligence",
        dl: "deep learning"
    };
    const expanded1 = abbreviations[normalized1] || normalized1;
    const expanded2 = abbreviations[normalized2] || normalized2;
    if (expanded1 === expanded2) return 0.9;
    if (expanded1.includes(expanded2) || expanded2.includes(expanded1)) return 0.8;
    return 0;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIva25vd2xlZGdlLWdyYXBoLW1hbmFnZW1lbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBLbm93bGVkZ2UgR3JhcGggTWFuYWdlbWVudCBNb2R1bGVcbiAqIEFEUi0wMDcgQ29tcGxpYW50IC0gS25vd2xlZGdlIE1hbmFnZW1lbnRcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEtub3dsZWRnZU5vZGUge1xuICBpZDogc3RyaW5nO1xuICBsYWJlbDogc3RyaW5nO1xuICB0eXBlOiBcImNvbmNlcHRcIiB8IFwiZmFjdFwiIHwgXCJlbnRpdHlcIiB8IFwicmVsYXRpb25zaGlwXCI7XG4gIHByb3BlcnRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG4gIC8vIFZpc3VhbCBwcm9wZXJ0aWVzIGZvciByZW5kZXJpbmdcbiAgeD86IG51bWJlcjtcbiAgeT86IG51bWJlcjtcbiAgcmFkaXVzPzogbnVtYmVyO1xuICBjb2xvcj86IHN0cmluZztcbiAgb3duZXJUeXBlPzogXCJpbmRpdmlkdWFsXCIgfCBcImNvbGxlY3RpdmVcIiB8IFwic2hhcmVkXCI7XG4gIGNvbmZpZGVuY2U/OiBudW1iZXI7XG4gIGltcG9ydGFuY2U/OiBudW1iZXI7XG4gIGxhc3RVcGRhdGVkPzogRGF0ZTtcbiAgY3JlYXRlZEF0PzogRGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBLbm93bGVkZ2VFZGdlIHtcbiAgaWQ6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHRhcmdldDogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIHdlaWdodD86IG51bWJlcjtcbiAgc3RyZW5ndGg/OiBudW1iZXI7XG4gIGNvbmZpZGVuY2U/OiBudW1iZXI7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBjcmVhdGVkQXQ/OiBEYXRlO1xuICBsYXN0VXBkYXRlZD86IERhdGU7XG4gIHByb3BlcnRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEtub3dsZWRnZUdyYXBoIHtcbiAgaWQ6IHN0cmluZztcbiAgbm9kZXM6IEtub3dsZWRnZU5vZGVbXTtcbiAgZWRnZXM6IEtub3dsZWRnZUVkZ2VbXTtcbiAgbWV0YWRhdGE6IHtcbiAgICBjcmVhdGVkOiBudW1iZXI7XG4gICAgbW9kaWZpZWQ6IG51bWJlcjtcbiAgICB2ZXJzaW9uOiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBoTWV0cmljcyB7XG4gIG5vZGVDb3VudDogbnVtYmVyO1xuICBlZGdlQ291bnQ6IG51bWJlcjtcbiAgZGVuc2l0eTogbnVtYmVyO1xuICBhdmdEZWdyZWU6IG51bWJlcjtcbiAgZGlhbWV0ZXI6IG51bWJlcjtcbiAgY2x1c3RlcmluZzogbnVtYmVyO1xuICBtb2R1bGFyaXR5OiBudW1iZXI7XG4gIGltcG9ydGFudE5vZGVzPzogQXJyYXk8eyBpZDogc3RyaW5nOyBzY29yZTogbnVtYmVyIH0+O1xuICBjb21tdW5pdGllcz86IHN0cmluZ1tdW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGhRdWVyeSB7XG4gIHN0YXJ0Tm9kZT86IHN0cmluZztcbiAgdHJhdmVyc2U/OiB7XG4gICAgZGlyZWN0aW9uOiBcImluY29taW5nXCIgfCBcIm91dGdvaW5nXCIgfCBcImJvdGhcIjtcbiAgICBlZGdlVHlwZXM/OiBzdHJpbmdbXTtcbiAgICBtYXhEZXB0aD86IG51bWJlcjtcbiAgfTtcbiAgZmlsdGVyPzoge1xuICAgIG5vZGVUeXBlcz86IHN0cmluZ1tdO1xuICAgIHByb3BlcnRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBoRGlmZiB7XG4gIGFkZGVkTm9kZXM6IEtub3dsZWRnZU5vZGVbXTtcbiAgcmVtb3ZlZE5vZGVzOiBLbm93bGVkZ2VOb2RlW107XG4gIG1vZGlmaWVkTm9kZXM6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGNoYW5nZXM6IFJlY29yZDxzdHJpbmcsIHsgb2xkOiBhbnk7IG5ldzogYW55IH0+O1xuICB9PjtcbiAgYWRkZWRFZGdlczogS25vd2xlZGdlRWRnZVtdO1xuICByZW1vdmVkRWRnZXM6IEtub3dsZWRnZUVkZ2VbXTtcbn1cblxubGV0IGdyYXBoQ291bnRlciA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVLbm93bGVkZ2VHcmFwaChpZD86IHN0cmluZyk6IEtub3dsZWRnZUdyYXBoIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogaWQgfHwgYGdyYXBoLSR7KytncmFwaENvdW50ZXJ9YCxcbiAgICBub2RlczogW10sXG4gICAgZWRnZXM6IFtdLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBjcmVhdGVkOiBEYXRlLm5vdygpLFxuICAgICAgbW9kaWZpZWQ6IERhdGUubm93KCksXG4gICAgICB2ZXJzaW9uOiBcIjEuMFwiLFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGROb2RlKFxuICBncmFwaDogS25vd2xlZGdlR3JhcGgsXG4gIG5vZGU6IEtub3dsZWRnZU5vZGUsXG4pOiBLbm93bGVkZ2VHcmFwaCB7XG4gIGlmIChncmFwaC5ub2Rlcy5zb21lKChuKSA9PiBuLmlkID09PSBub2RlLmlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSB3aXRoIElEICR7bm9kZS5pZH0gYWxyZWFkeSBleGlzdHNgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uZ3JhcGgsXG4gICAgbm9kZXM6IFsuLi5ncmFwaC5ub2Rlcywgbm9kZV0sXG4gICAgbWV0YWRhdGE6IHsgLi4uZ3JhcGgubWV0YWRhdGEsIG1vZGlmaWVkOiBEYXRlLm5vdygpIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFZGdlKFxuICBncmFwaDogS25vd2xlZGdlR3JhcGgsXG4gIGVkZ2U6IEtub3dsZWRnZUVkZ2UsXG4pOiBLbm93bGVkZ2VHcmFwaCB7XG4gIC8vIFZhbGlkYXRlIGVkZ2UgZW5kcG9pbnRzXG4gIGNvbnN0IHNvdXJjZUV4aXN0cyA9IGdyYXBoLm5vZGVzLnNvbWUoKG4pID0+IG4uaWQgPT09IGVkZ2Uuc291cmNlKTtcbiAgY29uc3QgdGFyZ2V0RXhpc3RzID0gZ3JhcGgubm9kZXMuc29tZSgobikgPT4gbi5pZCA9PT0gZWRnZS50YXJnZXQpO1xuXG4gIGlmICghc291cmNlRXhpc3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTb3VyY2Ugbm9kZSAke2VkZ2Uuc291cmNlfSBkb2VzIG5vdCBleGlzdGApO1xuICB9XG4gIGlmICghdGFyZ2V0RXhpc3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgbm9kZSAke2VkZ2UudGFyZ2V0fSBkb2VzIG5vdCBleGlzdGApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5ncmFwaCxcbiAgICBlZGdlczogWy4uLmdyYXBoLmVkZ2VzLCBlZGdlXSxcbiAgICBtZXRhZGF0YTogeyAuLi5ncmFwaC5tZXRhZGF0YSwgbW9kaWZpZWQ6IERhdGUubm93KCkgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU5vZGUoXG4gIGdyYXBoOiBLbm93bGVkZ2VHcmFwaCxcbiAgbm9kZUlkOiBzdHJpbmcsXG4gIHVwZGF0ZXM6IFBhcnRpYWw8S25vd2xlZGdlTm9kZT4sXG4pOiBLbm93bGVkZ2VHcmFwaCB7XG4gIGNvbnN0IG5vZGVJbmRleCA9IGdyYXBoLm5vZGVzLmZpbmRJbmRleCgobikgPT4gbi5pZCA9PT0gbm9kZUlkKTtcblxuICBpZiAobm9kZUluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSAke25vZGVJZH0gbm90IGZvdW5kYCk7XG4gIH1cblxuICBjb25zdCB1cGRhdGVkTm9kZXMgPSBbLi4uZ3JhcGgubm9kZXNdO1xuICB1cGRhdGVkTm9kZXNbbm9kZUluZGV4XSA9IHtcbiAgICAuLi51cGRhdGVkTm9kZXNbbm9kZUluZGV4XSxcbiAgICAuLi51cGRhdGVzLFxuICAgIGlkOiBub2RlSWQsIC8vIFByZXZlbnQgSUQgY2hhbmdlc1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uZ3JhcGgsXG4gICAgbm9kZXM6IHVwZGF0ZWROb2RlcyxcbiAgICBtZXRhZGF0YTogeyAuLi5ncmFwaC5tZXRhZGF0YSwgbW9kaWZpZWQ6IERhdGUubm93KCkgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUoXG4gIGdyYXBoOiBLbm93bGVkZ2VHcmFwaCxcbiAgbm9kZUlkOiBzdHJpbmcsXG4pOiBLbm93bGVkZ2VHcmFwaCB7XG4gIHJldHVybiB7XG4gICAgLi4uZ3JhcGgsXG4gICAgbm9kZXM6IGdyYXBoLm5vZGVzLmZpbHRlcigobikgPT4gbi5pZCAhPT0gbm9kZUlkKSxcbiAgICBlZGdlczogZ3JhcGguZWRnZXMuZmlsdGVyKFxuICAgICAgKGUpID0+IGUuc291cmNlICE9PSBub2RlSWQgJiYgZS50YXJnZXQgIT09IG5vZGVJZCxcbiAgICApLFxuICAgIG1ldGFkYXRhOiB7IC4uLmdyYXBoLm1ldGFkYXRhLCBtb2RpZmllZDogRGF0ZS5ub3coKSB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhdGgoXG4gIGdyYXBoOiBLbm93bGVkZ2VHcmFwaCxcbiAgc3RhcnRJZDogc3RyaW5nLFxuICBlbmRJZDogc3RyaW5nLFxuKTogc3RyaW5nW10gfCBudWxsIHtcbiAgaWYgKFxuICAgICFncmFwaC5ub2Rlcy5zb21lKChuKSA9PiBuLmlkID09PSBzdGFydElkKSB8fFxuICAgICFncmFwaC5ub2Rlcy5zb21lKChuKSA9PiBuLmlkID09PSBlbmRJZClcbiAgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBCRlMgdG8gZmluZCBzaG9ydGVzdCBwYXRoXG4gIGNvbnN0IHF1ZXVlOiBBcnJheTx7IG5vZGU6IHN0cmluZzsgcGF0aDogc3RyaW5nW10gfT4gPSBbXG4gICAgeyBub2RlOiBzdGFydElkLCBwYXRoOiBbc3RhcnRJZF0gfSxcbiAgXTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgeyBub2RlLCBwYXRoIH0gPSBxdWV1ZS5zaGlmdCgpITtcblxuICAgIGlmIChub2RlID09PSBlbmRJZCkge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWQuaGFzKG5vZGUpKSBjb250aW51ZTtcbiAgICB2aXNpdGVkLmFkZChub2RlKTtcblxuICAgIC8vIEZpbmQgbmVpZ2hib3JzXG4gICAgY29uc3QgbmVpZ2hib3JzID0gZ3JhcGguZWRnZXNcbiAgICAgIC5maWx0ZXIoKGUpID0+IGUuc291cmNlID09PSBub2RlIHx8IGUudGFyZ2V0ID09PSBub2RlKVxuICAgICAgLm1hcCgoZSkgPT4gKGUuc291cmNlID09PSBub2RlID8gZS50YXJnZXQgOiBlLnNvdXJjZSkpXG4gICAgICAuZmlsdGVyKChuKSA9PiAhdmlzaXRlZC5oYXMobikpO1xuXG4gICAgZm9yIChjb25zdCBuZWlnaGJvciBvZiBuZWlnaGJvcnMpIHtcbiAgICAgIHF1ZXVlLnB1c2goeyBub2RlOiBuZWlnaGJvciwgcGF0aDogWy4uLnBhdGgsIG5laWdoYm9yXSB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlR3JhcGhzKFxuICBncmFwaDE6IEtub3dsZWRnZUdyYXBoLFxuICBncmFwaDI6IEtub3dsZWRnZUdyYXBoLFxuICBvcHRpb25zOiB7XG4gICAgY29uZmxpY3RSZXNvbHV0aW9uPzogXCJrZWVwLWZpcnN0XCIgfCBcImtlZXAtc2Vjb25kXCIgfCBcIm5ld2VyXCI7XG4gICAgcmVwb3J0Q29uZmxpY3RzPzogYm9vbGVhbjtcbiAgfSA9IHt9LFxuKTogS25vd2xlZGdlR3JhcGggJiB7IGNvbmZsaWN0cz86IGFueVtdIH0ge1xuICBjb25zdCBjb25mbGljdHM6IGFueVtdID0gW107XG4gIGNvbnN0IG1lcmdlZE5vZGVzID0gbmV3IE1hcDxzdHJpbmcsIEtub3dsZWRnZU5vZGU+KCk7XG4gIGNvbnN0IG1lcmdlZEVkZ2VzID0gbmV3IE1hcDxzdHJpbmcsIEtub3dsZWRnZUVkZ2U+KCk7XG5cbiAgLy8gTWVyZ2Ugbm9kZXNcbiAgZm9yIChjb25zdCBub2RlIG9mIGdyYXBoMS5ub2Rlcykge1xuICAgIG1lcmdlZE5vZGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgfVxuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBncmFwaDIubm9kZXMpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IG1lcmdlZE5vZGVzLmdldChub2RlLmlkKTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIC8vIENvbmZsaWN0IGRldGVjdGVkXG4gICAgICBpZiAob3B0aW9ucy5yZXBvcnRDb25mbGljdHMpIHtcbiAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICBncmFwaDFWYWx1ZTogZXhpc3RpbmcubGFiZWwsXG4gICAgICAgICAgZ3JhcGgyVmFsdWU6IG5vZGUubGFiZWwsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMuY29uZmxpY3RSZXNvbHV0aW9uID09PSBcIm5ld2VyXCIgfHxcbiAgICAgICAgb3B0aW9ucy5jb25mbGljdFJlc29sdXRpb24gPT09IFwia2VlcC1zZWNvbmRcIlxuICAgICAgKSB7XG4gICAgICAgIG1lcmdlZE5vZGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSBrZWVwIGV4aXN0aW5nIChrZWVwLWZpcnN0IG9yIGRlZmF1bHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlZE5vZGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBNZXJnZSBlZGdlc1xuICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZ3JhcGgxLmVkZ2VzKSB7XG4gICAgbWVyZ2VkRWRnZXMuc2V0KGVkZ2UuaWQsIGVkZ2UpO1xuICB9XG5cbiAgZm9yIChjb25zdCBlZGdlIG9mIGdyYXBoMi5lZGdlcykge1xuICAgIGlmICghbWVyZ2VkRWRnZXMuaGFzKGVkZ2UuaWQpKSB7XG4gICAgICAvLyBPbmx5IGFkZCBpZiBib3RoIGVuZHBvaW50cyBleGlzdCBpbiBtZXJnZWQgZ3JhcGhcbiAgICAgIGlmIChtZXJnZWROb2Rlcy5oYXMoZWRnZS5zb3VyY2UpICYmIG1lcmdlZE5vZGVzLmhhcyhlZGdlLnRhcmdldCkpIHtcbiAgICAgICAgbWVyZ2VkRWRnZXMuc2V0KGVkZ2UuaWQsIGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc3VsdDogS25vd2xlZGdlR3JhcGggJiB7IGNvbmZsaWN0cz86IGFueVtdIH0gPSB7XG4gICAgaWQ6IGBtZXJnZWQtJHtncmFwaDEuaWR9LSR7Z3JhcGgyLmlkfWAsXG4gICAgbm9kZXM6IEFycmF5LmZyb20obWVyZ2VkTm9kZXMudmFsdWVzKCkpLFxuICAgIGVkZ2VzOiBBcnJheS5mcm9tKG1lcmdlZEVkZ2VzLnZhbHVlcygpKSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgY3JlYXRlZDogTWF0aC5taW4oZ3JhcGgxLm1ldGFkYXRhLmNyZWF0ZWQsIGdyYXBoMi5tZXRhZGF0YS5jcmVhdGVkKSxcbiAgICAgIG1vZGlmaWVkOiBEYXRlLm5vdygpLFxuICAgICAgdmVyc2lvbjogXCIxLjBcIixcbiAgICAgIG1lcmdlZEZyb206IFtncmFwaDEuaWQsIGdyYXBoMi5pZF0sXG4gICAgfSxcbiAgfTtcblxuICBpZiAob3B0aW9ucy5yZXBvcnRDb25mbGljdHMpIHtcbiAgICByZXN1bHQuY29uZmxpY3RzID0gY29uZmxpY3RzO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydEdyYXBoKFxuICBncmFwaDogS25vd2xlZGdlR3JhcGgsXG4gIGZvcm1hdDogXCJqc29uXCIgfCBcImdyYXBobWxcIixcbik6IHN0cmluZyB7XG4gIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGdyYXBoLCBudWxsLCAyKTtcbiAgfVxuXG4gIC8vIEdyYXBoTUwgZm9ybWF0XG4gIGxldCB4bWwgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XFxuJztcbiAgeG1sICs9ICc8Z3JhcGhtbCB4bWxucz1cImh0dHA6Ly9ncmFwaG1sLmdyYXBoZHJhd2luZy5vcmcveG1sbnNcIj5cXG4nO1xuICB4bWwgKz0gJyAgPGdyYXBoIGlkPVwiJyArIGdyYXBoLmlkICsgJ1wiIGVkZ2VkZWZhdWx0PVwiZGlyZWN0ZWRcIj5cXG4nO1xuXG4gIC8vIEFkZCBub2Rlc1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JhcGgubm9kZXMpIHtcbiAgICB4bWwgKz0gYCAgICA8bm9kZSBpZD1cIiR7bm9kZS5pZH1cIj5cXG5gO1xuICAgIHhtbCArPSBgICAgICAgPGRhdGEga2V5PVwibGFiZWxcIj4ke25vZGUubGFiZWx9PC9kYXRhPlxcbmA7XG4gICAgeG1sICs9IGAgICAgICA8ZGF0YSBrZXk9XCJ0eXBlXCI+JHtub2RlLnR5cGV9PC9kYXRhPlxcbmA7XG4gICAgeG1sICs9IFwiICAgIDwvbm9kZT5cXG5cIjtcbiAgfVxuXG4gIC8vIEFkZCBlZGdlc1xuICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZ3JhcGguZWRnZXMpIHtcbiAgICB4bWwgKz0gYCAgICA8ZWRnZSBpZD1cIiR7ZWRnZS5pZH1cIiBzb3VyY2U9XCIke2VkZ2Uuc291cmNlfVwiIHRhcmdldD1cIiR7ZWRnZS50YXJnZXR9XCI+XFxuYDtcbiAgICB4bWwgKz0gYCAgICAgIDxkYXRhIGtleT1cInR5cGVcIj4ke2VkZ2UudHlwZX08L2RhdGE+XFxuYDtcbiAgICBpZiAoZWRnZS53ZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeG1sICs9IGAgICAgICA8ZGF0YSBrZXk9XCJ3ZWlnaHRcIj4ke2VkZ2Uud2VpZ2h0fTwvZGF0YT5cXG5gO1xuICAgIH1cbiAgICB4bWwgKz0gXCIgICAgPC9lZGdlPlxcblwiO1xuICB9XG5cbiAgeG1sICs9IFwiICA8L2dyYXBoPlxcblwiO1xuICB4bWwgKz0gXCI8L2dyYXBobWw+XCI7XG5cbiAgcmV0dXJuIHhtbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGltcG9ydEdyYXBoKFxuICBkYXRhOiBzdHJpbmcsXG4gIGZvcm1hdDogXCJqc29uXCIgfCBcImdyYXBobWxcIixcbik6IEtub3dsZWRnZUdyYXBoIHtcbiAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgLy8gVmFsaWRhdGUgc3RydWN0dXJlXG4gICAgaWYgKCFwYXJzZWQubm9kZXMgfHwgIXBhcnNlZC5lZGdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncmFwaCBzdHJ1Y3R1cmVcIik7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgbm9kZXNcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcGFyc2VkLm5vZGVzKSB7XG4gICAgICBpZiAoIW5vZGUuaWQgfHwgIW5vZGUubGFiZWwgfHwgIW5vZGUudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyYXBoIHN0cnVjdHVyZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBlZGdlcyByZWZlcmVuY2UgZXhpc3Rpbmcgbm9kZXNcbiAgICBjb25zdCBub2RlSWRzID0gbmV3IFNldChwYXJzZWQubm9kZXMubWFwKChuOiBLbm93bGVkZ2VOb2RlKSA9PiBuLmlkKSk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHBhcnNlZC5lZGdlcykge1xuICAgICAgaWYgKCFub2RlSWRzLmhhcyhlZGdlLnNvdXJjZSkgfHwgIW5vZGVJZHMuaGFzKGVkZ2UudGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyYXBoIHN0cnVjdHVyZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHBhcnNlZC5pZCB8fCBjcmVhdGVLbm93bGVkZ2VHcmFwaCgpLmlkLFxuICAgICAgbm9kZXM6IHBhcnNlZC5ub2RlcyxcbiAgICAgIGVkZ2VzOiBwYXJzZWQuZWRnZXMsXG4gICAgICBtZXRhZGF0YTogcGFyc2VkLm1ldGFkYXRhIHx8IHtcbiAgICAgICAgY3JlYXRlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgbW9kaWZpZWQ6IERhdGUubm93KCksXG4gICAgICAgIHZlcnNpb246IFwiMS4wXCIsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFwaE1MIGltcG9ydCBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbmFseXplR3JhcGgoXG4gIGdyYXBoOiBLbm93bGVkZ2VHcmFwaCxcbiAgb3B0aW9uczoge1xuICAgIGluY2x1ZGVOb2RlSW1wb3J0YW5jZT86IGJvb2xlYW47XG4gICAgZGV0ZWN0Q29tbXVuaXRpZXM/OiBib29sZWFuO1xuICB9ID0ge30sXG4pOiBHcmFwaE1ldHJpY3Mge1xuICBjb25zdCBub2RlQ291bnQgPSBncmFwaC5ub2Rlcy5sZW5ndGg7XG4gIGNvbnN0IGVkZ2VDb3VudCA9IGdyYXBoLmVkZ2VzLmxlbmd0aDtcbiAgY29uc3QgbWF4UG9zc2libGVFZGdlcyA9IChub2RlQ291bnQgKiAobm9kZUNvdW50IC0gMSkpIC8gMjtcbiAgY29uc3QgZGVuc2l0eSA9IG5vZGVDb3VudCA+IDEgPyBlZGdlQ291bnQgLyBtYXhQb3NzaWJsZUVkZ2VzIDogMDtcblxuICAvLyBDYWxjdWxhdGUgYXZlcmFnZSBkZWdyZWVcbiAgY29uc3QgZGVncmVlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gIGZvciAoY29uc3QgZWRnZSBvZiBncmFwaC5lZGdlcykge1xuICAgIGRlZ3JlZXMuc2V0KGVkZ2Uuc291cmNlLCAoZGVncmVlcy5nZXQoZWRnZS5zb3VyY2UpIHx8IDApICsgMSk7XG4gICAgZGVncmVlcy5zZXQoZWRnZS50YXJnZXQsIChkZWdyZWVzLmdldChlZGdlLnRhcmdldCkgfHwgMCkgKyAxKTtcbiAgfVxuICBjb25zdCBhdmdEZWdyZWUgPVxuICAgIG5vZGVDb3VudCA+IDBcbiAgICAgID8gQXJyYXkuZnJvbShkZWdyZWVzLnZhbHVlcygpKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIG5vZGVDb3VudFxuICAgICAgOiAwO1xuXG4gIGNvbnN0IG1ldHJpY3M6IEdyYXBoTWV0cmljcyA9IHtcbiAgICBub2RlQ291bnQsXG4gICAgZWRnZUNvdW50LFxuICAgIGRlbnNpdHksXG4gICAgYXZnRGVncmVlLFxuICAgIGRpYW1ldGVyOiBjYWxjdWxhdGVEaWFtZXRlcihncmFwaCksXG4gICAgY2x1c3RlcmluZzogY2FsY3VsYXRlQ2x1c3RlcmluZyhncmFwaCksXG4gICAgbW9kdWxhcml0eTogMC41LCAvLyBNb2NrIHZhbHVlXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuaW5jbHVkZU5vZGVJbXBvcnRhbmNlKSB7XG4gICAgbWV0cmljcy5pbXBvcnRhbnROb2RlcyA9IEFycmF5LmZyb20oZGVncmVlcy5lbnRyaWVzKCkpXG4gICAgICAubWFwKChbaWQsIGRlZ3JlZV0pID0+ICh7IGlkLCBzY29yZTogZGVncmVlIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgLnNsaWNlKDAsIDMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZGV0ZWN0Q29tbXVuaXRpZXMpIHtcbiAgICBtZXRyaWNzLmNvbW11bml0aWVzID0gZGV0ZWN0Q29tbXVuaXRpZXMoZ3JhcGgpO1xuICB9XG5cbiAgcmV0dXJuIG1ldHJpY3M7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWl6ZUdyYXBoKFxuICBncmFwaDogS25vd2xlZGdlR3JhcGgsXG4gIG9wdGlvbnM6IHtcbiAgICByZW1vdmVSZWR1bmRhbnQ/OiBib29sZWFuO1xuICAgIGNvbnNvbGlkYXRlU2ltaWxhcj86IGJvb2xlYW47XG4gICAgc2ltaWxhcml0eVRocmVzaG9sZD86IG51bWJlcjtcbiAgICBwcnVuZVRocmVzaG9sZD86IG51bWJlcjtcbiAgfSA9IHt9LFxuKTogS25vd2xlZGdlR3JhcGgge1xuICBsZXQgb3B0aW1pemVkID0geyAuLi5ncmFwaCB9O1xuXG4gIGlmIChvcHRpb25zLnJlbW92ZVJlZHVuZGFudCkge1xuICAgIC8vIFJlbW92ZSB0cmFuc2l0aXZlIGVkZ2VzXG4gICAgY29uc3QgZWRnZXNUb1JlbW92ZSA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGdyYXBoLmVkZ2VzKSB7XG4gICAgICBpZiAoZWRnZS50eXBlID09PSBcImltcGxpZXNcIikge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFuIGluZGlyZWN0IHBhdGhcbiAgICAgICAgY29uc3QgcGF0aFdpdGhvdXRFZGdlID0gZmluZFBhdGhFeGNsdWRpbmdFZGdlKFxuICAgICAgICAgIGdyYXBoLFxuICAgICAgICAgIGVkZ2Uuc291cmNlLFxuICAgICAgICAgIGVkZ2UudGFyZ2V0LFxuICAgICAgICAgIGVkZ2UuaWQsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHBhdGhXaXRob3V0RWRnZSAmJiBwYXRoV2l0aG91dEVkZ2UubGVuZ3RoIDw9IDMpIHtcbiAgICAgICAgICBlZGdlc1RvUmVtb3ZlLmFkZChlZGdlLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGltaXplZC5lZGdlcyA9IG9wdGltaXplZC5lZGdlcy5maWx0ZXIoKGUpID0+ICFlZGdlc1RvUmVtb3ZlLmhhcyhlLmlkKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5jb25zb2xpZGF0ZVNpbWlsYXIpIHtcbiAgICAvLyBTaW1wbGUgY29uc29saWRhdGlvbiBiYXNlZCBvbiBsYWJlbCBzaW1pbGFyaXR5XG4gICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy5zaW1pbGFyaXR5VGhyZXNob2xkIHx8IDAuODtcbiAgICBjb25zdCBub2RlR3JvdXBzOiBLbm93bGVkZ2VOb2RlW11bXSA9IFtdO1xuICAgIGNvbnN0IHByb2Nlc3NlZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIGdyYXBoLm5vZGVzKSB7XG4gICAgICBpZiAocHJvY2Vzc2VkLmhhcyhub2RlLmlkKSkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IGdyb3VwID0gW25vZGVdO1xuICAgICAgcHJvY2Vzc2VkLmFkZChub2RlLmlkKTtcblxuICAgICAgZm9yIChjb25zdCBvdGhlciBvZiBncmFwaC5ub2Rlcykge1xuICAgICAgICBpZiAocHJvY2Vzc2VkLmhhcyhvdGhlci5pZCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBjYWxjdWxhdGVTaW1pbGFyaXR5KG5vZGUubGFiZWwsIG90aGVyLmxhYmVsKTtcbiAgICAgICAgaWYgKHNpbWlsYXJpdHkgPj0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChvdGhlcik7XG4gICAgICAgICAgcHJvY2Vzc2VkLmFkZChvdGhlci5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbm9kZUdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNZXJnZSBzaW1pbGFyIG5vZGVzXG4gICAgY29uc3QgbWVyZ2VkTm9kZXM6IEtub3dsZWRnZU5vZGVbXSA9IFtdO1xuICAgIGNvbnN0IG5vZGVNYXBwaW5nID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2Ygbm9kZUdyb3Vwcykge1xuICAgICAgY29uc3QgbWVyZ2VkID0gZ3JvdXBbMF07IC8vIEtlZXAgZmlyc3QgYXMgcmVwcmVzZW50YXRpdmVcbiAgICAgIG1lcmdlZE5vZGVzLnB1c2gobWVyZ2VkKTtcblxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIGdyb3VwKSB7XG4gICAgICAgIG5vZGVNYXBwaW5nLnNldChub2RlLmlkLCBtZXJnZWQuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBub24tZ3JvdXBlZCBub2Rlc1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBncmFwaC5ub2Rlcykge1xuICAgICAgaWYgKCFub2RlTWFwcGluZy5oYXMobm9kZS5pZCkgfHwgbm9kZU1hcHBpbmcuZ2V0KG5vZGUuaWQpID09PSBub2RlLmlkKSB7XG4gICAgICAgIGlmICghbWVyZ2VkTm9kZXMuc29tZSgobikgPT4gbi5pZCA9PT0gbm9kZS5pZCkpIHtcbiAgICAgICAgICBtZXJnZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW1pemVkLm5vZGVzID0gbWVyZ2VkTm9kZXM7XG5cbiAgICAvLyBVcGRhdGUgZWRnZXMgd2l0aCBtZXJnZWQgbm9kZSBJRHNcbiAgICBvcHRpbWl6ZWQuZWRnZXMgPSBvcHRpbWl6ZWQuZWRnZXNcbiAgICAgIC5tYXAoKGVkZ2UpID0+ICh7XG4gICAgICAgIC4uLmVkZ2UsXG4gICAgICAgIHNvdXJjZTogbm9kZU1hcHBpbmcuZ2V0KGVkZ2Uuc291cmNlKSB8fCBlZGdlLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBub2RlTWFwcGluZy5nZXQoZWRnZS50YXJnZXQpIHx8IGVkZ2UudGFyZ2V0LFxuICAgICAgfSkpXG4gICAgICAuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnNvdXJjZSAhPT0gZWRnZS50YXJnZXQpOyAvLyBSZW1vdmUgc2VsZi1sb29wc1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucHJ1bmVUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGltaXplZC5lZGdlcyA9IG9wdGltaXplZC5lZGdlcy5maWx0ZXIoXG4gICAgICAoZWRnZSkgPT4gKGVkZ2Uud2VpZ2h0IHx8IDEpID49IG9wdGlvbnMucHJ1bmVUaHJlc2hvbGQhLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gb3B0aW1pemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVHcmFwaChcbiAgZ3JhcGg6IEtub3dsZWRnZUdyYXBoLFxuICBvcHRpb25zOiB7IGFsbG93T3JwaGFucz86IGJvb2xlYW4gfSA9IHt9LFxuKTogeyBpc1ZhbGlkOiBib29sZWFuOyBlcnJvcnM6IGFueVtdIH0ge1xuICBjb25zdCBlcnJvcnM6IGFueVtdID0gW107XG5cbiAgLy8gQ2hlY2sgZm9yIG9ycGhhbmVkIG5vZGVzXG4gIGlmICghb3B0aW9ucy5hbGxvd09ycGhhbnMpIHtcbiAgICBjb25zdCBjb25uZWN0ZWROb2RlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGdyYXBoLmVkZ2VzKSB7XG4gICAgICBjb25uZWN0ZWROb2Rlcy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgICAgY29ubmVjdGVkTm9kZXMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JhcGgubm9kZXMpIHtcbiAgICAgIGlmICghY29ubmVjdGVkTm9kZXMuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcIm9ycGhhbmVkLW5vZGVcIixcbiAgICAgICAgICBub2RlSWQ6IG5vZGUuaWQsXG4gICAgICAgICAgbWVzc2FnZTogYE5vZGUgJHtub2RlLmlkfSBoYXMgbm8gY29ubmVjdGlvbnNgLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmb3IgaW52YWxpZCBlZGdlc1xuICBjb25zdCBub2RlSWRzID0gbmV3IFNldChncmFwaC5ub2Rlcy5tYXAoKG4pID0+IG4uaWQpKTtcblxuICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZ3JhcGguZWRnZXMpIHtcbiAgICBpZiAoIW5vZGVJZHMuaGFzKGVkZ2Uuc291cmNlKSkge1xuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImludmFsaWQtZWRnZVwiLFxuICAgICAgICBlZGdlSWQ6IGVkZ2UuaWQsXG4gICAgICAgIHJlYXNvbjogYFNvdXJjZSBub2RlICR7ZWRnZS5zb3VyY2V9IGRvZXMgbm90IGV4aXN0YCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vZGVJZHMuaGFzKGVkZ2UudGFyZ2V0KSkge1xuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImludmFsaWQtZWRnZVwiLFxuICAgICAgICBlZGdlSWQ6IGVkZ2UuaWQsXG4gICAgICAgIHJlYXNvbjogYFRhcmdldCBub2RlICR7ZWRnZS50YXJnZXR9IGRvZXMgbm90IGV4aXN0YCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICBlcnJvcnMsXG4gIH07XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGNhbGN1bGF0ZURpYW1ldGVyKGdyYXBoOiBLbm93bGVkZ2VHcmFwaCk6IG51bWJlciB7XG4gIGxldCBtYXhEaXN0YW5jZSA9IDA7XG5cbiAgZm9yIChjb25zdCBzdGFydCBvZiBncmFwaC5ub2Rlcykge1xuICAgIGZvciAoY29uc3QgZW5kIG9mIGdyYXBoLm5vZGVzKSB7XG4gICAgICBpZiAoc3RhcnQuaWQgIT09IGVuZC5pZCkge1xuICAgICAgICBjb25zdCBwYXRoID0gZmluZFBhdGgoZ3JhcGgsIHN0YXJ0LmlkLCBlbmQuaWQpO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIG1heERpc3RhbmNlID0gTWF0aC5tYXgobWF4RGlzdGFuY2UsIHBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4RGlzdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNsdXN0ZXJpbmcoZ3JhcGg6IEtub3dsZWRnZUdyYXBoKTogbnVtYmVyIHtcbiAgLy8gU2ltcGxpZmllZCBjbHVzdGVyaW5nIGNvZWZmaWNpZW50XG4gIGxldCB0b3RhbENsdXN0ZXJpbmcgPSAwO1xuICBsZXQgbm9kZUNvdW50ID0gMDtcblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JhcGgubm9kZXMpIHtcbiAgICBjb25zdCBuZWlnaGJvcnMgPSBncmFwaC5lZGdlc1xuICAgICAgLmZpbHRlcigoZSkgPT4gZS5zb3VyY2UgPT09IG5vZGUuaWQgfHwgZS50YXJnZXQgPT09IG5vZGUuaWQpXG4gICAgICAubWFwKChlKSA9PiAoZS5zb3VyY2UgPT09IG5vZGUuaWQgPyBlLnRhcmdldCA6IGUuc291cmNlKSk7XG5cbiAgICBpZiAobmVpZ2hib3JzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBsZXQgY29ubmVjdGlvbnMgPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZWlnaGJvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBoYXNFZGdlID0gZ3JhcGguZWRnZXMuc29tZShcbiAgICAgICAgICAgIChlKSA9PlxuICAgICAgICAgICAgICAoZS5zb3VyY2UgPT09IG5laWdoYm9yc1tpXSAmJiBlLnRhcmdldCA9PT0gbmVpZ2hib3JzW2pdKSB8fFxuICAgICAgICAgICAgICAoZS5zb3VyY2UgPT09IG5laWdoYm9yc1tqXSAmJiBlLnRhcmdldCA9PT0gbmVpZ2hib3JzW2ldKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChoYXNFZGdlKSBjb25uZWN0aW9ucysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1heENvbm5lY3Rpb25zID0gKG5laWdoYm9ycy5sZW5ndGggKiAobmVpZ2hib3JzLmxlbmd0aCAtIDEpKSAvIDI7XG4gICAgICB0b3RhbENsdXN0ZXJpbmcgKz0gY29ubmVjdGlvbnMgLyBtYXhDb25uZWN0aW9ucztcbiAgICAgIG5vZGVDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlQ291bnQgPiAwID8gdG90YWxDbHVzdGVyaW5nIC8gbm9kZUNvdW50IDogMDtcbn1cblxuZnVuY3Rpb24gZGV0ZWN0Q29tbXVuaXRpZXMoZ3JhcGg6IEtub3dsZWRnZUdyYXBoKTogc3RyaW5nW11bXSB7XG4gIC8vIFNpbXBsZSBjb21tdW5pdHkgZGV0ZWN0aW9uIHVzaW5nIGNvbm5lY3RlZCBjb21wb25lbnRzXG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3QgY29tbXVuaXRpZXM6IHN0cmluZ1tdW10gPSBbXTtcblxuICBmdW5jdGlvbiBkZnMobm9kZUlkOiBzdHJpbmcsIGNvbW11bml0eTogc3RyaW5nW10pIHtcbiAgICBpZiAodmlzaXRlZC5oYXMobm9kZUlkKSkgcmV0dXJuO1xuICAgIHZpc2l0ZWQuYWRkKG5vZGVJZCk7XG4gICAgY29tbXVuaXR5LnB1c2gobm9kZUlkKTtcblxuICAgIGNvbnN0IG5laWdoYm9ycyA9IGdyYXBoLmVkZ2VzXG4gICAgICAuZmlsdGVyKChlKSA9PiBlLnNvdXJjZSA9PT0gbm9kZUlkIHx8IGUudGFyZ2V0ID09PSBub2RlSWQpXG4gICAgICAubWFwKChlKSA9PiAoZS5zb3VyY2UgPT09IG5vZGVJZCA/IGUudGFyZ2V0IDogZS5zb3VyY2UpKTtcblxuICAgIGZvciAoY29uc3QgbmVpZ2hib3Igb2YgbmVpZ2hib3JzKSB7XG4gICAgICBkZnMobmVpZ2hib3IsIGNvbW11bml0eSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBub2RlIG9mIGdyYXBoLm5vZGVzKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhub2RlLmlkKSkge1xuICAgICAgY29uc3QgY29tbXVuaXR5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZGZzKG5vZGUuaWQsIGNvbW11bml0eSk7XG4gICAgICBjb21tdW5pdGllcy5wdXNoKGNvbW11bml0eSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbW11bml0aWVzO1xufVxuXG5mdW5jdGlvbiBmaW5kUGF0aEV4Y2x1ZGluZ0VkZ2UoXG4gIGdyYXBoOiBLbm93bGVkZ2VHcmFwaCxcbiAgc3RhcnQ6IHN0cmluZyxcbiAgZW5kOiBzdHJpbmcsXG4gIGV4Y2x1ZGVFZGdlSWQ6IHN0cmluZyxcbik6IHN0cmluZ1tdIHwgbnVsbCB7XG4gIGNvbnN0IGZpbHRlcmVkR3JhcGggPSB7XG4gICAgLi4uZ3JhcGgsXG4gICAgZWRnZXM6IGdyYXBoLmVkZ2VzLmZpbHRlcigoZSkgPT4gZS5pZCAhPT0gZXhjbHVkZUVkZ2VJZCksXG4gIH07XG4gIHJldHVybiBmaW5kUGF0aChmaWx0ZXJlZEdyYXBoLCBzdGFydCwgZW5kKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU2ltaWxhcml0eShsYWJlbDE6IHN0cmluZywgbGFiZWwyOiBzdHJpbmcpOiBudW1iZXIge1xuICAvLyBTaW1wbGUgY2FzZS1pbnNlbnNpdGl2ZSBjb21wYXJpc29uXG4gIGNvbnN0IG5vcm1hbGl6ZWQxID0gbGFiZWwxLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBjb25zdCBub3JtYWxpemVkMiA9IGxhYmVsMi50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblxuICBpZiAobm9ybWFsaXplZDEgPT09IG5vcm1hbGl6ZWQyKSByZXR1cm4gMTtcblxuICAvLyBDaGVjayBmb3IgY29tbW9uIGFiYnJldmlhdGlvbnNcbiAgY29uc3QgYWJicmV2aWF0aW9uczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICBtbDogXCJtYWNoaW5lIGxlYXJuaW5nXCIsXG4gICAgYWk6IFwiYXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2VcIixcbiAgICBkbDogXCJkZWVwIGxlYXJuaW5nXCIsXG4gIH07XG5cbiAgY29uc3QgZXhwYW5kZWQxID0gYWJicmV2aWF0aW9uc1tub3JtYWxpemVkMV0gfHwgbm9ybWFsaXplZDE7XG4gIGNvbnN0IGV4cGFuZGVkMiA9IGFiYnJldmlhdGlvbnNbbm9ybWFsaXplZDJdIHx8IG5vcm1hbGl6ZWQyO1xuXG4gIGlmIChleHBhbmRlZDEgPT09IGV4cGFuZGVkMikgcmV0dXJuIDAuOTtcbiAgaWYgKGV4cGFuZGVkMS5pbmNsdWRlcyhleHBhbmRlZDIpIHx8IGV4cGFuZGVkMi5pbmNsdWRlcyhleHBhbmRlZDEpKVxuICAgIHJldHVybiAwLjg7XG5cbiAgcmV0dXJuIDA7XG59XG4iXSwibmFtZXMiOlsiYWRkRWRnZSIsImFkZE5vZGUiLCJhbmFseXplR3JhcGgiLCJjcmVhdGVLbm93bGVkZ2VHcmFwaCIsImV4cG9ydEdyYXBoIiwiZmluZFBhdGgiLCJpbXBvcnRHcmFwaCIsIm1lcmdlR3JhcGhzIiwib3B0aW1pemVHcmFwaCIsInJlbW92ZU5vZGUiLCJ1cGRhdGVOb2RlIiwidmFsaWRhdGVHcmFwaCIsImdyYXBoQ291bnRlciIsImlkIiwibm9kZXMiLCJlZGdlcyIsIm1ldGFkYXRhIiwiY3JlYXRlZCIsIkRhdGUiLCJub3ciLCJtb2RpZmllZCIsInZlcnNpb24iLCJncmFwaCIsIm5vZGUiLCJzb21lIiwibiIsIkVycm9yIiwiZWRnZSIsInNvdXJjZUV4aXN0cyIsInNvdXJjZSIsInRhcmdldEV4aXN0cyIsInRhcmdldCIsIm5vZGVJZCIsInVwZGF0ZXMiLCJub2RlSW5kZXgiLCJmaW5kSW5kZXgiLCJ1cGRhdGVkTm9kZXMiLCJmaWx0ZXIiLCJlIiwic3RhcnRJZCIsImVuZElkIiwicXVldWUiLCJwYXRoIiwidmlzaXRlZCIsIlNldCIsImxlbmd0aCIsInNoaWZ0IiwiaGFzIiwiYWRkIiwibmVpZ2hib3JzIiwibWFwIiwibmVpZ2hib3IiLCJwdXNoIiwiZ3JhcGgxIiwiZ3JhcGgyIiwib3B0aW9ucyIsImNvbmZsaWN0cyIsIm1lcmdlZE5vZGVzIiwiTWFwIiwibWVyZ2VkRWRnZXMiLCJzZXQiLCJleGlzdGluZyIsImdldCIsInJlcG9ydENvbmZsaWN0cyIsImdyYXBoMVZhbHVlIiwibGFiZWwiLCJncmFwaDJWYWx1ZSIsImNvbmZsaWN0UmVzb2x1dGlvbiIsInJlc3VsdCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsIk1hdGgiLCJtaW4iLCJtZXJnZWRGcm9tIiwiZm9ybWF0IiwiSlNPTiIsInN0cmluZ2lmeSIsInhtbCIsInR5cGUiLCJ3ZWlnaHQiLCJ1bmRlZmluZWQiLCJkYXRhIiwicGFyc2VkIiwicGFyc2UiLCJub2RlSWRzIiwibm9kZUNvdW50IiwiZWRnZUNvdW50IiwibWF4UG9zc2libGVFZGdlcyIsImRlbnNpdHkiLCJkZWdyZWVzIiwiYXZnRGVncmVlIiwicmVkdWNlIiwiYSIsImIiLCJtZXRyaWNzIiwiZGlhbWV0ZXIiLCJjYWxjdWxhdGVEaWFtZXRlciIsImNsdXN0ZXJpbmciLCJjYWxjdWxhdGVDbHVzdGVyaW5nIiwibW9kdWxhcml0eSIsImluY2x1ZGVOb2RlSW1wb3J0YW5jZSIsImltcG9ydGFudE5vZGVzIiwiZW50cmllcyIsImRlZ3JlZSIsInNjb3JlIiwic29ydCIsInNsaWNlIiwiZGV0ZWN0Q29tbXVuaXRpZXMiLCJjb21tdW5pdGllcyIsIm9wdGltaXplZCIsInJlbW92ZVJlZHVuZGFudCIsImVkZ2VzVG9SZW1vdmUiLCJwYXRoV2l0aG91dEVkZ2UiLCJmaW5kUGF0aEV4Y2x1ZGluZ0VkZ2UiLCJjb25zb2xpZGF0ZVNpbWlsYXIiLCJ0aHJlc2hvbGQiLCJzaW1pbGFyaXR5VGhyZXNob2xkIiwibm9kZUdyb3VwcyIsInByb2Nlc3NlZCIsImdyb3VwIiwib3RoZXIiLCJzaW1pbGFyaXR5IiwiY2FsY3VsYXRlU2ltaWxhcml0eSIsIm5vZGVNYXBwaW5nIiwibWVyZ2VkIiwicHJ1bmVUaHJlc2hvbGQiLCJlcnJvcnMiLCJhbGxvd09ycGhhbnMiLCJjb25uZWN0ZWROb2RlcyIsIm1lc3NhZ2UiLCJlZGdlSWQiLCJyZWFzb24iLCJpc1ZhbGlkIiwibWF4RGlzdGFuY2UiLCJzdGFydCIsImVuZCIsIm1heCIsInRvdGFsQ2x1c3RlcmluZyIsImNvbm5lY3Rpb25zIiwiaSIsImoiLCJoYXNFZGdlIiwibWF4Q29ubmVjdGlvbnMiLCJkZnMiLCJjb21tdW5pdHkiLCJleGNsdWRlRWRnZUlkIiwiZmlsdGVyZWRHcmFwaCIsImxhYmVsMSIsImxhYmVsMiIsIm5vcm1hbGl6ZWQxIiwidG9Mb3dlckNhc2UiLCJ0cmltIiwibm9ybWFsaXplZDIiLCJhYmJyZXZpYXRpb25zIiwibWwiLCJhaSIsImRsIiwiZXhwYW5kZWQxIiwiZXhwYW5kZWQyIiwiaW5jbHVkZXMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7Ozs7Ozs7Ozs7SUFnSGVBLE9BQU87ZUFBUEE7O0lBZkFDLE9BQU87ZUFBUEE7O0lBK1FBQyxZQUFZO2VBQVpBOztJQTVSQUMsb0JBQW9CO2VBQXBCQTs7SUE2TUFDLFdBQVc7ZUFBWEE7O0lBcEhBQyxRQUFRO2VBQVJBOztJQXlKQUMsV0FBVztlQUFYQTs7SUEvR0FDLFdBQVc7ZUFBWEE7O0lBd01BQyxhQUFhO2VBQWJBOztJQWhRQUMsVUFBVTtlQUFWQTs7SUF6QkFDLFVBQVU7ZUFBVkE7O0lBaVlBQyxhQUFhO2VBQWJBOzs7QUFyYmhCLElBQUlDLGVBQWU7QUFFWixTQUFTVCxxQkFBcUJVLEVBQVc7SUFDOUMsT0FBTztRQUNMQSxJQUFJQSxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUVELGFBQWEsQ0FBQztRQUNuQ0UsT0FBTyxFQUFFO1FBQ1RDLE9BQU8sRUFBRTtRQUNUQyxVQUFVO1lBQ1JDLFNBQVNDLEtBQUtDLEdBQUc7WUFDakJDLFVBQVVGLEtBQUtDLEdBQUc7WUFDbEJFLFNBQVM7UUFDWDtJQUNGO0FBQ0Y7QUFFTyxTQUFTcEIsUUFDZHFCLEtBQXFCLEVBQ3JCQyxJQUFtQjtJQUVuQixJQUFJRCxNQUFNUixLQUFLLENBQUNVLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFWixFQUFFLEtBQUtVLEtBQUtWLEVBQUUsR0FBRztRQUM3QyxNQUFNLElBQUlhLE1BQU0sQ0FBQyxhQUFhLEVBQUVILEtBQUtWLEVBQUUsQ0FBQyxlQUFlLENBQUM7SUFDMUQ7SUFFQSxPQUFPO1FBQ0wsR0FBR1MsS0FBSztRQUNSUixPQUFPO2VBQUlRLE1BQU1SLEtBQUs7WUFBRVM7U0FBSztRQUM3QlAsVUFBVTtZQUFFLEdBQUdNLE1BQU1OLFFBQVE7WUFBRUksVUFBVUYsS0FBS0MsR0FBRztRQUFHO0lBQ3REO0FBQ0Y7QUFFTyxTQUFTbkIsUUFDZHNCLEtBQXFCLEVBQ3JCSyxJQUFtQjtJQUVuQiwwQkFBMEI7SUFDMUIsTUFBTUMsZUFBZU4sTUFBTVIsS0FBSyxDQUFDVSxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRVosRUFBRSxLQUFLYyxLQUFLRSxNQUFNO0lBQ2pFLE1BQU1DLGVBQWVSLE1BQU1SLEtBQUssQ0FBQ1UsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVaLEVBQUUsS0FBS2MsS0FBS0ksTUFBTTtJQUVqRSxJQUFJLENBQUNILGNBQWM7UUFDakIsTUFBTSxJQUFJRixNQUFNLENBQUMsWUFBWSxFQUFFQyxLQUFLRSxNQUFNLENBQUMsZUFBZSxDQUFDO0lBQzdEO0lBQ0EsSUFBSSxDQUFDQyxjQUFjO1FBQ2pCLE1BQU0sSUFBSUosTUFBTSxDQUFDLFlBQVksRUFBRUMsS0FBS0ksTUFBTSxDQUFDLGVBQWUsQ0FBQztJQUM3RDtJQUVBLE9BQU87UUFDTCxHQUFHVCxLQUFLO1FBQ1JQLE9BQU87ZUFBSU8sTUFBTVAsS0FBSztZQUFFWTtTQUFLO1FBQzdCWCxVQUFVO1lBQUUsR0FBR00sTUFBTU4sUUFBUTtZQUFFSSxVQUFVRixLQUFLQyxHQUFHO1FBQUc7SUFDdEQ7QUFDRjtBQUVPLFNBQVNULFdBQ2RZLEtBQXFCLEVBQ3JCVSxNQUFjLEVBQ2RDLE9BQStCO0lBRS9CLE1BQU1DLFlBQVlaLE1BQU1SLEtBQUssQ0FBQ3FCLFNBQVMsQ0FBQyxDQUFDVixJQUFNQSxFQUFFWixFQUFFLEtBQUttQjtJQUV4RCxJQUFJRSxjQUFjLENBQUMsR0FBRztRQUNwQixNQUFNLElBQUlSLE1BQU0sQ0FBQyxLQUFLLEVBQUVNLE9BQU8sVUFBVSxDQUFDO0lBQzVDO0lBRUEsTUFBTUksZUFBZTtXQUFJZCxNQUFNUixLQUFLO0tBQUM7SUFDckNzQixZQUFZLENBQUNGLFVBQVUsR0FBRztRQUN4QixHQUFHRSxZQUFZLENBQUNGLFVBQVU7UUFDMUIsR0FBR0QsT0FBTztRQUNWcEIsSUFBSW1CO0lBQ047SUFFQSxPQUFPO1FBQ0wsR0FBR1YsS0FBSztRQUNSUixPQUFPc0I7UUFDUHBCLFVBQVU7WUFBRSxHQUFHTSxNQUFNTixRQUFRO1lBQUVJLFVBQVVGLEtBQUtDLEdBQUc7UUFBRztJQUN0RDtBQUNGO0FBRU8sU0FBU1YsV0FDZGEsS0FBcUIsRUFDckJVLE1BQWM7SUFFZCxPQUFPO1FBQ0wsR0FBR1YsS0FBSztRQUNSUixPQUFPUSxNQUFNUixLQUFLLENBQUN1QixNQUFNLENBQUMsQ0FBQ1osSUFBTUEsRUFBRVosRUFBRSxLQUFLbUI7UUFDMUNqQixPQUFPTyxNQUFNUCxLQUFLLENBQUNzQixNQUFNLENBQ3ZCLENBQUNDLElBQU1BLEVBQUVULE1BQU0sS0FBS0csVUFBVU0sRUFBRVAsTUFBTSxLQUFLQztRQUU3Q2hCLFVBQVU7WUFBRSxHQUFHTSxNQUFNTixRQUFRO1lBQUVJLFVBQVVGLEtBQUtDLEdBQUc7UUFBRztJQUN0RDtBQUNGO0FBRU8sU0FBU2QsU0FDZGlCLEtBQXFCLEVBQ3JCaUIsT0FBZSxFQUNmQyxLQUFhO0lBRWIsSUFDRSxDQUFDbEIsTUFBTVIsS0FBSyxDQUFDVSxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRVosRUFBRSxLQUFLMEIsWUFDbEMsQ0FBQ2pCLE1BQU1SLEtBQUssQ0FBQ1UsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVaLEVBQUUsS0FBSzJCLFFBQ2xDO1FBQ0EsT0FBTztJQUNUO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU1DLFFBQWlEO1FBQ3JEO1lBQUVsQixNQUFNZ0I7WUFBU0csTUFBTTtnQkFBQ0g7YUFBUTtRQUFDO0tBQ2xDO0lBQ0QsTUFBTUksVUFBVSxJQUFJQztJQUVwQixNQUFPSCxNQUFNSSxNQUFNLEdBQUcsRUFBRztRQUN2QixNQUFNLEVBQUV0QixJQUFJLEVBQUVtQixJQUFJLEVBQUUsR0FBR0QsTUFBTUssS0FBSztRQUVsQyxJQUFJdkIsU0FBU2lCLE9BQU87WUFDbEIsT0FBT0U7UUFDVDtRQUVBLElBQUlDLFFBQVFJLEdBQUcsQ0FBQ3hCLE9BQU87UUFDdkJvQixRQUFRSyxHQUFHLENBQUN6QjtRQUVaLGlCQUFpQjtRQUNqQixNQUFNMEIsWUFBWTNCLE1BQU1QLEtBQUssQ0FDMUJzQixNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRVQsTUFBTSxLQUFLTixRQUFRZSxFQUFFUCxNQUFNLEtBQUtSLE1BQ2hEMkIsR0FBRyxDQUFDLENBQUNaLElBQU9BLEVBQUVULE1BQU0sS0FBS04sT0FBT2UsRUFBRVAsTUFBTSxHQUFHTyxFQUFFVCxNQUFNLEVBQ25EUSxNQUFNLENBQUMsQ0FBQ1osSUFBTSxDQUFDa0IsUUFBUUksR0FBRyxDQUFDdEI7UUFFOUIsS0FBSyxNQUFNMEIsWUFBWUYsVUFBVztZQUNoQ1IsTUFBTVcsSUFBSSxDQUFDO2dCQUFFN0IsTUFBTTRCO2dCQUFVVCxNQUFNO3VCQUFJQTtvQkFBTVM7aUJBQVM7WUFBQztRQUN6RDtJQUNGO0lBRUEsT0FBTztBQUNUO0FBRU8sU0FBUzVDLFlBQ2Q4QyxNQUFzQixFQUN0QkMsTUFBc0IsRUFDdEJDLFVBR0ksQ0FBQyxDQUFDO0lBRU4sTUFBTUMsWUFBbUIsRUFBRTtJQUMzQixNQUFNQyxjQUFjLElBQUlDO0lBQ3hCLE1BQU1DLGNBQWMsSUFBSUQ7SUFFeEIsY0FBYztJQUNkLEtBQUssTUFBTW5DLFFBQVE4QixPQUFPdkMsS0FBSyxDQUFFO1FBQy9CMkMsWUFBWUcsR0FBRyxDQUFDckMsS0FBS1YsRUFBRSxFQUFFVTtJQUMzQjtJQUVBLEtBQUssTUFBTUEsUUFBUStCLE9BQU94QyxLQUFLLENBQUU7UUFDL0IsTUFBTStDLFdBQVdKLFlBQVlLLEdBQUcsQ0FBQ3ZDLEtBQUtWLEVBQUU7UUFDeEMsSUFBSWdELFVBQVU7WUFDWixvQkFBb0I7WUFDcEIsSUFBSU4sUUFBUVEsZUFBZSxFQUFFO2dCQUMzQlAsVUFBVUosSUFBSSxDQUFDO29CQUNicEIsUUFBUVQsS0FBS1YsRUFBRTtvQkFDZm1ELGFBQWFILFNBQVNJLEtBQUs7b0JBQzNCQyxhQUFhM0MsS0FBSzBDLEtBQUs7Z0JBQ3pCO1lBQ0Y7WUFFQSxJQUNFVixRQUFRWSxrQkFBa0IsS0FBSyxXQUMvQlosUUFBUVksa0JBQWtCLEtBQUssZUFDL0I7Z0JBQ0FWLFlBQVlHLEdBQUcsQ0FBQ3JDLEtBQUtWLEVBQUUsRUFBRVU7WUFDM0I7UUFDQSxrREFBa0Q7UUFDcEQsT0FBTztZQUNMa0MsWUFBWUcsR0FBRyxDQUFDckMsS0FBS1YsRUFBRSxFQUFFVTtRQUMzQjtJQUNGO0lBRUEsY0FBYztJQUNkLEtBQUssTUFBTUksUUFBUTBCLE9BQU90QyxLQUFLLENBQUU7UUFDL0I0QyxZQUFZQyxHQUFHLENBQUNqQyxLQUFLZCxFQUFFLEVBQUVjO0lBQzNCO0lBRUEsS0FBSyxNQUFNQSxRQUFRMkIsT0FBT3ZDLEtBQUssQ0FBRTtRQUMvQixJQUFJLENBQUM0QyxZQUFZWixHQUFHLENBQUNwQixLQUFLZCxFQUFFLEdBQUc7WUFDN0IsbURBQW1EO1lBQ25ELElBQUk0QyxZQUFZVixHQUFHLENBQUNwQixLQUFLRSxNQUFNLEtBQUs0QixZQUFZVixHQUFHLENBQUNwQixLQUFLSSxNQUFNLEdBQUc7Z0JBQ2hFNEIsWUFBWUMsR0FBRyxDQUFDakMsS0FBS2QsRUFBRSxFQUFFYztZQUMzQjtRQUNGO0lBQ0Y7SUFFQSxNQUFNeUMsU0FBaUQ7UUFDckR2RCxJQUFJLENBQUMsT0FBTyxFQUFFd0MsT0FBT3hDLEVBQUUsQ0FBQyxDQUFDLEVBQUV5QyxPQUFPekMsRUFBRSxDQUFDLENBQUM7UUFDdENDLE9BQU91RCxNQUFNQyxJQUFJLENBQUNiLFlBQVljLE1BQU07UUFDcEN4RCxPQUFPc0QsTUFBTUMsSUFBSSxDQUFDWCxZQUFZWSxNQUFNO1FBQ3BDdkQsVUFBVTtZQUNSQyxTQUFTdUQsS0FBS0MsR0FBRyxDQUFDcEIsT0FBT3JDLFFBQVEsQ0FBQ0MsT0FBTyxFQUFFcUMsT0FBT3RDLFFBQVEsQ0FBQ0MsT0FBTztZQUNsRUcsVUFBVUYsS0FBS0MsR0FBRztZQUNsQkUsU0FBUztZQUNUcUQsWUFBWTtnQkFBQ3JCLE9BQU94QyxFQUFFO2dCQUFFeUMsT0FBT3pDLEVBQUU7YUFBQztRQUNwQztJQUNGO0lBRUEsSUFBSTBDLFFBQVFRLGVBQWUsRUFBRTtRQUMzQkssT0FBT1osU0FBUyxHQUFHQTtJQUNyQjtJQUVBLE9BQU9ZO0FBQ1Q7QUFFTyxTQUFTaEUsWUFDZGtCLEtBQXFCLEVBQ3JCcUQsTUFBMEI7SUFFMUIsSUFBSUEsV0FBVyxRQUFRO1FBQ3JCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ3ZELE9BQU8sTUFBTTtJQUNyQztJQUVBLGlCQUFpQjtJQUNqQixJQUFJd0QsTUFBTTtJQUNWQSxPQUFPO0lBQ1BBLE9BQU8sa0JBQWtCeEQsTUFBTVQsRUFBRSxHQUFHO0lBRXBDLFlBQVk7SUFDWixLQUFLLE1BQU1VLFFBQVFELE1BQU1SLEtBQUssQ0FBRTtRQUM5QmdFLE9BQU8sQ0FBQyxjQUFjLEVBQUV2RCxLQUFLVixFQUFFLENBQUMsSUFBSSxDQUFDO1FBQ3JDaUUsT0FBTyxDQUFDLHdCQUF3QixFQUFFdkQsS0FBSzBDLEtBQUssQ0FBQyxTQUFTLENBQUM7UUFDdkRhLE9BQU8sQ0FBQyx1QkFBdUIsRUFBRXZELEtBQUt3RCxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQ3JERCxPQUFPO0lBQ1Q7SUFFQSxZQUFZO0lBQ1osS0FBSyxNQUFNbkQsUUFBUUwsTUFBTVAsS0FBSyxDQUFFO1FBQzlCK0QsT0FBTyxDQUFDLGNBQWMsRUFBRW5ELEtBQUtkLEVBQUUsQ0FBQyxVQUFVLEVBQUVjLEtBQUtFLE1BQU0sQ0FBQyxVQUFVLEVBQUVGLEtBQUtJLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDckYrQyxPQUFPLENBQUMsdUJBQXVCLEVBQUVuRCxLQUFLb0QsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUNyRCxJQUFJcEQsS0FBS3FELE1BQU0sS0FBS0MsV0FBVztZQUM3QkgsT0FBTyxDQUFDLHlCQUF5QixFQUFFbkQsS0FBS3FELE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFDM0Q7UUFDQUYsT0FBTztJQUNUO0lBRUFBLE9BQU87SUFDUEEsT0FBTztJQUVQLE9BQU9BO0FBQ1Q7QUFFTyxTQUFTeEUsWUFDZDRFLElBQVksRUFDWlAsTUFBMEI7SUFFMUIsSUFBSUEsV0FBVyxRQUFRO1FBQ3JCLE1BQU1RLFNBQVNQLEtBQUtRLEtBQUssQ0FBQ0Y7UUFFMUIscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0MsT0FBT3JFLEtBQUssSUFBSSxDQUFDcUUsT0FBT3BFLEtBQUssRUFBRTtZQUNsQyxNQUFNLElBQUlXLE1BQU07UUFDbEI7UUFFQSxpQkFBaUI7UUFDakIsS0FBSyxNQUFNSCxRQUFRNEQsT0FBT3JFLEtBQUssQ0FBRTtZQUMvQixJQUFJLENBQUNTLEtBQUtWLEVBQUUsSUFBSSxDQUFDVSxLQUFLMEMsS0FBSyxJQUFJLENBQUMxQyxLQUFLd0QsSUFBSSxFQUFFO2dCQUN6QyxNQUFNLElBQUlyRCxNQUFNO1lBQ2xCO1FBQ0Y7UUFFQSwwQ0FBMEM7UUFDMUMsTUFBTTJELFVBQVUsSUFBSXpDLElBQUl1QyxPQUFPckUsS0FBSyxDQUFDb0MsR0FBRyxDQUFDLENBQUN6QixJQUFxQkEsRUFBRVosRUFBRTtRQUNuRSxLQUFLLE1BQU1jLFFBQVF3RCxPQUFPcEUsS0FBSyxDQUFFO1lBQy9CLElBQUksQ0FBQ3NFLFFBQVF0QyxHQUFHLENBQUNwQixLQUFLRSxNQUFNLEtBQUssQ0FBQ3dELFFBQVF0QyxHQUFHLENBQUNwQixLQUFLSSxNQUFNLEdBQUc7Z0JBQzFELE1BQU0sSUFBSUwsTUFBTTtZQUNsQjtRQUNGO1FBRUEsT0FBTztZQUNMYixJQUFJc0UsT0FBT3RFLEVBQUUsSUFBSVYsdUJBQXVCVSxFQUFFO1lBQzFDQyxPQUFPcUUsT0FBT3JFLEtBQUs7WUFDbkJDLE9BQU9vRSxPQUFPcEUsS0FBSztZQUNuQkMsVUFBVW1FLE9BQU9uRSxRQUFRLElBQUk7Z0JBQzNCQyxTQUFTQyxLQUFLQyxHQUFHO2dCQUNqQkMsVUFBVUYsS0FBS0MsR0FBRztnQkFDbEJFLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFFQSxNQUFNLElBQUlLLE1BQU07QUFDbEI7QUFFTyxTQUFTeEIsYUFDZG9CLEtBQXFCLEVBQ3JCaUMsVUFHSSxDQUFDLENBQUM7SUFFTixNQUFNK0IsWUFBWWhFLE1BQU1SLEtBQUssQ0FBQytCLE1BQU07SUFDcEMsTUFBTTBDLFlBQVlqRSxNQUFNUCxLQUFLLENBQUM4QixNQUFNO0lBQ3BDLE1BQU0yQyxtQkFBbUIsQUFBQ0YsWUFBYUEsQ0FBQUEsWUFBWSxDQUFBLElBQU07SUFDekQsTUFBTUcsVUFBVUgsWUFBWSxJQUFJQyxZQUFZQyxtQkFBbUI7SUFFL0QsMkJBQTJCO0lBQzNCLE1BQU1FLFVBQVUsSUFBSWhDO0lBQ3BCLEtBQUssTUFBTS9CLFFBQVFMLE1BQU1QLEtBQUssQ0FBRTtRQUM5QjJFLFFBQVE5QixHQUFHLENBQUNqQyxLQUFLRSxNQUFNLEVBQUUsQUFBQzZELENBQUFBLFFBQVE1QixHQUFHLENBQUNuQyxLQUFLRSxNQUFNLEtBQUssQ0FBQSxJQUFLO1FBQzNENkQsUUFBUTlCLEdBQUcsQ0FBQ2pDLEtBQUtJLE1BQU0sRUFBRSxBQUFDMkQsQ0FBQUEsUUFBUTVCLEdBQUcsQ0FBQ25DLEtBQUtJLE1BQU0sS0FBSyxDQUFBLElBQUs7SUFDN0Q7SUFDQSxNQUFNNEQsWUFDSkwsWUFBWSxJQUNSakIsTUFBTUMsSUFBSSxDQUFDb0IsUUFBUW5CLE1BQU0sSUFBSXFCLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQyxHQUFHLEtBQUtSLFlBQzFEO0lBRU4sTUFBTVMsVUFBd0I7UUFDNUJUO1FBQ0FDO1FBQ0FFO1FBQ0FFO1FBQ0FLLFVBQVVDLGtCQUFrQjNFO1FBQzVCNEUsWUFBWUMsb0JBQW9CN0U7UUFDaEM4RSxZQUFZO0lBQ2Q7SUFFQSxJQUFJN0MsUUFBUThDLHFCQUFxQixFQUFFO1FBQ2pDTixRQUFRTyxjQUFjLEdBQUdqQyxNQUFNQyxJQUFJLENBQUNvQixRQUFRYSxPQUFPLElBQ2hEckQsR0FBRyxDQUFDLENBQUMsQ0FBQ3JDLElBQUkyRixPQUFPLEdBQU0sQ0FBQTtnQkFBRTNGO2dCQUFJNEYsT0FBT0Q7WUFBTyxDQUFBLEdBQzNDRSxJQUFJLENBQUMsQ0FBQ2IsR0FBR0MsSUFBTUEsRUFBRVcsS0FBSyxHQUFHWixFQUFFWSxLQUFLLEVBQ2hDRSxLQUFLLENBQUMsR0FBRztJQUNkO0lBRUEsSUFBSXBELFFBQVFxRCxpQkFBaUIsRUFBRTtRQUM3QmIsUUFBUWMsV0FBVyxHQUFHRCxrQkFBa0J0RjtJQUMxQztJQUVBLE9BQU95RTtBQUNUO0FBRU8sU0FBU3ZGLGNBQ2RjLEtBQXFCLEVBQ3JCaUMsVUFLSSxDQUFDLENBQUM7SUFFTixJQUFJdUQsWUFBWTtRQUFFLEdBQUd4RixLQUFLO0lBQUM7SUFFM0IsSUFBSWlDLFFBQVF3RCxlQUFlLEVBQUU7UUFDM0IsMEJBQTBCO1FBQzFCLE1BQU1DLGdCQUFnQixJQUFJcEU7UUFFMUIsS0FBSyxNQUFNakIsUUFBUUwsTUFBTVAsS0FBSyxDQUFFO1lBQzlCLElBQUlZLEtBQUtvRCxJQUFJLEtBQUssV0FBVztnQkFDM0Isb0NBQW9DO2dCQUNwQyxNQUFNa0Msa0JBQWtCQyxzQkFDdEI1RixPQUNBSyxLQUFLRSxNQUFNLEVBQ1hGLEtBQUtJLE1BQU0sRUFDWEosS0FBS2QsRUFBRTtnQkFHVCxJQUFJb0csbUJBQW1CQSxnQkFBZ0JwRSxNQUFNLElBQUksR0FBRztvQkFDbERtRSxjQUFjaEUsR0FBRyxDQUFDckIsS0FBS2QsRUFBRTtnQkFDM0I7WUFDRjtRQUNGO1FBRUFpRyxVQUFVL0YsS0FBSyxHQUFHK0YsVUFBVS9GLEtBQUssQ0FBQ3NCLE1BQU0sQ0FBQyxDQUFDQyxJQUFNLENBQUMwRSxjQUFjakUsR0FBRyxDQUFDVCxFQUFFekIsRUFBRTtJQUN6RTtJQUVBLElBQUkwQyxRQUFRNEQsa0JBQWtCLEVBQUU7UUFDOUIsaURBQWlEO1FBQ2pELE1BQU1DLFlBQVk3RCxRQUFROEQsbUJBQW1CLElBQUk7UUFDakQsTUFBTUMsYUFBZ0MsRUFBRTtRQUN4QyxNQUFNQyxZQUFZLElBQUkzRTtRQUV0QixLQUFLLE1BQU1yQixRQUFRRCxNQUFNUixLQUFLLENBQUU7WUFDOUIsSUFBSXlHLFVBQVV4RSxHQUFHLENBQUN4QixLQUFLVixFQUFFLEdBQUc7WUFFNUIsTUFBTTJHLFFBQVE7Z0JBQUNqRzthQUFLO1lBQ3BCZ0csVUFBVXZFLEdBQUcsQ0FBQ3pCLEtBQUtWLEVBQUU7WUFFckIsS0FBSyxNQUFNNEcsU0FBU25HLE1BQU1SLEtBQUssQ0FBRTtnQkFDL0IsSUFBSXlHLFVBQVV4RSxHQUFHLENBQUMwRSxNQUFNNUcsRUFBRSxHQUFHO2dCQUU3QixNQUFNNkcsYUFBYUMsb0JBQW9CcEcsS0FBSzBDLEtBQUssRUFBRXdELE1BQU14RCxLQUFLO2dCQUM5RCxJQUFJeUQsY0FBY04sV0FBVztvQkFDM0JJLE1BQU1wRSxJQUFJLENBQUNxRTtvQkFDWEYsVUFBVXZFLEdBQUcsQ0FBQ3lFLE1BQU01RyxFQUFFO2dCQUN4QjtZQUNGO1lBRUEsSUFBSTJHLE1BQU0zRSxNQUFNLEdBQUcsR0FBRztnQkFDcEJ5RSxXQUFXbEUsSUFBSSxDQUFDb0U7WUFDbEI7UUFDRjtRQUVBLHNCQUFzQjtRQUN0QixNQUFNL0QsY0FBK0IsRUFBRTtRQUN2QyxNQUFNbUUsY0FBYyxJQUFJbEU7UUFFeEIsS0FBSyxNQUFNOEQsU0FBU0YsV0FBWTtZQUM5QixNQUFNTyxTQUFTTCxLQUFLLENBQUMsRUFBRSxFQUFFLCtCQUErQjtZQUN4RC9ELFlBQVlMLElBQUksQ0FBQ3lFO1lBRWpCLEtBQUssTUFBTXRHLFFBQVFpRyxNQUFPO2dCQUN4QkksWUFBWWhFLEdBQUcsQ0FBQ3JDLEtBQUtWLEVBQUUsRUFBRWdILE9BQU9oSCxFQUFFO1lBQ3BDO1FBQ0Y7UUFFQSx3QkFBd0I7UUFDeEIsS0FBSyxNQUFNVSxRQUFRRCxNQUFNUixLQUFLLENBQUU7WUFDOUIsSUFBSSxDQUFDOEcsWUFBWTdFLEdBQUcsQ0FBQ3hCLEtBQUtWLEVBQUUsS0FBSytHLFlBQVk5RCxHQUFHLENBQUN2QyxLQUFLVixFQUFFLE1BQU1VLEtBQUtWLEVBQUUsRUFBRTtnQkFDckUsSUFBSSxDQUFDNEMsWUFBWWpDLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFWixFQUFFLEtBQUtVLEtBQUtWLEVBQUUsR0FBRztvQkFDOUM0QyxZQUFZTCxJQUFJLENBQUM3QjtnQkFDbkI7WUFDRjtRQUNGO1FBRUF1RixVQUFVaEcsS0FBSyxHQUFHMkM7UUFFbEIsb0NBQW9DO1FBQ3BDcUQsVUFBVS9GLEtBQUssR0FBRytGLFVBQVUvRixLQUFLLENBQzlCbUMsR0FBRyxDQUFDLENBQUN2QixPQUFVLENBQUE7Z0JBQ2QsR0FBR0EsSUFBSTtnQkFDUEUsUUFBUStGLFlBQVk5RCxHQUFHLENBQUNuQyxLQUFLRSxNQUFNLEtBQUtGLEtBQUtFLE1BQU07Z0JBQ25ERSxRQUFRNkYsWUFBWTlELEdBQUcsQ0FBQ25DLEtBQUtJLE1BQU0sS0FBS0osS0FBS0ksTUFBTTtZQUNyRCxDQUFBLEdBQ0NNLE1BQU0sQ0FBQyxDQUFDVixPQUFTQSxLQUFLRSxNQUFNLEtBQUtGLEtBQUtJLE1BQU0sR0FBRyxvQkFBb0I7SUFDeEU7SUFFQSxJQUFJd0IsUUFBUXVFLGNBQWMsS0FBSzdDLFdBQVc7UUFDeEM2QixVQUFVL0YsS0FBSyxHQUFHK0YsVUFBVS9GLEtBQUssQ0FBQ3NCLE1BQU0sQ0FDdEMsQ0FBQ1YsT0FBUyxBQUFDQSxDQUFBQSxLQUFLcUQsTUFBTSxJQUFJLENBQUEsS0FBTXpCLFFBQVF1RSxjQUFjO0lBRTFEO0lBRUEsT0FBT2hCO0FBQ1Q7QUFFTyxTQUFTbkcsY0FDZFcsS0FBcUIsRUFDckJpQyxVQUFzQyxDQUFDLENBQUM7SUFFeEMsTUFBTXdFLFNBQWdCLEVBQUU7SUFFeEIsMkJBQTJCO0lBQzNCLElBQUksQ0FBQ3hFLFFBQVF5RSxZQUFZLEVBQUU7UUFDekIsTUFBTUMsaUJBQWlCLElBQUlyRjtRQUUzQixLQUFLLE1BQU1qQixRQUFRTCxNQUFNUCxLQUFLLENBQUU7WUFDOUJrSCxlQUFlakYsR0FBRyxDQUFDckIsS0FBS0UsTUFBTTtZQUM5Qm9HLGVBQWVqRixHQUFHLENBQUNyQixLQUFLSSxNQUFNO1FBQ2hDO1FBRUEsS0FBSyxNQUFNUixRQUFRRCxNQUFNUixLQUFLLENBQUU7WUFDOUIsSUFBSSxDQUFDbUgsZUFBZWxGLEdBQUcsQ0FBQ3hCLEtBQUtWLEVBQUUsR0FBRztnQkFDaENrSCxPQUFPM0UsSUFBSSxDQUFDO29CQUNWMkIsTUFBTTtvQkFDTi9DLFFBQVFULEtBQUtWLEVBQUU7b0JBQ2ZxSCxTQUFTLENBQUMsS0FBSyxFQUFFM0csS0FBS1YsRUFBRSxDQUFDLG1CQUFtQixDQUFDO2dCQUMvQztZQUNGO1FBQ0Y7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQixNQUFNd0UsVUFBVSxJQUFJekMsSUFBSXRCLE1BQU1SLEtBQUssQ0FBQ29DLEdBQUcsQ0FBQyxDQUFDekIsSUFBTUEsRUFBRVosRUFBRTtJQUVuRCxLQUFLLE1BQU1jLFFBQVFMLE1BQU1QLEtBQUssQ0FBRTtRQUM5QixJQUFJLENBQUNzRSxRQUFRdEMsR0FBRyxDQUFDcEIsS0FBS0UsTUFBTSxHQUFHO1lBQzdCa0csT0FBTzNFLElBQUksQ0FBQztnQkFDVjJCLE1BQU07Z0JBQ05vRCxRQUFReEcsS0FBS2QsRUFBRTtnQkFDZnVILFFBQVEsQ0FBQyxZQUFZLEVBQUV6RyxLQUFLRSxNQUFNLENBQUMsZUFBZSxDQUFDO1lBQ3JEO1FBQ0Y7UUFDQSxJQUFJLENBQUN3RCxRQUFRdEMsR0FBRyxDQUFDcEIsS0FBS0ksTUFBTSxHQUFHO1lBQzdCZ0csT0FBTzNFLElBQUksQ0FBQztnQkFDVjJCLE1BQU07Z0JBQ05vRCxRQUFReEcsS0FBS2QsRUFBRTtnQkFDZnVILFFBQVEsQ0FBQyxZQUFZLEVBQUV6RyxLQUFLSSxNQUFNLENBQUMsZUFBZSxDQUFDO1lBQ3JEO1FBQ0Y7SUFDRjtJQUVBLE9BQU87UUFDTHNHLFNBQVNOLE9BQU9sRixNQUFNLEtBQUs7UUFDM0JrRjtJQUNGO0FBQ0Y7QUFFQSxtQkFBbUI7QUFDbkIsU0FBUzlCLGtCQUFrQjNFLEtBQXFCO0lBQzlDLElBQUlnSCxjQUFjO0lBRWxCLEtBQUssTUFBTUMsU0FBU2pILE1BQU1SLEtBQUssQ0FBRTtRQUMvQixLQUFLLE1BQU0wSCxPQUFPbEgsTUFBTVIsS0FBSyxDQUFFO1lBQzdCLElBQUl5SCxNQUFNMUgsRUFBRSxLQUFLMkgsSUFBSTNILEVBQUUsRUFBRTtnQkFDdkIsTUFBTTZCLE9BQU9yQyxTQUFTaUIsT0FBT2lILE1BQU0xSCxFQUFFLEVBQUUySCxJQUFJM0gsRUFBRTtnQkFDN0MsSUFBSTZCLE1BQU07b0JBQ1I0RixjQUFjOUQsS0FBS2lFLEdBQUcsQ0FBQ0gsYUFBYTVGLEtBQUtHLE1BQU0sR0FBRztnQkFDcEQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPeUY7QUFDVDtBQUVBLFNBQVNuQyxvQkFBb0I3RSxLQUFxQjtJQUNoRCxvQ0FBb0M7SUFDcEMsSUFBSW9ILGtCQUFrQjtJQUN0QixJQUFJcEQsWUFBWTtJQUVoQixLQUFLLE1BQU0vRCxRQUFRRCxNQUFNUixLQUFLLENBQUU7UUFDOUIsTUFBTW1DLFlBQVkzQixNQUFNUCxLQUFLLENBQzFCc0IsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVULE1BQU0sS0FBS04sS0FBS1YsRUFBRSxJQUFJeUIsRUFBRVAsTUFBTSxLQUFLUixLQUFLVixFQUFFLEVBQzFEcUMsR0FBRyxDQUFDLENBQUNaLElBQU9BLEVBQUVULE1BQU0sS0FBS04sS0FBS1YsRUFBRSxHQUFHeUIsRUFBRVAsTUFBTSxHQUFHTyxFQUFFVCxNQUFNO1FBRXpELElBQUlvQixVQUFVSixNQUFNLElBQUksR0FBRztZQUN6QixJQUFJOEYsY0FBYztZQUVsQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSTNGLFVBQVVKLE1BQU0sRUFBRStGLElBQUs7Z0JBQ3pDLElBQUssSUFBSUMsSUFBSUQsSUFBSSxHQUFHQyxJQUFJNUYsVUFBVUosTUFBTSxFQUFFZ0csSUFBSztvQkFDN0MsTUFBTUMsVUFBVXhILE1BQU1QLEtBQUssQ0FBQ1MsSUFBSSxDQUM5QixDQUFDYyxJQUNDLEFBQUNBLEVBQUVULE1BQU0sS0FBS29CLFNBQVMsQ0FBQzJGLEVBQUUsSUFBSXRHLEVBQUVQLE1BQU0sS0FBS2tCLFNBQVMsQ0FBQzRGLEVBQUUsSUFDdER2RyxFQUFFVCxNQUFNLEtBQUtvQixTQUFTLENBQUM0RixFQUFFLElBQUl2RyxFQUFFUCxNQUFNLEtBQUtrQixTQUFTLENBQUMyRixFQUFFO29CQUUzRCxJQUFJRSxTQUFTSDtnQkFDZjtZQUNGO1lBRUEsTUFBTUksaUJBQWlCLEFBQUM5RixVQUFVSixNQUFNLEdBQUlJLENBQUFBLFVBQVVKLE1BQU0sR0FBRyxDQUFBLElBQU07WUFDckU2RixtQkFBbUJDLGNBQWNJO1lBQ2pDekQ7UUFDRjtJQUNGO0lBRUEsT0FBT0EsWUFBWSxJQUFJb0Qsa0JBQWtCcEQsWUFBWTtBQUN2RDtBQUVBLFNBQVNzQixrQkFBa0J0RixLQUFxQjtJQUM5Qyx3REFBd0Q7SUFDeEQsTUFBTXFCLFVBQVUsSUFBSUM7SUFDcEIsTUFBTWlFLGNBQTBCLEVBQUU7SUFFbEMsU0FBU21DLElBQUloSCxNQUFjLEVBQUVpSCxTQUFtQjtRQUM5QyxJQUFJdEcsUUFBUUksR0FBRyxDQUFDZixTQUFTO1FBQ3pCVyxRQUFRSyxHQUFHLENBQUNoQjtRQUNaaUgsVUFBVTdGLElBQUksQ0FBQ3BCO1FBRWYsTUFBTWlCLFlBQVkzQixNQUFNUCxLQUFLLENBQzFCc0IsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVULE1BQU0sS0FBS0csVUFBVU0sRUFBRVAsTUFBTSxLQUFLQyxRQUNsRGtCLEdBQUcsQ0FBQyxDQUFDWixJQUFPQSxFQUFFVCxNQUFNLEtBQUtHLFNBQVNNLEVBQUVQLE1BQU0sR0FBR08sRUFBRVQsTUFBTTtRQUV4RCxLQUFLLE1BQU1zQixZQUFZRixVQUFXO1lBQ2hDK0YsSUFBSTdGLFVBQVU4RjtRQUNoQjtJQUNGO0lBRUEsS0FBSyxNQUFNMUgsUUFBUUQsTUFBTVIsS0FBSyxDQUFFO1FBQzlCLElBQUksQ0FBQzZCLFFBQVFJLEdBQUcsQ0FBQ3hCLEtBQUtWLEVBQUUsR0FBRztZQUN6QixNQUFNb0ksWUFBc0IsRUFBRTtZQUM5QkQsSUFBSXpILEtBQUtWLEVBQUUsRUFBRW9JO1lBQ2JwQyxZQUFZekQsSUFBSSxDQUFDNkY7UUFDbkI7SUFDRjtJQUVBLE9BQU9wQztBQUNUO0FBRUEsU0FBU0ssc0JBQ1A1RixLQUFxQixFQUNyQmlILEtBQWEsRUFDYkMsR0FBVyxFQUNYVSxhQUFxQjtJQUVyQixNQUFNQyxnQkFBZ0I7UUFDcEIsR0FBRzdILEtBQUs7UUFDUlAsT0FBT08sTUFBTVAsS0FBSyxDQUFDc0IsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUV6QixFQUFFLEtBQUtxSTtJQUM1QztJQUNBLE9BQU83SSxTQUFTOEksZUFBZVosT0FBT0M7QUFDeEM7QUFFQSxTQUFTYixvQkFBb0J5QixNQUFjLEVBQUVDLE1BQWM7SUFDekQscUNBQXFDO0lBQ3JDLE1BQU1DLGNBQWNGLE9BQU9HLFdBQVcsR0FBR0MsSUFBSTtJQUM3QyxNQUFNQyxjQUFjSixPQUFPRSxXQUFXLEdBQUdDLElBQUk7SUFFN0MsSUFBSUYsZ0JBQWdCRyxhQUFhLE9BQU87SUFFeEMsaUNBQWlDO0lBQ2pDLE1BQU1DLGdCQUF3QztRQUM1Q0MsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLElBQUk7SUFDTjtJQUVBLE1BQU1DLFlBQVlKLGFBQWEsQ0FBQ0osWUFBWSxJQUFJQTtJQUNoRCxNQUFNUyxZQUFZTCxhQUFhLENBQUNELFlBQVksSUFBSUE7SUFFaEQsSUFBSUssY0FBY0MsV0FBVyxPQUFPO0lBQ3BDLElBQUlELFVBQVVFLFFBQVEsQ0FBQ0QsY0FBY0EsVUFBVUMsUUFBUSxDQUFDRixZQUN0RCxPQUFPO0lBRVQsT0FBTztBQUNUIn0=