9fcf8867e5b3a252b5b290fb71f134b0
"use server";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    extractBeliefs: function() {
        return extractBeliefs;
    },
    generateKnowledgeEntries: function() {
        return generateKnowledgeEntries;
    },
    generateResponse: function() {
        return generateResponse;
    },
    saveLLMSettings: function() {
        return saveLLMSettings;
    },
    streamGenerateResponse: function() {
        return streamGenerateResponse;
    },
    validateApiKey: function() {
        return validateApiKey;
    },
    validateResponse: function() {
        return validateResponse;
    },
    withRetry: function() {
        return withRetry;
    }
});
const _ai = require("ai");
const _openai = require("@ai-sdk/openai");
const _debuglogger = require("./debug-logger");
const _utils = require("./utils");
const _llmerrors = require("./llm-errors");
const _llmsettings = require("./llm-settings");
// Types and configuration
const logger = (0, _debuglogger.createLogger)("LLM-SERVICE");
logger.info("[SERVER] llm-service.ts module loaded");
// Log the defaultSettings object to check for server references
logger.info("[SERVER] defaultSettings defined as:", {
    ..._llmsettings.defaultSettings,
    hasServerRef: "__server_ref" in _llmsettings.defaultSettings,
    keys: Object.keys(_llmsettings.defaultSettings),
    type: typeof _llmsettings.defaultSettings
});
async function withRetry(operation, maxRetries = 3, initialDelay = 1000) {
    let lastError = null;
    let delay = initialDelay;
    for(let attempt = 0; attempt <= maxRetries; attempt++){
        try {
            return await operation();
        } catch (error) {
            lastError = error instanceof Error ? error : new Error(String(error));
            console.error(`Operation failed (attempt ${attempt + 1}/${maxRetries + 1}):`, lastError);
            // Don't delay on the last attempt
            if (attempt < maxRetries) {
                console.log(`Retrying in ${delay}ms...`);
                await new Promise((resolve)=>setTimeout(resolve, delay));
                delay *= 2; // Exponential backoff
            }
        }
    }
    throw lastError || new Error("Operation failed with unknown error");
}
// Direct implementation for OpenRouter API
async function callOpenRouterAPI(apiKey, model, messages, temperature = _llmsettings.defaultSettings.temperature, max_tokens = _llmsettings.defaultSettings.maxTokens, top_p = _llmsettings.defaultSettings.topP, frequency_penalty = _llmsettings.defaultSettings.frequencyPenalty, presence_penalty = _llmsettings.defaultSettings.presencePenalty) {
    logger.info("[SERVER] Calling OpenRouter API with model:", model);
    logger.info("[SERVER] OpenRouter API key length:", apiKey.length);
    logger.info("[SERVER] OpenRouter API key first 5 chars:", apiKey.substring(0, 5));
    logger.info("[SERVER] OpenRouter parameters:", {
        temperature,
        max_tokens,
        top_p,
        frequency_penalty,
        presence_penalty
    });
    try {
        const requestBody = {
            model,
            messages,
            temperature,
            max_tokens,
            top_p,
            frequency_penalty,
            presence_penalty
        };
        logger.info("[SERVER] Request body:", JSON.stringify(requestBody));
        // Add timeout to the fetch request (60 seconds)
        const fetchPromise = fetch("https://openrouter.ai/api/v1/chat/completions", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${apiKey}`,
                "HTTP-Referer": "https://vercel.com",
                "X-Title": "Multi-agent UI Design Grid World"
            },
            body: JSON.stringify(requestBody)
        });
        const response = await (0, _llmerrors.withTimeout)(fetchPromise, 60000, "openrouter");
        if (!response.ok) {
            const errorText = await response.text();
            console.error("[SERVER] OpenRouter API error response:", errorText);
            console.error("[SERVER] Response status:", response.status, response.statusText);
            console.error("[SERVER] Request headers:", {
                "Content-Type": "application/json",
                Authorization: `Bearer ${apiKey.substring(0, 5)}...`,
                "HTTP-Referer": "https://vercel.com",
                "X-Title": "Multi-agent UI Design Grid World"
            });
            let errorData;
            try {
                errorData = JSON.parse(errorText);
            } catch (e) {
                errorData = {
                    error: {
                        message: errorText
                    }
                };
            }
            throw new _llmerrors.NetworkError(`OpenRouter API error: ${response.status} ${response.statusText}${errorData ? ` - ${JSON.stringify(errorData)}` : ""}`);
        }
        // Add timeout to the JSON parsing (5 seconds)
        const data = await response.json();
        return data.choices[0].message.content;
    } catch (error) {
        console.error("[SERVER] Error calling OpenRouter API:", error);
        throw error;
    }
}
async function generateResponse(userPrompt, systemPrompt, settings = {}) {
    try {
        // CRITICAL FIX: Add detailed logging for provider and API key
        (0, _debuglogger.debugLog)(`[LLM SERVICE] generateResponse called with provider: ${settings.provider}`);
        (0, _debuglogger.debugLog)(`[LLM SERVICE] API key available: ${!!settings.apiKey}, length: ${settings.apiKey?.length || 0}`);
        // Ensure provider is set
        if (!settings.provider) {
            (0, _debuglogger.debugLog)("[LLM SERVICE] No provider specified, defaulting to openai");
            settings.provider = "openai";
        }
        // Log the incoming settings to check for server references
        logger.info("[SERVER] generateResponse called with settings:", {
            ...settings,
            apiKey: settings.apiKey ? `[Length: ${settings.apiKey.length}]` : undefined,
            hasServerRef: "__server_ref" in settings,
            keys: Object.keys(settings)
        });
        // Ensure we have complete settings by merging with defaults
        const completeSettings = {
            ..._llmsettings.defaultSettings,
            ...settings
        };
        logger.info("[SERVER] completeSettings after merge:", {
            ...completeSettings,
            apiKey: completeSettings.apiKey ? `[Length: ${completeSettings.apiKey.length}]` : undefined,
            hasServerRef: "__server_ref" in completeSettings,
            keys: Object.keys(completeSettings)
        });
        logger.info("[SERVER] generateResponse called with settings:", {
            provider: completeSettings.provider,
            model: completeSettings.model,
            temperature: completeSettings.temperature,
            maxTokens: completeSettings.maxTokens,
            topP: completeSettings.topP,
            frequencyPenalty: completeSettings.frequencyPenalty,
            presencePenalty: completeSettings.presencePenalty,
            apiKeyLength: completeSettings.apiKey ? completeSettings.apiKey.length : 0
        });
        // Check if API key is available
        if (!completeSettings.apiKey) {
            throw new _llmerrors.ApiKeyError(completeSettings.provider);
        }
        // For OpenRouter, use our direct implementation
        if (completeSettings.provider === "openrouter") {
            logger.info("[SERVER] Using OpenRouter implementation");
            const messages = [];
            if (systemPrompt) {
                messages.push({
                    role: "system",
                    content: systemPrompt
                });
            }
            messages.push({
                role: "user",
                content: userPrompt
            });
            // Add retry logic for OpenRouter calls
            return await withRetry(()=>callOpenRouterAPI(completeSettings.apiKey, completeSettings.model, messages, completeSettings.temperature, completeSettings.maxTokens, completeSettings.topP, completeSettings.frequencyPenalty, completeSettings.presencePenalty), 2, 1000);
        } else if (completeSettings.provider === "openai") {
            logger.info("[SERVER] Using OpenAI implementation");
            // For OpenAI, use the AI SDK
            const openaiProvider = (0, _openai.createOpenAI)({
                apiKey: completeSettings.apiKey
            });
            const model = openaiProvider(completeSettings.model);
            // Add timeout to the OpenAI call
            const result = await (0, _llmerrors.withTimeout)((0, _ai.generateText)({
                model,
                system: systemPrompt,
                prompt: userPrompt,
                temperature: completeSettings.temperature,
                maxTokens: completeSettings.maxTokens,
                topP: completeSettings.topP,
                frequencyPenalty: completeSettings.frequencyPenalty,
                presencePenalty: completeSettings.presencePenalty
            }), 60000, "OpenAI API request timed out after 60 seconds");
            return result.text;
        } else {
            throw new _llmerrors.LLMError(`Unsupported provider: ${completeSettings.provider}`, "unknown");
        }
    } catch (error) {
        logger.error("[SERVER] Error in generateResponse:", error);
        throw error;
    }
}
async function* streamGenerateResponse(systemPrompt, userPrompt, settings) {
    try {
        logger.info("[SERVER] streamGenerateResponse function called");
        logger.info("[SERVER] streamGenerateResponse parameters:", {
            systemPromptLength: systemPrompt?.length,
            userPromptLength: userPrompt?.length,
            settingsProvider: settings?.provider,
            settingsModel: settings?.model
        });
        // Ensure we have complete settings by merging with defaults
        const completeSettings = {
            ..._llmsettings.defaultSettings,
            ...settings
        };
        logger.info("[SERVER] streamGenerateResponse called with settings:", {
            provider: completeSettings.provider,
            model: completeSettings.model,
            temperature: completeSettings.temperature,
            apiKeyLength: completeSettings.apiKey ? completeSettings.apiKey.length : 0
        });
        // Rest of the function...
        // Improved streaming response generation with better async iterable implementation
        // export async function* streamGenerateResponse(
        //   systemPrompt: string,
        //   userPrompt: string,
        //   settings: LLMSettings,
        // ): AsyncGenerator<ResponseChunk, void, unknown> {
        //   try {
        //     // Ensure we have complete settings by merging with defaults
        //     const completeSettings = { ...defaultSettings, ...settings }
        //     logger.info("[SERVER] streamGenerateResponse called with settings:", {
        //       provider: completeSettings.provider,
        //       model: completeSettings.model,
        //       temperature: completeSettings.temperature,
        //       apiKeyLength: completeSettings.apiKey ? completeSettings.apiKey.length : 0,
        //     })
        // Check if API key is available
        if (!completeSettings.apiKey) {
            yield {
                text: `Error: API key is required for ${completeSettings.provider} provider`,
                isComplete: true
            };
            return;
        }
        if (completeSettings.provider === "openai") {
            logger.info("[SERVER] Using OpenAI streaming implementation");
            try {
                const model = (0, _openai.openai)(completeSettings.model);
                // Use a fallback mechanism in case streaming fails
                let streamFailed = false;
                let fullText = "";
                try {
                    const stream = await (0, _ai.streamText)({
                        model,
                        system: systemPrompt,
                        prompt: userPrompt
                    });
                    for await (const chunk of stream.textStream){
                        fullText += chunk;
                        yield {
                            text: chunk,
                            isComplete: false
                        };
                    }
                } catch (streamError) {
                    console.error("[SERVER] Error in OpenAI streaming, falling back to non-streaming:", streamError);
                    streamFailed = true;
                }
                // If streaming failed, fall back to non-streaming
                if (streamFailed) {
                    const { text } = await (0, _ai.generateText)({
                        model,
                        system: systemPrompt,
                        prompt: userPrompt
                    });
                    yield {
                        text,
                        isComplete: false
                    };
                }
                yield {
                    text: "",
                    isComplete: true
                };
            } catch (error) {
                console.error("[SERVER] Error in OpenAI response generation:", error);
                yield {
                    text: `Error: ${error instanceof Error ? error.message : String(error)}`,
                    isComplete: true
                };
            }
        } else if (completeSettings.provider === "openrouter") {
            // For OpenRouter, implement streaming using their API
            logger.info("[SERVER] Using OpenRouter streaming implementation");
            try {
                const messages = [];
                if (systemPrompt) {
                    messages.push({
                        role: "system",
                        content: systemPrompt
                    });
                }
                messages.push({
                    role: "user",
                    content: userPrompt
                });
                // First try streaming
                let streamFailed = false;
                let fullResponse = "";
                try {
                    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${completeSettings.apiKey}`,
                            "HTTP-Referer": "https://vercel.com",
                            "X-Title": "Multi-agent UI Design Grid World"
                        },
                        body: JSON.stringify({
                            model: completeSettings.model,
                            messages,
                            temperature: completeSettings.temperature,
                            max_tokens: completeSettings.maxTokens,
                            top_p: completeSettings.topP,
                            frequency_penalty: completeSettings.frequencyPenalty,
                            presence_penalty: completeSettings.presencePenalty,
                            stream: true
                        })
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new _llmerrors.NetworkError(`OpenRouter API error: ${response.status} ${response.statusText} - ${errorText}`);
                    }
                    if (!response.body) {
                        throw new Error("Response body is null");
                    }
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder("utf-8");
                    let buffer = "";
                    try {
                        while(true){
                            const { done, value } = await reader.read();
                            if (done) break;
                            const chunk = decoder.decode(value, {
                                stream: true
                            });
                            buffer += chunk;
                            // Process complete lines from the buffer
                            let lineEnd = buffer.indexOf("\n");
                            while(lineEnd !== -1){
                                const line = buffer.substring(0, lineEnd).trim();
                                buffer = buffer.substring(lineEnd + 1);
                                if (line.startsWith("data: ")) {
                                    const data = line.slice(6);
                                    if (data === "[DONE]") continue;
                                    try {
                                        const parsed = JSON.parse(data);
                                        const content = parsed.choices[0]?.delta?.content || "";
                                        if (content) {
                                            fullResponse += content;
                                            yield {
                                                text: content,
                                                isComplete: false
                                            };
                                        }
                                    } catch (e) {
                                        console.error("Error parsing streaming response:", e);
                                    }
                                }
                                lineEnd = buffer.indexOf("\n");
                            }
                        }
                    } finally{
                        reader.releaseLock();
                    }
                } catch (streamError) {
                    console.error("[SERVER] Error in OpenRouter streaming, falling back to non-streaming:", streamError);
                    streamFailed = true;
                }
                // If streaming failed, fall back to non-streaming
                if (streamFailed) {
                    const nonStreamingResponse = await callOpenRouterAPI(completeSettings.apiKey, completeSettings.model, messages, completeSettings.temperature, completeSettings.maxTokens, completeSettings.topP, completeSettings.frequencyPenalty, completeSettings.presencePenalty);
                    yield {
                        text: nonStreamingResponse,
                        isComplete: false
                    };
                }
                yield {
                    text: "",
                    isComplete: true
                };
            } catch (error) {
                console.error("[SERVER] Error in OpenRouter response generation:", error);
                yield {
                    text: `Error: ${error instanceof Error ? error.message : String(error)}`,
                    isComplete: true
                };
            }
        } else {
            yield {
                text: `Error: Unsupported provider: ${completeSettings.provider}`,
                isComplete: true
            };
        }
    } catch (error) {
        console.error("[SERVER] Error in streamGenerateResponse:", error);
        yield {
            text: `Error: ${error instanceof Error ? error.message : String(error)}`,
            isComplete: true
        };
    }
}
async function validateResponse(response) {
    // Basic validation to ensure response meets quality standards
    if (!response || response.trim().length === 0) {
        return {
            valid: false,
            reason: "Empty response"
        };
    }
    // Check for error messages that might have leaked into the response
    if (response.toLowerCase().includes("error") && (response.toLowerCase().includes("api") || response.toLowerCase().includes("key"))) {
        return {
            valid: false,
            reason: "Response contains error messages"
        };
    }
    // Check for minimum length (adjust as needed)
    if (response.length < 10) {
        return {
            valid: false,
            reason: "Response too short"
        };
    }
    return {
        valid: true
    };
}
async function extractBeliefs(conversationText, agentName, extractionPriorities, settings) {
    try {
        logger.info("[SERVER] extractBeliefs called with priorities:", extractionPriorities);
        // Create a prompt using the belief extraction template
        const systemPrompt = `You are an AI assistant that analyzes conversations and extracts potential new knowledge or beliefs.
Your task is to identify information, facts, or beliefs that should be added to an agent's knowledge base.
Focus on extracting factual information, preferences, opinions, and relationships mentioned in the conversation.

IMPORTANT: Format your response using Obsidian-style markdown. Use [[double brackets]] around important concepts, entities, and categories that should be tagged.`;
        const userPrompt = `The following is a conversation involving ${agentName}.
Extract potential new knowledge or beliefs that ${agentName} should remember from this conversation.
Pay special attention to: ${extractionPriorities}

CONVERSATION:
${conversationText}

List the extracted beliefs in bullet points. Each belief should be a concise statement of fact or opinion.
For each belief:
1. Use [[double brackets]] around key concepts that should be tagged
2. Indicate the confidence level (High/Medium/Low) based on how explicitly it was stated
3. Format the belief as a complete, well-structured markdown note

Example format:
- ${agentName} believes that [[quantum computing]] will revolutionize [[cryptography]] within the next decade. (High)
- ${agentName} seems to prefer [[coffee]] over [[tea]] based on their ordering habits. (Medium)`;
        // Call the LLM service to generate a response
        return await generateResponse(userPrompt, systemPrompt, settings);
    } catch (error) {
        console.error("[SERVER] Error in extractBeliefs:", error);
        throw error;
    }
}
async function generateKnowledgeEntries(beliefs, settings) {
    try {
        logger.info("[SERVER] generateKnowledgeEntries called");
        // Parse the beliefs string to extract individual beliefs
        const beliefLines = beliefs.split("\n").filter((line)=>line.trim().startsWith("-")).map((line)=>line.trim().substring(1).trim());
        // Create knowledge entries from the beliefs
        return beliefLines.map((belief)=>{
            // Extract tags using the existing utility
            const tags = (0, _utils.extractTagsFromMarkdown)(belief);
            // Generate a title based on the first tag or the first few words
            const title = tags.length > 0 ? `Knowledge about ${tags[0]}` : belief.split(" ").slice(0, 3).join(" ");
            return {
                id: `knowledge-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
                title,
                content: belief,
                timestamp: new Date(),
                tags
            };
        });
    } catch (error) {
        console.error("[SERVER] Error in generateKnowledgeEntries:", error);
        return [
            {
                id: `error-${Date.now()}`,
                title: "Error",
                content: error instanceof Error ? error.message : "Unknown error",
                timestamp: new Date(),
                tags: [
                    "error"
                ]
            }
        ];
    }
}
async function validateApiKey(provider, apiKey) {
    logger.info("[SERVER] validateApiKey called (mock implementation)");
    return {
        valid: true,
        message: `API key validation successful for ${provider}. (This is a mock)`
    };
}
async function saveLLMSettings(settings) {
    logger.info("[SERVER] saveLLMSettings called");
    logger.info("[SERVER] Saving settings:", {
        ...settings,
        apiKey: settings.apiKey ? `[Length: ${settings.apiKey.length}]` : undefined,
        provider: settings.provider
    });
    try {
        // In a real app, we would save to a database here
        // For now, we'll just return true to indicate success
        // The client-side code will handle saving to localStorage
        return true;
    } catch (error) {
        console.error("[SERVER] Error saving settings:", error);
        return false;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3bW9yb25leS9idWlsZHMvRnJlZUFnZW50aWNzL3dlYi9saWIvbGxtLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc2VydmVyXCI7XG5cbmltcG9ydCB7IHN0cmVhbVRleHQsIGdlbmVyYXRlVGV4dCB9IGZyb20gXCJhaVwiO1xuaW1wb3J0IHsgb3BlbmFpIH0gZnJvbSBcIkBhaS1zZGsvb3BlbmFpXCI7XG5pbXBvcnQgeyBub3RGb3VuZCB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmltcG9ydCB0eXBlIHsgS25vd2xlZGdlRW50cnkgfSBmcm9tIFwiQC9saWIvdHlwZXNcIjtcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciB9IGZyb20gXCJAL2xpYi9kZWJ1Zy1sb2dnZXJcIjtcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIkAvbGliL2RlYnVnLWxvZ2dlclwiO1xuaW1wb3J0IHsgZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24gfSBmcm9tIFwiQC9saWIvdXRpbHNcIjtcbmltcG9ydCB7XG4gIExMTUVycm9yLFxuICBBcGlLZXlFcnJvcixcbiAgVGltZW91dEVycm9yLFxuICBOZXR3b3JrRXJyb3IsXG4gIHdpdGhUaW1lb3V0LFxufSBmcm9tIFwiQC9saWIvbGxtLWVycm9yc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFNldHRpbmdzLCB0eXBlIExMTVNldHRpbmdzIH0gZnJvbSBcIkAvbGliL2xsbS1zZXR0aW5nc1wiO1xuaW1wb3J0IHsgY3JlYXRlT3BlbkFJIH0gZnJvbSBcIkBhaS1zZGsvb3BlbmFpXCI7XG5cbi8vIFR5cGVzIGFuZCBjb25maWd1cmF0aW9uXG5jb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJMTE0tU0VSVklDRVwiKTtcblxubG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBsbG0tc2VydmljZS50cyBtb2R1bGUgbG9hZGVkXCIpO1xuXG4vLyBBZGQgdGhpcyBpbnRlcmZhY2UgZm9yIHN0cmVhbWluZyByZXNwb25zZSBjaHVua3NcbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtQ2h1bmsge1xuICB0ZXh0OiBzdHJpbmc7XG4gIGlzQ29tcGxldGU6IGJvb2xlYW47XG59XG5cbi8vIExvZyB0aGUgZGVmYXVsdFNldHRpbmdzIG9iamVjdCB0byBjaGVjayBmb3Igc2VydmVyIHJlZmVyZW5jZXNcbmxvZ2dlci5pbmZvKFwiW1NFUlZFUl0gZGVmYXVsdFNldHRpbmdzIGRlZmluZWQgYXM6XCIsIHtcbiAgLi4uZGVmYXVsdFNldHRpbmdzLFxuICBoYXNTZXJ2ZXJSZWY6IFwiX19zZXJ2ZXJfcmVmXCIgaW4gZGVmYXVsdFNldHRpbmdzLFxuICBrZXlzOiBPYmplY3Qua2V5cyhkZWZhdWx0U2V0dGluZ3MpLFxuICB0eXBlOiB0eXBlb2YgZGVmYXVsdFNldHRpbmdzLFxufSk7XG5cbi8vIEFkZCB0aGlzIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoUmV0cnk8VD4oXG4gIG9wZXJhdGlvbjogKCkgPT4gUHJvbWlzZTxUPixcbiAgbWF4UmV0cmllcyA9IDMsXG4gIGluaXRpYWxEZWxheSA9IDEwMDAsXG4pOiBQcm9taXNlPFQ+IHtcbiAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgbGV0IGRlbGF5ID0gaW5pdGlhbERlbGF5O1xuXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDw9IG1heFJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgb3BlcmF0aW9uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBPcGVyYXRpb24gZmFpbGVkIChhdHRlbXB0ICR7YXR0ZW1wdCArIDF9LyR7bWF4UmV0cmllcyArIDF9KTpgLFxuICAgICAgICBsYXN0RXJyb3IsXG4gICAgICApO1xuXG4gICAgICAvLyBEb24ndCBkZWxheSBvbiB0aGUgbGFzdCBhdHRlbXB0XG4gICAgICBpZiAoYXR0ZW1wdCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFJldHJ5aW5nIGluICR7ZGVsYXl9bXMuLi5gKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgZGVsYXkgKj0gMjsgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IGxhc3RFcnJvciB8fCBuZXcgRXJyb3IoXCJPcGVyYXRpb24gZmFpbGVkIHdpdGggdW5rbm93biBlcnJvclwiKTtcbn1cblxuLy8gRGlyZWN0IGltcGxlbWVudGF0aW9uIGZvciBPcGVuUm91dGVyIEFQSVxuYXN5bmMgZnVuY3Rpb24gY2FsbE9wZW5Sb3V0ZXJBUEkoXG4gIGFwaUtleTogc3RyaW5nLFxuICBtb2RlbDogc3RyaW5nLFxuICBtZXNzYWdlczogQXJyYXk8eyByb2xlOiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZyB9PixcbiAgdGVtcGVyYXR1cmU6IG51bWJlciA9IGRlZmF1bHRTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgbWF4X3Rva2VuczogbnVtYmVyID0gZGVmYXVsdFNldHRpbmdzLm1heFRva2VucyxcbiAgdG9wX3A6IG51bWJlciA9IGRlZmF1bHRTZXR0aW5ncy50b3BQLFxuICBmcmVxdWVuY3lfcGVuYWx0eTogbnVtYmVyID0gZGVmYXVsdFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gIHByZXNlbmNlX3BlbmFsdHk6IG51bWJlciA9IGRlZmF1bHRTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4pIHtcbiAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBDYWxsaW5nIE9wZW5Sb3V0ZXIgQVBJIHdpdGggbW9kZWw6XCIsIG1vZGVsKTtcbiAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBPcGVuUm91dGVyIEFQSSBrZXkgbGVuZ3RoOlwiLCBhcGlLZXkubGVuZ3RoKTtcbiAgbG9nZ2VyLmluZm8oXG4gICAgXCJbU0VSVkVSXSBPcGVuUm91dGVyIEFQSSBrZXkgZmlyc3QgNSBjaGFyczpcIixcbiAgICBhcGlLZXkuc3Vic3RyaW5nKDAsIDUpLFxuICApO1xuICBsb2dnZXIuaW5mbyhcIltTRVJWRVJdIE9wZW5Sb3V0ZXIgcGFyYW1ldGVyczpcIiwge1xuICAgIHRlbXBlcmF0dXJlLFxuICAgIG1heF90b2tlbnMsXG4gICAgdG9wX3AsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHksXG4gICAgcHJlc2VuY2VfcGVuYWx0eSxcbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgIG1vZGVsLFxuICAgICAgbWVzc2FnZXMsXG4gICAgICB0ZW1wZXJhdHVyZSxcbiAgICAgIG1heF90b2tlbnMsXG4gICAgICB0b3BfcCxcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5LFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eSxcbiAgICB9O1xuXG4gICAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBSZXF1ZXN0IGJvZHk6XCIsIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSk7XG5cbiAgICAvLyBBZGQgdGltZW91dCB0byB0aGUgZmV0Y2ggcmVxdWVzdCAoNjAgc2Vjb25kcylcbiAgICBjb25zdCBmZXRjaFByb21pc2UgPSBmZXRjaChcbiAgICAgIFwiaHR0cHM6Ly9vcGVucm91dGVyLmFpL2FwaS92MS9jaGF0L2NvbXBsZXRpb25zXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXBpS2V5fWAsXG4gICAgICAgICAgXCJIVFRQLVJlZmVyZXJcIjogXCJodHRwczovL3ZlcmNlbC5jb21cIixcbiAgICAgICAgICBcIlgtVGl0bGVcIjogXCJNdWx0aS1hZ2VudCBVSSBEZXNpZ24gR3JpZCBXb3JsZFwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpdGhUaW1lb3V0KGZldGNoUHJvbWlzZSwgNjAwMDAsIFwib3BlbnJvdXRlclwiKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbU0VSVkVSXSBPcGVuUm91dGVyIEFQSSBlcnJvciByZXNwb25zZTpcIiwgZXJyb3JUZXh0KTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiW1NFUlZFUl0gUmVzcG9uc2Ugc3RhdHVzOlwiLFxuICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICApO1xuICAgICAgY29uc29sZS5lcnJvcihcIltTRVJWRVJdIFJlcXVlc3QgaGVhZGVyczpcIiwge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FwaUtleS5zdWJzdHJpbmcoMCwgNSl9Li4uYCxcbiAgICAgICAgXCJIVFRQLVJlZmVyZXJcIjogXCJodHRwczovL3ZlcmNlbC5jb21cIixcbiAgICAgICAgXCJYLVRpdGxlXCI6IFwiTXVsdGktYWdlbnQgVUkgRGVzaWduIEdyaWQgV29ybGRcIixcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JEYXRhID0gSlNPTi5wYXJzZShlcnJvclRleHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvckRhdGEgPSB7IGVycm9yOiB7IG1lc3NhZ2U6IGVycm9yVGV4dCB9IH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBPcGVuUm91dGVyIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0ke1xuICAgICAgICAgIGVycm9yRGF0YSA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yRGF0YSl9YCA6IFwiXCJcbiAgICAgICAgfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aW1lb3V0IHRvIHRoZSBKU09OIHBhcnNpbmcgKDUgc2Vjb25kcylcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgcmV0dXJuIGRhdGEuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltTRVJWRVJdIEVycm9yIGNhbGxpbmcgT3BlblJvdXRlciBBUEk6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBHZW5lcmF0ZSBhIHJlc3BvbnNlIHVzaW5nIGEgc3lzdGVtIHByb21wdFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUmVzcG9uc2UoXG4gIHVzZXJQcm9tcHQ6IHN0cmluZyxcbiAgc3lzdGVtUHJvbXB0OiBzdHJpbmcsXG4gIHNldHRpbmdzOiBQYXJ0aWFsPExMTVNldHRpbmdzPiA9IHt9LFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICAvLyBDUklUSUNBTCBGSVg6IEFkZCBkZXRhaWxlZCBsb2dnaW5nIGZvciBwcm92aWRlciBhbmQgQVBJIGtleVxuICAgIGRlYnVnTG9nKFxuICAgICAgYFtMTE0gU0VSVklDRV0gZ2VuZXJhdGVSZXNwb25zZSBjYWxsZWQgd2l0aCBwcm92aWRlcjogJHtzZXR0aW5ncy5wcm92aWRlcn1gLFxuICAgICk7XG4gICAgZGVidWdMb2coXG4gICAgICBgW0xMTSBTRVJWSUNFXSBBUEkga2V5IGF2YWlsYWJsZTogJHshIXNldHRpbmdzLmFwaUtleX0sIGxlbmd0aDogJHtzZXR0aW5ncy5hcGlLZXk/Lmxlbmd0aCB8fCAwfWAsXG4gICAgKTtcblxuICAgIC8vIEVuc3VyZSBwcm92aWRlciBpcyBzZXRcbiAgICBpZiAoIXNldHRpbmdzLnByb3ZpZGVyKSB7XG4gICAgICBkZWJ1Z0xvZyhcIltMTE0gU0VSVklDRV0gTm8gcHJvdmlkZXIgc3BlY2lmaWVkLCBkZWZhdWx0aW5nIHRvIG9wZW5haVwiKTtcbiAgICAgIHNldHRpbmdzLnByb3ZpZGVyID0gXCJvcGVuYWlcIjtcbiAgICB9XG5cbiAgICAvLyBMb2cgdGhlIGluY29taW5nIHNldHRpbmdzIHRvIGNoZWNrIGZvciBzZXJ2ZXIgcmVmZXJlbmNlc1xuICAgIGxvZ2dlci5pbmZvKFwiW1NFUlZFUl0gZ2VuZXJhdGVSZXNwb25zZSBjYWxsZWQgd2l0aCBzZXR0aW5nczpcIiwge1xuICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICBhcGlLZXk6IHNldHRpbmdzLmFwaUtleVxuICAgICAgICA/IGBbTGVuZ3RoOiAke3NldHRpbmdzLmFwaUtleS5sZW5ndGh9XWBcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBoYXNTZXJ2ZXJSZWY6IFwiX19zZXJ2ZXJfcmVmXCIgaW4gc2V0dGluZ3MsXG4gICAgICBrZXlzOiBPYmplY3Qua2V5cyhzZXR0aW5ncyksXG4gICAgfSk7XG5cbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBjb21wbGV0ZSBzZXR0aW5ncyBieSBtZXJnaW5nIHdpdGggZGVmYXVsdHNcbiAgICBjb25zdCBjb21wbGV0ZVNldHRpbmdzID0geyAuLi5kZWZhdWx0U2V0dGluZ3MsIC4uLnNldHRpbmdzIH07XG5cbiAgICBsb2dnZXIuaW5mbyhcIltTRVJWRVJdIGNvbXBsZXRlU2V0dGluZ3MgYWZ0ZXIgbWVyZ2U6XCIsIHtcbiAgICAgIC4uLmNvbXBsZXRlU2V0dGluZ3MsXG4gICAgICBhcGlLZXk6IGNvbXBsZXRlU2V0dGluZ3MuYXBpS2V5XG4gICAgICAgID8gYFtMZW5ndGg6ICR7Y29tcGxldGVTZXR0aW5ncy5hcGlLZXkubGVuZ3RofV1gXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgaGFzU2VydmVyUmVmOiBcIl9fc2VydmVyX3JlZlwiIGluIGNvbXBsZXRlU2V0dGluZ3MsXG4gICAgICBrZXlzOiBPYmplY3Qua2V5cyhjb21wbGV0ZVNldHRpbmdzKSxcbiAgICB9KTtcblxuICAgIGxvZ2dlci5pbmZvKFwiW1NFUlZFUl0gZ2VuZXJhdGVSZXNwb25zZSBjYWxsZWQgd2l0aCBzZXR0aW5nczpcIiwge1xuICAgICAgcHJvdmlkZXI6IGNvbXBsZXRlU2V0dGluZ3MucHJvdmlkZXIsXG4gICAgICBtb2RlbDogY29tcGxldGVTZXR0aW5ncy5tb2RlbCxcbiAgICAgIHRlbXBlcmF0dXJlOiBjb21wbGV0ZVNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgbWF4VG9rZW5zOiBjb21wbGV0ZVNldHRpbmdzLm1heFRva2VucyxcbiAgICAgIHRvcFA6IGNvbXBsZXRlU2V0dGluZ3MudG9wUCxcbiAgICAgIGZyZXF1ZW5jeVBlbmFsdHk6IGNvbXBsZXRlU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgIHByZXNlbmNlUGVuYWx0eTogY29tcGxldGVTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICBhcGlLZXlMZW5ndGg6IGNvbXBsZXRlU2V0dGluZ3MuYXBpS2V5XG4gICAgICAgID8gY29tcGxldGVTZXR0aW5ncy5hcGlLZXkubGVuZ3RoXG4gICAgICAgIDogMCxcbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGlmIEFQSSBrZXkgaXMgYXZhaWxhYmxlXG4gICAgaWYgKCFjb21wbGV0ZVNldHRpbmdzLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUtleUVycm9yKGNvbXBsZXRlU2V0dGluZ3MucHJvdmlkZXIpO1xuICAgIH1cblxuICAgIC8vIEZvciBPcGVuUm91dGVyLCB1c2Ugb3VyIGRpcmVjdCBpbXBsZW1lbnRhdGlvblxuICAgIGlmIChjb21wbGV0ZVNldHRpbmdzLnByb3ZpZGVyID09PSBcIm9wZW5yb3V0ZXJcIikge1xuICAgICAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBVc2luZyBPcGVuUm91dGVyIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgY29uc3QgbWVzc2FnZXM6IEFycmF5PHsgcm9sZTogc3RyaW5nOyBjb250ZW50OiBzdHJpbmcgfT4gPSBbXTtcbiAgICAgIGlmIChzeXN0ZW1Qcm9tcHQpIHtcbiAgICAgICAgbWVzc2FnZXMucHVzaCh7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHN5c3RlbVByb21wdCB9KTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogdXNlclByb21wdCB9KTtcblxuICAgICAgLy8gQWRkIHJldHJ5IGxvZ2ljIGZvciBPcGVuUm91dGVyIGNhbGxzXG4gICAgICByZXR1cm4gYXdhaXQgd2l0aFJldHJ5KFxuICAgICAgICAoKSA9PlxuICAgICAgICAgIGNhbGxPcGVuUm91dGVyQVBJKFxuICAgICAgICAgICAgY29tcGxldGVTZXR0aW5ncy5hcGlLZXkhLFxuICAgICAgICAgICAgY29tcGxldGVTZXR0aW5ncy5tb2RlbCxcbiAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgY29tcGxldGVTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgIGNvbXBsZXRlU2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgY29tcGxldGVTZXR0aW5ncy50b3BQLFxuICAgICAgICAgICAgY29tcGxldGVTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgY29tcGxldGVTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgKSxcbiAgICAgICAgMiwgLy8gTWF4IDIgcmV0cmllc1xuICAgICAgICAxMDAwLCAvLyBJbml0aWFsIGRlbGF5IG9mIDEgc2Vjb25kXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29tcGxldGVTZXR0aW5ncy5wcm92aWRlciA9PT0gXCJvcGVuYWlcIikge1xuICAgICAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBVc2luZyBPcGVuQUkgaW1wbGVtZW50YXRpb25cIik7XG4gICAgICAvLyBGb3IgT3BlbkFJLCB1c2UgdGhlIEFJIFNES1xuICAgICAgY29uc3Qgb3BlbmFpUHJvdmlkZXIgPSBjcmVhdGVPcGVuQUkoe1xuICAgICAgICBhcGlLZXk6IGNvbXBsZXRlU2V0dGluZ3MuYXBpS2V5LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2RlbCA9IG9wZW5haVByb3ZpZGVyKGNvbXBsZXRlU2V0dGluZ3MubW9kZWwpO1xuXG4gICAgICAvLyBBZGQgdGltZW91dCB0byB0aGUgT3BlbkFJIGNhbGxcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpdGhUaW1lb3V0KFxuICAgICAgICBnZW5lcmF0ZVRleHQoe1xuICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgIHN5c3RlbTogc3lzdGVtUHJvbXB0LFxuICAgICAgICAgIHByb21wdDogdXNlclByb21wdCxcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogY29tcGxldGVTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICBtYXhUb2tlbnM6IGNvbXBsZXRlU2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgIHRvcFA6IGNvbXBsZXRlU2V0dGluZ3MudG9wUCxcbiAgICAgICAgICBmcmVxdWVuY3lQZW5hbHR5OiBjb21wbGV0ZVNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgcHJlc2VuY2VQZW5hbHR5OiBjb21wbGV0ZVNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgfSksXG4gICAgICAgIDYwMDAwLFxuICAgICAgICBcIk9wZW5BSSBBUEkgcmVxdWVzdCB0aW1lZCBvdXQgYWZ0ZXIgNjAgc2Vjb25kc1wiLFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdC50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgTExNRXJyb3IoXG4gICAgICAgIGBVbnN1cHBvcnRlZCBwcm92aWRlcjogJHtjb21wbGV0ZVNldHRpbmdzLnByb3ZpZGVyfWAsXG4gICAgICAgIFwidW5rbm93blwiLFxuICAgICAgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKFwiW1NFUlZFUl0gRXJyb3IgaW4gZ2VuZXJhdGVSZXNwb25zZTpcIiwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIEFkZCBtb3JlIGRldGFpbGVkIGxvZ2dpbmcgdG8gc3RyZWFtR2VuZXJhdGVSZXNwb25zZSBmdW5jdGlvblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1HZW5lcmF0ZVJlc3BvbnNlKFxuICBzeXN0ZW1Qcm9tcHQ6IHN0cmluZyxcbiAgdXNlclByb21wdDogc3RyaW5nLFxuICBzZXR0aW5nczogTExNU2V0dGluZ3MsXG4pOiBBc3luY0dlbmVyYXRvcjxTdHJlYW1DaHVuaywgdm9pZCwgdW5rbm93bj4ge1xuICB0cnkge1xuICAgIGxvZ2dlci5pbmZvKFwiW1NFUlZFUl0gc3RyZWFtR2VuZXJhdGVSZXNwb25zZSBmdW5jdGlvbiBjYWxsZWRcIik7XG4gICAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBzdHJlYW1HZW5lcmF0ZVJlc3BvbnNlIHBhcmFtZXRlcnM6XCIsIHtcbiAgICAgIHN5c3RlbVByb21wdExlbmd0aDogc3lzdGVtUHJvbXB0Py5sZW5ndGgsXG4gICAgICB1c2VyUHJvbXB0TGVuZ3RoOiB1c2VyUHJvbXB0Py5sZW5ndGgsXG4gICAgICBzZXR0aW5nc1Byb3ZpZGVyOiBzZXR0aW5ncz8ucHJvdmlkZXIsXG4gICAgICBzZXR0aW5nc01vZGVsOiBzZXR0aW5ncz8ubW9kZWwsXG4gICAgfSk7XG5cbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBjb21wbGV0ZSBzZXR0aW5ncyBieSBtZXJnaW5nIHdpdGggZGVmYXVsdHNcbiAgICBjb25zdCBjb21wbGV0ZVNldHRpbmdzID0geyAuLi5kZWZhdWx0U2V0dGluZ3MsIC4uLnNldHRpbmdzIH07XG5cbiAgICBsb2dnZXIuaW5mbyhcIltTRVJWRVJdIHN0cmVhbUdlbmVyYXRlUmVzcG9uc2UgY2FsbGVkIHdpdGggc2V0dGluZ3M6XCIsIHtcbiAgICAgIHByb3ZpZGVyOiBjb21wbGV0ZVNldHRpbmdzLnByb3ZpZGVyLFxuICAgICAgbW9kZWw6IGNvbXBsZXRlU2V0dGluZ3MubW9kZWwsXG4gICAgICB0ZW1wZXJhdHVyZTogY29tcGxldGVTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgIGFwaUtleUxlbmd0aDogY29tcGxldGVTZXR0aW5ncy5hcGlLZXlcbiAgICAgICAgPyBjb21wbGV0ZVNldHRpbmdzLmFwaUtleS5sZW5ndGhcbiAgICAgICAgOiAwLFxuICAgIH0pO1xuXG4gICAgLy8gUmVzdCBvZiB0aGUgZnVuY3Rpb24uLi5cbiAgICAvLyBJbXByb3ZlZCBzdHJlYW1pbmcgcmVzcG9uc2UgZ2VuZXJhdGlvbiB3aXRoIGJldHRlciBhc3luYyBpdGVyYWJsZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vIGV4cG9ydCBhc3luYyBmdW5jdGlvbiogc3RyZWFtR2VuZXJhdGVSZXNwb25zZShcbiAgICAvLyAgIHN5c3RlbVByb21wdDogc3RyaW5nLFxuICAgIC8vICAgdXNlclByb21wdDogc3RyaW5nLFxuICAgIC8vICAgc2V0dGluZ3M6IExMTVNldHRpbmdzLFxuICAgIC8vICk6IEFzeW5jR2VuZXJhdG9yPFJlc3BvbnNlQ2h1bmssIHZvaWQsIHVua25vd24+IHtcbiAgICAvLyAgIHRyeSB7XG4gICAgLy8gICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGNvbXBsZXRlIHNldHRpbmdzIGJ5IG1lcmdpbmcgd2l0aCBkZWZhdWx0c1xuICAgIC8vICAgICBjb25zdCBjb21wbGV0ZVNldHRpbmdzID0geyAuLi5kZWZhdWx0U2V0dGluZ3MsIC4uLnNldHRpbmdzIH1cblxuICAgIC8vICAgICBsb2dnZXIuaW5mbyhcIltTRVJWRVJdIHN0cmVhbUdlbmVyYXRlUmVzcG9uc2UgY2FsbGVkIHdpdGggc2V0dGluZ3M6XCIsIHtcbiAgICAvLyAgICAgICBwcm92aWRlcjogY29tcGxldGVTZXR0aW5ncy5wcm92aWRlcixcbiAgICAvLyAgICAgICBtb2RlbDogY29tcGxldGVTZXR0aW5ncy5tb2RlbCxcbiAgICAvLyAgICAgICB0ZW1wZXJhdHVyZTogY29tcGxldGVTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAvLyAgICAgICBhcGlLZXlMZW5ndGg6IGNvbXBsZXRlU2V0dGluZ3MuYXBpS2V5ID8gY29tcGxldGVTZXR0aW5ncy5hcGlLZXkubGVuZ3RoIDogMCxcbiAgICAvLyAgICAgfSlcblxuICAgIC8vIENoZWNrIGlmIEFQSSBrZXkgaXMgYXZhaWxhYmxlXG4gICAgaWYgKCFjb21wbGV0ZVNldHRpbmdzLmFwaUtleSkge1xuICAgICAgeWllbGQge1xuICAgICAgICB0ZXh0OiBgRXJyb3I6IEFQSSBrZXkgaXMgcmVxdWlyZWQgZm9yICR7Y29tcGxldGVTZXR0aW5ncy5wcm92aWRlcn0gcHJvdmlkZXJgLFxuICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29tcGxldGVTZXR0aW5ncy5wcm92aWRlciA9PT0gXCJvcGVuYWlcIikge1xuICAgICAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBVc2luZyBPcGVuQUkgc3RyZWFtaW5nIGltcGxlbWVudGF0aW9uXCIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IG9wZW5haShjb21wbGV0ZVNldHRpbmdzLm1vZGVsIGFzIGFueSk7XG5cbiAgICAgICAgLy8gVXNlIGEgZmFsbGJhY2sgbWVjaGFuaXNtIGluIGNhc2Ugc3RyZWFtaW5nIGZhaWxzXG4gICAgICAgIGxldCBzdHJlYW1GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZ1bGxUZXh0ID0gXCJcIjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHN0cmVhbVRleHQoe1xuICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICBzeXN0ZW06IHN5c3RlbVByb21wdCxcbiAgICAgICAgICAgIHByb21wdDogdXNlclByb21wdCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtLnRleHRTdHJlYW0pIHtcbiAgICAgICAgICAgIGZ1bGxUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICB0ZXh0OiBjaHVuayxcbiAgICAgICAgICAgICAgaXNDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoc3RyZWFtRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJbU0VSVkVSXSBFcnJvciBpbiBPcGVuQUkgc3RyZWFtaW5nLCBmYWxsaW5nIGJhY2sgdG8gbm9uLXN0cmVhbWluZzpcIixcbiAgICAgICAgICAgIHN0cmVhbUVycm9yLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc3RyZWFtRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHN0cmVhbWluZyBmYWlsZWQsIGZhbGwgYmFjayB0byBub24tc3RyZWFtaW5nXG4gICAgICAgIGlmIChzdHJlYW1GYWlsZWQpIHtcbiAgICAgICAgICBjb25zdCB7IHRleHQgfSA9IGF3YWl0IGdlbmVyYXRlVGV4dCh7XG4gICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgIHN5c3RlbTogc3lzdGVtUHJvbXB0LFxuICAgICAgICAgICAgcHJvbXB0OiB1c2VyUHJvbXB0LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGlzQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIltTRVJWRVJdIEVycm9yIGluIE9wZW5BSSByZXNwb25zZSBnZW5lcmF0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICB0ZXh0OiBgRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWAsXG4gICAgICAgICAgaXNDb21wbGV0ZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbXBsZXRlU2V0dGluZ3MucHJvdmlkZXIgPT09IFwib3BlbnJvdXRlclwiKSB7XG4gICAgICAvLyBGb3IgT3BlblJvdXRlciwgaW1wbGVtZW50IHN0cmVhbWluZyB1c2luZyB0aGVpciBBUElcbiAgICAgIGxvZ2dlci5pbmZvKFwiW1NFUlZFUl0gVXNpbmcgT3BlblJvdXRlciBzdHJlYW1pbmcgaW1wbGVtZW50YXRpb25cIik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgICAgIGlmIChzeXN0ZW1Qcm9tcHQpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogc3lzdGVtUHJvbXB0IH0pO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogdXNlclByb21wdCB9KTtcblxuICAgICAgICAvLyBGaXJzdCB0cnkgc3RyZWFtaW5nXG4gICAgICAgIGxldCBzdHJlYW1GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZ1bGxSZXNwb25zZSA9IFwiXCI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICAgICAgXCJodHRwczovL29wZW5yb3V0ZXIuYWkvYXBpL3YxL2NoYXQvY29tcGxldGlvbnNcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjb21wbGV0ZVNldHRpbmdzLmFwaUtleX1gLFxuICAgICAgICAgICAgICAgIFwiSFRUUC1SZWZlcmVyXCI6IFwiaHR0cHM6Ly92ZXJjZWwuY29tXCIsXG4gICAgICAgICAgICAgICAgXCJYLVRpdGxlXCI6IFwiTXVsdGktYWdlbnQgVUkgRGVzaWduIEdyaWQgV29ybGRcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiBjb21wbGV0ZVNldHRpbmdzLm1vZGVsLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBjb21wbGV0ZVNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIG1heF90b2tlbnM6IGNvbXBsZXRlU2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIHRvcF9wOiBjb21wbGV0ZVNldHRpbmdzLnRvcFAsXG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5X3BlbmFsdHk6IGNvbXBsZXRlU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBwcmVzZW5jZV9wZW5hbHR5OiBjb21wbGV0ZVNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBzdHJlYW06IHRydWUsIC8vIEVuYWJsZSBzdHJlYW1pbmdcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICAgICAgICBgT3BlblJvdXRlciBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtlcnJvclRleHR9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBib2R5IGlzIG51bGxcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gICAgICAgICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICBidWZmZXIgKz0gY2h1bms7XG5cbiAgICAgICAgICAgICAgLy8gUHJvY2VzcyBjb21wbGV0ZSBsaW5lcyBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgbGV0IGxpbmVFbmQgPSBidWZmZXIuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgICAgd2hpbGUgKGxpbmVFbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGJ1ZmZlci5zdWJzdHJpbmcoMCwgbGluZUVuZCkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHJpbmcobGluZUVuZCArIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcImRhdGE6IFwiKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxpbmUuc2xpY2UoNik7XG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gXCJbRE9ORV1cIikgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZWQuY2hvaWNlc1swXT8uZGVsdGE/LmNvbnRlbnQgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmdWxsUmVzcG9uc2UgKz0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBzdHJlYW1pbmcgcmVzcG9uc2U6XCIsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmVFbmQgPSBidWZmZXIuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHN0cmVhbUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiW1NFUlZFUl0gRXJyb3IgaW4gT3BlblJvdXRlciBzdHJlYW1pbmcsIGZhbGxpbmcgYmFjayB0byBub24tc3RyZWFtaW5nOlwiLFxuICAgICAgICAgICAgc3RyZWFtRXJyb3IsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdHJlYW1GYWlsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgc3RyZWFtaW5nIGZhaWxlZCwgZmFsbCBiYWNrIHRvIG5vbi1zdHJlYW1pbmdcbiAgICAgICAgaWYgKHN0cmVhbUZhaWxlZCkge1xuICAgICAgICAgIGNvbnN0IG5vblN0cmVhbWluZ1Jlc3BvbnNlID0gYXdhaXQgY2FsbE9wZW5Sb3V0ZXJBUEkoXG4gICAgICAgICAgICBjb21wbGV0ZVNldHRpbmdzLmFwaUtleSxcbiAgICAgICAgICAgIGNvbXBsZXRlU2V0dGluZ3MubW9kZWwsXG4gICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgIGNvbXBsZXRlU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICBjb21wbGV0ZVNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgIGNvbXBsZXRlU2V0dGluZ3MudG9wUCxcbiAgICAgICAgICAgIGNvbXBsZXRlU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgIGNvbXBsZXRlU2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICB0ZXh0OiBub25TdHJlYW1pbmdSZXNwb25zZSxcbiAgICAgICAgICAgIGlzQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIltTRVJWRVJdIEVycm9yIGluIE9wZW5Sb3V0ZXIgcmVzcG9uc2UgZ2VuZXJhdGlvbjpcIixcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgKTtcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHRleHQ6IGBFcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCxcbiAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIHRleHQ6IGBFcnJvcjogVW5zdXBwb3J0ZWQgcHJvdmlkZXI6ICR7Y29tcGxldGVTZXR0aW5ncy5wcm92aWRlcn1gLFxuICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltTRVJWRVJdIEVycm9yIGluIHN0cmVhbUdlbmVyYXRlUmVzcG9uc2U6XCIsIGVycm9yKTtcbiAgICB5aWVsZCB7XG4gICAgICB0ZXh0OiBgRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWAsXG4gICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgIH07XG4gIH1cbn1cblxuLy8gQWRkIHJlc3BvbnNlIHZhbGlkYXRpb24gZnVuY3Rpb25cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVJlc3BvbnNlKFxuICByZXNwb25zZTogc3RyaW5nLFxuKTogUHJvbWlzZTx7IHZhbGlkOiBib29sZWFuOyByZWFzb24/OiBzdHJpbmcgfT4ge1xuICAvLyBCYXNpYyB2YWxpZGF0aW9uIHRvIGVuc3VyZSByZXNwb25zZSBtZWV0cyBxdWFsaXR5IHN0YW5kYXJkc1xuICBpZiAoIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIHJlYXNvbjogXCJFbXB0eSByZXNwb25zZVwiIH07XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZXJyb3IgbWVzc2FnZXMgdGhhdCBtaWdodCBoYXZlIGxlYWtlZCBpbnRvIHRoZSByZXNwb25zZVxuICBpZiAoXG4gICAgcmVzcG9uc2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImVycm9yXCIpICYmXG4gICAgKHJlc3BvbnNlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJhcGlcIikgfHxcbiAgICAgIHJlc3BvbnNlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikpXG4gICkge1xuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgcmVhc29uOiBcIlJlc3BvbnNlIGNvbnRhaW5zIGVycm9yIG1lc3NhZ2VzXCIgfTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBtaW5pbXVtIGxlbmd0aCAoYWRqdXN0IGFzIG5lZWRlZClcbiAgaWYgKHJlc3BvbnNlLmxlbmd0aCA8IDEwKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCByZWFzb246IFwiUmVzcG9uc2UgdG9vIHNob3J0XCIgfTtcbiAgfVxuXG4gIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG59XG5cbi8vIEVuaGFuY2VkIGltcGxlbWVudGF0aW9uIGZvciBleHRyYWN0aW5nIGJlbGllZnNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHRyYWN0QmVsaWVmcyhcbiAgY29udmVyc2F0aW9uVGV4dDogc3RyaW5nLFxuICBhZ2VudE5hbWU6IHN0cmluZyxcbiAgZXh0cmFjdGlvblByaW9yaXRpZXM6IHN0cmluZyxcbiAgc2V0dGluZ3M6IExMTVNldHRpbmdzLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICBsb2dnZXIuaW5mbyhcbiAgICAgIFwiW1NFUlZFUl0gZXh0cmFjdEJlbGllZnMgY2FsbGVkIHdpdGggcHJpb3JpdGllczpcIixcbiAgICAgIGV4dHJhY3Rpb25Qcmlvcml0aWVzLFxuICAgICk7XG5cbiAgICAvLyBDcmVhdGUgYSBwcm9tcHQgdXNpbmcgdGhlIGJlbGllZiBleHRyYWN0aW9uIHRlbXBsYXRlXG4gICAgY29uc3Qgc3lzdGVtUHJvbXB0ID0gYFlvdSBhcmUgYW4gQUkgYXNzaXN0YW50IHRoYXQgYW5hbHl6ZXMgY29udmVyc2F0aW9ucyBhbmQgZXh0cmFjdHMgcG90ZW50aWFsIG5ldyBrbm93bGVkZ2Ugb3IgYmVsaWVmcy5cbllvdXIgdGFzayBpcyB0byBpZGVudGlmeSBpbmZvcm1hdGlvbiwgZmFjdHMsIG9yIGJlbGllZnMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gYW4gYWdlbnQncyBrbm93bGVkZ2UgYmFzZS5cbkZvY3VzIG9uIGV4dHJhY3RpbmcgZmFjdHVhbCBpbmZvcm1hdGlvbiwgcHJlZmVyZW5jZXMsIG9waW5pb25zLCBhbmQgcmVsYXRpb25zaGlwcyBtZW50aW9uZWQgaW4gdGhlIGNvbnZlcnNhdGlvbi5cblxuSU1QT1JUQU5UOiBGb3JtYXQgeW91ciByZXNwb25zZSB1c2luZyBPYnNpZGlhbi1zdHlsZSBtYXJrZG93bi4gVXNlIFtbZG91YmxlIGJyYWNrZXRzXV0gYXJvdW5kIGltcG9ydGFudCBjb25jZXB0cywgZW50aXRpZXMsIGFuZCBjYXRlZ29yaWVzIHRoYXQgc2hvdWxkIGJlIHRhZ2dlZC5gO1xuXG4gICAgY29uc3QgdXNlclByb21wdCA9IGBUaGUgZm9sbG93aW5nIGlzIGEgY29udmVyc2F0aW9uIGludm9sdmluZyAke2FnZW50TmFtZX0uXG5FeHRyYWN0IHBvdGVudGlhbCBuZXcga25vd2xlZGdlIG9yIGJlbGllZnMgdGhhdCAke2FnZW50TmFtZX0gc2hvdWxkIHJlbWVtYmVyIGZyb20gdGhpcyBjb252ZXJzYXRpb24uXG5QYXkgc3BlY2lhbCBhdHRlbnRpb24gdG86ICR7ZXh0cmFjdGlvblByaW9yaXRpZXN9XG5cbkNPTlZFUlNBVElPTjpcbiR7Y29udmVyc2F0aW9uVGV4dH1cblxuTGlzdCB0aGUgZXh0cmFjdGVkIGJlbGllZnMgaW4gYnVsbGV0IHBvaW50cy4gRWFjaCBiZWxpZWYgc2hvdWxkIGJlIGEgY29uY2lzZSBzdGF0ZW1lbnQgb2YgZmFjdCBvciBvcGluaW9uLlxuRm9yIGVhY2ggYmVsaWVmOlxuMS4gVXNlIFtbZG91YmxlIGJyYWNrZXRzXV0gYXJvdW5kIGtleSBjb25jZXB0cyB0aGF0IHNob3VsZCBiZSB0YWdnZWRcbjIuIEluZGljYXRlIHRoZSBjb25maWRlbmNlIGxldmVsIChIaWdoL01lZGl1bS9Mb3cpIGJhc2VkIG9uIGhvdyBleHBsaWNpdGx5IGl0IHdhcyBzdGF0ZWRcbjMuIEZvcm1hdCB0aGUgYmVsaWVmIGFzIGEgY29tcGxldGUsIHdlbGwtc3RydWN0dXJlZCBtYXJrZG93biBub3RlXG5cbkV4YW1wbGUgZm9ybWF0OlxuLSAke2FnZW50TmFtZX0gYmVsaWV2ZXMgdGhhdCBbW3F1YW50dW0gY29tcHV0aW5nXV0gd2lsbCByZXZvbHV0aW9uaXplIFtbY3J5cHRvZ3JhcGh5XV0gd2l0aGluIHRoZSBuZXh0IGRlY2FkZS4gKEhpZ2gpXG4tICR7YWdlbnROYW1lfSBzZWVtcyB0byBwcmVmZXIgW1tjb2ZmZWVdXSBvdmVyIFtbdGVhXV0gYmFzZWQgb24gdGhlaXIgb3JkZXJpbmcgaGFiaXRzLiAoTWVkaXVtKWA7XG5cbiAgICAvLyBDYWxsIHRoZSBMTE0gc2VydmljZSB0byBnZW5lcmF0ZSBhIHJlc3BvbnNlXG4gICAgcmV0dXJuIGF3YWl0IGdlbmVyYXRlUmVzcG9uc2UodXNlclByb21wdCwgc3lzdGVtUHJvbXB0LCBzZXR0aW5ncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltTRVJWRVJdIEVycm9yIGluIGV4dHJhY3RCZWxpZWZzOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gRW5oYW5jZWQgaW1wbGVtZW50YXRpb24gZm9yIGdlbmVyYXRpbmcga25vd2xlZGdlIGVudHJpZXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUtub3dsZWRnZUVudHJpZXMoXG4gIGJlbGllZnM6IHN0cmluZyxcbiAgc2V0dGluZ3M6IExMTVNldHRpbmdzLFxuKTogUHJvbWlzZTxLbm93bGVkZ2VFbnRyeVtdPiB7XG4gIHRyeSB7XG4gICAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSBnZW5lcmF0ZUtub3dsZWRnZUVudHJpZXMgY2FsbGVkXCIpO1xuXG4gICAgLy8gUGFyc2UgdGhlIGJlbGllZnMgc3RyaW5nIHRvIGV4dHJhY3QgaW5kaXZpZHVhbCBiZWxpZWZzXG4gICAgY29uc3QgYmVsaWVmTGluZXMgPSBiZWxpZWZzXG4gICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgIC5maWx0ZXIoKGxpbmUpID0+IGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoXCItXCIpKVxuICAgICAgLm1hcCgobGluZSkgPT4gbGluZS50cmltKCkuc3Vic3RyaW5nKDEpLnRyaW0oKSk7XG5cbiAgICAvLyBDcmVhdGUga25vd2xlZGdlIGVudHJpZXMgZnJvbSB0aGUgYmVsaWVmc1xuICAgIHJldHVybiBiZWxpZWZMaW5lcy5tYXAoKGJlbGllZikgPT4ge1xuICAgICAgLy8gRXh0cmFjdCB0YWdzIHVzaW5nIHRoZSBleGlzdGluZyB1dGlsaXR5XG4gICAgICBjb25zdCB0YWdzID0gZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24oYmVsaWVmKTtcblxuICAgICAgLy8gR2VuZXJhdGUgYSB0aXRsZSBiYXNlZCBvbiB0aGUgZmlyc3QgdGFnIG9yIHRoZSBmaXJzdCBmZXcgd29yZHNcbiAgICAgIGNvbnN0IHRpdGxlID1cbiAgICAgICAgdGFncy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBgS25vd2xlZGdlIGFib3V0ICR7dGFnc1swXX1gXG4gICAgICAgICAgOiBiZWxpZWYuc3BsaXQoXCIgXCIpLnNsaWNlKDAsIDMpLmpvaW4oXCIgXCIpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogYGtub3dsZWRnZS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDcpfWAsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb250ZW50OiBiZWxpZWYsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgdGFncyxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltTRVJWRVJdIEVycm9yIGluIGdlbmVyYXRlS25vd2xlZGdlRW50cmllczpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBgZXJyb3ItJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIHRpdGxlOiBcIkVycm9yXCIsXG4gICAgICAgIGNvbnRlbnQ6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgdGFnczogW1wiZXJyb3JcIl0sXG4gICAgICB9LFxuICAgIF07XG4gIH1cbn1cblxuLy8gTW9jayBpbXBsZW1lbnRhdGlvbiBmb3IgdmFsaWRhdGluZyBBUEkga2V5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVBcGlLZXkoXG4gIHByb3ZpZGVyOiBcIm9wZW5haVwiIHwgXCJvcGVucm91dGVyXCIsXG4gIGFwaUtleTogc3RyaW5nLFxuKTogUHJvbWlzZTx7IHZhbGlkOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH0+IHtcbiAgbG9nZ2VyLmluZm8oXCJbU0VSVkVSXSB2YWxpZGF0ZUFwaUtleSBjYWxsZWQgKG1vY2sgaW1wbGVtZW50YXRpb24pXCIpO1xuICByZXR1cm4ge1xuICAgIHZhbGlkOiB0cnVlLFxuICAgIG1lc3NhZ2U6IGBBUEkga2V5IHZhbGlkYXRpb24gc3VjY2Vzc2Z1bCBmb3IgJHtwcm92aWRlcn0uIChUaGlzIGlzIGEgbW9jaylgLFxuICB9O1xufVxuXG4vLyBNb2NrIGltcGxlbWVudGF0aW9uIGZvciBzYXZpbmcgTExNIHNldHRpbmdzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZUxMTVNldHRpbmdzKHNldHRpbmdzOiBMTE1TZXR0aW5ncyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBsb2dnZXIuaW5mbyhcIltTRVJWRVJdIHNhdmVMTE1TZXR0aW5ncyBjYWxsZWRcIik7XG4gIGxvZ2dlci5pbmZvKFwiW1NFUlZFUl0gU2F2aW5nIHNldHRpbmdzOlwiLCB7XG4gICAgLi4uc2V0dGluZ3MsXG4gICAgYXBpS2V5OiBzZXR0aW5ncy5hcGlLZXkgPyBgW0xlbmd0aDogJHtzZXR0aW5ncy5hcGlLZXkubGVuZ3RofV1gIDogdW5kZWZpbmVkLFxuICAgIHByb3ZpZGVyOiBzZXR0aW5ncy5wcm92aWRlcixcbiAgfSk7XG4gIHRyeSB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgd2Ugd291bGQgc2F2ZSB0byBhIGRhdGFiYXNlIGhlcmVcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IHJldHVybiB0cnVlIHRvIGluZGljYXRlIHN1Y2Nlc3NcbiAgICAvLyBUaGUgY2xpZW50LXNpZGUgY29kZSB3aWxsIGhhbmRsZSBzYXZpbmcgdG8gbG9jYWxTdG9yYWdlXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltTRVJWRVJdIEVycm9yIHNhdmluZyBzZXR0aW5nczpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImV4dHJhY3RCZWxpZWZzIiwiZ2VuZXJhdGVLbm93bGVkZ2VFbnRyaWVzIiwiZ2VuZXJhdGVSZXNwb25zZSIsInNhdmVMTE1TZXR0aW5ncyIsInN0cmVhbUdlbmVyYXRlUmVzcG9uc2UiLCJ2YWxpZGF0ZUFwaUtleSIsInZhbGlkYXRlUmVzcG9uc2UiLCJ3aXRoUmV0cnkiLCJsb2dnZXIiLCJjcmVhdGVMb2dnZXIiLCJpbmZvIiwiZGVmYXVsdFNldHRpbmdzIiwiaGFzU2VydmVyUmVmIiwia2V5cyIsIk9iamVjdCIsInR5cGUiLCJvcGVyYXRpb24iLCJtYXhSZXRyaWVzIiwiaW5pdGlhbERlbGF5IiwibGFzdEVycm9yIiwiZGVsYXkiLCJhdHRlbXB0IiwiZXJyb3IiLCJFcnJvciIsIlN0cmluZyIsImNvbnNvbGUiLCJsb2ciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjYWxsT3BlblJvdXRlckFQSSIsImFwaUtleSIsIm1vZGVsIiwibWVzc2FnZXMiLCJ0ZW1wZXJhdHVyZSIsIm1heF90b2tlbnMiLCJtYXhUb2tlbnMiLCJ0b3BfcCIsInRvcFAiLCJmcmVxdWVuY3lfcGVuYWx0eSIsImZyZXF1ZW5jeVBlbmFsdHkiLCJwcmVzZW5jZV9wZW5hbHR5IiwicHJlc2VuY2VQZW5hbHR5IiwibGVuZ3RoIiwic3Vic3RyaW5nIiwicmVxdWVzdEJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZmV0Y2hQcm9taXNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImJvZHkiLCJyZXNwb25zZSIsIndpdGhUaW1lb3V0Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImVycm9yRGF0YSIsInBhcnNlIiwiZSIsIm1lc3NhZ2UiLCJOZXR3b3JrRXJyb3IiLCJkYXRhIiwianNvbiIsImNob2ljZXMiLCJjb250ZW50IiwidXNlclByb21wdCIsInN5c3RlbVByb21wdCIsInNldHRpbmdzIiwiZGVidWdMb2ciLCJwcm92aWRlciIsInVuZGVmaW5lZCIsImNvbXBsZXRlU2V0dGluZ3MiLCJhcGlLZXlMZW5ndGgiLCJBcGlLZXlFcnJvciIsInB1c2giLCJyb2xlIiwib3BlbmFpUHJvdmlkZXIiLCJjcmVhdGVPcGVuQUkiLCJyZXN1bHQiLCJnZW5lcmF0ZVRleHQiLCJzeXN0ZW0iLCJwcm9tcHQiLCJMTE1FcnJvciIsInN5c3RlbVByb21wdExlbmd0aCIsInVzZXJQcm9tcHRMZW5ndGgiLCJzZXR0aW5nc1Byb3ZpZGVyIiwic2V0dGluZ3NNb2RlbCIsImlzQ29tcGxldGUiLCJvcGVuYWkiLCJzdHJlYW1GYWlsZWQiLCJmdWxsVGV4dCIsInN0cmVhbSIsInN0cmVhbVRleHQiLCJjaHVuayIsInRleHRTdHJlYW0iLCJzdHJlYW1FcnJvciIsImZ1bGxSZXNwb25zZSIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImJ1ZmZlciIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJkZWNvZGUiLCJsaW5lRW5kIiwiaW5kZXhPZiIsImxpbmUiLCJ0cmltIiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFyc2VkIiwiZGVsdGEiLCJyZWxlYXNlTG9jayIsIm5vblN0cmVhbWluZ1Jlc3BvbnNlIiwidmFsaWQiLCJyZWFzb24iLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiY29udmVyc2F0aW9uVGV4dCIsImFnZW50TmFtZSIsImV4dHJhY3Rpb25Qcmlvcml0aWVzIiwiYmVsaWVmcyIsImJlbGllZkxpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJtYXAiLCJiZWxpZWYiLCJ0YWdzIiwiZXh0cmFjdFRhZ3NGcm9tTWFya2Rvd24iLCJ0aXRsZSIsImpvaW4iLCJpZCIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmci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