{"version":3,"sources":["/Users/matthewmoroney/builds/FreeAgentics/web/__tests__/lib/belief-extraction-simple.test.ts"],"sourcesContent":["/**\n * Phase 1: lib/belief-extraction.ts Simplified Test Suite\n * Target: Complete belief extraction functionality (simplified approach)\n * Goal: Maximum statement coverage for knowledge extraction utilities\n */\n\nimport {\n  parseBeliefs,\n  parseRefinedBeliefs,\n  createFallbackRefinedBeliefs,\n  type ExtractedBelief,\n  type RefinedBelief,\n} from \"../../lib/belief-extraction\";\n\n// Mock the utils module\njest.mock(\"../../lib/utils\", () => ({\n  extractTagsFromMarkdown: jest.fn(() => [\"test-tag\"]),\n}));\n\ndescribe(\"lib/belief-extraction.ts - Simplified Coverage\", () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe(\"parseBeliefs function\", () => {\n    test(\"parses simple bullet point belief\", () => {\n      const response = `- Simple belief content`;\n      const beliefs = parseBeliefs(response);\n\n      expect(beliefs).toHaveLength(1);\n      expect(beliefs[0].content).toBe(\"Simple belief content\");\n      expect(beliefs[0].confidence).toBe(\"Medium\");\n      expect(beliefs[0].source).toBe(\"conversation\");\n    });\n\n    test(\"parses belief with confidence marker\", () => {\n      const response = `- Belief with confidence $$High$$`;\n      const beliefs = parseBeliefs(response);\n\n      expect(beliefs).toHaveLength(1);\n      expect(beliefs[0].content).toBe(\"Belief with confidence\");\n      expect(beliefs[0].confidence).toBe(\"High\");\n    });\n\n    test(\"parses numbered list item\", () => {\n      const response = `1. Numbered belief content`;\n      const beliefs = parseBeliefs(response);\n\n      expect(beliefs).toHaveLength(1);\n      expect(beliefs[0].content).toBe(\"Numbered belief content\");\n      expect(beliefs[0].confidence).toBe(\"Medium\");\n    });\n\n    test(\"parses bullet point item\", () => {\n      const response = `• Bullet point belief`;\n      const beliefs = parseBeliefs(response);\n\n      expect(beliefs).toHaveLength(1);\n      expect(beliefs[0].content).toBe(\"Bullet point belief\");\n      expect(beliefs[0].confidence).toBe(\"Medium\");\n    });\n\n    test(\"handles multiple confidence levels\", () => {\n      const testCases = [\n        { input: \"- Low confidence $$Low$$\", expected: \"Low\" },\n        { input: \"- Medium confidence $$Medium$$\", expected: \"Medium\" },\n        { input: \"- High confidence $$High$$\", expected: \"High\" },\n        { input: \"- No confidence\", expected: \"Medium\" },\n      ];\n\n      testCases.forEach(({ input, expected }) => {\n        const beliefs = parseBeliefs(input);\n        expect(beliefs[0].confidence).toBe(expected);\n      });\n    });\n\n    test(\"returns empty array for non-matching input\", () => {\n      const testCases = [\"\", \"Regular text without bullets\", \"   \", \"\\n\\n\"];\n\n      testCases.forEach((input) => {\n        const beliefs = parseBeliefs(input);\n        expect(beliefs).toHaveLength(0);\n      });\n    });\n\n    test(\"filters out empty content\", () => {\n      const response = `\n- Valid content\n-    \n• \n1. Another valid content\n2.   $$High$$\n      `;\n\n      const beliefs = parseBeliefs(response);\n      expect(beliefs).toHaveLength(2);\n      expect(beliefs[0].content).toBe(\"Valid content\");\n      expect(beliefs[1].content).toBe(\"Another valid content\");\n    });\n\n    test(\"handles case insensitive confidence\", () => {\n      const testCases = [\n        \"- Content $$high$$\",\n        \"- Content $$HIGH$$\",\n        \"- Content $$High$$\",\n        \"- Content $$HiGh$$\",\n      ];\n\n      testCases.forEach((input) => {\n        const beliefs = parseBeliefs(input);\n        expect(beliefs).toHaveLength(1);\n        // The function preserves the case as-is\n        expect([\"high\", \"HIGH\", \"High\", \"HiGh\"]).toContain(\n          beliefs[0].confidence,\n        );\n      });\n    });\n  });\n\n  describe(\"createFallbackRefinedBeliefs function\", () => {\n    test(\"creates fallback beliefs with correct structure\", () => {\n      const extractedBeliefs: ExtractedBelief[] = [\n        {\n          content: \"Test belief\",\n          confidence: \"High\",\n          source: \"conversation\",\n          tags: [\"work\"],\n        },\n      ];\n\n      const fallbackBeliefs = createFallbackRefinedBeliefs(extractedBeliefs);\n\n      expect(fallbackBeliefs).toHaveLength(1);\n      expect(fallbackBeliefs[0]).toEqual({\n        originalIndex: 0,\n        accuracy: 3,\n        relevance: 3,\n        category: \"Fact\",\n        title: \"Knowledge about work\",\n        refined_content: \"Test belief\",\n        confidence: \"High\",\n        tags: [\"work\"],\n        selected: true,\n        novelty: \"Medium\",\n      });\n    });\n\n    test(\"handles beliefs with no tags\", () => {\n      const extractedBeliefs: ExtractedBelief[] = [\n        {\n          content: \"Belief without tags\",\n          confidence: \"Medium\",\n          source: \"conversation\",\n          tags: [],\n        },\n      ];\n\n      const fallbackBeliefs = createFallbackRefinedBeliefs(extractedBeliefs);\n\n      expect(fallbackBeliefs[0].title).toBe(\"Knowledge about topic\");\n    });\n\n    test(\"handles empty beliefs array\", () => {\n      const fallbackBeliefs = createFallbackRefinedBeliefs([]);\n      expect(fallbackBeliefs).toHaveLength(0);\n    });\n\n    test(\"preserves original index correctly\", () => {\n      const extractedBeliefs: ExtractedBelief[] = Array.from(\n        { length: 3 },\n        (_, i) => ({\n          content: `Belief ${i}`,\n          confidence: \"Medium\" as const,\n          source: \"conversation\" as const,\n          tags: [`tag${i}`],\n        }),\n      );\n\n      const fallbackBeliefs = createFallbackRefinedBeliefs(extractedBeliefs);\n\n      expect(fallbackBeliefs).toHaveLength(3);\n      fallbackBeliefs.forEach((belief, index) => {\n        expect(belief.originalIndex).toBe(index);\n      });\n    });\n  });\n\n  describe(\"parseRefinedBeliefs function\", () => {\n    const mockSourceBeliefs: ExtractedBelief[] = [\n      {\n        content: \"Source belief\",\n        confidence: \"High\",\n        source: \"conversation\",\n        tags: [\"source\"],\n      },\n    ];\n\n    test(\"parses valid JSON response correctly\", () => {\n      const validJsonResponse = JSON.stringify([\n        {\n          originalIndex: 0,\n          accuracy: 4,\n          relevance: 5,\n          category: \"Fact\",\n          title: \"Important fact\",\n          refined_content: \"This is refined content\",\n          confidence: \"High\",\n          tags: [\"important\"],\n          selected: true,\n          novelty: \"High\",\n        },\n      ]);\n\n      const refinedBeliefs = parseRefinedBeliefs(\n        validJsonResponse,\n        mockSourceBeliefs,\n      );\n\n      expect(refinedBeliefs).toHaveLength(1);\n      expect(refinedBeliefs[0].title).toBe(\"Important fact\");\n      expect(refinedBeliefs[0].refined_content).toBe(\"This is refined content\");\n      expect(refinedBeliefs[0].selected).toBe(true);\n    });\n\n    test(\"handles missing optional fields with defaults\", () => {\n      const jsonWithMissingFields = JSON.stringify([\n        {\n          originalIndex: 0,\n          accuracy: 3,\n          relevance: 3,\n          category: \"Opinion\",\n          title: \"Test opinion\",\n          refined_content: \"Refined opinion content\",\n          confidence: \"Medium\",\n          // Missing tags, selected, novelty\n        },\n      ]);\n\n      const refinedBeliefs = parseRefinedBeliefs(\n        jsonWithMissingFields,\n        mockSourceBeliefs,\n      );\n\n      expect(refinedBeliefs).toHaveLength(1);\n      expect(refinedBeliefs[0].selected).toBe(true); // Default to true\n      expect(refinedBeliefs[0].tags).toEqual([\"test-tag\"]); // From mock\n      expect(refinedBeliefs[0].novelty).toBe(\"Medium\"); // Default value\n    });\n\n    test(\"filters out invalid beliefs\", () => {\n      const jsonWithInvalidBeliefs = JSON.stringify([\n        {\n          originalIndex: 0,\n          accuracy: 4,\n          relevance: 5,\n          category: \"Fact\",\n          title: \"Valid belief\",\n          refined_content: \"Valid content\",\n          confidence: \"High\",\n        },\n        {\n          // Missing originalIndex\n          accuracy: 3,\n          title: \"Invalid belief\",\n          refined_content: \"Invalid content\",\n        },\n        {\n          originalIndex: 2,\n          title: \"Empty content\",\n          refined_content: \"\", // Empty content\n        },\n      ]);\n\n      const refinedBeliefs = parseRefinedBeliefs(\n        jsonWithInvalidBeliefs,\n        mockSourceBeliefs,\n      );\n\n      expect(refinedBeliefs).toHaveLength(1);\n      expect(refinedBeliefs[0].title).toBe(\"Valid belief\");\n    });\n\n    test(\"returns fallback when no valid beliefs found\", () => {\n      const consoleSpy = jest.spyOn(console, \"warn\").mockImplementation();\n\n      const jsonWithOnlyInvalidBeliefs = JSON.stringify([\n        {\n          // Missing required fields\n          accuracy: 3,\n          relevance: 3,\n        },\n      ]);\n\n      const refinedBeliefs = parseRefinedBeliefs(\n        jsonWithOnlyInvalidBeliefs,\n        mockSourceBeliefs,\n      );\n\n      expect(consoleSpy).toHaveBeenCalledWith(\n        \"No valid beliefs found in parsed JSON\",\n      );\n      expect(refinedBeliefs).toHaveLength(1);\n      expect(refinedBeliefs[0].category).toBe(\"Fact\"); // Fallback structure\n\n      consoleSpy.mockRestore();\n    });\n\n    test(\"handles invalid JSON gracefully\", () => {\n      const consoleSpy = jest.spyOn(console, \"error\").mockImplementation();\n\n      const invalidJson = \"invalid json\";\n      const refinedBeliefs = parseRefinedBeliefs(\n        invalidJson,\n        mockSourceBeliefs,\n      );\n\n      expect(consoleSpy).toHaveBeenCalledWith(\n        \"Error parsing refined beliefs JSON:\",\n        expect.any(Error),\n      );\n      expect(refinedBeliefs).toHaveLength(1);\n      expect(refinedBeliefs[0].category).toBe(\"Fact\"); // Fallback structure\n\n      consoleSpy.mockRestore();\n    });\n\n    test(\"handles selected field correctly\", () => {\n      const testCases = [\n        { selected: true, expected: true },\n        { selected: false, expected: false },\n        { expected: true }, // Missing selected field defaults to true\n      ];\n\n      testCases.forEach(({ selected, expected }) => {\n        const beliefData: any = {\n          originalIndex: 0,\n          accuracy: 3,\n          relevance: 3,\n          category: \"Fact\",\n          title: \"Test\",\n          refined_content: \"Content\",\n          confidence: \"Medium\",\n        };\n\n        if (selected !== undefined) {\n          beliefData.selected = selected;\n        }\n\n        const jsonResponse = JSON.stringify([beliefData]);\n        const refinedBeliefs = parseRefinedBeliefs(\n          jsonResponse,\n          mockSourceBeliefs,\n        );\n\n        expect(refinedBeliefs[0].selected).toBe(expected);\n      });\n    });\n  });\n\n  describe(\"error handling and edge cases\", () => {\n    test(\"functions handle null and undefined gracefully\", () => {\n      expect(() => parseBeliefs(\"\")).not.toThrow();\n      expect(() => createFallbackRefinedBeliefs([])).not.toThrow();\n      expect(() => parseRefinedBeliefs(\"null\", [])).not.toThrow();\n    });\n\n    test(\"functions return consistent types\", () => {\n      const beliefs = parseBeliefs(\"- Test\");\n      expect(Array.isArray(beliefs)).toBe(true);\n\n      const fallbacks = createFallbackRefinedBeliefs([]);\n      expect(Array.isArray(fallbacks)).toBe(true);\n\n      const refined = parseRefinedBeliefs(\"invalid\", []);\n      expect(Array.isArray(refined)).toBe(true);\n    });\n\n    test(\"parseBeliefs handles large input efficiently\", () => {\n      const largeInput = Array.from(\n        { length: 1000 },\n        (_, i) => `- Belief ${i} content`,\n      ).join(\"\\n\");\n\n      const beliefs = parseBeliefs(largeInput);\n      expect(beliefs).toHaveLength(1000);\n      expect(beliefs[0].content).toBe(\"Belief 0 content\");\n      expect(beliefs[999].content).toBe(\"Belief 999 content\");\n    });\n\n    test(\"createFallbackRefinedBeliefs handles large arrays\", () => {\n      const largeBeliefs: ExtractedBelief[] = Array.from(\n        { length: 100 },\n        (_, i) => ({\n          content: `Belief ${i}`,\n          confidence: \"Medium\" as const,\n          source: \"conversation\" as const,\n          tags: [`tag${i}`],\n        }),\n      );\n\n      const fallbacks = createFallbackRefinedBeliefs(largeBeliefs);\n      expect(fallbacks).toHaveLength(100);\n      expect(fallbacks[0].originalIndex).toBe(0);\n      expect(fallbacks[99].originalIndex).toBe(99);\n    });\n  });\n});\n"],"names":["jest","mock","extractTagsFromMarkdown","fn","describe","beforeEach","clearAllMocks","test","response","beliefs","parseBeliefs","expect","toHaveLength","content","toBe","confidence","source","testCases","input","expected","forEach","toContain","extractedBeliefs","tags","fallbackBeliefs","createFallbackRefinedBeliefs","toEqual","originalIndex","accuracy","relevance","category","title","refined_content","selected","novelty","Array","from","length","_","i","belief","index","mockSourceBeliefs","validJsonResponse","JSON","stringify","refinedBeliefs","parseRefinedBeliefs","jsonWithMissingFields","jsonWithInvalidBeliefs","consoleSpy","spyOn","console","mockImplementation","jsonWithOnlyInvalidBeliefs","toHaveBeenCalledWith","mockRestore","invalidJson","any","Error","beliefData","undefined","jsonResponse","not","toThrow","isArray","fallbacks","refined","largeInput","join","largeBeliefs"],"mappings":"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"}