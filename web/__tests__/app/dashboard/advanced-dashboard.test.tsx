/**
 * Advanced Dashboard Tests
 *
 * Comprehensive tests for dashboard panels, layouts, and interactive components
 * following ADR-007 requirements for complete dashboard coverage.
 */

import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { jest } from "@jest/globals";

// Mock D3 for visualizations
const mockD3 = {
  select: jest.fn((...args: any[]) => ({
    selectAll: jest.fn((...args: any[]) => ({
      data: jest.fn((...args: any[]) => ({
        enter: jest.fn((...args: any[]) => ({
          append: jest.fn((...args: any[]) => ({
            attr: jest.fn((...args: any[]) => ({
              attr: jest.fn((...args: any[]) => {}),
            })),
            style: jest.fn((...args: any[]) => ({
              style: jest.fn((...args: any[]) => {}),
            })),
            text: jest.fn((...args: any[]) => ({
              text: jest.fn((...args: any[]) => {}),
            })),
          })),
        })),
      })),
      remove: jest.fn((...args: any[]) => {}),
    })),
    attr: jest.fn((...args: any[]) => ({
      attr: jest.fn((...args: any[]) => {}),
    })),
    style: jest.fn((...args: any[]) => ({
      style: jest.fn((...args: any[]) => {}),
    })),
    on: jest.fn((...args: any[]) => ({ on: jest.fn((...args: any[]) => {}) })),
  })),
  scaleLinear: jest.fn(() => {
    const scale = jest.fn((...args: any[]) => 0) as any;
    scale.domain = jest.fn((...args: any[]) => scale);
    scale.range = jest.fn((...args: any[]) => scale);
    return scale;
  }),
  scaleOrdinal: jest.fn(() => {
    const scale = jest.fn((...args: any[]) => 0) as any;
    scale.domain = jest.fn((...args: any[]) => scale);
    scale.range = jest.fn((...args: any[]) => scale);
    return scale;
  }),
  extent: jest.fn((...args: any[]) => [0, 100]),
  max: jest.fn((...args: any[]) => 100),
  min: jest.fn((...args: any[]) => 0),
  zoom: jest.fn(() => ({
    scaleExtent: jest.fn((...args: any[]) => ({
      on: jest.fn((...args: any[]) => {}),
    })),
    on: jest.fn((...args: any[]) => ({
      scaleExtent: jest.fn((...args: any[]) => {}),
    })),
  })),
  drag: jest.fn(() => ({
    on: jest.fn((...args: any[]) => ({ on: jest.fn((...args: any[]) => {}) })),
  })),
  forceSimulation: jest.fn((...args: any[]) => {
    const simulation = {
      force: jest.fn((...args: any[]) => simulation),
      nodes: jest.fn((...args: any[]) => simulation),
      links: jest.fn((...args: any[]) => simulation),
      on: jest.fn((...args: any[]) => simulation),
      stop: jest.fn((...args: any[]) => simulation),
      restart: jest.fn((...args: any[]) => simulation),
    };
    return simulation;
  }),
  forceLink: jest.fn((...args: any[]) => ({
    id: jest.fn((...args: any[]) => ({
      distance: jest.fn((...args: any[]) => {}),
    })),
    distance: jest.fn((...args: any[]) => ({
      id: jest.fn((...args: any[]) => {}),
    })),
  })),
  forceManyBody: jest.fn((...args: any[]) => ({
    strength: jest.fn((...args: any[]) => ({
      strength: jest.fn((...args: any[]) => {}),
    })),
  })),
  forceCenter: jest.fn((...args: any[]) => ({
    x: jest.fn((...args: any[]) => {}),
    y: jest.fn((...args: any[]) => {}),
  })),
};

jest.unstable_mockModule("d3", () => mockD3);

// Mock comprehensive dashboard implementations
interface DashboardMetrics {
  activeAgents: number;
  messageRate: number;
  networkUtilization: number;
  errorRate: number;
  averageResponseTime: number;
  knowledgeGraphNodes: number;
  coalitionsFormed: number;
  beliefStates: number;
}

interface DashboardAlert {
  id: string;
  severity: "low" | "medium" | "high" | "critical";
  message: string;
  timestamp: Date;
  acknowledged: boolean;
  category: "performance" | "security" | "system" | "user";
}

// Enhanced Metrics Panel
const MetricsPanel: React.FC<{ metrics: DashboardMetrics }> = ({ metrics }) => {
  const getMetricColor = (value: number, threshold: number) => {
    return value > threshold
      ? "#ef4444"
      : value > threshold * 0.7
        ? "#f59e0b"
        : "#10b981";
  };

  return (
    <div data-testid="metrics-panel" className="metrics-panel">
      <h3>System Metrics</h3>

      <div className="metric-grid">
        <div data-testid="active-agents" className="metric-card">
          <span className="metric-label">Active Agents</span>
          <span className="metric-value">{metrics.activeAgents}</span>
        </div>

        <div data-testid="message-rate" className="metric-card">
          <span className="metric-label">Message Rate (msg/s)</span>
          <span
            className="metric-value"
            style={{ color: getMetricColor(metrics.messageRate, 100) }}
          >
            {metrics.messageRate.toFixed(1)}
          </span>
        </div>

        <div data-testid="network-utilization" className="metric-card">
          <span className="metric-label">Network Utilization (%)</span>
          <span
            className="metric-value"
            style={{ color: getMetricColor(metrics.networkUtilization, 80) }}
          >
            {metrics.networkUtilization.toFixed(1)}%
          </span>
        </div>

        <div data-testid="error-rate" className="metric-card">
          <span className="metric-label">Error Rate (%)</span>
          <span
            className="metric-value"
            style={{ color: getMetricColor(metrics.errorRate, 5) }}
          >
            {metrics.errorRate.toFixed(2)}%
          </span>
        </div>

        <div data-testid="response-time" className="metric-card">
          <span className="metric-label">Avg Response Time (ms)</span>
          <span
            className="metric-value"
            style={{ color: getMetricColor(metrics.averageResponseTime, 500) }}
          >
            {metrics.averageResponseTime.toFixed(0)}
          </span>
        </div>

        <div data-testid="knowledge-nodes" className="metric-card">
          <span className="metric-label">Knowledge Nodes</span>
          <span className="metric-value">{metrics.knowledgeGraphNodes}</span>
        </div>

        <div data-testid="coalitions-formed" className="metric-card">
          <span className="metric-label">Coalitions Formed</span>
          <span className="metric-value">{metrics.coalitionsFormed}</span>
        </div>

        <div data-testid="belief-states" className="metric-card">
          <span className="metric-label">Belief States</span>
          <span className="metric-value">{metrics.beliefStates}</span>
        </div>
      </div>
    </div>
  );
};

// Alert Management Panel
const AlertPanel: React.FC<{
  alerts: DashboardAlert[];
  onAcknowledge: (id: string) => void;
  onDismiss: (id: string) => void;
  onClearAll: () => void;
}> = ({ alerts, onAcknowledge, onDismiss, onClearAll }) => {
  const [filter, setFilter] = React.useState<string>("all");
  const [sortBy, setSortBy] = React.useState<"timestamp" | "severity">(
    "timestamp",
  );

  const filteredAlerts = React.useMemo(() => {
    let filtered = alerts;

    if (filter !== "all") {
      filtered = alerts.filter((alert) =>
        filter === "unacknowledged"
          ? !alert.acknowledged
          : alert.category === filter,
      );
    }

    return filtered.sort((a, b) => {
      if (sortBy === "timestamp") {
        return (
          new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
        );
      } else {
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        return severityOrder[b.severity] - severityOrder[a.severity];
      }
    });
  }, [alerts, filter, sortBy]);

  const getSeverityColor = (severity: string) => {
    const colors = {
      critical: "#dc2626",
      high: "#ea580c",
      medium: "#d97706",
      low: "#65a30d",
    };
    return colors[severity as keyof typeof colors] || "#6b7280";
  };

  return (
    <div data-testid="alert-panel" className="alert-panel">
      <div className="alert-header">
        <h3>System Alerts</h3>
        <div className="alert-controls">
          <select
            data-testid="alert-filter"
            value={filter}
            onChange={(e) => setFilter(e.target.value)}
          >
            <option value="all">All Alerts</option>
            <option value="unacknowledged">Unacknowledged</option>
            <option value="performance">Performance</option>
            <option value="security">Security</option>
            <option value="system">System</option>
            <option value="user">User</option>
          </select>

          <select
            data-testid="alert-sort"
            value={sortBy}
            onChange={(e) =>
              setSortBy(e.target.value as "timestamp" | "severity")
            }
          >
            <option value="timestamp">Sort by Time</option>
            <option value="severity">Sort by Severity</option>
          </select>

          <button
            data-testid="clear-all-alerts"
            onClick={onClearAll}
            disabled={alerts.length === 0}
          >
            Clear All
          </button>
        </div>
      </div>

      <div className="alert-list" data-testid="alert-list">
        {filteredAlerts.length === 0 ? (
          <div data-testid="no-alerts" className="no-alerts">
            No alerts to display
          </div>
        ) : (
          filteredAlerts.map((alert) => (
            <div
              key={alert.id}
              data-testid={`alert-${alert.id}`}
              className={`alert-item ${alert.acknowledged ? "acknowledged" : ""}`}
              style={{ borderLeftColor: getSeverityColor(alert.severity) }}
            >
              <div className="alert-content">
                <div
                  className="alert-severity"
                  data-testid={`alert-severity-${alert.id}`}
                >
                  {alert.severity.toUpperCase()}
                </div>
                <div
                  className="alert-category"
                  data-testid={`alert-category-${alert.id}`}
                >
                  {alert.category}
                </div>
                <div
                  className="alert-message"
                  data-testid={`alert-message-${alert.id}`}
                >
                  {alert.message}
                </div>
                <div
                  className="alert-timestamp"
                  data-testid={`alert-timestamp-${alert.id}`}
                >
                  {alert.timestamp.toLocaleString()}
                </div>
              </div>

              <div className="alert-actions">
                {!alert.acknowledged && (
                  <button
                    data-testid={`acknowledge-${alert.id}`}
                    onClick={() => onAcknowledge(alert.id)}
                    className="acknowledge-btn"
                  >
                    Acknowledge
                  </button>
                )}
                <button
                  data-testid={`dismiss-${alert.id}`}
                  onClick={() => onDismiss(alert.id)}
                  className="dismiss-btn"
                >
                  Dismiss
                </button>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
};

// Performance Chart Component
const PerformanceChart: React.FC<{
  data: Array<{ timestamp: Date; value: number; metric: string }>;
  timeRange: "1h" | "6h" | "24h" | "7d";
  onTimeRangeChange: (range: "1h" | "6h" | "24h" | "7d") => void;
}> = ({ data, timeRange, onTimeRangeChange }) => {
  const chartRef = React.useRef<SVGSVGElement>(null);
  const [hoveredPoint, setHoveredPoint] = React.useState<any>(null);

  React.useEffect(() => {
    if (!chartRef.current || !data.length) return;

    // Mock D3 chart rendering
    const svg = mockD3.select(chartRef.current);
    svg.selectAll("*").remove();

    // Simulate chart rendering with D3
    const margin = { top: 20, right: 30, bottom: 40, left: 50 };
    const width = 800 - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    const xScale = mockD3
      .scaleLinear()
      .domain(mockD3.extent(data, (d: any) => d.timestamp))
      .range([0, width]);

    const yScale = mockD3
      .scaleLinear()
      .domain(mockD3.extent(data, (d: any) => d.value))
      .range([height, 0]);

    // Mock line path creation
    const line = data
      .map(
        (d, i) =>
          `${i === 0 ? "M" : "L"} ${xScale(d.timestamp)} ${yScale(d.value)}`,
      )
      .join(" ");

    return () => {
      // Cleanup
    };
  }, [data, timeRange]);

  return (
    <div data-testid="performance-chart" className="performance-chart">
      <div className="chart-header">
        <h3>Performance Metrics</h3>
        <div className="time-range-selector">
          {(["1h", "6h", "24h", "7d"] as const).map((range) => (
            <button
              key={range}
              data-testid={`time-range-${range}`}
              className={timeRange === range ? "active" : ""}
              onClick={() => onTimeRangeChange(range)}
            >
              {range}
            </button>
          ))}
        </div>
      </div>

      <div className="chart-container">
        <svg
          ref={chartRef}
          data-testid="chart-svg"
          width="800"
          height="400"
          viewBox="0 0 800 400"
        >
          {/* Chart content rendered by D3 mock */}
          <g data-testid="chart-content">
            <text x="400" y="200" textAnchor="middle">
              Performance Chart ({data.length} data points)
            </text>
          </g>
        </svg>

        {hoveredPoint && (
          <div
            data-testid="chart-tooltip"
            className="chart-tooltip"
            style={{
              position: "absolute",
              left: hoveredPoint.x,
              top: hoveredPoint.y,
            }}
          >
            <div>Value: {hoveredPoint.value}</div>
            <div>Time: {hoveredPoint.timestamp.toLocaleString()}</div>
          </div>
        )}
      </div>
    </div>
  );
};

// Network Topology Visualization
const NetworkTopology: React.FC<{
  nodes: Array<{
    id: string;
    type: string;
    status: string;
    connections: number;
  }>;
  edges: Array<{
    source: string;
    target: string;
    strength: number;
    type: string;
  }>;
  onNodeClick: (nodeId: string) => void;
  onEdgeClick: (edgeId: string) => void;
}> = ({ nodes, edges, onNodeClick, onEdgeClick }) => {
  const svgRef = React.useRef<SVGSVGElement>(null);
  const [selectedNode, setSelectedNode] = React.useState<string | null>(null);
  const [zoomLevel, setZoomLevel] = React.useState(1);

  React.useEffect(() => {
    if (!svgRef.current) return;

    // Mock D3 force simulation
    const simulation = mockD3
      .forceSimulation(nodes)
      .force(
        "link",
        mockD3.forceLink(edges).id((d: any) => d.id),
      )
      .force("charge", mockD3.forceManyBody().strength(-300))
      .force("center", mockD3.forceCenter(400, 300));

    simulation.on("tick", () => {
      // Mock tick updates
    });

    return () => {
      simulation.stop();
    };
  }, [nodes, edges]);

  const handleNodeClick = (nodeId: string) => {
    setSelectedNode(nodeId);
    onNodeClick(nodeId);
  };

  const getNodeColor = (type: string, status: string) => {
    const typeColors = {
      agent: "#3b82f6",
      coalition: "#8b5cf6",
      knowledge: "#10b981",
      message: "#f59e0b",
    };

    const statusModifier =
      status === "active" ? 1 : status === "idle" ? 0.7 : 0.4;
    return typeColors[type as keyof typeof typeColors] || "#6b7280";
  };

  return (
    <div data-testid="network-topology" className="network-topology">
      <div className="topology-header">
        <h3>Network Topology</h3>
        <div className="topology-controls">
          <button
            data-testid="zoom-in"
            onClick={() => setZoomLevel((prev) => Math.min(prev * 1.2, 3))}
          >
            Zoom In
          </button>
          <button
            data-testid="zoom-out"
            onClick={() => setZoomLevel((prev) => Math.max(prev / 1.2, 0.3))}
          >
            Zoom Out
          </button>
          <button data-testid="reset-view" onClick={() => setZoomLevel(1)}>
            Reset View
          </button>
        </div>
      </div>

      <div className="topology-stats">
        <span data-testid="node-count">Nodes: {nodes.length}</span>
        <span data-testid="edge-count">Connections: {edges.length}</span>
        <span data-testid="zoom-level">
          Zoom: {(zoomLevel * 100).toFixed(0)}%
        </span>
      </div>

      <div className="topology-container">
        <svg
          ref={svgRef}
          data-testid="topology-svg"
          width="800"
          height="600"
          viewBox="0 0 800 600"
          style={{ transform: `scale(${zoomLevel})` }}
        >
          <defs>
            <marker
              id="arrowhead"
              markerWidth="10"
              markerHeight="7"
              refX="9"
              refY="3.5"
              orient="auto"
            >
              <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
            </marker>
          </defs>

          {/* Render edges */}
          <g data-testid="topology-edges">
            {edges.map((edge, index) => (
              <line
                key={`edge-${index}`}
                data-testid={`edge-${edge.source}-${edge.target}`}
                x1={100 + index * 20}
                y1={100}
                x2={200 + index * 20}
                y2={200}
                stroke="#666"
                strokeWidth={edge.strength * 2}
                markerEnd="url(#arrowhead)"
                onClick={() => onEdgeClick(`${edge.source}-${edge.target}`)}
                style={{ cursor: "pointer" }}
              />
            ))}
          </g>

          {/* Render nodes */}
          <g data-testid="topology-nodes">
            {nodes.map((node, index) => (
              <g key={node.id}>
                <circle
                  data-testid={`node-${node.id}`}
                  cx={100 + (index % 8) * 80}
                  cy={100 + Math.floor(index / 8) * 80}
                  r={10 + node.connections * 2}
                  fill={getNodeColor(node.type, node.status)}
                  stroke={selectedNode === node.id ? "#000" : "none"}
                  strokeWidth={selectedNode === node.id ? 3 : 0}
                  onClick={() => handleNodeClick(node.id)}
                  style={{ cursor: "pointer" }}
                />
                <text
                  data-testid={`node-label-${node.id}`}
                  x={100 + (index % 8) * 80}
                  y={120 + Math.floor(index / 8) * 80}
                  textAnchor="middle"
                  fontSize="10"
                  fill="#333"
                >
                  {node.id}
                </text>
              </g>
            ))}
          </g>
        </svg>
      </div>

      {selectedNode && (
        <div data-testid="node-details" className="node-details">
          <h4>Node Details: {selectedNode}</h4>
          {nodes.find((n) => n.id === selectedNode) && (
            <div>
              <p>Type: {nodes.find((n) => n.id === selectedNode)?.type}</p>
              <p>Status: {nodes.find((n) => n.id === selectedNode)?.status}</p>
              <p>
                Connections:{" "}
                {nodes.find((n) => n.id === selectedNode)?.connections}
              </p>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// Main Dashboard Component
const AdvancedDashboard: React.FC = () => {
  const [metrics, setMetrics] = React.useState<DashboardMetrics>({
    activeAgents: 12,
    messageRate: 45.3,
    networkUtilization: 67.8,
    errorRate: 0.02,
    averageResponseTime: 234,
    knowledgeGraphNodes: 1847,
    coalitionsFormed: 8,
    beliefStates: 156,
  });

  const [alerts, setAlerts] = React.useState<DashboardAlert[]>([
    {
      id: "1",
      severity: "high",
      message: "High network utilization detected",
      timestamp: new Date(Date.now() - 300000),
      acknowledged: false,
      category: "performance",
    },
    {
      id: "2",
      severity: "medium",
      message: "Agent coalition formation taking longer than expected",
      timestamp: new Date(Date.now() - 600000),
      acknowledged: true,
      category: "system",
    },
  ]);

  const [performanceData, setPerformanceData] = React.useState([
    {
      timestamp: new Date(Date.now() - 3600000),
      value: 45,
      metric: "response_time",
    },
    {
      timestamp: new Date(Date.now() - 1800000),
      value: 52,
      metric: "response_time",
    },
    {
      timestamp: new Date(Date.now() - 900000),
      value: 38,
      metric: "response_time",
    },
    { timestamp: new Date(), value: 41, metric: "response_time" },
  ]);

  const [timeRange, setTimeRange] = React.useState<"1h" | "6h" | "24h" | "7d">(
    "1h",
  );

  const [networkNodes] = React.useState([
    { id: "agent-1", type: "agent", status: "active", connections: 5 },
    { id: "agent-2", type: "agent", status: "idle", connections: 3 },
    { id: "coalition-1", type: "coalition", status: "active", connections: 8 },
    { id: "knowledge-1", type: "knowledge", status: "active", connections: 12 },
  ]);

  const [networkEdges] = React.useState([
    { source: "agent-1", target: "coalition-1", strength: 0.8, type: "member" },
    { source: "agent-2", target: "coalition-1", strength: 0.6, type: "member" },
    {
      source: "coalition-1",
      target: "knowledge-1",
      strength: 0.9,
      type: "access",
    },
  ]);

  // Simulate real-time updates
  React.useEffect(() => {
    const interval = setInterval(() => {
      setMetrics((prev) => ({
        ...prev,
        messageRate: prev.messageRate + (Math.random() - 0.5) * 10,
        networkUtilization: Math.max(
          0,
          Math.min(100, prev.networkUtilization + (Math.random() - 0.5) * 5),
        ),
        averageResponseTime: Math.max(
          50,
          prev.averageResponseTime + (Math.random() - 0.5) * 50,
        ),
      }));
    }, 5000);

    return () => clearInterval(interval);
  }, []);

  const handleAcknowledgeAlert = (id: string) => {
    setAlerts((prev) =>
      prev.map((alert) =>
        alert.id === id ? { ...alert, acknowledged: true } : alert,
      ),
    );
  };

  const handleDismissAlert = (id: string) => {
    setAlerts((prev) => prev.filter((alert) => alert.id !== id));
  };

  const handleClearAllAlerts = () => {
    setAlerts([]);
  };

  const handleNodeClick = (nodeId: string) => {
    console.log("Node clicked:", nodeId);
  };

  const handleEdgeClick = (edgeId: string) => {
    console.log("Edge clicked:", edgeId);
  };

  return (
    <div data-testid="advanced-dashboard" className="advanced-dashboard">
      <header className="dashboard-header">
        <h1>FreeAgentics Advanced Dashboard</h1>
        <div className="dashboard-actions">
          <button data-testid="refresh-dashboard">Refresh</button>
          <button data-testid="export-data">Export Data</button>
          <button data-testid="configure-alerts">Configure Alerts</button>
        </div>
      </header>

      <div className="dashboard-grid">
        <div className="dashboard-section">
          <MetricsPanel metrics={metrics} />
        </div>

        <div className="dashboard-section">
          <AlertPanel
            alerts={alerts}
            onAcknowledge={handleAcknowledgeAlert}
            onDismiss={handleDismissAlert}
            onClearAll={handleClearAllAlerts}
          />
        </div>

        <div className="dashboard-section">
          <PerformanceChart
            data={performanceData}
            timeRange={timeRange}
            onTimeRangeChange={setTimeRange}
          />
        </div>

        <div className="dashboard-section">
          <NetworkTopology
            nodes={networkNodes}
            edges={networkEdges}
            onNodeClick={handleNodeClick}
            onEdgeClick={handleEdgeClick}
          />
        </div>
      </div>
    </div>
  );
};

describe("Advanced Dashboard Tests", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("MetricsPanel", () => {
    const mockMetrics: DashboardMetrics = {
      activeAgents: 15,
      messageRate: 78.5,
      networkUtilization: 85.2,
      errorRate: 2.1,
      averageResponseTime: 456,
      knowledgeGraphNodes: 2341,
      coalitionsFormed: 12,
      beliefStates: 289,
    };

    it("renders all metrics correctly", () => {
      render(<MetricsPanel metrics={mockMetrics} />);

      expect(screen.getByTestId("active-agents")).toHaveTextContent("15");
      expect(screen.getByTestId("message-rate")).toHaveTextContent("78.5");
      expect(screen.getByTestId("network-utilization")).toHaveTextContent(
        "85.2%",
      );
      expect(screen.getByTestId("error-rate")).toHaveTextContent("2.10%");
      expect(screen.getByTestId("response-time")).toHaveTextContent("456");
      expect(screen.getByTestId("knowledge-nodes")).toHaveTextContent("2341");
      expect(screen.getByTestId("coalitions-formed")).toHaveTextContent("12");
      expect(screen.getByTestId("belief-states")).toHaveTextContent("289");
    });

    it("applies correct color coding for thresholds", () => {
      render(<MetricsPanel metrics={mockMetrics} />);

      // High network utilization should have warning/error color
      const networkMetric = screen
        .getByTestId("network-utilization")
        .querySelector(".metric-value");
      expect(networkMetric).toHaveStyle({ color: expect.any(String) });
    });
  });

  describe("AlertPanel", () => {
    const mockAlerts: DashboardAlert[] = [
      {
        id: "1",
        severity: "critical",
        message: "System overload detected",
        timestamp: new Date("2024-01-01T10:00:00Z"),
        acknowledged: false,
        category: "performance",
      },
      {
        id: "2",
        severity: "medium",
        message: "Agent timeout warning",
        timestamp: new Date("2024-01-01T09:30:00Z"),
        acknowledged: true,
        category: "system",
      },
    ];

    const mockHandlers = {
      onAcknowledge: jest.fn(),
      onDismiss: jest.fn(),
      onClearAll: jest.fn(),
    };

    it("renders alerts correctly", () => {
      render(<AlertPanel alerts={mockAlerts} {...mockHandlers} />);

      expect(screen.getByTestId("alert-1")).toBeInTheDocument();
      expect(screen.getByTestId("alert-2")).toBeInTheDocument();
      expect(screen.getByTestId("alert-severity-1")).toHaveTextContent(
        "CRITICAL",
      );
      expect(screen.getByTestId("alert-message-1")).toHaveTextContent(
        "System overload detected",
      );
    });

    it("filters alerts correctly", () => {
      render(<AlertPanel alerts={mockAlerts} {...mockHandlers} />);

      const filterSelect = screen.getByTestId("alert-filter");
      fireEvent.change(filterSelect, { target: { value: "unacknowledged" } });

      expect(screen.getByTestId("alert-1")).toBeInTheDocument();
      expect(screen.queryByTestId("alert-2")).not.toBeInTheDocument();
    });

    it("sorts alerts correctly", () => {
      render(<AlertPanel alerts={mockAlerts} {...mockHandlers} />);

      const sortSelect = screen.getByTestId("alert-sort");
      fireEvent.change(sortSelect, { target: { value: "severity" } });

      // Critical alert should appear first
      const alertList = screen.getByTestId("alert-list");
      const alerts = alertList.querySelectorAll('[data-testid^="alert-"]');
      expect(alerts[0]).toHaveAttribute("data-testid", "alert-1");
    });

    it("acknowledges alerts", () => {
      render(<AlertPanel alerts={mockAlerts} {...mockHandlers} />);

      const acknowledgeButton = screen.getByTestId("acknowledge-1");
      fireEvent.click(acknowledgeButton);

      expect(mockHandlers.onAcknowledge).toHaveBeenCalledWith("1");
    });

    it("dismisses alerts", () => {
      render(<AlertPanel alerts={mockAlerts} {...mockHandlers} />);

      const dismissButton = screen.getByTestId("dismiss-1");
      fireEvent.click(dismissButton);

      expect(mockHandlers.onDismiss).toHaveBeenCalledWith("1");
    });

    it("clears all alerts", () => {
      render(<AlertPanel alerts={mockAlerts} {...mockHandlers} />);

      const clearAllButton = screen.getByTestId("clear-all-alerts");
      fireEvent.click(clearAllButton);

      expect(mockHandlers.onClearAll).toHaveBeenCalled();
    });

    it("shows no alerts message when empty", () => {
      render(<AlertPanel alerts={[]} {...mockHandlers} />);

      expect(screen.getByTestId("no-alerts")).toHaveTextContent(
        "No alerts to display",
      );
    });
  });

  describe("PerformanceChart", () => {
    const mockData = [
      {
        timestamp: new Date("2024-01-01T10:00:00Z"),
        value: 100,
        metric: "cpu",
      },
      {
        timestamp: new Date("2024-01-01T10:15:00Z"),
        value: 120,
        metric: "cpu",
      },
      { timestamp: new Date("2024-01-01T10:30:00Z"), value: 95, metric: "cpu" },
    ];

    const mockProps = {
      data: mockData,
      timeRange: "1h" as const,
      onTimeRangeChange: jest.fn(),
    };

    it("renders chart correctly", () => {
      render(<PerformanceChart {...mockProps} />);

      expect(screen.getByTestId("performance-chart")).toBeInTheDocument();
      expect(screen.getByTestId("chart-svg")).toBeInTheDocument();
      expect(screen.getByTestId("chart-content")).toHaveTextContent(
        "3 data points",
      );
    });

    it("changes time range", () => {
      render(<PerformanceChart {...mockProps} />);

      const timeRangeButton = screen.getByTestId("time-range-6h");
      fireEvent.click(timeRangeButton);

      expect(mockProps.onTimeRangeChange).toHaveBeenCalledWith("6h");
    });

    it("highlights active time range", () => {
      render(<PerformanceChart {...mockProps} />);

      const activeButton = screen.getByTestId("time-range-1h");
      expect(activeButton).toHaveClass("active");
    });
  });

  describe("NetworkTopology", () => {
    const mockNodes = [
      { id: "node1", type: "agent", status: "active", connections: 3 },
      { id: "node2", type: "coalition", status: "idle", connections: 5 },
    ];

    const mockEdges = [
      { source: "node1", target: "node2", strength: 0.8, type: "connection" },
    ];

    const mockProps = {
      nodes: mockNodes,
      edges: mockEdges,
      onNodeClick: jest.fn(),
      onEdgeClick: jest.fn(),
    };

    it("renders topology correctly", () => {
      render(<NetworkTopology {...mockProps} />);

      expect(screen.getByTestId("network-topology")).toBeInTheDocument();
      expect(screen.getByTestId("topology-svg")).toBeInTheDocument();
      expect(screen.getByTestId("node-count")).toHaveTextContent("Nodes: 2");
      expect(screen.getByTestId("edge-count")).toHaveTextContent(
        "Connections: 1",
      );
    });

    it("handles node clicks", () => {
      render(<NetworkTopology {...mockProps} />);

      const node = screen.getByTestId("node-node1");
      fireEvent.click(node);

      expect(mockProps.onNodeClick).toHaveBeenCalledWith("node1");
      expect(screen.getByTestId("node-details")).toBeInTheDocument();
    });

    it("handles edge clicks", () => {
      render(<NetworkTopology {...mockProps} />);

      const edge = screen.getByTestId("edge-node1-node2");
      fireEvent.click(edge);

      expect(mockProps.onEdgeClick).toHaveBeenCalledWith("node1-node2");
    });

    it("controls zoom levels", () => {
      render(<NetworkTopology {...mockProps} />);

      const zoomInButton = screen.getByTestId("zoom-in");
      fireEvent.click(zoomInButton);

      expect(screen.getByTestId("zoom-level")).toHaveTextContent("120%");

      const zoomOutButton = screen.getByTestId("zoom-out");
      fireEvent.click(zoomOutButton);

      const resetButton = screen.getByTestId("reset-view");
      fireEvent.click(resetButton);

      expect(screen.getByTestId("zoom-level")).toHaveTextContent("100%");
    });
  });

  describe("AdvancedDashboard Integration", () => {
    it("renders full dashboard", () => {
      render(<AdvancedDashboard />);

      expect(screen.getByTestId("advanced-dashboard")).toBeInTheDocument();
      expect(screen.getByTestId("metrics-panel")).toBeInTheDocument();
      expect(screen.getByTestId("alert-panel")).toBeInTheDocument();
      expect(screen.getByTestId("performance-chart")).toBeInTheDocument();
      expect(screen.getByTestId("network-topology")).toBeInTheDocument();
    });

    it("handles dashboard actions", () => {
      render(<AdvancedDashboard />);

      expect(screen.getByTestId("refresh-dashboard")).toBeInTheDocument();
      expect(screen.getByTestId("export-data")).toBeInTheDocument();
      expect(screen.getByTestId("configure-alerts")).toBeInTheDocument();
    });

    it("updates metrics in real-time", async () => {
      jest.useFakeTimers();
      render(<AdvancedDashboard />);

      const initialMessageRate = screen.getByTestId("message-rate").textContent;

      // Fast-forward time to trigger updates
      jest.advanceTimersByTime(5000);

      await waitFor(() => {
        const updatedMessageRate =
          screen.getByTestId("message-rate").textContent;
        expect(updatedMessageRate).toBeDefined();
      });

      jest.useRealTimers();
    });

    it("manages alert lifecycle", () => {
      render(<AdvancedDashboard />);

      // Initial alerts should be present
      expect(screen.getByTestId("alert-1")).toBeInTheDocument();

      // Acknowledge an alert
      const acknowledgeButton = screen.getByTestId("acknowledge-1");
      fireEvent.click(acknowledgeButton);

      // Alert should still be present but acknowledged
      expect(screen.getByTestId("alert-1")).toHaveClass("acknowledged");

      // Dismiss an alert
      const dismissButton = screen.getByTestId("dismiss-1");
      fireEvent.click(dismissButton);

      // Alert should be removed
      expect(screen.queryByTestId("alert-1")).not.toBeInTheDocument();
    });
  });
});
