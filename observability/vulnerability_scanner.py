"""
Automated Vulnerability Scanner for FreeAgentics.

This module provides continuous vulnerability scanning capabilities including
static analysis, dependency scanning, and dynamic security testing.
"""

import asyncio
import json
import logging
import os
import subprocess  # nosec B404 # Required for legitimate security scanning tools
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

from auth.security_logging import (
    SecurityEventSeverity,
    SecurityEventType,
    security_auditor,
)
from observability.security_monitoring import security_monitor

logger = logging.getLogger(__name__)


class VulnerabilityType(str, Enum):
    """Types of vulnerabilities."""

    DEPENDENCY = "dependency"
    CODE_QUALITY = "code_quality"
    SECURITY_HOTSPOT = "security_hotspot"
    INJECTION = "injection"
    CRYPTOGRAPHIC = "cryptographic"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INPUT_VALIDATION = "input_validation"
    CONFIGURATION = "configuration"
    CONTAINER = "container"


class SeverityLevel(str, Enum):
    """Vulnerability severity levels."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class Vulnerability:
    """Vulnerability data structure."""

    id: str
    type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    remediation: Optional[str] = None
    confidence: float = 1.0
    first_detected: datetime = field(default_factory=datetime.utcnow)
    last_seen: datetime = field(default_factory=datetime.utcnow)
    status: str = "open"
    false_positive: bool = False
    suppressed: bool = False
    scanner_name: str = ""
    raw_data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ScanResult:
    """Vulnerability scan result."""

    scan_id: str
    scanner_name: str
    start_time: datetime
    end_time: datetime
    success: bool
    vulnerabilities: List[Vulnerability]
    error_message: Optional[str] = None
    scan_duration: float = 0.0
    total_files_scanned: int = 0
    scan_config: Dict[str, Any] = field(default_factory=dict)


class VulnerabilityScanner:
    """Automated vulnerability scanning system."""

    def __init__(self):
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.scan_results: List[ScanResult] = []
        self.suppressed_vulnerabilities: Set[str] = set()
        self.false_positives: Set[str] = set()

        # Scanner configuration
        self.scan_interval = 3600  # 1 hour
        self.enabled_scanners = [
            "bandit",
            "safety",
            "semgrep",
            "secrets",
            "dockerfile",
            "dependency_check",
        ]

        # Paths to scan
        self.scan_paths = [
            ".",
            "api/",
            "auth/",
            "agents/",
            "observability/",
            "knowledge_graph/",
            "inference/",
        ]

        # Exclude patterns
        self.exclude_patterns = [
            ".git/",
            ".venv/",
            "venv/",
            "__pycache__/",
            "node_modules/",
            ".archive/",
            "web/node_modules/",
            "tests/",
            "*.pyc",
            "*.log",
        ]

        # Background tasks
        self.scanning_task: Optional[asyncio.Task] = None
        self.running = False

        logger.info("🔍 Vulnerability scanner initialized")

    async def start_scanning(self):
        """Start continuous vulnerability scanning."""
        if self.running:
            return

        self.running = True
        self.scanning_task = asyncio.create_task(self._scanning_loop())

        logger.info("🚀 Vulnerability scanning started")

    async def stop_scanning(self):
        """Stop vulnerability scanning."""
        self.running = False

        if self.scanning_task:
            self.scanning_task.cancel()
            try:
                await self.scanning_task
            except asyncio.CancelledError:
                pass

        logger.info("🛑 Vulnerability scanning stopped")

    async def _scanning_loop(self):
        """Main scanning loop."""
        while self.running:
            try:
                await self._run_all_scanners()
                await asyncio.sleep(self.scan_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in vulnerability scanning loop: {e}")
                await asyncio.sleep(300)  # Wait 5 minutes before retrying

    async def _run_all_scanners(self):
        """Run all enabled vulnerability scanners."""
        logger.info("🔎 Starting vulnerability scan cycle")

        scan_tasks = []

        if "bandit" in self.enabled_scanners:
            scan_tasks.append(self._run_bandit_scan())
        if "safety" in self.enabled_scanners:
            scan_tasks.append(self._run_safety_scan())
        if "semgrep" in self.enabled_scanners:
            scan_tasks.append(self._run_semgrep_scan())
        if "secrets" in self.enabled_scanners:
            scan_tasks.append(self._run_secrets_scan())
        if "dockerfile" in self.enabled_scanners:
            scan_tasks.append(self._run_dockerfile_scan())
        if "dependency_check" in self.enabled_scanners:
            scan_tasks.append(self._run_dependency_check())

        # Run scans in parallel
        results = await asyncio.gather(*scan_tasks, return_exceptions=True)

        # Process results
        for result in results:
            if isinstance(result, Exception):
                logger.error(f"Scanner error: {result}")
            elif isinstance(result, ScanResult):
                await self._process_scan_result(result)

        logger.info("✅ Vulnerability scan cycle completed")

    async def _run_bandit_scan(self) -> ScanResult:
        """Run Bandit static analysis scanner."""
        start_time = datetime.utcnow()
        scan_id = f"bandit_{int(time.time())}"

        try:
            # Prepare command
            cmd = [
                "bandit",
                "-r",
                ".",
                "-f",
                "json",
                "-o",
                f"bandit_results_{scan_id}.json",
                "--skip",
                "B101,B601,B603",  # Skip some common false positives
                "--exclude",
                ",".join(self.exclude_patterns),
            ]

            # Run Bandit
            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await result.communicate()

            # Parse results
            result_file = f"bandit_results_{scan_id}.json"
            vulnerabilities = []

            if Path(result_file).exists():
                with open(result_file, "r") as f:
                    bandit_results = json.load(f)

                for issue in bandit_results.get("results", []):
                    vulnerability = Vulnerability(
                        id=f"bandit_{issue['test_id']}_{issue['filename']}_{issue['line_number']}",
                        type=VulnerabilityType.SECURITY_HOTSPOT,
                        severity=self._map_bandit_severity(
                            issue["issue_severity"]
                        ),
                        title=issue["issue_text"],
                        description=issue["issue_text"],
                        file_path=issue["filename"],
                        line_number=issue["line_number"],
                        cwe_id=issue.get("issue_cwe"),
                        remediation=issue.get("more_info"),
                        confidence=self._map_bandit_confidence(
                            issue["issue_confidence"]
                        ),
                        scanner_name="bandit",
                        raw_data=issue,
                    )
                    vulnerabilities.append(vulnerability)

                # Clean up result file
                os.remove(result_file)

            end_time = datetime.utcnow()

            return ScanResult(
                scan_id=scan_id,
                scanner_name="bandit",
                start_time=start_time,
                end_time=end_time,
                success=True,
                vulnerabilities=vulnerabilities,
                scan_duration=(end_time - start_time).total_seconds(),
            )

        except Exception as e:
            end_time = datetime.utcnow()
            logger.error(f"Bandit scan failed: {e}")

            return ScanResult(
                scan_id=scan_id,
                scanner_name="bandit",
                start_time=start_time,
                end_time=end_time,
                success=False,
                vulnerabilities=[],
                error_message=str(e),
                scan_duration=(end_time - start_time).total_seconds(),
            )

    async def _run_safety_scan(self) -> ScanResult:
        """Run Safety dependency vulnerability scanner."""
        start_time = datetime.utcnow()
        scan_id = f"safety_{int(time.time())}"

        try:
            # Run Safety check
            cmd = ["safety", "check", "--json"]

            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await result.communicate()

            vulnerabilities = []

            if stdout:
                try:
                    safety_results = json.loads(stdout.decode())

                    for vuln in safety_results:
                        vulnerability = Vulnerability(
                            id=f"safety_{vuln['id']}",
                            type=VulnerabilityType.DEPENDENCY,
                            severity=SeverityLevel.HIGH,  # Safety usually reports high severity
                            title=f"Vulnerable dependency: {vuln['package']}",
                            description=vuln["advisory"],
                            cve_id=vuln.get("cve"),
                            remediation=f"Update {vuln['package']} to version {vuln['vulnerable_spec']}",
                            scanner_name="safety",
                            raw_data=vuln,
                        )
                        vulnerabilities.append(vulnerability)

                except json.JSONDecodeError:
                    logger.warning("Failed to parse Safety JSON output")

            end_time = datetime.utcnow()

            return ScanResult(
                scan_id=scan_id,
                scanner_name="safety",
                start_time=start_time,
                end_time=end_time,
                success=True,
                vulnerabilities=vulnerabilities,
                scan_duration=(end_time - start_time).total_seconds(),
            )

        except Exception as e:
            end_time = datetime.utcnow()
            logger.error(f"Safety scan failed: {e}")

            return ScanResult(
                scan_id=scan_id,
                scanner_name="safety",
                start_time=start_time,
                end_time=end_time,
                success=False,
                vulnerabilities=[],
                error_message=str(e),
                scan_duration=(end_time - start_time).total_seconds(),
            )

    async def _run_semgrep_scan(self) -> ScanResult:
        """Run Semgrep security pattern scanner."""
        start_time = datetime.utcnow()
        scan_id = f"semgrep_{int(time.time())}"

        try:
            # Run Semgrep
            cmd = [
                "semgrep",
                "--config=auto",
                "--config=p/security-audit",
                "--config=p/secrets",
                "--json",
                ".",
            ]

            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await result.communicate()

            vulnerabilities = []

            if stdout:
                try:
                    semgrep_results = json.loads(stdout.decode())

                    for finding in semgrep_results.get("results", []):
                        severity = self._map_semgrep_severity(
                            finding.get("extra", {}).get("severity", "INFO")
                        )

                        vulnerability = Vulnerability(
                            id=f"semgrep_{finding['check_id']}_{finding['path']}_{finding['start']['line']}",
                            type=VulnerabilityType.SECURITY_HOTSPOT,
                            severity=severity,
                            title=finding.get("extra", {}).get(
                                "message", "Security issue detected"
                            ),
                            description=finding.get("extra", {}).get(
                                "message", ""
                            ),
                            file_path=finding["path"],
                            line_number=finding["start"]["line"],
                            cwe_id=finding.get("extra", {}).get("cwe"),
                            remediation=finding.get("extra", {}).get("fix"),
                            scanner_name="semgrep",
                            raw_data=finding,
                        )
                        vulnerabilities.append(vulnerability)

                except json.JSONDecodeError:
                    logger.warning("Failed to parse Semgrep JSON output")

            end_time = datetime.utcnow()

            return ScanResult(
                scan_id=scan_id,
                scanner_name="semgrep",
                start_time=start_time,
                end_time=end_time,
                success=True,
                vulnerabilities=vulnerabilities,
                scan_duration=(end_time - start_time).total_seconds(),
            )

        except Exception as e:
            end_time = datetime.utcnow()
            logger.error(f"Semgrep scan failed: {e}")

            return ScanResult(
                scan_id=scan_id,
                scanner_name="semgrep",
                start_time=start_time,
                end_time=end_time,
                success=False,
                vulnerabilities=[],
                error_message=str(e),
                scan_duration=(end_time - start_time).total_seconds(),
            )

    async def _run_secrets_scan(self) -> ScanResult:
        """Run secrets detection scanner."""
        start_time = datetime.utcnow()
        scan_id = f"secrets_{int(time.time())}"

        try:
            # Ensure baseline exists
            if not Path(".secrets.baseline").exists():
                subprocess.run(  # nosec B607 B603 # Security tool detect-secrets is trusted
                    [
                        "detect-secrets",
                        "scan",
                        "--baseline",
                        ".secrets.baseline",
                    ],
                    check=False,
                )

            # Run secrets detection
            cmd = [
                "detect-secrets",
                "scan",
                "--baseline",
                ".secrets.baseline",
                "--force-use-all-plugins",
            ]

            result = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await result.communicate()

            vulnerabilities = []

            if stdout:
                try:
                    secrets_results = json.loads(stdout.decode())

                    for filename, secrets in secrets_results.get(
                        "results", {}
                    ).items():
                        for secret in secrets:
                            vulnerability = Vulnerability(
                                id=f"secrets_{secret['type']}_{filename}_{secret.get('line_number', 0)}",
                                type=VulnerabilityType.CRYPTOGRAPHIC,
                                severity=SeverityLevel.HIGH,
                                title=f"Potential secret detected: {secret['type']}",
                                description=f"Potential {secret['type']} secret detected in {filename}",
                                file_path=filename,
                                line_number=secret.get("line_number"),
                                remediation="Remove or encrypt the secret",
                                scanner_name="detect-secrets",
                                raw_data=secret,
                            )
                            vulnerabilities.append(vulnerability)

                except json.JSONDecodeError:
                    logger.warning(
                        "Failed to parse secrets detection JSON output"
                    )

            end_time = datetime.utcnow()

            return ScanResult(
                scan_id=scan_id,
                scanner_name="detect-secrets",
                start_time=start_time,
                end_time=end_time,
                success=True,
                vulnerabilities=vulnerabilities,
                scan_duration=(end_time - start_time).total_seconds(),
            )

        except Exception as e:
            end_time = datetime.utcnow()
            logger.error(f"Secrets scan failed: {e}")

            return ScanResult(
                scan_id=scan_id,
                scanner_name="detect-secrets",
                start_time=start_time,
                end_time=end_time,
                success=False,
                vulnerabilities=[],
                error_message=str(e),
                scan_duration=(end_time - start_time).total_seconds(),
            )

    async def _run_dockerfile_scan(self) -> ScanResult:
        """Run Dockerfile security scanner."""
        start_time = datetime.utcnow()
        scan_id = f"dockerfile_{int(time.time())}"

        try:
            dockerfiles = list(Path(".").glob("**/Dockerfile*"))
            vulnerabilities = []

            for dockerfile in dockerfiles:
                # Run hadolint
                cmd = ["hadolint", "--format", "json", str(dockerfile)]

                result = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )

                stdout, stderr = await result.communicate()

                if stdout:
                    try:
                        hadolint_results = json.loads(stdout.decode())

                        for issue in hadolint_results:
                            severity = self._map_hadolint_severity(
                                issue.get("level", "info")
                            )

                            vulnerability = Vulnerability(
                                id=f"dockerfile_{issue['code']}_{dockerfile}_{issue.get('line', 0)}",
                                type=VulnerabilityType.CONTAINER,
                                severity=severity,
                                title=f"Dockerfile issue: {issue['code']}",
                                description=issue.get("message", ""),
                                file_path=str(dockerfile),
                                line_number=issue.get("line"),
                                remediation="Follow Dockerfile best practices",
                                scanner_name="hadolint",
                                raw_data=issue,
                            )
                            vulnerabilities.append(vulnerability)

                    except json.JSONDecodeError:
                        logger.warning(
                            f"Failed to parse hadolint JSON output for {dockerfile}"
                        )

            end_time = datetime.utcnow()

            return ScanResult(
                scan_id=scan_id,
                scanner_name="hadolint",
                start_time=start_time,
                end_time=end_time,
                success=True,
                vulnerabilities=vulnerabilities,
                scan_duration=(end_time - start_time).total_seconds(),
            )

        except Exception as e:
            end_time = datetime.utcnow()
            logger.error(f"Dockerfile scan failed: {e}")

            return ScanResult(
                scan_id=scan_id,
                scanner_name="hadolint",
                start_time=start_time,
                end_time=end_time,
                success=False,
                vulnerabilities=[],
                error_message=str(e),
                scan_duration=(end_time - start_time).total_seconds(),
            )

    async def _run_dependency_check(self) -> ScanResult:
        """Run OWASP dependency check."""
        start_time = datetime.utcnow()
        scan_id = f"dependency_check_{int(time.time())}"

        try:
            # This is a placeholder for OWASP dependency check
            # In a real implementation, you would integrate with dependency-check
            vulnerabilities = []

            end_time = datetime.utcnow()

            return ScanResult(
                scan_id=scan_id,
                scanner_name="dependency-check",
                start_time=start_time,
                end_time=end_time,
                success=True,
                vulnerabilities=vulnerabilities,
                scan_duration=(end_time - start_time).total_seconds(),
            )

        except Exception as e:
            end_time = datetime.utcnow()
            logger.error(f"Dependency check failed: {e}")

            return ScanResult(
                scan_id=scan_id,
                scanner_name="dependency-check",
                start_time=start_time,
                end_time=end_time,
                success=False,
                vulnerabilities=[],
                error_message=str(e),
                scan_duration=(end_time - start_time).total_seconds(),
            )

    async def _process_scan_result(self, result: ScanResult):
        """Process scan result and update vulnerability database."""
        self.scan_results.append(result)

        # Log scan completion
        security_auditor.log_event(
            SecurityEventType.SECURITY_CONFIG_CHANGE,
            SecurityEventSeverity.INFO,
            f"Vulnerability scan completed: {result.scanner_name}",
            details={
                "scan_id": result.scan_id,
                "vulnerabilities_found": len(result.vulnerabilities),
                "scan_duration": result.scan_duration,
                "success": result.success,
            },
        )

        # Process vulnerabilities
        for vuln in result.vulnerabilities:
            if (
                vuln.id in self.suppressed_vulnerabilities
                or vuln.id in self.false_positives
            ):
                continue

            if vuln.id in self.vulnerabilities:
                # Update existing vulnerability
                existing = self.vulnerabilities[vuln.id]
                existing.last_seen = datetime.utcnow()
                existing.raw_data = vuln.raw_data
            else:
                # Add new vulnerability
                self.vulnerabilities[vuln.id] = vuln

                # Generate security alert for high/critical vulnerabilities
                if vuln.severity in [
                    SeverityLevel.HIGH,
                    SeverityLevel.CRITICAL,
                ]:
                    await security_monitor.process_security_event(
                        {
                            "event_type": SecurityEventType.SUSPICIOUS_PATTERN,
                            "severity": (
                                SecurityEventSeverity.CRITICAL
                                if vuln.severity == SeverityLevel.CRITICAL
                                else SecurityEventSeverity.WARNING
                            ),
                            "message": f"High severity vulnerability detected: {vuln.title}",
                            "timestamp": datetime.utcnow().isoformat(),
                            "details": {
                                "vulnerability_id": vuln.id,
                                "type": vuln.type,
                                "severity": vuln.severity,
                                "file_path": vuln.file_path,
                                "line_number": vuln.line_number,
                                "scanner": vuln.scanner_name,
                            },
                        }
                    )

        # Clean up old scan results (keep last 100)
        self.scan_results = self.scan_results[-100:]

    def _map_bandit_severity(self, severity: str) -> SeverityLevel:
        """Map Bandit severity to our severity levels."""
        mapping = {
            "LOW": SeverityLevel.LOW,
            "MEDIUM": SeverityLevel.MEDIUM,
            "HIGH": SeverityLevel.HIGH,
        }
        return mapping.get(severity.upper(), SeverityLevel.MEDIUM)

    def _map_bandit_confidence(self, confidence: str) -> float:
        """Map Bandit confidence to float."""
        mapping = {"LOW": 0.3, "MEDIUM": 0.6, "HIGH": 0.9}
        return mapping.get(confidence.upper(), 0.5)

    def _map_semgrep_severity(self, severity: str) -> SeverityLevel:
        """Map Semgrep severity to our severity levels."""
        mapping = {
            "INFO": SeverityLevel.LOW,
            "WARNING": SeverityLevel.MEDIUM,
            "ERROR": SeverityLevel.HIGH,
        }
        return mapping.get(severity.upper(), SeverityLevel.MEDIUM)

    def _map_hadolint_severity(self, level: str) -> SeverityLevel:
        """Map Hadolint severity to our severity levels."""
        mapping = {
            "info": SeverityLevel.LOW,
            "warning": SeverityLevel.MEDIUM,
            "error": SeverityLevel.HIGH,
        }
        return mapping.get(level.lower(), SeverityLevel.MEDIUM)

    def get_vulnerabilities(
        self,
        severity: Optional[SeverityLevel] = None,
        vuln_type: Optional[VulnerabilityType] = None,
    ) -> List[Vulnerability]:
        """Get vulnerabilities with optional filtering."""
        vulnerabilities = list(self.vulnerabilities.values())

        if severity:
            vulnerabilities = [
                v for v in vulnerabilities if v.severity == severity
            ]

        if vuln_type:
            vulnerabilities = [
                v for v in vulnerabilities if v.type == vuln_type
            ]

        return vulnerabilities

    def get_scan_history(self, limit: int = 10) -> List[ScanResult]:
        """Get recent scan history."""
        return self.scan_results[-limit:]

    def suppress_vulnerability(self, vuln_id: str, reason: str = ""):
        """Suppress a vulnerability."""
        self.suppressed_vulnerabilities.add(vuln_id)

        if vuln_id in self.vulnerabilities:
            self.vulnerabilities[vuln_id].suppressed = True
            self.vulnerabilities[vuln_id].status = "suppressed"

        logger.info(f"Vulnerability suppressed: {vuln_id} - {reason}")

    def mark_false_positive(self, vuln_id: str, reason: str = ""):
        """Mark vulnerability as false positive."""
        self.false_positives.add(vuln_id)

        if vuln_id in self.vulnerabilities:
            self.vulnerabilities[vuln_id].false_positive = True
            self.vulnerabilities[vuln_id].status = "false_positive"

        logger.info(
            f"Vulnerability marked as false positive: {vuln_id} - {reason}"
        )

    def get_vulnerability_stats(self) -> Dict[str, Any]:
        """Get vulnerability statistics."""
        vulnerabilities = list(self.vulnerabilities.values())

        stats = {
            "total_vulnerabilities": len(vulnerabilities),
            "by_severity": {},
            "by_type": {},
            "by_status": {},
            "by_scanner": {},
            "open_vulnerabilities": 0,
            "suppressed_vulnerabilities": len(self.suppressed_vulnerabilities),
            "false_positives": len(self.false_positives),
        }

        for vuln in vulnerabilities:
            # Count by severity
            severity_key = vuln.severity.value
            stats["by_severity"][severity_key] = (
                stats["by_severity"].get(severity_key, 0) + 1
            )

            # Count by type
            type_key = vuln.type.value
            stats["by_type"][type_key] = stats["by_type"].get(type_key, 0) + 1

            # Count by status
            status_key = vuln.status
            stats["by_status"][status_key] = (
                stats["by_status"].get(status_key, 0) + 1
            )

            # Count by scanner
            scanner_key = vuln.scanner_name
            stats["by_scanner"][scanner_key] = (
                stats["by_scanner"].get(scanner_key, 0) + 1
            )

            # Count open vulnerabilities
            if vuln.status == "open":
                stats["open_vulnerabilities"] += 1

        return stats


# Global vulnerability scanner instance
vulnerability_scanner = VulnerabilityScanner()


async def start_vulnerability_scanning():
    """Start vulnerability scanning."""
    await vulnerability_scanner.start_scanning()


async def stop_vulnerability_scanning():
    """Stop vulnerability scanning."""
    await vulnerability_scanner.stop_scanning()


def get_vulnerability_stats() -> Dict[str, Any]:
    """Get vulnerability statistics."""
    return vulnerability_scanner.get_vulnerability_stats()


def get_vulnerabilities(
    severity: Optional[SeverityLevel] = None,
    vuln_type: Optional[VulnerabilityType] = None,
) -> List[Vulnerability]:
    """Get vulnerabilities with optional filtering."""
    return vulnerability_scanner.get_vulnerabilities(severity, vuln_type)
